{
  "version": 3,
  "sources": ["../../shaka-player/node_modules/google-closure-library/closure/goog/base.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/util/arrayiterator.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/util/defineproperty.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/util/global.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/util/polyfill.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/symbol.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/util/makeiterator.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/util/arrayfromiterable.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/util/arrayfromiterator.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/util/objectcreate.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/util/setprototypeof.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/util/inherits.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/generator_engine.js", "../../shaka-player/lib/offline/offline_manifest_parser.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/execute_async_generator.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/util/restarguments.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/promise/promise.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/util/owns.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/weakmap.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/map.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/set.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/util/findinternal.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/array/findindex.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/object/is.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/array/includes.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/util/checkstringargs.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/string/includes.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/array/find.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/string/startswith.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/util/iteratorfromarray.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/array/keys.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/util/assign.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/object/assign.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/array/from.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/array/values.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/promise/finally.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/array/entries.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/string/repeat.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/number/isnan.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/object/values.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/math/log2.js", "../../shaka-player/dist/src/com/google/javascript/jscomp/js/es6/object/entries.js", "../../shaka-player/lib/abr/ewma.js", "../../shaka-player/lib/abr/ewma_bandwidth_estimator.js", "../../shaka-player/lib/debug/log.js", "../../shaka-player/lib/util/array_utils.js", "../../shaka-player/lib/text/cue.js", "../../shaka-player/lib/util/buffer_utils.js", "../../shaka-player/lib/deprecate/version.js", "../../shaka-player/lib/deprecate/deprecate.js", "../../shaka-player/lib/util/functional.js", "../../shaka-player/lib/deprecate/enforcer.js", "../../shaka-player/lib/dependencies/all.js", "../../shaka-player/lib/util/error.js", "../../shaka-player/third_party/closure-uri/utils.js", "../../shaka-player/third_party/closure-uri/uri.js", "../../shaka-player/lib/util/manifest_parser_utils.js", "../../shaka-player/lib/util/public_promise.js", "../../shaka-player/lib/util/lazy.js", "../../shaka-player/lib/util/delayed_tick.js", "../../shaka-player/lib/util/timer.js", "../../shaka-player/lib/util/platform.js", "../../shaka-player/lib/util/string_utils.js", "../../shaka-player/lib/util/uint8array_utils.js", "../../shaka-player/lib/media/transmuxer.js", "../../shaka-player/lib/util/mime_utils.js", "../../shaka-player/lib/text/text_engine.js", "../../shaka-player/lib/util/language_utils.js", "../../shaka-player/lib/util/multi_map.js", "../../shaka-player/lib/util/stream_utils.js", "../../shaka-player/lib/media/segment_reference.js", "../../shaka-player/lib/abr/simple_abr_manager.js", "../../shaka-player/lib/media/adaptation_set.js", "../../shaka-player/lib/media/adaptation_set_criteria.js", "../../shaka-player/lib/media/buffering_observer.js", "../../shaka-player/lib/player.js", "../../shaka-player/lib/net/backoff.js", "../../shaka-player/lib/util/abortable_operation.js", "../../shaka-player/lib/util/fake_event.js", "../../shaka-player/lib/util/fake_event_target.js", "../../shaka-player/lib/util/object_utils.js", "../../shaka-player/lib/util/operation_manager.js", "../../shaka-player/lib/net/networking_engine.js", "../../shaka-player/lib/util/destroyer.js", "../../shaka-player/lib/util/event_manager.js", "../../shaka-player/lib/util/fairplay_utils.js", "../../shaka-player/lib/util/iterables.js", "../../shaka-player/lib/util/map_utils.js", "../../shaka-player/lib/util/xml_utils.js", "../../shaka-player/lib/media/drm_engine.js", "../../shaka-player/lib/media/manifest_parser.js", "../../shaka-player/lib/util/data_view_reader.js", "../../shaka-player/lib/util/mp4_parser.js", "../../shaka-player/lib/media/content_workarounds.js", "../../shaka-player/lib/cea/cea_utils.js", "../../shaka-player/lib/cea/cea608_memory.js", "../../shaka-player/lib/cea/cea608_data_channel.js", "../../shaka-player/lib/cea/cea708_window.js", "../../shaka-player/lib/cea/dtvcc_packet_builder.js", "../../shaka-player/lib/cea/cea708_service.js", "../../shaka-player/lib/cea/cea_decoder.js", "../../shaka-player/lib/util/mp4_box_parsers.js", "../../shaka-player/lib/cea/mp4_cea_parser.js", "../../shaka-player/lib/cea/i_cea_parser.js", "../../shaka-player/lib/cea/sei_processor.js", "../../shaka-player/lib/media/closed_caption_parser.js", "../../shaka-player/lib/media/time_ranges_utils.js", "../../shaka-player/lib/media/media_source_engine.js", "../../shaka-player/lib/media/presentation_timeline.js", "../../shaka-player/lib/media/stall_detector.js", "../../shaka-player/lib/media/gap_jumping_controller.js", "../../shaka-player/lib/util/media_ready_state_utils.js", "../../shaka-player/lib/media/video_wrapper.js", "../../shaka-player/lib/media/playhead.js", "../../shaka-player/lib/media/segment_index.js", "../../shaka-player/lib/media/play_rate_controller.js", "../../shaka-player/lib/media/playhead_observer.js", "../../shaka-player/lib/media/quality_observer.js", "../../shaka-player/lib/media/region_timeline.js", "../../shaka-player/lib/media/region_observer.js", "../../shaka-player/lib/util/networking.js", "../../shaka-player/lib/media/streaming_engine.js", "../../shaka-player/lib/routing/walker.js", "../../shaka-player/lib/text/simple_text_displayer.js", "../../shaka-player/lib/util/dom_utils.js", "../../shaka-player/lib/text/ui_text_displayer.js", "../../shaka-player/lib/text/web_vtt_generator.js", "../../shaka-player/lib/util/cmcd_manager.js", "../../shaka-player/lib/util/config_utils.js", "../../shaka-player/lib/util/player_configuration.js", "../../shaka-player/lib/util/state_history.js", "../../shaka-player/lib/util/switch_history.js", "../../shaka-player/lib/util/stats.js", "../../shaka-player/lib/ads/ads_stats.js", "../../shaka-player/lib/ads/client_side_ad.js", "../../shaka-player/lib/ads/client_side_ad_manager.js", "../../shaka-player/lib/ads/ad_manager.js", "../../shaka-player/lib/ads/server_side_ad.js", "../../shaka-player/lib/ads/server_side_ad_manager.js", "../../shaka-player/lib/cast/cast_utils.js", "../../shaka-player/lib/cast/cast_sender.js", "../../shaka-player/lib/cast/cast_proxy.js", "../../shaka-player/lib/cast/cast_receiver.js", "../../shaka-player/lib/util/pssh.js", "../../shaka-player/lib/dash/content_protection.js", "../../shaka-player/lib/dash/mpd_utils.js", "../../shaka-player/lib/media/mp4_segment_index_parser.js", "../../shaka-player/lib/util/ebml_parser.js", "../../shaka-player/lib/media/webm_segment_index_parser.js", "../../shaka-player/lib/dash/segment_base.js", "../../shaka-player/lib/dash/segment_list.js", "../../shaka-player/lib/dash/segment_template.js", "../../shaka-player/lib/util/periods.js", "../../shaka-player/lib/dash/dash_parser.js", "../../shaka-player/lib/hls/hls_classes.js", "../../shaka-player/lib/hls/hls_utils.js", "../../shaka-player/lib/util/text_parser.js", "../../shaka-player/lib/hls/manifest_text_parser.js", "../../shaka-player/lib/net/data_uri_plugin.js", "../../shaka-player/lib/hls/hls_parser.js", "../../shaka-player/lib/net/http_plugin_utils.js", "../../shaka-player/lib/net/http_fetch_plugin.js", "../../shaka-player/lib/net/http_xhr_plugin.js", "../../shaka-player/lib/offline/download_info.js", "../../shaka-player/lib/offline/download_progress_estimator.js", "../../shaka-player/lib/offline/download_manager.js", "../../shaka-player/lib/offline/indexeddb/db_operation.js", "../../shaka-player/lib/offline/indexeddb/db_connection.js", "../../shaka-player/lib/offline/indexeddb/base_storage_cell.js", "../../shaka-player/lib/offline/indexeddb/eme_session_storage_cell.js", "../../shaka-player/lib/offline/indexeddb/storage_mechanism.js", "../../shaka-player/lib/offline/storage_muxer.js", "../../shaka-player/lib/offline/indexeddb/v1_storage_cell.js", "../../shaka-player/lib/offline/indexeddb/v2_storage_cell.js", "../../shaka-player/lib/offline/indexeddb/v5_storage_cell.js", "../../shaka-player/lib/offline/offline_uri.js", "../../shaka-player/lib/offline/manifest_converter.js", "../../shaka-player/lib/offline/offline_scheme.js", "../../shaka-player/lib/offline/session_deleter.js", "../../shaka-player/lib/offline/stored_content_utils.js", "../../shaka-player/lib/offline/storage.js", "../../shaka-player/lib/offline/stream_bandwidth_estimator.js", "../../shaka-player/lib/polyfill/all.js", "../../shaka-player/lib/polyfill/aria.js", "../../shaka-player/lib/polyfill/encryption_scheme.js", "../../shaka-player/lib/polyfill/fullscreen.js", "../../shaka-player/lib/polyfill/mathround.js", "../../shaka-player/lib/polyfill/media_capabilities.js", "../../shaka-player/lib/polyfill/mediasource.js", "../../shaka-player/lib/polyfill/orientation.js", "../../shaka-player/lib/polyfill/patchedmediakeys_apple.js", "../../shaka-player/lib/polyfill/patchedmediakeys_ms.js", "../../shaka-player/lib/polyfill/patchedmediakeys_nop.js", "../../shaka-player/lib/polyfill/patchedmediakeys_webkit.js", "../../shaka-player/lib/polyfill/pip_webkit.js", "../../shaka-player/lib/polyfill/random_uuid.js", "../../shaka-player/lib/polyfill/storage_estimate.js", "../../shaka-player/lib/polyfill/symbol.js", "../../shaka-player/lib/polyfill/video_play_promise.js", "../../shaka-player/lib/polyfill/videoplaybackquality.js", "../../shaka-player/lib/polyfill/vttcue.js", "../../shaka-player/lib/text/lrc_text_parser.js", "../../shaka-player/lib/text/ttml_text_parser.js", "../../shaka-player/lib/text/mp4_ttml_parser.js", "../../shaka-player/lib/text/vtt_text_parser.js", "../../shaka-player/lib/text/mp4_vtt_parser.js", "../../shaka-player/lib/text/sbv_text_parser.js", "../../shaka-player/lib/text/srt_text_parser.js", "../../shaka-player/lib/text/ssa_text_parser.js", "../../shaka-player/node_modules/eme-encryption-scheme-polyfill/index.js"],
  "sourcesContent": [null, null, null, null, null, null, null, null, null, null, null, null, null, "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.OfflineManifestParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.offline.ManifestConverter');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @summary Creates a new offline manifest parser.\n * @implements {shaka.extern.ManifestParser}\n */\nshaka.offline.OfflineManifestParser = class {\n  /** */\n  constructor() {\n    /** @private {shaka.offline.OfflineUri} */\n    this.uri_ = null;\n  }\n\n  /** @override */\n  configure(config) {\n    // No-op\n  }\n\n  /** @override */\n  async start(uriString, playerInterface) {\n    /** @type {shaka.offline.OfflineUri} */\n    const uri = shaka.offline.OfflineUri.parse(uriString);\n    this.uri_ = uri;\n\n    if (uri == null || !uri.isManifest()) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n          uriString);\n    }\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n\n    try {\n      await muxer.init();\n\n      const cell = await muxer.getCell(uri.mechanism(), uri.cell());\n\n      const manifests = await cell.getManifests([uri.key()]);\n      const manifest = manifests[0];\n\n      const converter = new shaka.offline.ManifestConverter(\n          uri.mechanism(), uri.cell());\n\n      const finalManifest = converter.fromManifestDB(manifest);\n      playerInterface.makeTextStreamsForClosedCaptions(finalManifest);\n      return finalManifest;\n    } finally {\n      await muxer.destroy();\n    }\n  }\n\n  /** @override */\n  stop() {\n    return Promise.resolve();\n  }\n\n  /** @override */\n  update() {\n    // No-op\n  }\n\n  /** @override */\n  async onExpirationUpdated(sessionId, expiration) {\n    goog.asserts.assert(\n        this.uri_,\n        'Should not get update event before start has been called');\n\n    /** @type {!shaka.offline.OfflineUri} */\n    const uri = this.uri_;\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n\n    try {\n      await muxer.init();\n\n      const cell = await muxer.getCell(uri.mechanism(), uri.cell());\n\n      const manifests = await cell.getManifests([uri.key()]);\n      const manifest = manifests[0];\n\n      const foundSession = manifest.sessionIds.includes(sessionId);\n      const newExpiration = manifest.expiration == undefined ||\n                        manifest.expiration > expiration;\n\n      if (foundSession && newExpiration) {\n        shaka.log.debug('Updating expiration for stored content');\n        await cell.updateManifestExpiration(uri.key(), expiration);\n      }\n    } catch (e) {\n      // Ignore errors with update.\n      shaka.log.error('There was an error updating', uri, e);\n    } finally {\n      await muxer.destroy();\n    }\n  }\n};\n\n\nshaka.media.ManifestParser.registerParserByMime(\n    'application/x-offline-manifest',\n    () => new shaka.offline.OfflineManifestParser());\n", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.abr.Ewma');\n\ngoog.require('goog.asserts');\n\n\n/**\n * @summary\n * This class computes an exponentionally-weighted moving average.\n */\nshaka.abr.Ewma = class {\n  /**\n   * @param {number} halfLife The quantity of prior samples (by weight) used\n   *   when creating a new estimate.  Those prior samples make up half of the\n   *   new estimate.\n   */\n  constructor(halfLife) {\n    goog.asserts.assert(halfLife > 0, 'expected halfLife to be positive');\n\n    /**\n     * Larger values of alpha expire historical data more slowly.\n     * @private {number}\n     */\n    this.alpha_ = Math.exp(Math.log(0.5) / halfLife);\n\n    /** @private {number} */\n    this.estimate_ = 0;\n\n    /** @private {number} */\n    this.totalWeight_ = 0;\n  }\n\n\n  /**\n   * Update the alpha with a new halfLife value.\n   *\n   * @param {number} halfLife The quantity of prior samples (by weight) used\n   *   when creating a new estimate.  Those prior samples make up half of the\n   *   new estimate.\n   */\n  updateAlpha(halfLife) {\n    goog.asserts.assert(halfLife > 0, 'expected halfLife to be positive');\n    this.alpha_ = Math.exp(Math.log(0.5) / halfLife);\n  }\n\n\n  /**\n   * Takes a sample.\n   *\n   * @param {number} weight\n   * @param {number} value\n   */\n  sample(weight, value) {\n    const adjAlpha = Math.pow(this.alpha_, weight);\n    const newEstimate = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n\n    if (!isNaN(newEstimate)) {\n      this.estimate_ = newEstimate;\n      this.totalWeight_ += weight;\n    }\n  }\n\n\n  /**\n   * @return {number}\n   */\n  getEstimate() {\n    const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n    return this.estimate_ / zeroFactor;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.abr.EwmaBandwidthEstimator');\n\ngoog.require('shaka.abr.Ewma');\n\n\n/**\n * @summary\n * This class tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n *\n */\nshaka.abr.EwmaBandwidthEstimator = class {\n  /** */\n  constructor() {\n    /**\n     * A fast-moving average.\n     * Half of the estimate is based on the last 2 seconds of sample history.\n     * @private {!shaka.abr.Ewma}\n     */\n    this.fast_ = new shaka.abr.Ewma(2);\n\n    /**\n     * A slow-moving average.\n     * Half of the estimate is based on the last 5 seconds of sample history.\n     * @private {!shaka.abr.Ewma}\n     */\n    this.slow_ = new shaka.abr.Ewma(5);\n\n    /**\n     * Number of bytes sampled.\n     * @private {number}\n     */\n    this.bytesSampled_ = 0;\n\n\n    /**\n     * Minimum number of bytes sampled before we trust the estimate.  If we have\n     * not sampled much data, our estimate may not be accurate enough to trust.\n     * If bytesSampled_ is less than minTotalBytes_, we use defaultEstimate_.\n     * This specific value is based on experimentation.\n     *\n     * @private {number}\n     */\n    this.minTotalBytes_ = 128e3;  // 128kB\n\n    /**\n     * Minimum number of bytes, under which samples are discarded.  Our models\n     * do not include latency information, so connection startup time (time to\n     * first byte) is considered part of the download time.  Because of this, we\n     * should ignore very small downloads which would cause our estimate to be\n     * too low.\n     * This specific value is based on experimentation.\n     *\n     * @private {number}\n     */\n    this.minBytes_ = 16e3;  // 16kB\n  }\n\n\n  /**\n   * Called by the Player to provide an updated configuration any time it\n   * changes.\n   * Must be called at least once before init().\n   *\n   * @param {shaka.extern.AdvancedAbrConfiguration} config\n   */\n  configure(config) {\n    this.minTotalBytes_ = config.minTotalBytes;\n    this.minBytes_ = config.minBytes;\n    this.fast_.updateAlpha(config.fastHalfLife);\n    this.slow_.updateAlpha(config.slowHalfLife);\n  }\n\n\n  /**\n   * Takes a bandwidth sample.\n   *\n   * @param {number} durationMs The amount of time, in milliseconds, for a\n   *   particular request.\n   * @param {number} numBytes The total number of bytes transferred in that\n   *   request.\n   */\n  sample(\n      durationMs, numBytes) {\n    if (numBytes < this.minBytes_) {\n      return;\n    }\n\n    const bandwidth = 8000 * numBytes / durationMs;\n    const weight = durationMs / 1000;\n\n    this.bytesSampled_ += numBytes;\n    this.fast_.sample(weight, bandwidth);\n    this.slow_.sample(weight, bandwidth);\n  }\n\n\n  /**\n   * Gets the current bandwidth estimate.\n   *\n   * @param {number} defaultEstimate\n   * @return {number} The bandwidth estimate in bits per second.\n   */\n  getBandwidthEstimate(defaultEstimate) {\n    if (this.bytesSampled_ < this.minTotalBytes_) {\n      return defaultEstimate;\n    }\n\n    // Take the minimum of these two estimates.  This should have the effect\n    // of adapting down quickly, but up more slowly.\n    return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n  }\n\n\n  /**\n   * @return {boolean} True if there is enough data to produce a meaningful\n   *   estimate.\n   */\n  hasGoodEstimate() {\n    return this.bytesSampled_ >= this.minTotalBytes_;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.log');\n\ngoog.require('goog.asserts');\n\n/**\n * @summary\n * A console logging framework which is compiled out for deployment.  This is\n * only available when using the uncompiled version.\n * @exportDoc\n */\nshaka.log = class {\n  /**\n   * This always logs to the console, even in Release mode.  This should only be\n   * used for deprecation messages and things the app should never ignore.\n   *\n   * @param {...*} args\n   */\n  static alwaysError(...args) {}\n\n  /**\n   * This always logs to the console, even in Release mode.  This should only be\n   * used for deprecation messages and things the app should never ignore.\n   *\n   * @param {...*} args\n   */\n  static alwaysWarn(...args) {}\n\n  /**\n   * This always logs to the console, even in Release mode.  This should only be\n   * used for deprecation messages and things the app should never ignore.\n   *\n   * @param {string} id\n   * @param {...*} args\n   */\n  static warnOnce(id, ...args) {\n    if (shaka.log.oneTimeWarningIssued_.has(id)) {\n      return;\n    }\n\n    shaka.log.oneTimeWarningIssued_.add(id);\n    shaka.log.alwaysWarn(...args);\n  }\n\n  /**\n   * This log is for when an error occurs.  This should always be accompanied\n   * with an error event, thrown exception, or rejected Promise.  Logs are\n   * disabled in Release mode, so there should be other methods of detecting the\n   * error.\n   *\n   * @param {...*} args\n   */\n  static error(...args) {}\n\n  /**\n   * This log is for possible errors or things that may be surprising to a user.\n   * For example, if we work around unusual or bad content, we should warn that\n   * they should fix their content.  Deprecation messages and messages the app\n   * shouldn't ignore should use alwaysWarn instead.\n   *\n   * @param {...*} args\n   */\n  static warning(...args) {}\n\n  /**\n   * This log is for messages to the user about what is happening.  For example,\n   * when we update a manifest or install a polyfill.\n   *\n   * @param {...*} args\n   */\n  static info(...args) {}\n\n  /**\n   * This log is to aid *users* in debugging their content.  This should be for\n   * logs about the content and what we do with it.  For example, when we change\n   * streams or what we are choosing.\n   *\n   * @param {...*} args\n   */\n  static debug(...args) {}\n\n  /**\n   * This log is for debugging Shaka Player itself.  This may be logs about\n   * internal states or events.  This may also be for more verbose logs about\n   * content, such as for segment appends.\n   *\n   * @param {...*} args\n   */\n  static v1(...args) {}\n\n  /**\n   * This log is for tracing and debugging Shaka Player.  These logs will happen\n   * a lot, for example, logging every segment append or every update check.\n   * These are mostly used for tracking which calls happen through the code.\n   *\n   * @param {...*} args\n   */\n  static v2(...args) {}\n};\n\n\n/**\n * Log levels.\n * @enum {number}\n * @exportDoc\n */\nshaka.log.Level = {\n  NONE: 0,\n  ERROR: 1,\n  WARNING: 2,\n  INFO: 3,\n  DEBUG: 4,\n  V1: 5,\n  V2: 6,\n};\n\n\n/**\n * @define {number} the maximum log level.\n */\nshaka.log.MAX_LOG_LEVEL = 3;\n\n\n/**\n * A Set to indicate which one-time warnings have been issued.\n *\n * @private {!Set.<string>}\n */\nshaka.log.oneTimeWarningIssued_ = new Set();\n\n\n// IE8 has no console unless it is opened in advance.\n// IE9 console methods are not Functions and have no bind.\nif (window.console && window.console.log.bind) {\n  /** @private {!Object.<shaka.log.Level, function(...*)>} */\n  shaka.log.logMap_ = {\n    /* eslint-disable no-restricted-syntax */\n    [shaka.log.Level.ERROR]: console.error.bind(console),\n    [shaka.log.Level.WARNING]: console.warn.bind(console),\n    [shaka.log.Level.INFO]: console.info.bind(console),\n    [shaka.log.Level.DEBUG]: console.log.bind(console),\n    [shaka.log.Level.V1]: console.debug.bind(console),\n    [shaka.log.Level.V2]: console.debug.bind(console),\n    /* eslint-enable no-restricted-syntax */\n  };\n\n  shaka.log.alwaysWarn = shaka.log.logMap_[shaka.log.Level.WARNING];\n  shaka.log.alwaysError = shaka.log.logMap_[shaka.log.Level.ERROR];\n\n  if (goog.DEBUG) {\n    // Since we don't want to export shaka.log in production builds, we don't\n    // use the @export annotation.  But the module wrapper (used in debug builds\n    // since v2.5.11) hides anything non-exported.  This is a debug-only,\n    // API-based export to make sure logging is available in debug builds.\n    goog.exportSymbol('shaka.log', shaka.log);\n\n    /** @type {number} */\n    shaka.log.currentLevel;\n\n    /**\n     * Change the log level.  Useful for debugging in uncompiled mode.\n     *\n     * @param {number} level\n     * @exportDoc\n     */\n    shaka.log.setLevel = (level) => {\n      const getLog = (curLevel) => {\n        if (curLevel <= level) {\n          goog.asserts.assert(\n              shaka.log.logMap_[curLevel], 'Unexpected log level');\n          return shaka.log.logMap_[curLevel];\n        } else {\n          return () => {};\n        }\n      };\n\n      shaka.log.currentLevel = level;\n      shaka.log.error = getLog(shaka.log.Level.ERROR);\n      shaka.log.warning = getLog(shaka.log.Level.WARNING);\n      shaka.log.info = getLog(shaka.log.Level.INFO);\n      shaka.log.debug = getLog(shaka.log.Level.DEBUG);\n      shaka.log.v1 = getLog(shaka.log.Level.V1);\n      shaka.log.v2 = getLog(shaka.log.Level.V2);\n    };\n\n    shaka.log.setLevel(shaka.log.MAX_LOG_LEVEL);\n  } else {\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.ERROR) {\n      shaka.log.error = shaka.log.logMap_[shaka.log.Level.ERROR];\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.WARNING) {\n      shaka.log.warning = shaka.log.logMap_[shaka.log.Level.WARNING];\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.INFO) {\n      shaka.log.info = shaka.log.logMap_[shaka.log.Level.INFO];\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.DEBUG) {\n      shaka.log.debug = shaka.log.logMap_[shaka.log.Level.DEBUG];\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.V1) {\n      shaka.log.v1 = shaka.log.logMap_[shaka.log.Level.V1];\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.V2) {\n      shaka.log.v2 = shaka.log.logMap_[shaka.log.Level.V2];\n    }\n  }\n}\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.ArrayUtils');\n\n\n/**\n * @namespace shaka.util.ArrayUtils\n * @summary Array utility functions.\n */\n\n\nshaka.util.ArrayUtils = class {\n  /**\n   * Returns whether the two values contain the same value.  This correctly\n   * handles comparisons involving NaN.\n   * @param {T} a\n   * @param {T} b\n   * @return {boolean}\n   * @template T\n   */\n  static defaultEquals(a, b) {\n    // NaN !== NaN, so we need to special case it.\n    if (typeof a === 'number' &&\n        typeof b === 'number' && isNaN(a) && isNaN(b)) {\n      return true;\n    }\n    return a === b;\n  }\n\n\n  /**\n   * Remove given element from array (assumes no duplicates).\n   * @param {!Array.<T>} array\n   * @param {T} element\n   * @template T\n   */\n  static remove(array, element) {\n    const index = array.indexOf(element);\n    if (index > -1) {\n      array.splice(index, 1);\n    }\n  }\n\n\n  /**\n   * Count the number of items in the list that pass the check function.\n   * @param {!Array.<T>} array\n   * @param {function(T):boolean} check\n   * @return {number}\n   * @template T\n   */\n  static count(array, check) {\n    let count = 0;\n\n    for (const element of array) {\n      count += check(element) ? 1 : 0;\n    }\n\n    return count;\n  }\n\n\n  /**\n   * Determines if the given arrays contain equal elements in any order.\n   *\n   * @param {!Array.<T>} a\n   * @param {!Array.<T>} b\n   * @param {function(T, T):boolean=} compareFn\n   * @return {boolean}\n   * @template T\n   */\n  static hasSameElements(a, b, compareFn) {\n    if (!compareFn) {\n      compareFn = shaka.util.ArrayUtils.defaultEquals;\n    }\n    if (a.length != b.length) {\n      return false;\n    }\n\n    const copy = b.slice();\n    for (const item of a) {\n      const idx = copy.findIndex((other) => compareFn(item, other));\n      if (idx == -1) {\n        return false;\n      }\n      // Since order doesn't matter, just swap the last element with\n      // this one and then drop the last element.\n      copy[idx] = copy[copy.length - 1];\n      copy.pop();\n    }\n\n    return copy.length == 0;\n  }\n\n\n  /**\n   * Determines if the given arrays contain equal elements in the same order.\n   *\n   * @param {!Array.<T>} a\n   * @param {!Array.<T>} b\n   * @param {function(T, T):boolean=} compareFn\n   * @return {boolean}\n   * @template T\n   */\n  static equal(a, b, compareFn) {\n    if (!compareFn) {\n      compareFn = shaka.util.ArrayUtils.defaultEquals;\n    }\n    if (a.length != b.length) {\n      return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n      if (!compareFn(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.Cue');\ngoog.provide('shaka.text.CueRegion');\n\ngoog.require('shaka.util.ArrayUtils');\n\n\n/**\n * @implements {shaka.extern.Cue}\n * @export\n */\nshaka.text.Cue = class {\n  /**\n   * @param {number} startTime\n   * @param {number} endTime\n   * @param {string} payload\n   */\n  constructor(startTime, endTime, payload) {\n    const Cue = shaka.text.Cue;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.startTime = startTime;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.direction = Cue.direction.HORIZONTAL_LEFT_TO_RIGHT;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.endTime = endTime;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.payload = payload;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.region = new shaka.text.CueRegion();\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.position = null;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.positionAlign = Cue.positionAlign.AUTO;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.size = 0;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.textAlign = Cue.textAlign.CENTER;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.writingMode = Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.lineInterpretation = Cue.lineInterpretation.LINE_NUMBER;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.line = null;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.lineHeight = '';\n\n    /**\n     * Line Alignment is set to start by default.\n     * @override\n     * @exportInterface\n     */\n    this.lineAlign = Cue.lineAlign.START;\n\n    /**\n     * Set the captions at the bottom of the text container by default.\n     * @override\n     * @exportInterface\n     */\n    this.displayAlign = Cue.displayAlign.AFTER;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.color = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.backgroundColor = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.backgroundImage = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.border = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.textShadow = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.textStrokeColor = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.textStrokeWidth = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.fontSize = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.fontWeight = Cue.fontWeight.NORMAL;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.fontStyle = Cue.fontStyle.NORMAL;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.fontFamily = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.letterSpacing = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.linePadding = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.opacity = 1;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.textDecoration = [];\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.wrapLine = true;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.id = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.nestedCues = [];\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.isContainer = false;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.lineBreak = false;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.spacer = false;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.cellResolution = {\n      columns: 32,\n      rows: 15,\n    };\n  }\n\n  /**\n   * @param {number} start\n   * @param {number} end\n   * @return {!shaka.text.Cue}\n   */\n  static lineBreak(start, end) {\n    const cue = new shaka.text.Cue(start, end, '');\n    cue.lineBreak = true;\n    return cue;\n  }\n\n  /**\n   * Create a copy of the cue with the same properties.\n   * @return {!shaka.text.Cue}\n   * @suppress {checkTypes} since we must use [] and \"in\" with a struct type.\n   */\n  clone() {\n    const clone = new shaka.text.Cue(0, 0, '');\n\n    for (const k in this) {\n      clone[k] = this[k];\n\n      // Make copies of array fields, but only one level deep.  That way, if we\n      // change, for instance, textDecoration on the clone, we don't affect the\n      // original.\n      if (clone[k] && clone[k].constructor == Array) {\n        clone[k] = /** @type {!Array} */(clone[k]).slice();\n      }\n    }\n\n    return clone;\n  }\n\n  /**\n   * Check if two Cues have all the same values in all properties.\n   * @param {!shaka.text.Cue} cue1\n   * @param {!shaka.text.Cue} cue2\n   * @return {boolean}\n   * @suppress {checkTypes} since we must use [] and \"in\" with a struct type.\n   */\n  static equal(cue1, cue2) {\n    // Compare the start time, end time and payload of the cues first for\n    // performance optimization.  We can avoid the more expensive recursive\n    // checks if the top-level properties don't match.\n    // See: https://github.com/shaka-project/shaka-player/issues/3018\n    if (cue1.startTime != cue2.startTime || cue1.endTime != cue2.endTime ||\n      cue1.payload != cue2.payload) {\n      return false;\n    }\n    for (const k in cue1) {\n      if (k == 'startTime' || k == 'endTime' || k == 'payload') {\n        // Already compared.\n      } else if (k == 'nestedCues') {\n        // This uses shaka.text.Cue.equal rather than just this.equal, since\n        // otherwise recursing here will unbox the method and cause \"this\" to be\n        // undefined in deeper recursion.\n        if (!shaka.util.ArrayUtils.equal(\n            cue1.nestedCues, cue2.nestedCues, shaka.text.Cue.equal)) {\n          return false;\n        }\n      } else if (k == 'region' || k == 'cellResolution') {\n        for (const k2 in cue1[k]) {\n          if (cue1[k][k2] != cue2[k][k2]) {\n            return false;\n          }\n        }\n      } else if (Array.isArray(cue1[k])) {\n        if (!shaka.util.ArrayUtils.equal(cue1[k], cue2[k])) {\n          return false;\n        }\n      } else {\n        if (cue1[k] != cue2[k]) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.positionAlign = {\n  'LEFT': 'line-left',\n  'RIGHT': 'line-right',\n  'CENTER': 'center',\n  'AUTO': 'auto',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.textAlign = {\n  'LEFT': 'left',\n  'RIGHT': 'right',\n  'CENTER': 'center',\n  'START': 'start',\n  'END': 'end',\n};\n\n\n/**\n * Vertical alignments of the cues within their extents.\n * 'BEFORE' means displaying at the top of the captions container box, 'CENTER'\n *  means in the middle, 'AFTER' means at the bottom.\n * @enum {string}\n * @export\n */\nshaka.text.Cue.displayAlign = {\n  'BEFORE': 'before',\n  'CENTER': 'center',\n  'AFTER': 'after',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.direction = {\n  'HORIZONTAL_LEFT_TO_RIGHT': 'ltr',\n  'HORIZONTAL_RIGHT_TO_LEFT': 'rtl',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.writingMode = {\n  'HORIZONTAL_TOP_TO_BOTTOM': 'horizontal-tb',\n  'VERTICAL_LEFT_TO_RIGHT': 'vertical-lr',\n  'VERTICAL_RIGHT_TO_LEFT': 'vertical-rl',\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.text.Cue.lineInterpretation = {\n  'LINE_NUMBER': 0,\n  'PERCENTAGE': 1,\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.lineAlign = {\n  'CENTER': 'center',\n  'START': 'start',\n  'END': 'end',\n};\n\n\n/**\n * Default text color according to\n * https://w3c.github.io/webvtt/#default-text-color\n * @enum {string}\n * @export\n */\nshaka.text.Cue.defaultTextColor = {\n  'white': '#FFF',\n  'lime': '#0F0',\n  'cyan': '#0FF',\n  'red': '#F00',\n  'yellow': '#FF0',\n  'magenta': '#F0F',\n  'blue': '#00F',\n  'black': '#000',\n};\n\n\n/**\n * Default text background color according to\n * https://w3c.github.io/webvtt/#default-text-background\n * @enum {string}\n * @export\n */\nshaka.text.Cue.defaultTextBackgroundColor = {\n  'bg_white': '#FFF',\n  'bg_lime': '#0F0',\n  'bg_cyan': '#0FF',\n  'bg_red': '#F00',\n  'bg_yellow': '#FF0',\n  'bg_magenta': '#F0F',\n  'bg_blue': '#00F',\n  'bg_black': '#000',\n};\n\n\n/**\n * In CSS font weight can be a number, where 400 is normal and 700 is bold.\n * Use these values for the enum for consistency.\n * @enum {number}\n * @export\n */\nshaka.text.Cue.fontWeight = {\n  'NORMAL': 400,\n  'BOLD': 700,\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.fontStyle = {\n  'NORMAL': 'normal',\n  'ITALIC': 'italic',\n  'OBLIQUE': 'oblique',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.textDecoration = {\n  'UNDERLINE': 'underline',\n  'LINE_THROUGH': 'lineThrough',\n  'OVERLINE': 'overline',\n};\n\n\n/**\n * @implements {shaka.extern.CueRegion}\n * @struct\n * @export\n */\nshaka.text.CueRegion = class {\n  /** */\n  constructor() {\n    const CueRegion = shaka.text.CueRegion;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.id = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.viewportAnchorX = 0;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.viewportAnchorY = 0;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.regionAnchorX = 0;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.regionAnchorY = 0;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.width = 100;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.height = 100;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.heightUnits = CueRegion.units.PERCENTAGE;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.widthUnits = CueRegion.units.PERCENTAGE;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.viewportAnchorUnits = CueRegion.units.PERCENTAGE;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.scroll = CueRegion.scrollMode.NONE;\n  }\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.text.CueRegion.units = {\n  'PX': 0,\n  'PERCENTAGE': 1,\n  'LINES': 2,\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.CueRegion.scrollMode = {\n  'NONE': '',\n  'UP': 'up',\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.BufferUtils');\n\n\n/**\n * @summary A set of BufferSource utility functions.\n * @export\n */\nshaka.util.BufferUtils = class {\n  /**\n   * Compare two buffers for equality.  For buffers of different types, this\n   * compares the underlying buffers as binary data.\n   *\n   * @param {?BufferSource} arr1\n   * @param {?BufferSource} arr2\n   * @return {boolean}\n   * @export\n   * @suppress {strictMissingProperties}\n   */\n  static equal(arr1, arr2) {\n    const BufferUtils = shaka.util.BufferUtils;\n    if (!arr1 && !arr2) {\n      return true;\n    }\n    if (!arr1 || !arr2) {\n      return false;\n    }\n    if (arr1.byteLength != arr2.byteLength) {\n      return false;\n    }\n\n    // Quickly check if these are views of the same buffer.  An ArrayBuffer can\n    // be passed but doesn't have a byteOffset field, so default to 0.\n    if (BufferUtils.unsafeGetArrayBuffer_(arr1) ==\n            BufferUtils.unsafeGetArrayBuffer_(arr2) &&\n        (arr1.byteOffset || 0) == (arr2.byteOffset || 0)) {\n      return true;\n    }\n\n    const uint8A = shaka.util.BufferUtils.toUint8(arr1);\n    const uint8B = shaka.util.BufferUtils.toUint8(arr2);\n    for (let i = 0; i < arr1.byteLength; i++) {\n      if (uint8A[i] != uint8B[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Gets the underlying ArrayBuffer of the given view.  The caller needs to\n   * ensure it uses the \"byteOffset\" and \"byteLength\" fields of the view to\n   * only use the same \"view\" of the data.\n   *\n   * @param {BufferSource} view\n   * @return {!ArrayBuffer}\n   * @private\n   */\n  static unsafeGetArrayBuffer_(view) {\n    if (view instanceof ArrayBuffer) {\n      return view;\n    } else {\n      return view.buffer;\n    }\n  }\n\n  /**\n   * Gets an ArrayBuffer that contains the data from the given TypedArray.  Note\n   * this will allocate a new ArrayBuffer if the object is a partial view of\n   * the data.\n   *\n   * @param {!BufferSource} view\n   * @return {!ArrayBuffer}\n   * @export\n   */\n  static toArrayBuffer(view) {\n    if (view instanceof ArrayBuffer) {\n      return view;\n    } else {\n      if (view.byteOffset == 0 && view.byteLength == view.buffer.byteLength) {\n        // This is a TypedArray over the whole buffer.\n        return view.buffer;\n      }\n      // This is a \"view\" on the buffer.  Create a new buffer that only contains\n      // the data.  Note that since this isn't an ArrayBuffer, the \"new\" call\n      // will allocate a new buffer to hold the copy.\n      return new Uint8Array(view).buffer;\n    }\n  }\n\n  /**\n   * Creates a new Uint8Array view on the same buffer.  This clamps the values\n   * to be within the same view (i.e. you can't use this to move past the end\n   * of the view, even if the underlying buffer is larger).  However, you can\n   * pass a negative offset to access the data before the view.\n   *\n   * @param {BufferSource} data\n   * @param {number=} offset The offset from the beginning of this data's view\n   *   to start the new view at.\n   * @param {number=} length The byte length of the new view.\n   * @return {!Uint8Array}\n   * @export\n   */\n  static toUint8(data, offset = 0, length = Infinity) {\n    return shaka.util.BufferUtils.view_(data, offset, length, Uint8Array);\n  }\n\n  /**\n   * Creates a DataView over the given buffer.\n   *\n   * @see toUint8\n   * @param {BufferSource} buffer\n   * @param {number=} offset\n   * @param {number=} length\n   * @return {!DataView}\n   * @export\n   */\n  static toDataView(buffer, offset = 0, length = Infinity) {\n    return shaka.util.BufferUtils.view_(buffer, offset, length, DataView);\n  }\n\n  /**\n   * @param {BufferSource} data\n   * @param {number} offset\n   * @param {number} length\n   * @param {function(new:T, ArrayBuffer, number, number)} Type\n   * @return {!T}\n   * @template T\n   * @private\n   */\n  static view_(data, offset, length, Type) {\n    const buffer = shaka.util.BufferUtils.unsafeGetArrayBuffer_(data);\n    // Absolute end of the |data| view within |buffer|.\n    /** @suppress {strictMissingProperties} */\n    const dataEnd = (data.byteOffset || 0) + data.byteLength;\n    // Absolute start of the result within |buffer|.\n    /** @suppress {strictMissingProperties} */\n    const rawStart = (data.byteOffset || 0) + offset;\n    const start = Math.max(0, Math.min(rawStart, dataEnd));\n    // Absolute end of the result within |buffer|.\n    const end = Math.min(start + Math.max(length, 0), dataEnd);\n    return new Type(buffer, start, end - start);\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.deprecate.Version');\n\n/**\n * A class that defines what a library version is within the deprecation\n * system. Within deprecation we only care about the major and minor versions.\n *\n * @final\n */\nshaka.deprecate.Version = class {\n  /**\n   * @param {number} major\n   * @param {number} minor\n   */\n  constructor(major, minor) {\n    this.major_ = major;\n    this.minor_ = minor;\n  }\n\n  /** @return {number} */\n  major() { return this.major_; }\n\n  /** @return {number} */\n  minor() { return this.minor_; }\n\n  /**\n   * Returns:\n   *  - positive if |this| > |other|\n   *  - zero if |this| == |other|\n   *  - negative if |this| < |other|\n   *\n   * @param {!shaka.deprecate.Version} other\n   * @return {number}\n   */\n  compareTo(other) {\n    const majorCheck = this.major_ - other.major_;\n    const minorCheck = this.minor_ - other.minor_;\n\n    return majorCheck || minorCheck;\n  }\n\n  /** @override */\n  toString() {\n    return 'v' + this.major_ + '.' + this.minor_;\n  }\n\n  /**\n   * Parse the major and minor values out of a version string that is assumed\n   * to follow the grammar: \"vMAJOR.MINOR.\". What comes after the last \".\" we\n   * will ignore.\n   *\n   * @param {string} versionString\n   * @return {!shaka.deprecate.Version}\n   */\n  static parse(versionString) {\n    // Make sure to drop the \"v\" from the front. We limit the number of splits\n    // to two as we don't care what happens after the minor version number.\n    // For example: 'a.b.c.d'.split('.', 2) == ['a', 'b']\n    const components = versionString.substring(1).split('.', /* limit= */ 2);\n\n    return new shaka.deprecate.Version(\n        Number(components[0]),\n        Number(components[1]));\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.Deprecate');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.deprecate.Enforcer');\ngoog.require('shaka.deprecate.Version');\ngoog.require('shaka.log');\n\n\n/**\n * |shaka.Deprecate| is the front-end of the deprecation system, allowing for\n * any part of the code to say that \"this block of code should be removed by\n * version X\".\n *\n * @final\n */\nshaka.Deprecate = class {\n  /**\n   * Initialize the system. This must happen before any calls to |enforce|. In\n   * our code base, |shaka.Player| will be the only one to call this (it has the\n   * version string).\n   *\n   * If the |Deprecate| called |Player.version| to initialize itself, it would\n   * mean that |Player| could not use |Deprecate| because it would create a\n   * circular dependency. To work around this, we provide this method so that\n   * |Player| can give us the version without us needing to know about |Player|.\n   *\n   * This will initialize the system to:\n   *  - print warning messages when the feature is scheduled to be removed in a\n   *    later version\n   *  - print errors and fail assertions when the feature should be removed now\n   *\n   * @param {string} versionString\n   */\n  static init(versionString) {\n    goog.asserts.assert(\n        shaka.Deprecate.enforcer_ == null,\n        'Deprecate.init should only be called once.');\n\n    shaka.Deprecate.enforcer_ = new shaka.deprecate.Enforcer(\n        shaka.deprecate.Version.parse(versionString),\n        shaka.Deprecate.onPending_,\n        shaka.Deprecate.onExpired_);\n  }\n\n  /**\n   * Ask the deprecation system to require this feature to be removed by the\n   * given version.\n   *\n   * @param {number} major\n   * @param {string} name\n   * @param {string} description\n   */\n  static deprecateFeature(major, name, description) {\n    const enforcer = shaka.Deprecate.enforcer_;\n    goog.asserts.assert(\n        enforcer,\n        'Missing deprecation enforcer. Was |init| called?');\n\n    const expiresAt = new shaka.deprecate.Version(major, 0);\n    enforcer.enforce(expiresAt, name, description);\n  }\n\n  /**\n   * @param {!shaka.deprecate.Version} libraryVersion\n   * @param {!shaka.deprecate.Version} featureVersion\n   * @param {string} name\n   * @param {string} description\n   * @private\n   */\n  static onPending_(libraryVersion, featureVersion, name, description) {\n    // If we were to pass each value to the log call, it would be printed as\n    // a comma-separated list. To make the print state appear more natural to\n    // the reader, create one string for the message.\n    shaka.log.alwaysWarn([\n      name,\n      'has been deprecated and will be removed in',\n      featureVersion,\n      '. We are currently at version',\n      libraryVersion,\n      '. Additional information:',\n      description,\n    ].join(' '));\n  }\n\n  /**\n   * @param {!shaka.deprecate.Version} libraryVersion\n   * @param {!shaka.deprecate.Version} featureVersion\n   * @param {string} name\n   * @param {string} description\n   * @private\n   */\n  static onExpired_(libraryVersion, featureVersion, name, description) {\n    // If we were to pass each value to the log call, it would be printed as\n    // a comma-separated list. To make the print state appear more natural to\n    // the reader, create one string for the message.\n    const errorMessage = [\n      name,\n      'has been deprecated and has been removed in',\n      featureVersion,\n      '. We are now at version',\n      libraryVersion,\n      '. Additional information:',\n      description,\n    ].join('');\n\n    shaka.log.alwaysError(errorMessage);\n    goog.asserts.assert(false, errorMessage);\n  }\n};\n\n/**\n * The global deprecation enforcer that will be set by the player (because the\n * player knows the version) when it calls |init|. This may appear a little\n * round-about to you, because it is. Since player uses |Deprecate|, it means\n * that |Deprecate| can't depend on Player directly.\n *\n * @private {shaka.deprecate.Enforcer}\n */\nshaka.Deprecate.enforcer_ = null;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Functional');\n\ngoog.require('shaka.Deprecate');\n\n\n/**\n * @summary A set of functional utility functions.\n */\nshaka.util.Functional = class {\n  /**\n   * Creates a promise chain that calls the given callback for each element in\n   * the array in a catch of a promise.\n   *\n   * e.g.:\n   * Promise.reject().catch(callback(array[0])).catch(callback(array[1]));\n   *\n   * @param {!Array.<ELEM>} array\n   * @param {function(ELEM):!Promise.<RESULT>} callback\n   * @return {!Promise.<RESULT>}\n   * @template ELEM,RESULT\n   */\n  static createFallbackPromiseChain(array, callback) {\n    return array.reduce((promise, elem) => {\n      return promise.catch(() => callback(elem));\n    }, Promise.reject());\n  }\n\n\n  /**\n   * Returns the first array concatenated to the second; used to collapse an\n   * array of arrays into a single array.\n   *\n   * @param {!Array.<T>} all\n   * @param {!Array.<T>} part\n   * @return {!Array.<T>}\n   * @template T\n   */\n  static collapseArrays(all, part) {\n    return all.concat(part);\n  }\n\n  /**\n   * A no-op function that ignores its arguments.  This is used to suppress\n   * unused variable errors.\n   * @param {...*} args\n   */\n  static ignored(...args) {}\n\n\n  /**\n   * A no-op function.  Useful in promise chains.\n   */\n  static noop() {}\n\n\n  /**\n   * Returns if the given value is not null; useful for filtering out null\n   * values.\n   *\n   * @param {T} value\n   * @return {boolean}\n   * @template T\n   */\n  static isNotNull(value) {\n    return value != null;\n  }\n\n  /**\n   * Calls a factory function while allowing it to be a constructor for\n   * reverse-compatibility.\n   *\n   * @param {function():!T} factory\n   * @return {!T}\n   * @template T\n   */\n  static callFactory(factory) {\n    // See https://stackoverflow.com/q/10428603/1208502\n    // eslint-disable-next-line no-restricted-syntax\n    const obj = Object.create(factory.prototype || Object.prototype);\n    // If this is a constructor, call it with our newly created object to\n    // initialize it; if this isn't a constructor, the \"this\" shouldn't be used\n    // since it should be \"undefined\".\n    let ret;\n    try {\n      ret = factory.call(obj);  // eslint-disable-line no-restricted-syntax\n\n      // If it didn't return anything, assume it is a constructor and return our\n      // \"this\" value instead.\n      if (!ret) {\n        shaka.Deprecate.deprecateFeature(4,\n            'Factories requiring new',\n            'Factories should be plain functions');\n        ret = obj;\n      }\n    } catch (e) {\n      // This was an ES6 class, so it threw a TypeError because we didn't use\n      // \"new\".  Fall back to actually using \"new\".\n      shaka.Deprecate.deprecateFeature(4,\n          'Factories requiring new',\n          'Factories should be plain functions');\n      const FactoryAsClass = /** @type {function(new: T)} */(factory);\n      ret = new FactoryAsClass();\n    }\n    return ret;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.deprecate.Enforcer');\n\ngoog.require('shaka.deprecate.Version');\n\n\n/**\n * The enforcer's job is to call the correct callback when a feature will need\n * to be removed later or removed now.\n *\n * The \"what should be done\" is not part of the enforcer, that must be provided\n * to the enforcer when it is created. This separation was created so that\n * testing and production could be equal users of the enforcer.\n *\n * @final\n */\nshaka.deprecate.Enforcer = class {\n  /**\n   * @param {!shaka.deprecate.Version} libraryVersion\n   * @param {shaka.deprecate.Listener} onPending\n   * @param {shaka.deprecate.Listener} onExpired\n   */\n  constructor(libraryVersion, onPending, onExpired) {\n    /** @private {!shaka.deprecate.Version} */\n    this.libraryVersion_ = libraryVersion;\n\n    /** @private {shaka.deprecate.Listener} */\n    this.onPending_ = onPending;\n    /** @private {shaka.deprecate.Listener} */\n    this.onExpired_ = onExpired;\n  }\n\n  /**\n   * Tell the enforcer that a feature will expire on |expiredOn| and that it\n   * should notify the listeners if it is pending or expired.\n   *\n   * @param {!shaka.deprecate.Version} expiresOn\n   * @param {string} name\n   * @param {string} description\n   */\n  enforce(expiresOn, name, description) {\n    // If the expiration version is larger than the library version\n    // (compareTo > 0), it means the expiration is in the future, and is still\n    // pending.\n    const isPending = expiresOn.compareTo(this.libraryVersion_) > 0;\n\n    // Find the right callback (pending or expired) for this enforcement request\n    // call it to handle this features pending/expired removal.\n    const callback = isPending ? this.onPending_ : this.onExpired_;\n    callback(this.libraryVersion_, expiresOn, name, description);\n  }\n};\n\n/**\n * A callback for listening to deprecation events.\n *\n * Parameters:\n *  libraryVersion: !shaka.deprecate.Version\n *  featureVersion: !shaka.deprecate.Version\n *  name: string\n *  description: string\n *\n * libraryVersion: The current version of the library.\n * featureVersion: The version of the library when the feature should be\n *                 removed.\n * name: The name of the feature that will/should be removed.\n * description: A description of what is changing.\n *\n * @typedef {function(\n *    !shaka.deprecate.Version,\n *    !shaka.deprecate.Version,\n *    string,\n *    string)}\n */\nshaka.deprecate.Listener;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dependencies');\n\n/**\n * @export\n */\nshaka.dependencies = class {\n  /**\n   * Registers a new dependency.\n   *\n   * @param {shaka.dependencies.Allowed} key which is used for retrieving a\n   *   dependency\n   * @param {?} dep a dependency\n   * @export\n   */\n  static add(key, dep) {\n    if (!shaka.dependencies.Allowed[key]) {\n      throw new Error(`${key} is not supported`);\n    }\n    shaka.dependencies.dependencies_.set(key, () => dep);\n  }\n\n  /**\n   * Check if we have a dependency for the key.\n   *\n   * @param {shaka.dependencies.Allowed} key key\n   * @return {boolean}\n   * @export\n   */\n  static has(key) {\n    return shaka.dependencies.dependencies_.has(key);\n  }\n\n  /** @return {?muxjs} */\n  static muxjs() {\n    return /** @type {?muxjs} */ (shaka.dependencies.dependencies_.get(\n        shaka.dependencies.Allowed.muxjs)());\n  }\n};\n\n/**\n * @export\n * @enum {string}\n */\nshaka.dependencies.Allowed = {\n  muxjs: 'muxjs',\n};\n\n/**\n * Contains accessor functions to shared dependencies that could be used by\n * other components.  The default accessors can be overridden.\n *\n * @private {!Map.<shaka.dependencies.Allowed, function():?>}\n */\nshaka.dependencies.dependencies_ = new Map([\n  [shaka.dependencies.Allowed.muxjs, () => window.muxjs],\n]);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Error');\n\n\n/**\n * @summary\n * Describes an error that happened.\n *\n * @description\n * This uses numerical codes to describe\n * which error happened.\n *\n * Some error are caused by errors from the browser.  In these cases, the error\n * object is provided as part of the <code>data</code> field.  System codes come\n * from the browser and may or may not be documented.  Here are some places\n * where the errors may be documented:\n * <ul>\n *   <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaError\">MediaError</a>\n *   <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\">HTTP Codes</a>\n *   <li><a href=\"https://hresult.info\">Edge/PlayReady errors</a>\n * </ul>\n *\n * @export\n * @implements {shaka.extern.Error}\n * @extends {Error}\n */\nshaka.util.Error = class {\n  /**\n   * @param {shaka.util.Error.Severity} severity\n   * @param {shaka.util.Error.Category} category\n   * @param {shaka.util.Error.Code} code\n   * @param {...*} varArgs\n   */\n  constructor(severity, category, code, ...varArgs) {\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.severity = severity;\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.category = category;\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.code = code;\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.data = varArgs;\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.handled = false;\n\n    // This improves the formatting of Errors in failure messages in the tests.\n    if (goog.DEBUG) {\n      let categoryName = 'UNKNOWN';\n      let codeName = 'UNKNOWN';\n\n      for (const k in shaka.util.Error.Category) {\n        if (shaka.util.Error.Category[k] == this.category) {\n          categoryName = k;\n        }\n      }\n      for (const k in shaka.util.Error.Code) {\n        if (shaka.util.Error.Code[k] == this.code) {\n          codeName = k;\n        }\n      }\n\n      /**\n       * A human-readable version of the category and code.\n       * <i>(Only available in uncompiled mode.)</i>\n       *\n       * @const {string}\n       * @exportDoc\n       */\n      this.message = 'Shaka Error ' + categoryName + '.' + codeName +\n                     ' (' + this.data.toString() + ')';\n\n      if (shaka.util.Error.createStack) {\n        try {\n          throw new Error(this.message);\n        } catch (e) {\n          /**\n           * A stack-trace showing where the error occurred.\n           * <i>(Only available in uncompiled mode.)</i>\n           *\n           * @const {string}\n           * @exportDoc\n           */\n          this.stack = e.stack;\n        }\n      }\n    }\n  }\n\n\n  /**\n   * @return {string}\n   * @override\n   */\n  toString() {\n    return 'shaka.util.Error ' + JSON.stringify(this, null, '  ');\n  }\n};\n\n\nif (goog.DEBUG) {\n  /**\n   * If true, create a stack trace in Error objects.\n   *\n   * Only available in uncompiled mode, and disabled in tests to avoid issues\n   * with karma-jasmine.  See comments in test/test/boot.js for details.\n   *\n   * @type {boolean}\n   */\n  shaka.util.Error.createStack = true;\n}\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.util.Error.Severity = {\n  /**\n   * An error occurred, but the Player is attempting to recover from the error.\n   *\n   * If the Player cannot ultimately recover, it still may not throw a CRITICAL\n   * error.  For example, retrying for a media segment will never result in\n   * a CRITICAL error (the Player will just retry forever).\n   */\n  'RECOVERABLE': 1,\n\n  /**\n   * A critical error that the library cannot recover from.  These usually cause\n   * the Player to stop loading or updating.  A new manifest must be loaded\n   * to reset the library.\n   */\n  'CRITICAL': 2,\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.util.Error.Category = {\n  /** Errors from the network stack. */\n  'NETWORK': 1,\n\n  /** Errors parsing text streams. */\n  'TEXT': 2,\n\n  /** Errors parsing or processing audio or video streams. */\n  'MEDIA': 3,\n\n  /** Errors parsing the Manifest. */\n  'MANIFEST': 4,\n\n  /** Errors related to streaming. */\n  'STREAMING': 5,\n\n  /** Errors related to DRM. */\n  'DRM': 6,\n\n  /** Miscellaneous errors from the player. */\n  'PLAYER': 7,\n\n  /** Errors related to cast. */\n  'CAST': 8,\n\n  /** Errors in the database storage (offline). */\n  'STORAGE': 9,\n\n  /** Errors related to ad insertion. */\n  'ADS': 10,\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.util.Error.Code = {\n  /**\n   * A network request was made using an unsupported URI scheme.\n   * <br> error.data[0] is the URI.\n   */\n  'UNSUPPORTED_SCHEME': 1000,\n\n  /**\n   * An HTTP network request returned an HTTP status that indicated a failure.\n   * <br> error.data[0] is the URI.\n   * <br> error.data[1] is the status code.\n   * <br> error.data[2] is the response text, or null if the response could not\n   *   be interpretted as text.\n   * <br> error.data[3] is the map of response headers.\n   * <br> error.data[4] is the NetworkingEngine.RequestType of the request,\n   *   if one was provided.\n   */\n  'BAD_HTTP_STATUS': 1001,\n\n  /**\n   * An HTTP network request failed with an error, but not from the server.\n   * <br> error.data[0] is the URI.\n   * <br> error.data[1] is the original error.\n   * <br> error.data[2] is the NetworkingEngine.RequestType of the request.\n   */\n  'HTTP_ERROR': 1002,\n\n  /**\n   * A network request timed out.\n   * <br> error.data[0] is the URI.\n   * <br> error.data[1] is the NetworkingEngine.RequestType of the request,\n   *   if one was provided.\n   */\n  'TIMEOUT': 1003,\n\n  /**\n   * A network request was made with a malformed data URI.\n   * <br> error.data[0] is the URI.\n   */\n  'MALFORMED_DATA_URI': 1004,\n\n  // RETIRED: 'UNKNOWN_DATA_URI_ENCODING': 1005,\n\n  /**\n   * A request filter threw an error.\n   * <br> error.data[0] is the original error.\n   */\n  'REQUEST_FILTER_ERROR': 1006,\n\n  /**\n   * A response filter threw an error.\n   * <br> error.data[0] is the original error.\n   */\n  'RESPONSE_FILTER_ERROR': 1007,\n\n  /**\n   * A testing network request was made with a malformed URI.\n   * This error is only used by unit and integration tests.\n   */\n  'MALFORMED_TEST_URI': 1008,\n\n  /**\n   * An unexpected network request was made to the FakeNetworkingEngine.\n   * This error is only used by unit and integration tests.\n   */\n  'UNEXPECTED_TEST_REQUEST': 1009,\n\n  /**\n   * The number of retry attempts have run out.\n   * This is an internal error and shouldn't be propagated.\n   */\n  'ATTEMPTS_EXHAUSTED': 1010,\n\n\n  /** The text parser failed to parse a text stream due to an invalid header. */\n  'INVALID_TEXT_HEADER': 2000,\n\n  /**\n   * The text parser failed to parse a text stream due to an invalid cue.\n   * <br> error.data[0] is extra context, if available.\n   */\n  'INVALID_TEXT_CUE': 2001,\n\n  // RETIRED: 'INVALID_TEXT_SETTINGS': 2002,\n\n  /**\n   * Was unable to detect the encoding of the response text.  Suggest adding\n   * byte-order-markings to the response data.\n   */\n  'UNABLE_TO_DETECT_ENCODING': 2003,\n\n  /** The response data contains invalid Unicode character encoding. */\n  'BAD_ENCODING': 2004,\n\n  /**\n   * The XML parser failed to parse an xml stream, or the XML lacks mandatory\n   * elements for TTML.\n   * <br> error.data[0] is extra context, if available.\n   */\n  'INVALID_XML': 2005,\n\n  // RETIRED: 'INVALID_TTML': 2006,\n\n  /**\n   * MP4 segment does not contain TTML.\n   */\n  'INVALID_MP4_TTML': 2007,\n\n  /**\n   * MP4 segment does not contain VTT.\n   */\n  'INVALID_MP4_VTT': 2008,\n\n  /**\n   * When examining media in advance, we were unable to extract the cue time.\n   * This should only be possible with HLS, where we do not have explicit\n   * segment start times.\n   * <br> error.data[0] is the underlying exception or Error object.\n   */\n  'UNABLE_TO_EXTRACT_CUE_START_TIME': 2009,\n\n  /**\n   * MP4 segment for CEA data is invalid.\n   */\n  'INVALID_MP4_CEA': 2010,\n\n  /**\n   * Unable to guess mime type of the text.\n   * <br> error.data[0] is the text file's extension.\n   */\n  'TEXT_COULD_NOT_GUESS_MIME_TYPE': 2011,\n\n  /**\n   * External text tracks cannot be added in src= because native platform\n   * doesn't support it.\n   */\n  'CANNOT_ADD_EXTERNAL_TEXT_TO_SRC_EQUALS': 2012,\n\n  /**\n   * Only WebVTT is supported when using src=.\n   * <br> error.data[0] is the text MIME type.\n   */\n  'TEXT_ONLY_WEBVTT_SRC_EQUALS': 2013,\n\n  /**\n   * The compilation does not contain a required text plugin for this\n   * operation.\n   * <br> error.data[0] is the text MIME type.\n   */\n  'MISSING_TEXT_PLUGIN': 2014,\n\n  /**\n   * The chapters track failed to load.  The browser does not provide any\n   * information in this case to identify why it failed, but there may be\n   * details in the JavaScript console.\n   */\n  'CHAPTERS_TRACK_FAILED': 2015,\n\n  /**\n   * Some component tried to read past the end of a buffer.  The segment index,\n   * init segment, or PSSH may be malformed.\n   */\n  'BUFFER_READ_OUT_OF_BOUNDS': 3000,\n\n  /**\n   * Some component tried to parse an integer that was too large to fit in a\n   * JavaScript number without rounding error.  JavaScript can only natively\n   * represent integers up to 53 bits.\n   */\n  'JS_INTEGER_OVERFLOW': 3001,\n\n  /**\n   * The EBML parser used to parse the WebM container encountered an integer,\n   * ID, or other field larger than the maximum supported by the parser.\n   */\n  'EBML_OVERFLOW': 3002,\n\n  /**\n   * The EBML parser used to parse the WebM container encountered a floating-\n   * point field of a size not supported by the parser.\n   */\n  'EBML_BAD_FLOATING_POINT_SIZE': 3003,\n\n  /**\n   * The MP4 SIDX parser found the wrong box type.\n   * Either the segment index range is incorrect or the data is corrupt.\n   */\n  'MP4_SIDX_WRONG_BOX_TYPE': 3004,\n\n  /**\n   * The MP4 SIDX parser encountered an invalid timescale.\n   * The segment index data may be corrupt.\n   */\n  'MP4_SIDX_INVALID_TIMESCALE': 3005,\n\n  /** The MP4 SIDX parser encountered a type of SIDX that is not supported. */\n  'MP4_SIDX_TYPE_NOT_SUPPORTED': 3006,\n\n  /**\n   * The WebM Cues parser was unable to locate the Cues element.\n   * The segment index data may be corrupt.\n   */\n  'WEBM_CUES_ELEMENT_MISSING': 3007,\n\n  /**\n   * The WebM header parser was unable to locate the Ebml element.\n   * The init segment data may be corrupt.\n   */\n  'WEBM_EBML_HEADER_ELEMENT_MISSING': 3008,\n\n  /**\n   * The WebM header parser was unable to locate the Segment element.\n   * The init segment data may be corrupt.\n   */\n  'WEBM_SEGMENT_ELEMENT_MISSING': 3009,\n\n  /**\n   * The WebM header parser was unable to locate the Info element.\n   * The init segment data may be corrupt.\n   */\n  'WEBM_INFO_ELEMENT_MISSING': 3010,\n\n  /**\n   * The WebM header parser was unable to locate the Duration element.\n   * The init segment data may be corrupt or may have been incorrectly encoded.\n   * Shaka requires a duration in WebM DASH content.\n   */\n  'WEBM_DURATION_ELEMENT_MISSING': 3011,\n\n  /**\n   * The WebM Cues parser was unable to locate the Cue Track Positions element.\n   * The segment index data may be corrupt.\n   */\n  'WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING': 3012,\n\n  /**\n   * The WebM Cues parser was unable to locate the Cue Time element.\n   * The segment index data may be corrupt.\n   */\n  'WEBM_CUE_TIME_ELEMENT_MISSING': 3013,\n\n  /**\n   * A MediaSource operation failed.\n   * <br> error.data[0] is a MediaError code from the video element.\n   */\n  'MEDIA_SOURCE_OPERATION_FAILED': 3014,\n\n  /**\n   * A MediaSource operation threw an exception.\n   * <br> error.data[0] is the exception that was thrown.\n   */\n  'MEDIA_SOURCE_OPERATION_THREW': 3015,\n\n  /**\n   * The video element reported an error.\n   * <br> error.data[0] is a MediaError code from the video element.\n   * <br> On Edge, error.data[1] is a Microsoft extended error code in hex.\n   * <br> On Chrome, error.data[2] is a string with details on the error.\n   * <br> See top of file for links to browser error codes.\n   */\n  'VIDEO_ERROR': 3016,\n\n  /**\n   * A MediaSource operation threw QuotaExceededError and recovery failed. The\n   * content cannot be played correctly because the segments are too large for\n   * the browser/platform. This may occur when attempting to play very high\n   * quality, very high bitrate content on low-end devices.\n   * <br> error.data[0] is the type of content which caused the error.\n   */\n  'QUOTA_EXCEEDED_ERROR': 3017,\n\n  /**\n   * Mux.js did not invoke the callback signifying successful transmuxing.\n   */\n  'TRANSMUXING_FAILED': 3018,\n\n  /**\n   * Content transformations required by the platform could not be performed for\n   * some reason (unsupported container, etc.)\n   *\n   * @see https://github.com/shaka-project/shaka-player/issues/2759\n   */\n  'CONTENT_TRANSFORMATION_FAILED': 3019,\n\n\n  /**\n   * The Player was unable to guess the manifest type based on file extension\n   * or MIME type.  To fix, try one of the following:\n   * <br><ul>\n   *   <li>Rename the manifest so that the URI ends in a well-known extension.\n   *   <li>Configure the server to send a recognizable Content-Type header.\n   *   <li>Configure the server to accept a HEAD request for the manifest.\n   * </ul>\n   * <br> error.data[0] is the manifest URI.\n   */\n  'UNABLE_TO_GUESS_MANIFEST_TYPE': 4000,\n\n  /**\n   * The DASH Manifest contained invalid XML markup.\n   * <br> error.data[0] is the URI associated with the XML.\n   */\n  'DASH_INVALID_XML': 4001,\n\n  /**\n   * The DASH Manifest contained a Representation with insufficient segment\n   * information.\n   */\n  'DASH_NO_SEGMENT_INFO': 4002,\n\n  /** The DASH Manifest contained an AdaptationSet with no Representations. */\n  'DASH_EMPTY_ADAPTATION_SET': 4003,\n\n  /** The DASH Manifest contained an Period with no AdaptationSets. */\n  'DASH_EMPTY_PERIOD': 4004,\n\n  /**\n   * The DASH Manifest does not specify an init segment with a WebM container.\n   */\n  'DASH_WEBM_MISSING_INIT': 4005,\n\n  /** The DASH Manifest contained an unsupported container format. */\n  'DASH_UNSUPPORTED_CONTAINER': 4006,\n\n  /** The embedded PSSH data has invalid encoding. */\n  'DASH_PSSH_BAD_ENCODING': 4007,\n\n  /**\n   * There is an AdaptationSet whose Representations do not have any common\n   * key-systems.\n   */\n  'DASH_NO_COMMON_KEY_SYSTEM': 4008,\n\n  /** Having multiple key IDs per Representation is not supported. */\n  'DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED': 4009,\n\n  /** The DASH Manifest specifies conflicting key IDs. */\n  'DASH_CONFLICTING_KEY_IDS': 4010,\n\n  // RETIRED: 'UNPLAYABLE_PERIOD': 4011,\n\n  /**\n   * There exist some streams that could be decoded, but restrictions imposed\n   * by the application or the key system prevent us from playing.  This may\n   * happen under the following conditions:\n   * <ul>\n   *   <li>The application has given restrictions to the Player that restrict\n   *       at least one content type completely (e.g. no playable audio).\n   *   <li>The manifest specifies different keys than were given to us from the\n   *       license server.\n   *   <li>The key system has imposed output restrictions that cannot be met\n   *       (such as HDCP) and there are no unrestricted alternatives.\n   * </ul>\n   * <br> error.data[0] is a {@link shaka.extern.RestrictionInfo} object\n   * describing the kinds of restrictions that caused this error.\n   */\n  'RESTRICTIONS_CANNOT_BE_MET': 4012,\n\n  // RETIRED: 'INTERNAL_ERROR_KEY_STATUS': 4013,\n\n  // RETIRED: 'NO_PERIODS': 4014,\n\n  /**\n   * HLS playlist doesn't start with a mandory #EXTM3U tag.\n   */\n  'HLS_PLAYLIST_HEADER_MISSING': 4015,\n\n  /**\n   * HLS tag has an invalid name that doesn't start with '#EXT'\n   * <br> error.data[0] is the invalid tag.\n   */\n  'INVALID_HLS_TAG': 4016,\n\n  /**\n   * HLS playlist has both Master and Media/Segment tags.\n   */\n  'HLS_INVALID_PLAYLIST_HIERARCHY': 4017,\n\n  /**\n   * A Representation has an id that is the same as another Representation in\n   * the same Period.  This makes manifest updates impossible since we cannot\n   * map the updated Representation to the old one.\n   */\n  'DASH_DUPLICATE_REPRESENTATION_ID': 4018,\n\n  // RETIRED: 'HLS_MEDIA_INIT_SECTION_INFO_MISSING': 4019,\n\n  /**\n   * HLS manifest has several #EXT-X-MAP tags. We can only\n   * support one at the moment.\n   */\n  'HLS_MULTIPLE_MEDIA_INIT_SECTIONS_FOUND': 4020,\n\n  // RETIRED: 'HLS_COULD_NOT_GUESS_MIME_TYPE': 4021,\n\n  /**\n   * No Master Playlist has been provided. Master playlist provides\n   * vital information about the streams (like codecs) that is\n   * required for MediaSource. We don't support directly providing\n   * a Media Playlist.\n   */\n  'HLS_MASTER_PLAYLIST_NOT_PROVIDED': 4022,\n\n  /**\n   * One of the required attributes was not provided, so the\n   * HLS manifest is invalid.\n   * <br> error.data[0] is the missing attribute's name.\n   */\n  'HLS_REQUIRED_ATTRIBUTE_MISSING': 4023,\n\n  /**\n   * One of the required tags was not provided, so the\n   * HLS manifest is invalid.\n   * <br> error.data[0] is the missing tag's name.\n   */\n  'HLS_REQUIRED_TAG_MISSING': 4024,\n\n  /**\n   * The HLS parser was unable to guess codecs of a stream.\n   * <br> error.data[0] is the list of all codecs for the variant.\n   */\n  'HLS_COULD_NOT_GUESS_CODECS': 4025,\n\n  /**\n   * The HLS parser has encountered encrypted content with unsupported\n   * KEYFORMAT attributes.\n   */\n  'HLS_KEYFORMATS_NOT_SUPPORTED': 4026,\n\n  /**\n   * The manifest parser only supports xlink links with xlink:actuate=\"onLoad\".\n   */\n  'DASH_UNSUPPORTED_XLINK_ACTUATE': 4027,\n\n  /**\n   * The manifest parser has hit its depth limit on xlink link chains.\n   */\n  'DASH_XLINK_DEPTH_LIMIT': 4028,\n\n  // RETIRED: 'HLS_LIVE_CONTENT_NOT_SUPPORTED': 4029,\n\n  /**\n   * The HLS parser was unable to parse segment start time from the media.\n   * <br> error.data[0] is the failed media playlist URI.\n   * <br> error.data[1] is the failed media segment URI (if any).\n   */\n  'HLS_COULD_NOT_PARSE_SEGMENT_START_TIME': 4030,\n\n  // RETIRED: 'HLS_MEDIA_SEQUENCE_REQUIRED_IN_LIVE_STREAMS': 4031,\n\n  /**\n   * The content container or codecs are not supported by this browser. For\n   * example, this could happen if the content is WebM, but your browser does\n   * not support the WebM container, or if the content uses HEVC, but your\n   * browser does not support the HEVC codec.  This can also occur for\n   * multicodec or multicontainer manifests if none of the codecs or containers\n   * are supported by the browser.\n   *\n   * To see what your browser supports, you can check the JSON data dumped by\n   * http://support.shaka-player-demo.appspot.com/\n   */\n  'CONTENT_UNSUPPORTED_BY_BROWSER': 4032,\n\n  /**\n   * External text tracks cannot be added to live streams.\n   */\n  'CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM': 4033,\n\n  /**\n   * We do not support AES-128 encryption with HLS yet.\n   */\n  'HLS_AES_128_ENCRYPTION_NOT_SUPPORTED': 4034,\n\n  /**\n   * An internal error code that should never be seen by applications, thrown\n   * to force the HLS parser to skip an unsupported stream.\n   */\n  'HLS_INTERNAL_SKIP_STREAM': 4035,\n\n  /** The Manifest contained no Variants. */\n  'NO_VARIANTS': 4036,\n\n  /**\n   * We failed to find matching streams across DASH Periods, and the\n   * period-flattening aglorithm introduced in v3.0 has failed.\n   */\n  'PERIOD_FLATTENING_FAILED': 4037,\n\n  /**\n   * We failed to find matching streams across DASH Periods due to inconsistent\n   * DRM systems across periods.\n   */\n  'INCONSISTENT_DRM_ACROSS_PERIODS': 4038,\n\n  /**\n   * The HLS manifest refers to an undeclared variables.\n   * <br> error.data[0] is the variable undeclared.\n   */\n  'HLS_VARIABLE_NOT_FOUND': 4039,\n\n\n  // RETIRED: 'INCONSISTENT_BUFFER_STATE': 5000,\n  // RETIRED: 'INVALID_SEGMENT_INDEX': 5001,\n  // RETIRED: 'SEGMENT_DOES_NOT_EXIST': 5002,\n  // RETIRED: 'CANNOT_SATISFY_BYTE_LIMIT': 5003,\n  // RETIRED: 'BAD_SEGMENT': 5004,\n  // RETIRED: 'INVALID_STREAMS_CHOSEN': 5005,\n\n  /**\n   * This would only happen if StreamingEngine were not started correctly, and\n   * should not be seen in production.\n   */\n  'STREAMING_ENGINE_STARTUP_INVALID_STATE': 5006,\n\n\n  /**\n   * The manifest indicated protected content, but the manifest parser was\n   * unable to determine what key systems should be used.\n   */\n  'NO_RECOGNIZED_KEY_SYSTEMS': 6000,\n\n  /**\n   * None of the requested key system configurations are available.  This may\n   * happen under the following conditions:\n   * <ul>\n   *   <li> The key system is not supported.\n   *   <li> The key system does not support the features requested (e.g.\n   *        persistent state).\n   *   <li> A user prompt was shown and the user denied access.\n   *   <li> The key system is not available from unsecure contexts. (i.e.\n            requires HTTPS) See https://bit.ly/2K9X1nY\n   * </ul>\n   */\n  'REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE': 6001,\n\n  /**\n   * The browser found one of the requested key systems, but it failed to\n   * create an instance of the CDM for some unknown reason.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_CREATE_CDM': 6002,\n\n  /**\n   * The browser found one of the requested key systems and created an instance\n   * of the CDM, but it failed to attach the CDM to the video for some unknown\n   * reason.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_ATTACH_TO_VIDEO': 6003,\n\n  /**\n   * The CDM rejected the server certificate supplied by the application.\n   * The certificate may be malformed or in an unsupported format.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'INVALID_SERVER_CERTIFICATE': 6004,\n\n  /**\n   * The CDM refused to create a session for some unknown reason.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_CREATE_SESSION': 6005,\n\n  /**\n   * The CDM was unable to generate a license request for the init data it was\n   * given.  The init data may be malformed or in an unsupported format.\n   * <br> error.data[0] is an error message string from the browser.\n   * <br> error.data[1] is the error object from the browser.\n   * <br> error.data[2] is a string with the extended error code, if available.\n   * <br> See top of file for links to browser error codes.\n   */\n  'FAILED_TO_GENERATE_LICENSE_REQUEST': 6006,\n\n  /**\n   * The license request failed.  This could be a timeout, a network failure, or\n   * a rejection by the server.\n   * <br> error.data[0] is a shaka.util.Error from the networking engine.\n   */\n  'LICENSE_REQUEST_FAILED': 6007,\n\n  /**\n   * The license response was rejected by the CDM.  The server's response may be\n   * invalid or malformed for this CDM.\n   * <br> error.data[0] is an error message string from the browser.\n   * <br> See top of file for links to browser error codes.\n   */\n  'LICENSE_RESPONSE_REJECTED': 6008,\n\n  // RETIRED: 'NO_LICENSE_SERVER_SPECIFIED': 6009,\n\n  /**\n   * The manifest does not specify any DRM info, but the content is encrypted.\n   * Either the manifest or the manifest parser are broken.\n   */\n  'ENCRYPTED_CONTENT_WITHOUT_DRM_INFO': 6010,\n\n  // RETIRED: 'WRONG_KEYS': 6011,\n\n  /**\n   * No license server was given for the key system signaled by the manifest.\n   * A license server URI is required for every key system.\n   * <br> error.data[0] is the key system identifier.\n   */\n  'NO_LICENSE_SERVER_GIVEN': 6012,\n\n  /**\n   * A required offline session was removed.  The content is not playable.\n   */\n  'OFFLINE_SESSION_REMOVED': 6013,\n\n  /**\n   * The license has expired.  This is triggered when all keys in the key\n   * status map have a status of 'expired'.\n   */\n  'EXPIRED': 6014,\n\n  /**\n   * A server certificate wasn't given when it is required.  FairPlay requires\n   * setting an explicit server certificate in the configuration.\n   */\n  'SERVER_CERTIFICATE_REQUIRED': 6015,\n\n  /**\n   * An error was thrown while executing the init data transformation.\n   * <br> error.data[0] is the original error.\n   */\n  'INIT_DATA_TRANSFORM_ERROR': 6016,\n\n  /**\n   * The server certificate request failed.\n   * <br> error.data[0] is a shaka.util.Error from the networking engine.\n   */\n  'SERVER_CERTIFICATE_REQUEST_FAILED': 6017,\n\n\n  /**\n   * The call to Player.load() was interrupted by a call to Player.unload()\n   * or another call to Player.load().\n   */\n  'LOAD_INTERRUPTED': 7000,\n\n  /**\n   * An internal error which indicates that an operation was aborted.  This\n   * should not be seen by applications.\n   */\n  'OPERATION_ABORTED': 7001,\n\n  /**\n   * The call to Player.load() failed because the Player does not have a video\n   * element.  The video element must either be provided to the constructor or\n   * to Player.attach() before Player.load() is called.\n   */\n  'NO_VIDEO_ELEMENT': 7002,\n\n  /**\n   * The operation failed because the object has been destroyed.\n   */\n  'OBJECT_DESTROYED': 7003,\n\n  /**\n   * The content has not been loaded in the Player.\n   */\n  'CONTENT_NOT_LOADED': 7004,\n\n  /**\n   * The Cast API is unavailable.  This may be because of one of the following:\n   *  1. The browser may not have Cast support\n   *  2. The browser may be missing a necessary Cast extension\n   *  3. The Cast sender library may not be loaded in your app\n   */\n  'CAST_API_UNAVAILABLE': 8000,\n\n  /**\n   * No cast receivers are available at this time.\n   */\n  'NO_CAST_RECEIVERS': 8001,\n\n  /**\n   * The library is already casting.\n   */\n  'ALREADY_CASTING': 8002,\n\n  /**\n   * A Cast SDK error that we did not explicitly plan for has occurred.\n   * Check data[0] and refer to the Cast SDK documentation for details.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'UNEXPECTED_CAST_ERROR': 8003,\n\n  /**\n   * The cast operation was canceled by the user.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'CAST_CANCELED_BY_USER': 8004,\n\n  /**\n   * The cast connection timed out.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'CAST_CONNECTION_TIMED_OUT': 8005,\n\n  /**\n   * The requested receiver app ID does not exist or is unavailable.\n   * Check the requested app ID for typos.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'CAST_RECEIVER_APP_UNAVAILABLE': 8006,\n\n\n  // RETIRED: CAST_RECEIVER_APP_ID_MISSING': 8007,\n\n\n  /**\n   * Offline storage is not supported on this browser; it is required for\n   * offline support.\n   */\n  'STORAGE_NOT_SUPPORTED': 9000,\n\n  /**\n   * An unknown error occurred in the IndexedDB.\n   * <br> On Firefox, one common source for UnknownError calls is reverting\n   * Firefox to an old version. This makes the IndexedDB storage inaccessible\n   * for older versions. The only way to fix this is to delete the storage\n   * data in your profile. See https://mzl.la/2yCGWCm\n   * <br> error.data[0] is the error object.\n   */\n  'INDEXED_DB_ERROR': 9001,\n\n  /**\n   * The storage operation was aborted.  Deprecated in favor of more general\n   * OPERATION_ABORTED.\n   */\n  'DEPRECATED_OPERATION_ABORTED': 9002,\n\n  /**\n   * The specified item was not found in the IndexedDB.\n   * <br> error.data[0] is the offline URI.\n   */\n  'REQUESTED_ITEM_NOT_FOUND': 9003,\n\n  /**\n   * A network request was made with a malformed offline URI.\n   * <br> error.data[0] is the URI.\n   */\n  'MALFORMED_OFFLINE_URI': 9004,\n\n  /**\n   * The specified content is live or in-progress.\n   * Live and in-progress streams cannot be stored offline.\n   * <br> error.data[0] is the URI.\n   */\n  'CANNOT_STORE_LIVE_OFFLINE': 9005,\n\n  // RETIRED: 'STORE_ALREADY_IN_PROGRESS': 9006,\n\n  /**\n   * There was no init data available for offline storage.  This happens when\n   * there is no init data in the manifest nor could we find any in the\n   * segments.  We currently only support searching MP4 init segments for init\n   * data.\n   */\n  'NO_INIT_DATA_FOR_OFFLINE': 9007,\n\n  /**\n   * shaka.offline.Storage was constructed with a Player proxy instead of a\n   * local player instance.  To fix this, use Player directly with Storage\n   * instead of the results of CastProxy.prototype.getPlayer().\n   */\n  'LOCAL_PLAYER_INSTANCE_REQUIRED': 9008,\n\n  // RETIRED/MOVED TO 4000's: 'CONTENT_UNSUPPORTED_BY_BROWSER': 9009,\n\n  // RETIRED: 'UNSUPPORTED_UPGRADE_REQUEST': 9010,\n\n  /**\n   * The storage cell does not allow new operations that require new keys.\n   */\n  'NEW_KEY_OPERATION_NOT_SUPPORTED': 9011,\n\n  /**\n   * A key was not found in a storage cell.\n   */\n  'KEY_NOT_FOUND': 9012,\n\n  /**\n   * A storage cell was not found.\n   */\n  'MISSING_STORAGE_CELL': 9013,\n\n  /**\n   * The storage limit defined in <code>downloadSizeCallback</code> has been\n   * reached.\n   */\n  'STORAGE_LIMIT_REACHED': 9014,\n\n  /**\n   * <code>downloadSizeCallback</code> has produced an unexpected error.\n   */\n  'DOWNLOAD_SIZE_CALLBACK_ERROR': 9015,\n\n  /**\n   * The storage cell does not allow new operations that significantly change\n   * existing data.\n   */\n  'MODIFY_OPERATION_NOT_SUPPORTED': 9016,\n\n  /**\n   * When attempting to open an indexedDB instance, nothing happened for long\n   * enough for us to time out.  This keeps the storage mechanism from hanging\n   * indefinitely, if neither the success nor error callbacks are called.\n   */\n  'INDEXED_DB_INIT_TIMED_OUT': 9017,\n\n  /**\n   * CS IMA SDK, required for ad insertion, has not been included on the page.\n   */\n  'CS_IMA_SDK_MISSING': 10000,\n\n  /**\n   * Client Side Ad Manager needs to be initialized to enable Client Side\n   * Ad Insertion. Call adManager.initClientSide() to do it.\n   */\n  'CS_AD_MANAGER_NOT_INITIALIZED': 10001,\n\n  /**\n   * SS IMA SDK, required for ad insertion, has not been included on the page.\n   */\n  'SS_IMA_SDK_MISSING': 10002,\n\n  /**\n   * Server Side Ad Manager needs to be initialized to enable Server Side\n   * Ad Insertion. Call adManager.initServerSide() to do it.\n   */\n  'SS_AD_MANAGER_NOT_INITIALIZED': 10003,\n\n  /**\n   * A new DAI steam was requested before the previous request had been\n   * resolved. Only one stream request at a time is supported. Please wait\n   * for the previous request to complete before initiating a new one.\n   */\n  'CURRENT_DAI_REQUEST_NOT_FINISHED': 10004,\n};\n", "/*! @license\n * Copyright 2008 The Closure Library Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Simple utilities for splitting URI strings.\n *\n * Uses features of RFC 3986 for parsing/formatting URIs:\n *   http://www.ietf.org/rfc/rfc3986.txt\n *\n * @author gboyer@google.com (Garrett Boyer) - The \"lightened\" design.\n * @author msamuel@google.com (Mike Samuel) - Domain knowledge and regexes.\n */\n\ngoog.provide('goog.uri.utils');\ngoog.provide('goog.uri.utils.ComponentIndex');\n\n\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {@link http://www.ietf.org/rfc/rfc3986.txt} says in Appendix B\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n * @type {!RegExp}\n * @private\n */\ngoog.uri.utils.splitRe_ = new RegExp(\n    '^' +\n    '(?:' +\n        '([^:/?#.]+)' +                  // scheme - ignore special characters\n                                         // used by other URL parts such as :,\n                                         // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n        '(?:([^/?#]*)@)?' +              // userInfo\n        '([^/#?]*?)' +                   // domain\n        '(?::([0-9]+))?' +               // port\n        '(?=[/#?]|$)' +                  // authority-terminating character\n    ')?' +\n    '([^?#]+)?' +                        // path\n    '(?:\\\\?([^#]*))?' +                  // query\n    '(?:#(.*))?' +                       // fragment\n    '$');\n\n\n/**\n * The index of each URI component in the return value of goog.uri.utils.split.\n * @enum {number}\n */\ngoog.uri.utils.ComponentIndex = {\n  SCHEME: 1,\n  USER_INFO: 2,\n  DOMAIN: 3,\n  PORT: 4,\n  PATH: 5,\n  QUERY_DATA: 6,\n  FRAGMENT: 7\n};\n\n\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\n * </pre>\n *\n * @param {string} uri The URI string to examine.\n * @return {!Array.<string|undefined>} Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\ngoog.uri.utils.split = function(uri) {\n  // See @return comment -- never null.\n  return /** @type {!Array.<string|undefined>} */ (\n      uri.match(goog.uri.utils.splitRe_));\n};\n", "/*! @license\n * Copyright 2006 The Closure Library Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class for parsing and formatting URIs.\n *\n * Use new goog.Uri(string) to parse a URI string.\n *\n * e.g: <code>var myUri = new goog.Uri(window.location);</code>\n *\n * Implements RFC 3986 for parsing/formatting URIs.\n * http://www.ietf.org/rfc/rfc3986.txt\n *\n * Some changes have been made to the interface (more like .NETs), though the\n * internal representation is now of un-encoded parts, this will change the\n * behavior slightly.\n *\n */\n\ngoog.provide('goog.Uri');\ngoog.provide('goog.Uri.QueryData');\n\ngoog.require('goog.asserts');\ngoog.require('goog.uri.utils');\ngoog.require('goog.uri.utils.ComponentIndex');\n\n\n\n/**\n * This class contains setters and getters for the parts of the URI.\n * The <code>getXyz</code>/<code>setXyz</code> methods return the decoded part\n * -- so<code>new goog.Uri('/foo%20bar').getPath()</code> will return the\n * decoded path, <code>/foo bar</code>.\n *\n * Reserved characters (see RFC 3986 section 2.2) can be present in\n * their percent-encoded form in scheme, domain, and path URI components and\n * will not be auto-decoded. For example:\n * <code>new goog.Uri('rel%61tive/path%2fto/resource').getPath()</code> will\n * return <code>relative/path%2fto/resource</code>.\n *\n * The constructor accepts an optional unparsed, raw URI string.  The parser\n * is relaxed, so special characters that aren't escaped but don't cause\n * ambiguities will not cause parse failures.\n *\n * All setters return <code>this</code> and so may be chained, a la\n * <code>new goog.Uri('/foo').setFragment('part').toString()</code>.\n *\n * @param {*=} uri Optional string URI to parse, or if a goog.Uri is\n *        passed, a clone is created.\n *\n * @constructor\n */\ngoog.Uri = function(uri) {\n  // Parse in the uri string\n  var m;\n  if (uri instanceof goog.Uri) {\n    this.setScheme(uri.getScheme());\n    this.setUserInfo(uri.getUserInfo());\n    this.setDomain(uri.getDomain());\n    this.setPort(uri.getPort());\n    this.setPath(uri.getPath());\n    this.setQueryData(uri.getQueryData().clone());\n    this.setFragment(uri.getFragment());\n  } else if (uri && (m = goog.uri.utils.split(String(uri)))) {\n    // Set the parts -- decoding as we do so.\n    // COMPATABILITY NOTE - In IE, unmatched fields may be empty strings,\n    // whereas in other browsers they will be undefined.\n    this.setScheme(m[goog.uri.utils.ComponentIndex.SCHEME] || '', true);\n    this.setUserInfo(m[goog.uri.utils.ComponentIndex.USER_INFO] || '', true);\n    this.setDomain(m[goog.uri.utils.ComponentIndex.DOMAIN] || '', true);\n    this.setPort(m[goog.uri.utils.ComponentIndex.PORT]);\n    this.setPath(m[goog.uri.utils.ComponentIndex.PATH] || '', true);\n    this.setQueryData(m[goog.uri.utils.ComponentIndex.QUERY_DATA] || '', true);\n    this.setFragment(m[goog.uri.utils.ComponentIndex.FRAGMENT] || '', true);\n  } else {\n    this.queryData_ = new goog.Uri.QueryData(null, null);\n  }\n};\n\n\n/**\n * Scheme such as \"http\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.scheme_ = '';\n\n\n/**\n * User credentials in the form \"username:password\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.userInfo_ = '';\n\n\n/**\n * Domain part, e.g. \"www.google.com\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.domain_ = '';\n\n\n/**\n * Port, e.g. 8080.\n * @type {?number}\n * @private\n */\ngoog.Uri.prototype.port_ = null;\n\n\n/**\n * Path, e.g. \"/tests/img.png\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.path_ = '';\n\n\n/**\n * Object representing query data.\n * @type {!goog.Uri.QueryData}\n * @private\n */\ngoog.Uri.prototype.queryData_;\n\n\n/**\n * The fragment without the #.\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.fragment_ = '';\n\n\n/**\n * @return {string} The string form of the url.\n * @override\n */\ngoog.Uri.prototype.toString = function() {\n  var out = [];\n\n  var scheme = this.getScheme();\n  if (scheme) {\n    out.push(goog.Uri.encodeSpecialChars_(\n        scheme, goog.Uri.reDisallowedInSchemeOrUserInfo_, true), ':');\n  }\n\n  var domain = this.getDomain();\n  if (domain) {\n    out.push('//');\n\n    var userInfo = this.getUserInfo();\n    if (userInfo) {\n      out.push(goog.Uri.encodeSpecialChars_(\n          userInfo, goog.Uri.reDisallowedInSchemeOrUserInfo_, true), '@');\n    }\n\n    out.push(goog.Uri.removeDoubleEncoding_(encodeURIComponent(domain)));\n\n    var port = this.getPort();\n    if (port != null) {\n      out.push(':', String(port));\n    }\n  }\n\n  var path = this.getPath();\n  if (path) {\n    if (this.hasDomain() && path.charAt(0) != '/') {\n      out.push('/');\n    }\n    out.push(goog.Uri.encodeSpecialChars_(\n        path,\n        path.charAt(0) == '/' ?\n            goog.Uri.reDisallowedInAbsolutePath_ :\n            goog.Uri.reDisallowedInRelativePath_,\n        true));\n  }\n\n  var query = this.getEncodedQuery();\n  if (query) {\n    out.push('?', query);\n  }\n\n  var fragment = this.getFragment();\n  if (fragment) {\n    out.push('#', goog.Uri.encodeSpecialChars_(\n        fragment, goog.Uri.reDisallowedInFragment_));\n  }\n  return out.join('');\n};\n\n\n/**\n * Resolves the given relative URI (a goog.Uri object), using the URI\n * represented by this instance as the base URI.\n *\n * There are several kinds of relative URIs:<br>\n * 1. foo - replaces the last part of the path, the whole query and fragment<br>\n * 2. /foo - replaces the the path, the query and fragment<br>\n * 3. //foo - replaces everything from the domain on.  foo is a domain name<br>\n * 4. ?foo - replace the query and fragment<br>\n * 5. #foo - replace the fragment only\n *\n * Additionally, if relative URI has a non-empty path, all \"..\" and \".\"\n * segments will be resolved, as described in RFC 3986.\n *\n * @param {goog.Uri} relativeUri The relative URI to resolve.\n * @return {!goog.Uri} The resolved URI.\n */\ngoog.Uri.prototype.resolve = function(relativeUri) {\n\n  var absoluteUri = this.clone();\n  if (absoluteUri.scheme_ === 'data') {\n    // Cannot have a relative URI to a data URI.\n    absoluteUri = new goog.Uri();\n  }\n\n  // we satisfy these conditions by looking for the first part of relativeUri\n  // that is not blank and applying defaults to the rest\n\n  var overridden = relativeUri.hasScheme();\n\n  if (overridden) {\n    absoluteUri.setScheme(relativeUri.getScheme());\n  } else {\n    overridden = relativeUri.hasUserInfo();\n  }\n\n  if (overridden) {\n    absoluteUri.setUserInfo(relativeUri.getUserInfo());\n  } else {\n    overridden = relativeUri.hasDomain();\n  }\n\n  if (overridden) {\n    absoluteUri.setDomain(relativeUri.getDomain());\n  } else {\n    overridden = relativeUri.hasPort();\n  }\n\n  var path = relativeUri.getPath();\n  if (overridden) {\n    absoluteUri.setPort(relativeUri.getPort());\n  } else {\n    overridden = relativeUri.hasPath();\n    if (overridden) {\n      // resolve path properly\n      if (path.charAt(0) != '/') {\n        // path is relative\n        if (this.hasDomain() && !this.hasPath()) {\n          // RFC 3986, section 5.2.3, case 1\n          path = '/' + path;\n        } else {\n          // RFC 3986, section 5.2.3, case 2\n          var lastSlashIndex = absoluteUri.getPath().lastIndexOf('/');\n          if (lastSlashIndex != -1) {\n            path = absoluteUri.getPath().substr(0, lastSlashIndex + 1) + path;\n          }\n        }\n      }\n      path = goog.Uri.removeDotSegments(path);\n    }\n  }\n\n  if (overridden) {\n    absoluteUri.setPath(path);\n  } else {\n    overridden = relativeUri.hasQuery();\n  }\n\n  if (overridden) {\n    absoluteUri.setQueryData(relativeUri.getQueryData().clone());\n  } else {\n    overridden = relativeUri.hasFragment();\n  }\n\n  if (overridden) {\n    absoluteUri.setFragment(relativeUri.getFragment());\n  }\n\n  return absoluteUri;\n};\n\n\n/**\n * Clones the URI instance.\n * @return {!goog.Uri} New instance of the URI object.\n */\ngoog.Uri.prototype.clone = function() {\n  return new goog.Uri(this);\n};\n\n\n/**\n * @return {string} The encoded scheme/protocol for the URI.\n */\ngoog.Uri.prototype.getScheme = function() {\n  return this.scheme_;\n};\n\n\n/**\n * Sets the scheme/protocol.\n * @param {string} newScheme New scheme value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setScheme = function(newScheme, decode) {\n  this.scheme_ = decode ? goog.Uri.decodeOrEmpty_(newScheme, true) :\n      newScheme;\n\n  // remove an : at the end of the scheme so somebody can pass in\n  // window.location.protocol\n  if (this.scheme_) {\n    this.scheme_ = this.scheme_.replace(/:$/, '');\n  }\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the scheme has been set.\n */\ngoog.Uri.prototype.hasScheme = function() {\n  return !!this.scheme_;\n};\n\n\n/**\n * @return {string} The decoded user info.\n */\ngoog.Uri.prototype.getUserInfo = function() {\n  return this.userInfo_;\n};\n\n\n/**\n * Sets the userInfo.\n * @param {string} newUserInfo New userInfo value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setUserInfo = function(newUserInfo, decode) {\n  this.userInfo_ = decode ? goog.Uri.decodeOrEmpty_(newUserInfo) :\n                   newUserInfo;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the user info has been set.\n */\ngoog.Uri.prototype.hasUserInfo = function() {\n  return !!this.userInfo_;\n};\n\n\n/**\n * @return {string} The decoded domain.\n */\ngoog.Uri.prototype.getDomain = function() {\n  return this.domain_;\n};\n\n\n/**\n * Sets the domain.\n * @param {string} newDomain New domain value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setDomain = function(newDomain, decode) {\n  this.domain_ = decode ? goog.Uri.decodeOrEmpty_(newDomain, true) :\n      newDomain;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the domain has been set.\n */\ngoog.Uri.prototype.hasDomain = function() {\n  return !!this.domain_;\n};\n\n\n/**\n * @return {?number} The port number.\n */\ngoog.Uri.prototype.getPort = function() {\n  return this.port_;\n};\n\n\n/**\n * Sets the port number.\n * @param {*} newPort Port number. Will be explicitly casted to a number.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setPort = function(newPort) {\n  if (newPort) {\n    newPort = Number(newPort);\n    if (isNaN(newPort) || newPort < 0) {\n      throw Error('Bad port number ' + newPort);\n    }\n    this.port_ = newPort;\n  } else {\n    this.port_ = null;\n  }\n\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the port has been set.\n */\ngoog.Uri.prototype.hasPort = function() {\n  return this.port_ != null;\n};\n\n\n/**\n  * @return {string} The decoded path.\n */\ngoog.Uri.prototype.getPath = function() {\n  return this.path_;\n};\n\n\n/**\n * Sets the path.\n * @param {string} newPath New path value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setPath = function(newPath, decode) {\n  this.path_ = decode ? goog.Uri.decodeOrEmpty_(newPath, true) : newPath;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the path has been set.\n */\ngoog.Uri.prototype.hasPath = function() {\n  return !!this.path_;\n};\n\n\n/**\n * @return {boolean} Whether the query string has been set.\n */\ngoog.Uri.prototype.hasQuery = function() {\n  return this.queryData_.toString() !== '';\n};\n\n\n/**\n * Sets the query data.\n * @param {goog.Uri.QueryData|string|undefined} queryData QueryData object.\n * @param {boolean=} decode Optional param for whether to decode new value.\n *     Applies only if queryData is a string.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setQueryData = function(queryData, decode) {\n  if (queryData instanceof goog.Uri.QueryData) {\n    this.queryData_ = queryData;\n  } else {\n    if (!decode) {\n      // QueryData accepts encoded query string, so encode it if\n      // decode flag is not true.\n      queryData = goog.Uri.encodeSpecialChars_(queryData,\n                                               goog.Uri.reDisallowedInQuery_);\n    }\n    this.queryData_ = new goog.Uri.QueryData(queryData, null);\n  }\n\n  return this;\n};\n\n\n/**\n * @return {string} The encoded URI query, not including the ?.\n */\ngoog.Uri.prototype.getEncodedQuery = function() {\n  return this.queryData_.toString();\n};\n\n\n/**\n * @return {string} The decoded URI query, not including the ?.\n */\ngoog.Uri.prototype.getDecodedQuery = function() {\n  return this.queryData_.toDecodedString();\n};\n\n\n/**\n * Returns the query data.\n * @return {!goog.Uri.QueryData} QueryData object.\n */\ngoog.Uri.prototype.getQueryData = function() {\n  return this.queryData_;\n};\n\n\n/**\n * @return {string} The URI fragment, not including the #.\n */\ngoog.Uri.prototype.getFragment = function() {\n  return this.fragment_;\n};\n\n\n/**\n * Sets the URI fragment.\n * @param {string} newFragment New fragment value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setFragment = function(newFragment, decode) {\n  this.fragment_ = decode ? goog.Uri.decodeOrEmpty_(newFragment) :\n                   newFragment;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the URI has a fragment set.\n */\ngoog.Uri.prototype.hasFragment = function() {\n  return !!this.fragment_;\n};\n\n\n//==============================================================================\n// Static members\n//==============================================================================\n\n\n/**\n * Removes dot segments in given path component, as described in\n * RFC 3986, section 5.2.4.\n *\n * @param {string} path A non-empty path component.\n * @return {string} Path component with removed dot segments.\n */\ngoog.Uri.removeDotSegments = function(path) {\n  if (path == '..' || path == '.') {\n    return '';\n\n  } else if (path.indexOf('./') == -1 &&\n             path.indexOf('/.') == -1) {\n    // This optimization detects uris which do not contain dot-segments,\n    // and as a consequence do not require any processing.\n    return path;\n\n  } else {\n    var leadingSlash = (path.lastIndexOf('/', 0) == 0);\n    var segments = path.split('/');\n    var out = [];\n\n    for (var pos = 0; pos < segments.length; ) {\n      var segment = segments[pos++];\n\n      if (segment == '.') {\n        if (leadingSlash && pos == segments.length) {\n          out.push('');\n        }\n      } else if (segment == '..') {\n        if (out.length > 1 || out.length == 1 && out[0] != '') {\n          out.pop();\n        }\n        if (leadingSlash && pos == segments.length) {\n          out.push('');\n        }\n      } else {\n        out.push(segment);\n        leadingSlash = true;\n      }\n    }\n\n    return out.join('/');\n  }\n};\n\n\n/**\n * Decodes a value or returns the empty string if it isn't defined or empty.\n * @param {string|undefined} val Value to decode.\n * @param {boolean=} preserveReserved If true, restricted characters will\n *     not be decoded.\n * @return {string} Decoded value.\n * @private\n */\ngoog.Uri.decodeOrEmpty_ = function(val, preserveReserved) {\n  // Don't use UrlDecode() here because val is not a query parameter.\n  if (!val) {\n    return '';\n  }\n\n  return preserveReserved ? decodeURI(val) : decodeURIComponent(val);\n};\n\n\n/**\n * If unescapedPart is non null, then escapes any characters in it that aren't\n * valid characters in a url and also escapes any special characters that\n * appear in extra.\n *\n * @param {(?string|undefined)} unescapedPart The string to encode.\n * @param {RegExp} extra A character set of characters in [\\01-\\177].\n * @param {boolean=} removeDoubleEncoding If true, remove double percent\n *     encoding.\n * @return {?string} null iff unescapedPart == null.\n * @private\n */\ngoog.Uri.encodeSpecialChars_ = function(unescapedPart, extra,\n    removeDoubleEncoding) {\n  if (unescapedPart != null) {\n    var encoded = encodeURI(unescapedPart).\n        replace(extra, goog.Uri.encodeChar_);\n    if (removeDoubleEncoding) {\n      // encodeURI double-escapes %XX sequences used to represent restricted\n      // characters in some URI components, remove the double escaping here.\n      encoded = goog.Uri.removeDoubleEncoding_(encoded);\n    }\n    return encoded;\n  }\n  return null;\n};\n\n\n/**\n * Converts a character in [\\01-\\177] to its unicode character equivalent.\n * @param {string} ch One character string.\n * @return {string} Encoded string.\n * @private\n */\ngoog.Uri.encodeChar_ = function(ch) {\n  var n = ch.charCodeAt(0);\n  return '%' + ((n >> 4) & 0xf).toString(16) + (n & 0xf).toString(16);\n};\n\n\n/**\n * Removes double percent-encoding from a string.\n * @param  {string} doubleEncodedString String\n * @return {string} String with double encoding removed.\n * @private\n */\ngoog.Uri.removeDoubleEncoding_ = function(doubleEncodedString) {\n  return doubleEncodedString.replace(/%25([0-9a-fA-F]{2})/g, '%$1');\n};\n\n\n/**\n * Regular expression for characters that are disallowed in the scheme or\n * userInfo part of the URI.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInSchemeOrUserInfo_ = /[#\\/\\?@]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in a relative path.\n * Colon is included due to RFC 3986 3.3.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInRelativePath_ = /[\\#\\?:]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in an absolute path.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInAbsolutePath_ = /[\\#\\?]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in the query.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInQuery_ = /[\\#\\?@]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in the fragment.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInFragment_ = /#/g;\n\n\n\n/**\n * Class used to represent URI query parameters.  It is essentially a hash of\n * name-value pairs, though a name can be present more than once.\n *\n * Has the same interface as the collections in goog.structs.\n *\n * @param {?string=} query Optional encoded query string to parse into\n *     the object.\n * @param {goog.Uri=} uri Optional uri object that should have its\n *     cache invalidated when this object updates. Deprecated -- this\n *     is no longer required.\n * @constructor\n * @final\n */\ngoog.Uri.QueryData = function(query, uri) {\n  /**\n   * Encoded query string, or null if it requires computing from the key map.\n   * @type {?string}\n   * @private\n   */\n  this.encodedQuery_ = query || null;\n};\n\n\n/**\n * If the underlying key map is not yet initialized, it parses the\n * query string and fills the map with parsed data.\n * @private\n */\ngoog.Uri.QueryData.prototype.ensureKeyMapInitialized_ = function() {\n  if (!this.keyMap_) {\n    this.keyMap_ = {};\n    this.count_ = 0;\n\n    if (this.encodedQuery_) {\n      var pairs = this.encodedQuery_.split('&');\n      for (var i = 0; i < pairs.length; i++) {\n        var indexOfEquals = pairs[i].indexOf('=');\n        var name = null;\n        var value = null;\n        if (indexOfEquals >= 0) {\n          name = pairs[i].substring(0, indexOfEquals);\n          value = pairs[i].substring(indexOfEquals + 1);\n        } else {\n          name = pairs[i];\n        }\n        name = decodeURIComponent(name.replace(/\\+/g, ' '));\n        value = value || '';\n        this.add(name, decodeURIComponent(value.replace(/\\+/g, ' ')));\n      }\n    }\n  }\n};\n\n\n/**\n * The map containing name/value or name/array-of-values pairs.\n * May be null if it requires parsing from the query string.\n *\n * We need to use a Map because we cannot guarantee that the key names will\n * not be problematic for IE.\n *\n * @type {Object.<string, !Array.<string>>}\n * @private\n */\ngoog.Uri.QueryData.prototype.keyMap_ = null;\n\n\n/**\n * The number of params, or null if it requires computing.\n * @type {?number}\n * @private\n */\ngoog.Uri.QueryData.prototype.count_ = null;\n\n\n/**\n * @return {?number} The number of parameters.\n */\ngoog.Uri.QueryData.prototype.getCount = function() {\n  this.ensureKeyMapInitialized_();\n  return this.count_;\n};\n\n\n/**\n * Adds a key value pair.\n * @param {string} key Name.\n * @param {string} value Value.\n * @return {!goog.Uri.QueryData} Instance of this object.\n */\ngoog.Uri.QueryData.prototype.add = function(key, value) {\n  this.ensureKeyMapInitialized_();\n  // Invalidate the cache.\n  this.encodedQuery_ = null;\n\n  var values = this.keyMap_.hasOwnProperty(key) && this.keyMap_[key];\n  if (!values) {\n    this.keyMap_[key] = (values = []);\n  }\n  values.push(value);\n  goog.asserts.assert(this.count_ != null, 'Should not be null.');\n  this.count_++;\n  return this;\n};\n\n/**\n * Sets a key value pair and removes all other keys with the same value.\n *\n * @param {string} key Name.\n * @param {string} value Value.\n * @return {!goog.Uri.QueryData} Instance of this object.\n */\n goog.Uri.QueryData.prototype.set = function(key, value) {\n  this.ensureKeyMapInitialized_();\n  // Invalidate the cache.\n  this.encodedQuery_ = null;\n\n  if (!this.keyMap_.hasOwnProperty(key)) {\n    this.add(key, value);\n  } else {\n    this.keyMap_[key] = [value];\n  }\n\n  return this;\n};\n\n\n/**\n * @return {string} Encoded query string.\n * @override\n */\ngoog.Uri.QueryData.prototype.toString = function() {\n  if (this.encodedQuery_) {\n    return this.encodedQuery_;\n  }\n\n  if (!this.keyMap_) {\n    return '';\n  }\n\n  var sb = [];\n\n  for (var key in this.keyMap_) {\n    var encodedKey = encodeURIComponent(key);\n    var val = this.keyMap_[key];\n    for (var j = 0; j < val.length; j++) {\n      var param = encodedKey;\n      // Ensure that null and undefined are encoded into the url as\n      // literal strings.\n      if (val[j] !== '') {\n        param += '=' + encodeURIComponent(val[j]);\n      }\n      sb.push(param);\n    }\n  }\n\n  return this.encodedQuery_ = sb.join('&');\n};\n\n\n/**\n * @return {string} Decoded query string.\n */\ngoog.Uri.QueryData.prototype.toDecodedString = function() {\n  return goog.Uri.decodeOrEmpty_(this.toString());\n};\n\n\n/**\n * Clone the query data instance.\n * @return {!goog.Uri.QueryData} New instance of the QueryData object.\n */\ngoog.Uri.QueryData.prototype.clone = function() {\n  var rv = new goog.Uri.QueryData();\n  rv.encodedQuery_ = this.encodedQuery_;\n  if (this.keyMap_) {\n    var cloneMap = {};\n    for (var key in this.keyMap_) {\n      cloneMap[key] = this.keyMap_[key].concat();\n    }\n    rv.keyMap_ = cloneMap;\n    rv.count_ = this.count_;\n  }\n  return rv;\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.ManifestParserUtils');\n\ngoog.require('goog.Uri');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\n\n\n/**\n * @summary Utility functions for manifest parsing.\n */\nshaka.util.ManifestParserUtils = class {\n  /**\n   * Resolves an array of relative URIs to the given base URIs. This will result\n   * in M*N number of URIs.\n   *\n   * @param {!Array.<string>} baseUris\n   * @param {!Array.<string>} relativeUris\n   * @return {!Array.<string>}\n   */\n  static resolveUris(baseUris, relativeUris) {\n    const Functional = shaka.util.Functional;\n    if (relativeUris.length == 0) {\n      return baseUris;\n    }\n\n    const relativeAsGoog = relativeUris.map((uri) => new goog.Uri(uri));\n    // Resolve each URI relative to each base URI, creating an Array of Arrays.\n    // Then flatten the Arrays into a single Array.\n    return baseUris.map((uri) => new goog.Uri(uri))\n        .map((base) => relativeAsGoog.map((i) => base.resolve(i)))\n        .reduce(Functional.collapseArrays, [])\n        .map((uri) => uri.toString());\n  }\n\n\n  /**\n   * Creates a DrmInfo object from the given info.\n   *\n   * @param {string} keySystem\n   * @param {Array.<shaka.extern.InitDataOverride>} initData\n   * @return {shaka.extern.DrmInfo}\n   */\n  static createDrmInfo(keySystem, initData) {\n    return {\n      keySystem: keySystem,\n      licenseServerUri: '',\n      distinctiveIdentifierRequired: false,\n      persistentStateRequired: false,\n      audioRobustness: '',\n      videoRobustness: '',\n      serverCertificate: null,\n      serverCertificateUri: '',\n      sessionType: '',\n      initData: initData || [],\n      keyIds: new Set(),\n    };\n  }\n\n\n  /**\n   * Attempts to guess which codecs from the codecs list belong to a given\n   * content type.\n   * Assumes that at least one codec is correct, and throws if none are.\n   *\n   * @param {string} contentType\n   * @param {!Array.<string>} codecs\n   * @return {string}\n   */\n  static guessCodecs(contentType, codecs) {\n    if (codecs.length == 1) {\n      return codecs[0];\n    }\n\n    const match = shaka.util.ManifestParserUtils.guessCodecsSafe(\n        contentType, codecs);\n    // A failure is specifically denoted by null; an empty string represents a\n    // valid match of no codec.\n    if (match != null) {\n      return match;\n    }\n\n    // Unable to guess codecs.\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_COULD_NOT_GUESS_CODECS,\n        codecs);\n  }\n\n\n  /**\n   * Attempts to guess which codecs from the codecs list belong to a given\n   * content type. Does not assume a single codec is anything special, and does\n   * not throw if it fails to match.\n   *\n   * @param {string} contentType\n   * @param {!Array.<string>} codecs\n   * @return {?string} or null if no match is found\n   */\n  static guessCodecsSafe(contentType, codecs) {\n    const formats = shaka.util.ManifestParserUtils\n        .CODEC_REGEXPS_BY_CONTENT_TYPE_[contentType];\n    for (const format of formats) {\n      for (const codec of codecs) {\n        if (format.test(codec.trim())) {\n          return codec.trim();\n        }\n      }\n    }\n\n    // Text does not require a codec string.\n    if (contentType == shaka.util.ManifestParserUtils.ContentType.TEXT) {\n      return '';\n    }\n\n    return null;\n  }\n};\n\n\n/**\n * @enum {string}\n */\nshaka.util.ManifestParserUtils.ContentType = {\n  VIDEO: 'video',\n  AUDIO: 'audio',\n  TEXT: 'text',\n  IMAGE: 'image',\n  APPLICATION: 'application',\n};\n\n\n/**\n * @enum {string}\n */\nshaka.util.ManifestParserUtils.TextStreamKind = {\n  SUBTITLE: 'subtitle',\n  CLOSED_CAPTION: 'caption',\n};\n\n\n/**\n * Specifies how tolerant the player is of inaccurate segment start times and\n * end times within a manifest. For example, gaps or overlaps between segments\n * in a SegmentTimeline which are greater than or equal to this value will\n * result in a warning message.\n *\n * @const {number}\n */\nshaka.util.ManifestParserUtils.GAP_OVERLAP_TOLERANCE_SECONDS = 1 / 15;\n\n\n/**\n * A list of regexps to detect well-known video codecs.\n *\n * @const {!Array.<!RegExp>}\n * @private\n */\nshaka.util.ManifestParserUtils.VIDEO_CODEC_REGEXPS_ = [\n  /^avc/,\n  /^hev/,\n  /^hvc/,\n  /^vp0?[89]/,\n  /^av01/,\n  /^dvhe/,\n];\n\n\n/**\n * A list of regexps to detect well-known audio codecs.\n *\n * @const {!Array.<!RegExp>}\n * @private\n */\nshaka.util.ManifestParserUtils.AUDIO_CODEC_REGEXPS_ = [\n  /^vorbis$/,\n  /^opus$/,\n  /^flac$/,\n  /^mp4a/,\n  /^[ae]c-3$/,\n  /^ac-4$/,\n  /^dts[cex]$/, // DTS Digital Surround (dtsc), DTS Express (dtse), DTS:X (dtsx)\n];\n\n\n/**\n * A list of regexps to detect well-known text codecs.\n *\n * @const {!Array.<!RegExp>}\n * @private\n */\nshaka.util.ManifestParserUtils.TEXT_CODEC_REGEXPS_ = [\n  /^vtt$/,\n  /^wvtt/,\n  /^stpp/,\n];\n\n\n/**\n * @const {!Object.<string, !Array.<!RegExp>>}\n */\nshaka.util.ManifestParserUtils.CODEC_REGEXPS_BY_CONTENT_TYPE_ = {\n  'audio': shaka.util.ManifestParserUtils.AUDIO_CODEC_REGEXPS_,\n  'video': shaka.util.ManifestParserUtils.VIDEO_CODEC_REGEXPS_,\n  'text': shaka.util.ManifestParserUtils.TEXT_CODEC_REGEXPS_,\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.PublicPromise');\n\n\n/**\n * @summary\n * A utility to create Promises with convenient public resolve and reject\n * methods.\n *\n * @extends {Promise.<T>}\n * @template T\n */\nshaka.util.PublicPromise = class {\n  /**\n   * @return {!Promise.<T>}\n   */\n  constructor() {\n    let resolvePromise;\n    let rejectPromise;\n\n    // Promise.call causes an error.  It seems that inheriting from a native\n    // Promise is not permitted by JavaScript interpreters.\n\n    // The work-around is to construct a Promise object, modify it to look like\n    // the compiler's picture of PublicPromise, then return it.  The caller of\n    // new PublicPromise will receive |promise| instead of |this|, and the\n    // compiler will be aware of the additional properties |resolve| and\n    // |reject|.\n\n    const promise = new Promise(((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    }));\n\n    // Now cast the Promise object to our subclass PublicPromise so that the\n    // compiler will permit us to attach resolve() and reject() to it.\n    const publicPromise = /** @type {shaka.util.PublicPromise} */(promise);\n    publicPromise.resolve = resolvePromise;\n    publicPromise.reject = rejectPromise;\n\n    return publicPromise;\n  }\n\n\n  /** @param {T=} value */\n  resolve(value) {}\n\n\n  /** @param {*=} reason */\n  reject(reason) {}\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Lazy');\n\ngoog.require('goog.asserts');\n\n\n/**\n * @summary\n * This contains a single value that is lazily generated when it is first\n * requested.  This can store any value except \"undefined\".\n *\n * @template T\n */\nshaka.util.Lazy = class {\n  /** @param {function():T} gen */\n  constructor(gen) {\n    /** @private {function():T} */\n    this.gen_ = gen;\n\n    /** @private {T|undefined} */\n    this.value_ = undefined;\n  }\n\n  /** @return {T} */\n  value() {\n    if (this.value_ == undefined) {\n      // Compiler complains about unknown fields without this cast.\n      this.value_ = /** @type {*} */ (this.gen_());\n      goog.asserts.assert(\n          this.value_ != undefined, 'Unable to create lazy value');\n    }\n    return this.value_;\n  }\n\n  /** Resets the value of the lazy function, so it has to be remade. */\n  reset() {\n    this.value_ = undefined;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.DelayedTick');\n\n\n/**\n * @summary\n * This class wraps a function so that we can defer executing the function by X\n * seconds.\n *\n * @final\n */\nshaka.util.DelayedTick = class {\n  /**\n   * @param {function()} onTick\n   */\n  constructor(onTick) {\n    /** @private {function()} */\n    this.onTick_ = onTick;\n\n    /** @private {?function()} */\n    this.cancelPending_ = null;\n  }\n\n  /**\n   * Call |onTick| after |delayInSeconds| has elapsed. If there is already a\n   * pending call to |onTick|, the pending call will be canceled.\n   *\n   * @param {number} delayInSeconds\n   * @return {!shaka.util.DelayedTick}\n   */\n  tickAfter(delayInSeconds) {\n    // We only want one timeout set at a time, so make sure no other timeouts\n    // are running.\n    this.stop();\n\n    // We will wrap these values in a function to allow us to cancel the timeout\n    // we are about to create.\n    let alive = true;\n    let timeoutId = null;\n\n    this.cancelPending_ = () => {\n      window.clearTimeout(timeoutId);\n      alive = false;\n    };\n\n    // For some reason, a timeout may still execute after we have cleared it in\n    // our tests. We will wrap the callback so that we can double-check our\n    // |alive| flag.\n    const onTick = () => {\n      if (alive) {\n        this.onTick_();\n      }\n    };\n\n    timeoutId = window.setTimeout(onTick, delayInSeconds * 1000);\n\n    return this;\n  }\n\n  /**\n   * Cancel any pending calls to |onTick|. If there are no pending calls to\n   * |onTick|, this will be a no-op.\n   */\n  stop() {\n    if (this.cancelPending_) {\n      this.cancelPending_();\n      this.cancelPending_ = null;\n    }\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Timer');\n\ngoog.require('shaka.util.DelayedTick');\n\n\n/**\n * A timer allows a single function to be executed at a later time or at\n * regular intervals.\n *\n * @final\n * @export\n */\nshaka.util.Timer = class {\n  /**\n   * Create a new timer. A timer is committed to a single callback function.\n   * While there is no technical reason to do this, it is far easier to\n   * understand and use timers when they are connected to one functional idea.\n   *\n   * @param {function()} onTick\n   */\n  constructor(onTick) {\n    /**\n     * Each time our timer \"does work\", we call that a \"tick\". The name comes\n     * from old analog clocks.\n     *\n     * @private {function()}\n     */\n    this.onTick_ = onTick;\n\n    /** @private {shaka.util.DelayedTick} */\n    this.ticker_ = null;\n  }\n\n  /**\n   * Have the timer call |onTick| now.\n   *\n   * @return {!shaka.util.Timer}\n   * @export\n   */\n  tickNow() {\n    this.stop();\n    this.onTick_();\n\n    return this;\n  }\n\n  /**\n   * Have the timer call |onTick| after |seconds| has elapsed unless |stop| is\n   * called first.\n   *\n   * @param {number} seconds\n   * @return {!shaka.util.Timer}\n   * @export\n   */\n  tickAfter(seconds) {\n    this.stop();\n\n    this.ticker_ = new shaka.util.DelayedTick(() => {\n      this.onTick_();\n    }).tickAfter(seconds);\n\n    return this;\n  }\n\n  /**\n   * Have the timer call |onTick| every |seconds| until |stop| is called.\n   *\n   * @param {number} seconds\n   * @return {!shaka.util.Timer}\n   * @export\n   */\n  tickEvery(seconds) {\n    this.stop();\n\n    if (goog.DEBUG) {\n      // Capture the stack trace by making a fake error.\n      const stackTrace = Error('Timer created').stack;\n      shaka.util.Timer.activeTimers.set(this, stackTrace);\n    }\n    this.ticker_ = new shaka.util.DelayedTick(() => {\n      // Schedule the timer again first. |onTick_| could cancel the timer and\n      // rescheduling first simplifies the implementation.\n      this.ticker_.tickAfter(seconds);\n      this.onTick_();\n    }).tickAfter(seconds);\n\n    return this;\n  }\n\n  /**\n   * Stop the timer and clear the previous behaviour. The timer is still usable\n   * after calling |stop|.\n   *\n   * @export\n   */\n  stop() {\n    if (this.ticker_) {\n      this.ticker_.stop();\n      this.ticker_ = null;\n    }\n    if (goog.DEBUG) {\n      shaka.util.Timer.activeTimers.delete(this);\n    }\n  }\n};\n\nif (goog.DEBUG) {\n  /**\n   * Tracks all active timer instances, along with the stack trace that created\n   * that timer.\n   * @type {!Map.<!shaka.util.Timer, string>}\n   */\n  shaka.util.Timer.activeTimers = new Map();\n}\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Platform');\n\ngoog.require('shaka.util.Timer');\n\n\n/**\n * A wrapper for platform-specific functions.\n *\n * @final\n */\nshaka.util.Platform = class {\n  /**\n   * Check if the current platform supports media source. We assume that if\n   * the current platform supports media source, then we can use media source\n   * as per its design.\n   *\n   * @return {boolean}\n   */\n  static supportsMediaSource() {\n    // Browsers that lack a media source implementation will have no reference\n    // to |window.MediaSource|. Platforms that we see having problematic media\n    // source implementations will have this reference removed via a polyfill.\n    if (!window.MediaSource) {\n      return false;\n    }\n\n    // Some very old MediaSource implementations didn't have isTypeSupported.\n    if (!MediaSource.isTypeSupported) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns true if the media type is supported natively by the platform.\n   *\n   * @param {string} mimeType\n   * @return {boolean}\n   */\n  static supportsMediaType(mimeType) {\n    const video = shaka.util.Platform.anyMediaElement();\n    return video.canPlayType(mimeType) != '';\n  }\n\n  /**\n   * Check if the current platform is MS Edge.\n   *\n   * @return {boolean}\n   */\n  static isEdge() {\n    // Legacy Edge contains \"Edge/version\".\n    // Chromium-based Edge contains \"Edg/version\" (no \"e\").\n    if (navigator.userAgent.match(/Edge?\\//)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if the current platform is Legacy Edge.\n   *\n   * @return {boolean}\n   */\n  static isLegacyEdge() {\n    // Legacy Edge contains \"Edge/version\".\n    // Chromium-based Edge contains \"Edg/version\" (no \"e\").\n    if (navigator.userAgent.match(/Edge\\//)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if the current platform is MS IE.\n   *\n   * @return {boolean}\n   */\n  static isIE() {\n    return shaka.util.Platform.userAgentContains_('Trident/');\n  }\n\n  /**\n   * Check if the current platform is an Xbox One.\n   *\n   * @return {boolean}\n   */\n  static isXboxOne() {\n    return shaka.util.Platform.userAgentContains_('Xbox One');\n  }\n\n  /**\n   * Check if the current platform is a Tizen TV.\n   *\n   * @return {boolean}\n   */\n  static isTizen() {\n    return shaka.util.Platform.userAgentContains_('Tizen');\n  }\n\n  /**\n   * Check if the current platform is a Tizen 4 TV.\n   *\n   * @return {boolean}\n   */\n  static isTizen4() {\n    return shaka.util.Platform.userAgentContains_('Tizen 4');\n  }\n\n  /**\n   * Check if the current platform is a Tizen 3 TV.\n   *\n   * @return {boolean}\n   */\n  static isTizen3() {\n    return shaka.util.Platform.userAgentContains_('Tizen 3');\n  }\n\n  /**\n   * Check if the current platform is a Tizen 2 TV.\n   *\n   * @return {boolean}\n   */\n  static isTizen2() {\n    return shaka.util.Platform.userAgentContains_('Tizen 2');\n  }\n\n  /**\n   * Check if the current platform is a WebOS.\n   *\n   * @return {boolean}\n   */\n  static isWebOS() {\n    return shaka.util.Platform.userAgentContains_('Web0S');\n  }\n\n  /**\n   * Check if the current platform is a WebOS 3.\n   *\n   * @return {boolean}\n   */\n  static isWebOS3() {\n    // See: http://webostv.developer.lge.com/discover/specifications/web-engine/\n    return shaka.util.Platform.userAgentContains_('Web0S') &&\n        shaka.util.Platform.userAgentContains_(\n            'Chrome/38.0.2125.122 Safari/537.36');\n  }\n\n  /**\n   * Check if the current platform is a Google Chromecast.\n   *\n   * @return {boolean}\n   */\n  static isChromecast() {\n    return shaka.util.Platform.userAgentContains_('CrKey');\n  }\n\n  /**\n   * Check if the current platform is a Android-based Cast devices.\n   *\n   * @return {boolean}\n   */\n  static isAndroidCastDevice() {\n    return shaka.util.Platform.isChromecast() &&\n        shaka.util.Platform.userAgentContains_('Android');\n  }\n\n  /**\n   * Returns a major version number for Chrome, or Chromium-based browsers.\n   *\n   * For example:\n   *   - Chrome 106.0.5249.61 returns 106.\n   *   - Edge 106.0.1370.34 returns 106 (since this is based on Chromium).\n   *   - Safari returns null (since this is independent of Chromium).\n   *\n   * @return {?number} A major version number or null if not Chromium-based.\n   */\n  static chromeVersion() {\n    if (!shaka.util.Platform.isChrome()) {\n      return null;\n    }\n\n    // Looking for something like \"Chrome/106.0.0.0\".\n    const match = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) {\n      return parseInt(match[1], /* base= */ 10);\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if the current platform is Google Chrome.\n   *\n   * @return {boolean}\n   */\n  static isChrome() {\n    // The Edge user agent will also contain the \"Chrome\" keyword, so we need\n    // to make sure this is not Edge.\n    return shaka.util.Platform.userAgentContains_('Chrome') &&\n           !shaka.util.Platform.isEdge();\n  }\n\n  /**\n   * Check if the current platform is from Apple.\n   *\n   * Returns true on all iOS browsers and on desktop Safari.\n   *\n   * Returns false for non-Safari browsers on macOS, which are independent of\n   * Apple.\n   *\n   * @return {boolean}\n   */\n  static isApple() {\n    return !!navigator.vendor && navigator.vendor.includes('Apple') &&\n        !shaka.util.Platform.isTizen() &&\n        !shaka.util.Platform.isEOS() &&\n        !shaka.util.Platform.isVirginMedia() &&\n        !shaka.util.Platform.isPS4() &&\n        !shaka.util.Platform.isAmazonFireTV();\n  }\n\n  /**\n   * Check if the current platform is Playstation 5.\n   *\n   * Returns true on Playstation 5 browsers.\n   *\n   * Returns false for Playstation 5 browsers\n   *\n   * @return {boolean}\n   */\n  static isPS5() {\n    return shaka.util.Platform.userAgentContains_('PlayStation 5');\n  }\n\n  /**\n   * Check if the current platform is Playstation 4.\n   */\n  static isPS4() {\n    return shaka.util.Platform.userAgentContains_('PlayStation 4');\n  }\n\n  /**\n   * Check if the current platform is Hisense.\n   */\n  static isHisense() {\n    return shaka.util.Platform.userAgentContains_('Hisense') ||\n        shaka.util.Platform.userAgentContains_('VIDAA');\n  }\n\n  /**\n   * Check if the current platform is Virgin Media device.\n   */\n  static isVirginMedia() {\n    return shaka.util.Platform.userAgentContains_('VirginMedia');\n  }\n\n  /**\n   * Check if the current platform is Amazon Fire TV.\n   * https://developer.amazon.com/docs/fire-tv/identify-amazon-fire-tv-devices.html\n   *\n   * @return {boolean}\n   */\n  static isAmazonFireTV() {\n    return shaka.util.Platform.userAgentContains_('AFT');\n  }\n\n  /**\n   * Returns a major version number for Safari, or Safari-based iOS browsers.\n   *\n   * For example:\n   *   - Safari 13.0.4 on macOS returns 13.\n   *   - Safari on iOS 13.3.1 returns 13.\n   *   - Chrome on iOS 13.3.1 returns 13 (since this is based on Safari/WebKit).\n   *   - Chrome on macOS returns null (since this is independent of Apple).\n   *\n   * Returns null on Firefox on iOS, where this version information is not\n   * available.\n   *\n   * @return {?number} A major version number or null if not iOS.\n   */\n  static safariVersion() {\n    // All iOS browsers and desktop Safari will return true for isApple().\n    if (!shaka.util.Platform.isApple()) {\n      return null;\n    }\n\n    // This works for iOS Safari and desktop Safari, which contain something\n    // like \"Version/13.0\" indicating the major Safari or iOS version.\n    let match = navigator.userAgent.match(/Version\\/(\\d+)/);\n    if (match) {\n      return parseInt(match[1], /* base= */ 10);\n    }\n\n    // This works for all other browsers on iOS, which contain something like\n    // \"OS 13_3\" indicating the major & minor iOS version.\n    match = navigator.userAgent.match(/OS (\\d+)(?:_\\d+)?/);\n    if (match) {\n      return parseInt(match[1], /* base= */ 10);\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if the current platform is Apple Safari\n   * or Safari-based iOS browsers.\n   *\n   * @return {boolean}\n   */\n  static isSafari() {\n    return !!shaka.util.Platform.safariVersion();\n  }\n\n  /**\n   * Check if the current platform is an EOS set-top box.\n   *\n   * @return {boolean}\n   */\n  static isEOS() {\n    return shaka.util.Platform.userAgentContains_('PC=EOS');\n  }\n\n  /**\n   * Guesses if the platform is a mobile one (iOS or Android).\n   *\n   * @return {boolean}\n   */\n  static isMobile() {\n    if (/(?:iPhone|iPad|iPod|Android)/.test(navigator.userAgent)) {\n      // This is Android, iOS, or iPad < 13.\n      return true;\n    }\n\n    // Starting with iOS 13 on iPad, the user agent string no longer has the\n    // word \"iPad\" in it.  It looks very similar to desktop Safari.  This seems\n    // to be intentional on Apple's part.\n    // See: https://forums.developer.apple.com/thread/119186\n    //\n    // So if it's an Apple device with multi-touch support, assume it's a mobile\n    // device.  If some future iOS version starts masking their user agent on\n    // both iPhone & iPad, this clause should still work.  If a future\n    // multi-touch desktop Mac is released, this will need some adjustment.\n    //\n    // As of January 2020, this is mainly used to adjust the default UI config\n    // for mobile devices, so it's low risk if something changes to break this\n    // detection.\n    return shaka.util.Platform.isApple() && navigator.maxTouchPoints > 1;\n  }\n\n  /**\n   * Check if the user agent contains a key. This is the best way we know of\n   * right now to detect platforms. If there is a better way, please send a\n   * PR.\n   *\n   * @param {string} key\n   * @return {boolean}\n   * @private\n   */\n  static userAgentContains_(key) {\n    const userAgent = navigator.userAgent || '';\n    return userAgent.includes(key);\n  }\n\n  /**\n   * For canPlayType queries, we just need any instance.\n   *\n   * First, use a cached element from a previous query.\n   * Second, search the page for one.\n   * Third, create a temporary one.\n   *\n   * Cached elements expire in one second so that they can be GC'd or removed.\n   *\n   * @return {!HTMLMediaElement}\n   */\n  static anyMediaElement() {\n    const Platform = shaka.util.Platform;\n    if (Platform.cachedMediaElement_) {\n      return Platform.cachedMediaElement_;\n    }\n\n    if (!Platform.cacheExpirationTimer_) {\n      Platform.cacheExpirationTimer_ = new shaka.util.Timer(() => {\n        Platform.cachedMediaElement_ = null;\n      });\n    }\n\n    Platform.cachedMediaElement_ = /** @type {HTMLMediaElement} */(\n      document.getElementsByTagName('video')[0] ||\n      document.getElementsByTagName('audio')[0]);\n\n    if (!Platform.cachedMediaElement_) {\n      Platform.cachedMediaElement_ = /** @type {!HTMLMediaElement} */(\n        document.createElement('video'));\n    }\n\n    Platform.cacheExpirationTimer_.tickAfter(/* seconds= */ 1);\n    return Platform.cachedMediaElement_;\n  }\n\n  /**\n   * Returns true if the platform requires encryption information in all init\n   * segments.  For such platforms, MediaSourceEngine will attempt to work\n   * around a lack of such info by inserting fake encryption information into\n   * initialization segments.\n   *\n   * @return {boolean}\n   * @see https://github.com/shaka-project/shaka-player/issues/2759\n   */\n  static requiresEncryptionInfoInAllInitSegments() {\n    const Platform = shaka.util.Platform;\n    return Platform.isTizen() || Platform.isXboxOne();\n  }\n};\n\n/** @private {shaka.util.Timer} */\nshaka.util.Platform.cacheExpirationTimer_ = null;\n\n/** @private {HTMLMediaElement} */\nshaka.util.Platform.cachedMediaElement_ = null;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.StringUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Lazy');\ngoog.require('shaka.util.Platform');\n\n\n/**\n * @namespace shaka.util.StringUtils\n * @summary A set of string utility functions.\n * @export\n */\nshaka.util.StringUtils = class {\n  /**\n   * Creates a string from the given buffer as UTF-8 encoding.\n   *\n   * @param {?BufferSource} data\n   * @return {string}\n   * @export\n   */\n  static fromUTF8(data) {\n    if (!data) {\n      return '';\n    }\n\n    let uint8 = shaka.util.BufferUtils.toUint8(data);\n    // If present, strip off the UTF-8 BOM.\n    if (uint8[0] == 0xef && uint8[1] == 0xbb && uint8[2] == 0xbf) {\n      uint8 = uint8.subarray(3);\n    }\n\n    if (window.TextDecoder && !shaka.util.Platform.isPS4()) {\n      // Use the TextDecoder interface to decode the text.  This has the\n      // advantage compared to the previously-standard decodeUriComponent that\n      // it will continue parsing even if it finds an invalid UTF8 character,\n      // rather than stop and throw an error.\n      const utf8decoder = new TextDecoder();\n      const decoded = utf8decoder.decode(uint8);\n      if (decoded.includes('\\uFFFD')) {\n        shaka.log.alwaysError('Decoded string contains an \"unknown character' +\n                              '\" codepoint.  That probably means the UTF8 ' +\n                              'encoding was incorrect!');\n      }\n      return decoded;\n    } else {\n      // Homebrewed UTF-8 decoder based on\n      // https://en.wikipedia.org/wiki/UTF-8#Encoding\n      // Unlike decodeURIComponent, won't throw on bad encoding.\n      // In this way, it is similar to TextDecoder.\n\n      let decoded = '';\n      for (let i = 0; i < uint8.length; ++i) {\n        // By default, the \"replacement character\" codepoint.\n        let codePoint = 0xFFFD;\n\n        // Top bit is 0, 1-byte encoding.\n        if ((uint8[i] & 0x80) == 0) {\n          codePoint = uint8[i];\n\n        // Top 3 bits of byte 0 are 110, top 2 bits of byte 1 are 10,\n        // 2-byte encoding.\n        } else if (uint8.length >= i + 2 &&\n            (uint8[i] & 0xe0) == 0xc0 &&\n            (uint8[i + 1] & 0xc0) == 0x80) {\n          codePoint = ((uint8[i] & 0x1f) << 6) |\n                      ((uint8[i + 1] & 0x3f));\n          i += 1;  // Consume one extra byte.\n\n        // Top 4 bits of byte 0 are 1110, top 2 bits of byte 1 and 2 are 10,\n        // 3-byte encoding.\n        } else if (uint8.length >= i + 3 &&\n            (uint8[i] & 0xf0) == 0xe0 &&\n            (uint8[i + 1] & 0xc0) == 0x80 &&\n            (uint8[i + 2] & 0xc0) == 0x80) {\n          codePoint = ((uint8[i] & 0x0f) << 12) |\n                      ((uint8[i + 1] & 0x3f) << 6) |\n                      ((uint8[i + 2] & 0x3f));\n          i += 2;  // Consume two extra bytes.\n\n        // Top 5 bits of byte 0 are 11110, top 2 bits of byte 1, 2 and 3 are 10,\n        // 4-byte encoding.\n        } else if (uint8.length >= i + 4 &&\n            (uint8[i] & 0xf1) == 0xf0 &&\n            (uint8[i + 1] & 0xc0) == 0x80 &&\n            (uint8[i + 2] & 0xc0) == 0x80 &&\n            (uint8[i + 3] & 0xc0) == 0x80) {\n          codePoint = ((uint8[i] & 0x07) << 18) |\n                      ((uint8[i + 1] & 0x3f) << 12) |\n                      ((uint8[i + 2] & 0x3f) << 6) |\n                      ((uint8[i + 3] & 0x3f));\n          i += 3;  // Consume three extra bytes.\n        }\n\n        // JavaScript strings are a series of UTF-16 characters.\n        if (codePoint <= 0xffff) {\n          decoded += String.fromCharCode(codePoint);\n        } else {\n          // UTF-16 surrogate-pair encoding, based on\n          // https://en.wikipedia.org/wiki/UTF-16#Description\n          const baseCodePoint = codePoint - 0x10000;\n          const highPart = baseCodePoint >> 10;\n          const lowPart = baseCodePoint & 0x3ff;\n          decoded += String.fromCharCode(0xd800 + highPart);\n          decoded += String.fromCharCode(0xdc00 + lowPart);\n        }\n      }\n\n      return decoded;\n    }\n  }\n\n\n  /**\n   * Creates a string from the given buffer as UTF-16 encoding.\n   *\n   * @param {?BufferSource} data\n   * @param {boolean} littleEndian\n         true to read little endian, false to read big.\n   * @param {boolean=} noThrow true to avoid throwing in cases where we may\n   *     expect invalid input.  If noThrow is true and the data has an odd\n   *     length,it will be truncated.\n   * @return {string}\n   * @export\n   */\n  static fromUTF16(data, littleEndian, noThrow) {\n    if (!data) {\n      return '';\n    }\n\n    if (!noThrow && data.byteLength % 2 != 0) {\n      shaka.log.error('Data has an incorrect length, must be even.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL, shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.BAD_ENCODING);\n    }\n\n    // Use a DataView to ensure correct endianness.\n    const length = Math.floor(data.byteLength / 2);\n    const arr = new Uint16Array(length);\n    const dataView = shaka.util.BufferUtils.toDataView(data);\n    for (let i = 0; i < length; i++) {\n      arr[i] = dataView.getUint16(i * 2, littleEndian);\n    }\n    return shaka.util.StringUtils.fromCharCode(arr);\n  }\n\n\n  /**\n   * Creates a string from the given buffer, auto-detecting the encoding that is\n   * being used.  If it cannot detect the encoding, it will throw an exception.\n   *\n   * @param {?BufferSource} data\n   * @return {string}\n   * @export\n   */\n  static fromBytesAutoDetect(data) {\n    const StringUtils = shaka.util.StringUtils;\n    if (!data) {\n      return '';\n    }\n\n    const uint8 = shaka.util.BufferUtils.toUint8(data);\n    if (uint8[0] == 0xef && uint8[1] == 0xbb && uint8[2] == 0xbf) {\n      return StringUtils.fromUTF8(uint8);\n    } else if (uint8[0] == 0xfe && uint8[1] == 0xff) {\n      return StringUtils.fromUTF16(\n          uint8.subarray(2), /* littleEndian= */ false);\n    } else if (uint8[0] == 0xff && uint8[1] == 0xfe) {\n      return StringUtils.fromUTF16(uint8.subarray(2), /* littleEndian= */ true);\n    }\n\n    const isAscii = (i) => {\n      // arr[i] >= ' ' && arr[i] <= '~';\n      return uint8.byteLength <= i || (uint8[i] >= 0x20 && uint8[i] <= 0x7e);\n    };\n\n    shaka.log.debug(\n        'Unable to find byte-order-mark, making an educated guess.');\n    if (uint8[0] == 0 && uint8[2] == 0) {\n      return StringUtils.fromUTF16(data, /* littleEndian= */ false);\n    } else if (uint8[1] == 0 && uint8[3] == 0) {\n      return StringUtils.fromUTF16(data, /* littleEndian= */ true);\n    } else if (isAscii(0) && isAscii(1) && isAscii(2) && isAscii(3)) {\n      return StringUtils.fromUTF8(data);\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.UNABLE_TO_DETECT_ENCODING);\n  }\n\n\n  /**\n   * Creates a ArrayBuffer from the given string, converting to UTF-8 encoding.\n   *\n   * @param {string} str\n   * @return {!ArrayBuffer}\n   * @export\n   */\n  static toUTF8(str) {\n    if (window.TextEncoder && !shaka.util.Platform.isPS4()) {\n      const utf8Encoder = new TextEncoder();\n      return shaka.util.BufferUtils.toArrayBuffer(utf8Encoder.encode(str));\n    } else {\n      // http://stackoverflow.com/a/13691499\n      // Converts the given string to a URI encoded string.  If a character\n      // falls in the ASCII range, it is not converted; otherwise it will be\n      // converted to a series of URI escape sequences according to UTF-8.\n      // Example: 'g#€' -> 'g#%E3%82%AC'\n      const encoded = encodeURIComponent(str);\n      // Convert each escape sequence individually into a character.  Each\n      // escape sequence is interpreted as a code-point, so if an escape\n      // sequence happens to be part of a multi-byte sequence, each byte will\n      // be converted to a single character.\n      // Example: 'g#%E3%82%AC' -> '\\x67\\x35\\xe3\\x82\\xac'\n      const utf8 = unescape(encoded);\n\n      const result = new Uint8Array(utf8.length);\n      for (let i = 0; i < utf8.length; i++) {\n        const item = utf8[i];\n        result[i] = item.charCodeAt(0);\n      }\n      return shaka.util.BufferUtils.toArrayBuffer(result);\n    }\n  }\n\n\n  /**\n   * Creates a ArrayBuffer from the given string, converting to UTF-16 encoding.\n   *\n   * @param {string} str\n   * @param {boolean} littleEndian\n   * @return {!ArrayBuffer}\n   * @export\n   */\n  static toUTF16(str, littleEndian) {\n    const result = new ArrayBuffer(str.length * 2);\n    const view = new DataView(result);\n    for (let i = 0; i < str.length; ++i) {\n      const value = str.charCodeAt(i);\n      view.setUint16(/* position= */ i * 2, value, littleEndian);\n    }\n    return result;\n  }\n\n\n  /**\n   * Creates a new string from the given array of char codes.\n   *\n   * Using String.fromCharCode.apply is risky because you can trigger stack\n   * errors on very large arrays.  This breaks up the array into several pieces\n   * to avoid this.\n   *\n   * @param {!TypedArray} array\n   * @return {string}\n   */\n  static fromCharCode(array) {\n    return shaka.util.StringUtils.fromCharCodeImpl_.value()(array);\n  }\n\n  /**\n   * Resets the fromCharCode method's implementation.\n   * For debug use.\n   * @export\n   */\n  static resetFromCharCode() {\n    shaka.util.StringUtils.fromCharCodeImpl_.reset();\n  }\n};\n\n\n/** @private {!shaka.util.Lazy.<function(!TypedArray):string>} */\nshaka.util.StringUtils.fromCharCodeImpl_ = new shaka.util.Lazy(() => {\n  /** @param {number} size @return {boolean} */\n  const supportsChunkSize = (size) => {\n    try {\n      // The compiler will complain about suspicious value if this isn't\n      // stored in a variable and used.\n      const buffer = new Uint8Array(size);\n\n      // This can't use the spread operator, or it blows up on Xbox One.\n      // So we use apply() instead, which is normally not allowed.\n      // See issue #2186 for more details.\n      // eslint-disable-next-line no-restricted-syntax\n      const foo = String.fromCharCode.apply(null, buffer);\n      goog.asserts.assert(foo, 'Should get value');\n      return foo.length > 0; // Actually use \"foo\", so it's not compiled out.\n    } catch (error) {\n      return false;\n    }\n  };\n\n  // Different browsers support different chunk sizes; find out the largest\n  // this browser supports so we can use larger chunks on supported browsers\n  // but still support lower-end devices that require small chunks.\n  // 64k is supported on all major desktop browsers.\n  for (let size = 64 * 1024; size > 0; size /= 2) {\n    if (supportsChunkSize(size)) {\n      return (buffer) => {\n        let ret = '';\n        for (let i = 0; i < buffer.length; i += size) {\n          const subArray = buffer.subarray(i, i + size);\n\n          // This can't use the spread operator, or it blows up on Xbox One.\n          // So we use apply() instead, which is normally not allowed.\n          // See issue #2186 for more details.\n          // eslint-disable-next-line no-restricted-syntax\n          ret += String.fromCharCode.apply(null, subArray);  // Issue #2186\n        }\n        return ret;\n      };\n    }\n  }\n  goog.asserts.assert(false, 'Unable to create a fromCharCode method');\n  return null;\n});\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Uint8ArrayUtils');\n\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.StringUtils');\n\n\n// TODO: revisit this when Closure Compiler supports partially-exported classes.\n/**\n * @summary A set of Uint8Array utility functions.\n * @export\n */\nshaka.util.Uint8ArrayUtils = class {\n  /**\n   * Compare two Uint8Arrays for equality.\n   * @param {Uint8Array} arr1\n   * @param {Uint8Array} arr2\n   * @return {boolean}\n   * @deprecated\n   * @export\n   */\n  static equal(arr1, arr2) {\n    shaka.Deprecate.deprecateFeature(4,\n        'shaka.util.Uint8ArrayUtils.equal',\n        'Please use shaka.util.BufferUtils.equal instead.');\n    return shaka.util.BufferUtils.equal(arr1, arr2);\n  }\n\n  /**\n   * Convert a buffer to a base64 string. The output will be standard\n   * alphabet as opposed to base64url safe alphabet.\n   * @param {BufferSource} data\n   * @return {string}\n   * @export\n   */\n  static toStandardBase64(data) {\n    const bytes = shaka.util.StringUtils.fromCharCode(\n        shaka.util.BufferUtils.toUint8(data));\n    return btoa(bytes);\n  }\n\n  /**\n   * Convert a buffer to a base64 string.  The output will always use the\n   * alternate encoding/alphabet also known as \"base64url\".\n   * @param {BufferSource} data\n   * @param {boolean=} padding If true, pad the output with equals signs.\n   *   Defaults to true.\n   * @return {string}\n   * @export\n   */\n  static toBase64(data, padding) {\n    padding = (padding == undefined) ? true : padding;\n    const base64 = shaka.util.Uint8ArrayUtils.toStandardBase64(data)\n        .replace(/\\+/g, '-').replace(/\\//g, '_');\n    return padding ? base64 : base64.replace(/[=]*$/, '');\n  }\n\n  /**\n   * Convert a base64 string to a Uint8Array.  Accepts either the standard\n   * alphabet or the alternate \"base64url\" alphabet.\n   * @param {string} str\n   * @return {!Uint8Array}\n   * @export\n   */\n  static fromBase64(str) {\n    // atob creates a \"raw string\" where each character is interpreted as a\n    // byte.\n    const bytes = window.atob(str.replace(/-/g, '+').replace(/_/g, '/'));\n    const result = new Uint8Array(bytes.length);\n    for (let i = 0; i < bytes.length; ++i) {\n      result[i] = bytes.charCodeAt(i);\n    }\n    return result;\n  }\n\n\n  /**\n   * Convert a hex string to a Uint8Array.\n   * @param {string} str\n   * @return {!Uint8Array}\n   * @export\n   */\n  static fromHex(str) {\n    const size = str.length / 2;\n    const arr = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n      arr[i] = window.parseInt(str.substr(i * 2, 2), 16);\n    }\n    return arr;\n  }\n\n\n  /**\n   * Convert a buffer to a hex string.\n   * @param {BufferSource} data\n   * @return {string}\n   * @export\n   */\n  static toHex(data) {\n    const arr = shaka.util.BufferUtils.toUint8(data);\n    let hex = '';\n    for (let value of arr) {\n      value = value.toString(16);\n      if (value.length == 1) {\n        value = '0' + value;\n      }\n      hex += value;\n    }\n    return hex;\n  }\n\n\n  /**\n   * Concatenate buffers.\n   * @param {...BufferSource} varArgs\n   * @return {!Uint8Array}\n   * @export\n   */\n  static concat(...varArgs) {\n    let totalLength = 0;\n    for (const arr of varArgs) {\n      totalLength += arr.byteLength;\n    }\n\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const arr of varArgs) {\n      result.set(shaka.util.BufferUtils.toUint8(arr), offset);\n      offset += arr.byteLength;\n    }\n    return result;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.Transmuxer');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.Uint8ArrayUtils');\ngoog.require('shaka.dependencies');\n\n\n/**\n * Transmuxer provides all operations for transmuxing from Transport\n * Stream to MP4.\n *\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.Transmuxer = class {\n  /** */\n  constructor() {\n    /** @private {?muxjs} */\n    this.muxjs_ = shaka.dependencies.muxjs();\n\n    /** @private {muxjs.mp4.Transmuxer} */\n    this.muxTransmuxer_ = null;\n\n    /** @private {shaka.util.PublicPromise} */\n    this.transmuxPromise_ = null;\n\n    /** @private {!Array.<!Uint8Array>} */\n    this.transmuxedData_ = [];\n\n    /** @private {!Array.<muxjs.mp4.ClosedCaption>} */\n    this.captions_ = [];\n\n    /** @private {!Array.<muxjs.mp4.Metadata>} */\n    this.metadata_ = [];\n\n    /** @private {boolean} */\n    this.isTransmuxing_ = false;\n\n    if (this.muxjs_) {\n      this.muxTransmuxer_ = new this.muxjs_.mp4.Transmuxer({\n        'keepOriginalTimestamps': true,\n      });\n      this.muxTransmuxer_.on('data', (segment) => this.onTransmuxed_(segment));\n      this.muxTransmuxer_.on('done', () => this.onTransmuxDone_());\n    }\n  }\n\n  /**\n   * @override\n   */\n  destroy() {\n    if (this.muxTransmuxer_) {\n      this.muxTransmuxer_.dispose();\n    }\n    this.muxTransmuxer_ = null;\n    return Promise.resolve();\n  }\n\n\n  /**\n   * Check if the content type is Transport Stream, and if muxjs is loaded.\n   * @param {string} mimeType\n   * @param {string=} contentType\n   * @return {boolean}\n   */\n  static isSupported(mimeType, contentType) {\n    const Transmuxer = shaka.media.Transmuxer;\n\n    if (!shaka.dependencies.muxjs() || !Transmuxer.isTsContainer(mimeType)) {\n      return false;\n    }\n\n    if (contentType) {\n      return MediaSource.isTypeSupported(\n          Transmuxer.convertTsCodecs(contentType, mimeType));\n    }\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const audioMime = Transmuxer.convertTsCodecs(ContentType.AUDIO, mimeType);\n    const videoMime = Transmuxer.convertTsCodecs(ContentType.VIDEO, mimeType);\n    return MediaSource.isTypeSupported(audioMime) ||\n        MediaSource.isTypeSupported(videoMime);\n  }\n\n\n  /**\n   * Check if the mimetype contains 'mp2t'.\n   * @param {string} mimeType\n   * @return {boolean}\n   */\n  static isTsContainer(mimeType) {\n    return mimeType.toLowerCase().split(';')[0].split('/')[1] == 'mp2t';\n  }\n\n\n  /**\n   * For transport stream, convert its codecs to MP4 codecs.\n   * @param {string} contentType\n   * @param {string} tsMimeType\n   * @return {string}\n   */\n  static convertTsCodecs(contentType, tsMimeType) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    let mp4MimeType = tsMimeType.replace(/mp2t/i, 'mp4');\n    if (contentType == ContentType.AUDIO) {\n      mp4MimeType = mp4MimeType.replace('video', 'audio');\n    }\n\n    // Handle legacy AVC1 codec strings (pre-RFC 6381).\n    // Look for \"avc1.<profile>.<level>\", where profile is:\n    //   66 (baseline => 0x42)\n    //   77 (main => 0x4d)\n    //   100 (high => 0x64)\n    // Reference: https://bit.ly/2K9JI3x\n    const match = /avc1\\.(66|77|100)\\.(\\d+)/.exec(mp4MimeType);\n    if (match) {\n      let newCodecString = 'avc1.';\n\n      const profile = match[1];\n      if (profile == '66') {\n        newCodecString += '4200';\n      } else if (profile == '77') {\n        newCodecString += '4d00';\n      } else {\n        goog.asserts.assert(profile == '100',\n            'Legacy avc1 parsing code out of sync with regex!');\n        newCodecString += '6400';\n      }\n\n      // Convert the level to hex and append to the codec string.\n      const level = Number(match[2]);\n      goog.asserts.assert(level < 256,\n          'Invalid legacy avc1 level number!');\n      newCodecString += (level >> 4).toString(16);\n      newCodecString += (level & 0xf).toString(16);\n\n      mp4MimeType = mp4MimeType.replace(match[0], newCodecString);\n    }\n\n    return mp4MimeType;\n  }\n\n\n  /**\n   * Transmux from Transport stream to MP4, using the mux.js library.\n   * @param {BufferSource} data\n   * @return {!Promise.<{data: !Uint8Array,\n   *                     captions: !Array.<!muxjs.mp4.ClosedCaption>,\n   *                     metadata: !Array.<!Object>}>}\n   */\n  transmux(data) {\n    goog.asserts.assert(this.muxTransmuxer_,\n        'mux.js should be available.');\n    goog.asserts.assert(!this.isTransmuxing_,\n        'No transmuxing should be in progress.');\n    this.isTransmuxing_ = true;\n    this.transmuxPromise_ = new shaka.util.PublicPromise();\n    this.transmuxedData_ = [];\n    this.captions_ = [];\n    this.metadata_ = [];\n\n    const dataArray = shaka.util.BufferUtils.toUint8(data);\n    this.muxTransmuxer_.push(dataArray);\n    this.muxTransmuxer_.flush();\n\n    // Workaround for https://bit.ly/Shaka1449 mux.js not\n    // emitting 'data' and 'done' events.\n    // mux.js code is synchronous, so if onTransmuxDone_ has\n    // not been called by now, it's not going to be.\n    // Treat it as a transmuxing failure and reject the promise.\n    if (this.isTransmuxing_) {\n      this.transmuxPromise_.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.TRANSMUXING_FAILED));\n    }\n    return this.transmuxPromise_;\n  }\n\n\n  /**\n   * Handles the 'data' event of the transmuxer.\n   * Extracts the cues from the transmuxed segment, and adds them to an array.\n   * Stores the transmuxed data in another array, to pass it back to\n   * MediaSourceEngine, and append to the source buffer.\n   *\n   * @param {muxjs.mp4.Transmuxer.Segment} segment\n   * @private\n   */\n  onTransmuxed_(segment) {\n    this.captions_ = segment.captions;\n    this.metadata_ = segment.metadata;\n    this.transmuxedData_.push(\n        shaka.util.Uint8ArrayUtils.concat(segment.initSegment, segment.data));\n  }\n\n\n  /**\n   * Handles the 'done' event of the transmuxer.\n   * Resolves the transmux Promise, and returns the transmuxed data.\n   * @private\n   */\n  onTransmuxDone_() {\n    const output = {\n      data: shaka.util.Uint8ArrayUtils.concat(...this.transmuxedData_),\n      captions: this.captions_,\n      metadata: this.metadata_,\n    };\n\n    this.transmuxPromise_.resolve(output);\n    this.isTransmuxing_ = false;\n  }\n};\n\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.MimeUtils');\n\ngoog.require('shaka.dependencies');\ngoog.require('shaka.media.Transmuxer');\ngoog.require('shaka.util.ManifestParserUtils');\n\n/**\n * @summary A set of utility functions for dealing with MIME types.\n */\nshaka.util.MimeUtils = class {\n  /**\n   * Takes a MIME type and optional codecs string and produces the full MIME\n   * type.\n   *\n   * @param {string} mimeType\n   * @param {string=} codecs\n   * @return {string}\n   */\n  static getFullType(mimeType, codecs) {\n    let fullMimeType = mimeType;\n    if (codecs) {\n      fullMimeType += '; codecs=\"' + codecs + '\"';\n    }\n    return fullMimeType;\n  }\n\n  /**\n   * Takes a MIME type and a codecs string and produces the full MIME\n   * type. If it's a transport stream, convert its codecs to MP4 codecs.\n   * Otherwise for multiplexed content, convert the video MIME types to\n   * their audio equivalents if the content type is audio.\n   *\n   * @param {string} mimeType\n   * @param {string} codecs\n   * @param {string} contentType\n   * @return {string}\n   */\n  static getFullOrConvertedType(mimeType, codecs, contentType) {\n    const fullMimeType = shaka.util.MimeUtils.getFullType(mimeType, codecs);\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    if (shaka.media.Transmuxer.isTsContainer(fullMimeType)) {\n      if (shaka.dependencies.muxjs()) {\n        return shaka.media.Transmuxer.convertTsCodecs(\n            contentType, fullMimeType);\n      }\n    } else if (mimeType != 'video/mp2t' && contentType == ContentType.AUDIO) {\n      // video/mp2t is the correct mime type for TS audio, so only replace the\n      // word \"video\" with \"audio\" for non-TS audio content.\n      return fullMimeType.replace('video', 'audio');\n    }\n    return fullMimeType;\n  }\n\n\n  /**\n   * Takes a Stream object and produces an extended MIME type with information\n   * beyond the container and codec type, when available.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {string}\n   */\n  static getExtendedType(stream) {\n    const components = [stream.mimeType];\n\n    const extendedMimeParams = shaka.util.MimeUtils.EXTENDED_MIME_PARAMETERS_;\n    extendedMimeParams.forEach((mimeKey, streamKey) => {\n      const value = stream[streamKey];\n      if (value) {\n        components.push(mimeKey + '=\"' + value + '\"');\n      }\n    });\n    if (stream.hdr == 'PQ') {\n      components.push('eotf=\"smpte2084\"');\n    }\n\n    return components.join(';');\n  }\n\n  /**\n   * Takes a full MIME type (with codecs) or basic MIME type (without codecs)\n   * and returns a container type string (\"mp2t\", \"mp4\", \"webm\", etc.)\n   *\n   * @param {string} mimeType\n   * @return {string}\n   */\n  static getContainerType(mimeType) {\n    return mimeType.split(';')[0].split('/')[1];\n  }\n\n  /**\n   * Split a list of codecs encoded in a string into a list of codecs.\n   * @param {string} codecs\n   * @return {!Array.<string>}\n   */\n  static splitCodecs(codecs) {\n    return codecs.split(',');\n  }\n\n  /**\n   * Get the normalized codec from a codec string,\n   * independently of their container.\n   *\n   * @param {string} codecString\n   * @return {string}\n   */\n  static getNormalizedCodec(codecString) {\n    const parts =\n      shaka.util.MimeUtils.getCodecParts_(codecString);\n    const base = parts[0];\n    const profile = parts[1].toLowerCase();\n    switch (true) {\n      case base === 'mp4a' && profile === '69':\n      case base === 'mp4a' && profile === '6b':\n        return 'mp3';\n      case base === 'mp4a' && profile === '66':\n      case base === 'mp4a' && profile === '67':\n      case base === 'mp4a' && profile === '68':\n      case base === 'mp4a' && profile === '40.2':\n      case base === 'mp4a' && profile === '40.02':\n      case base === 'mp4a' && profile === '40.5':\n      case base === 'mp4a' && profile === '40.05':\n      case base === 'mp4a' && profile === '40.29':\n      case base === 'mp4a' && profile === '40.42': // Extended HE-AAC\n        return 'aac';\n      case base === 'mp4a' && profile === 'a5':\n        return 'ac-3'; // Dolby Digital\n      case base === 'mp4a' && profile === 'a6':\n        return 'ec-3'; // Dolby Digital Plus\n      case base === 'mp4a' && profile === 'b2':\n        return 'dtsx'; // DTS:X\n      case base === 'mp4a' && profile === 'a9':\n        return 'dtsc'; // DTS Digital Surround\n      case base === 'avc1':\n      case base === 'avc3':\n        return 'avc'; // H264\n      case base === 'hvc1':\n      case base === 'hev1':\n        return 'hevc'; // H265\n      case base === 'dvh1':\n      case base === 'dvhe':\n        return 'dovi'; // Dolby Vision\n    }\n    return base;\n  }\n\n  /**\n   * Get the base codec from a codec string.\n   *\n   * @param {string} codecString\n   * @return {string}\n   */\n  static getCodecBase(codecString) {\n    const parts = shaka.util.MimeUtils.getCodecParts_(codecString);\n    return parts[0];\n  }\n\n  /**\n   * Takes a full MIME type (with codecs) or basic MIME type (without codecs)\n   * and returns a basic MIME type (without codecs or other parameters).\n   *\n   * @param {string} mimeType\n   * @return {string}\n   */\n  static getBasicType(mimeType) {\n    return mimeType.split(';')[0];\n  }\n\n  /**\n   * Takes a MIME type and returns the codecs parameter, or an empty string if\n   * there is no codecs parameter.\n   *\n   * @param {string} mimeType\n   * @return {string}\n   */\n  static getCodecs(mimeType) {\n    // Parse the basic MIME type from its parameters.\n    const pieces = mimeType.split(/ *; */);\n    pieces.shift();  // Remove basic MIME type from pieces.\n\n    const codecs = pieces.find((piece) => piece.startsWith('codecs='));\n    if (!codecs) {\n      return '';\n    }\n\n    // The value may be quoted, so remove quotes at the beginning or end.\n    const value = codecs.split('=')[1].replace(/^\"|\"$/g, '');\n    return value;\n  }\n\n  /**\n   * Checks if the given MIME type is HLS MIME type.\n   *\n   * @param {string} mimeType\n   * @return {boolean}\n   */\n  static isHlsType(mimeType) {\n    return mimeType === 'application/x-mpegurl' ||\n        mimeType === 'application/vnd.apple.mpegurl';\n  }\n\n  /**\n   * Get the base and profile of a codec string. Where [0] will be the codec\n   * base and [1] will be the profile.\n   * @param {string} codecString\n   * @return {!Array.<string>}\n   * @private\n   */\n  static getCodecParts_(codecString) {\n    const parts = codecString.split('.');\n\n    const base = parts[0];\n\n    parts.shift();\n    const profile = parts.join('.');\n\n    // Make sure that we always return a \"base\" and \"profile\".\n    return [base, profile];\n  }\n};\n\n\n/**\n * A map from Stream object keys to MIME type parameters.  These should be\n * ignored by platforms that do not recognize them.\n *\n * This initial set of parameters are all recognized by Chromecast.\n *\n * @const {!Map.<string, string>}\n * @private\n */\nshaka.util.MimeUtils.EXTENDED_MIME_PARAMETERS_ = new Map()\n    .set('codecs', 'codecs')\n    .set('frameRate', 'framerate')  // Ours is camelCase, theirs is lowercase.\n    .set('bandwidth', 'bitrate')  // They are in the same units: bits/sec.\n    .set('width', 'width')\n    .set('height', 'height')\n    .set('channelsCount', 'channels');\n\n\n/**\n * A mimetype created for CEA-608 closed captions.\n * @const {string}\n */\nshaka.util.MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE = 'application/cea-608';\n\n/**\n * A mimetype created for CEA-708 closed captions.\n * @const {string}\n */\nshaka.util.MimeUtils.CEA708_CLOSED_CAPTION_MIMETYPE = 'application/cea-708';\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.TextEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.MimeUtils');\ngoog.requireType('shaka.cea.ICaptionDecoder');\n\n\n// TODO: revisit this when Closure Compiler supports partially-exported classes.\n/**\n * @summary Manages text parsers and cues.\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.text.TextEngine = class {\n  /** @param {shaka.extern.TextDisplayer} displayer */\n  constructor(displayer) {\n    /** @private {?shaka.extern.TextParser} */\n    this.parser_ = null;\n\n    /** @private {shaka.extern.TextDisplayer} */\n    this.displayer_ = displayer;\n\n    /** @private {number} */\n    this.timestampOffset_ = 0;\n\n    /** @private {number} */\n    this.appendWindowStart_ = 0;\n\n    /** @private {number} */\n    this.appendWindowEnd_ = Infinity;\n\n    /** @private {?number} */\n    this.bufferStart_ = null;\n\n    /** @private {?number} */\n    this.bufferEnd_ = null;\n\n    /** @private {string} */\n    this.selectedClosedCaptionId_ = '';\n\n    /**\n     * The closed captions map stores the CEA closed captions by closed captions\n     * id and start and end time.\n     * It's used as the buffer of closed caption text streams, to show captions\n     * when we start displaying captions or switch caption tracks, we need to be\n     * able to get the cues for the other language and display them without\n     * re-fetching the video segments they were embedded in.\n     * Structure of closed caption map:\n     * closed caption id -> {start and end time -> cues}\n     * @private {!Map.<string, !Map.<string, !Array.<shaka.text.Cue>>>} */\n    this.closedCaptionsMap_ = new Map();\n  }\n\n  /**\n   * @param {string} mimeType\n   * @param {!shaka.extern.TextParserPlugin} plugin\n   * @export\n   */\n  static registerParser(mimeType, plugin) {\n    shaka.text.TextEngine.parserMap_[mimeType] = plugin;\n  }\n\n  /**\n   * @param {string} mimeType\n   * @export\n   */\n  static unregisterParser(mimeType) {\n    delete shaka.text.TextEngine.parserMap_[mimeType];\n  }\n\n  /**\n   * @return {?shaka.extern.TextParserPlugin}\n   * @export\n   */\n  static findParser(mimeType) {\n    return shaka.text.TextEngine.parserMap_[mimeType];\n  }\n\n  /**\n   * @param {string} mimeType\n   * @return {boolean}\n   */\n  static isTypeSupported(mimeType) {\n    if (shaka.text.TextEngine.parserMap_[mimeType]) {\n      // An actual parser is available.\n      return true;\n    }\n    if (mimeType == shaka.util.MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE ||\n        mimeType == shaka.util.MimeUtils.CEA708_CLOSED_CAPTION_MIMETYPE ) {\n      // Closed captions.\n      return true;\n    }\n    return false;\n  }\n\n  // TODO: revisit this when the compiler supports partially-exported classes.\n  /**\n   * @override\n   * @export\n   */\n  destroy() {\n    this.parser_ = null;\n    this.displayer_ = null;\n    this.closedCaptionsMap_.clear();\n\n    return Promise.resolve();\n  }\n\n  /**\n   * @param {!shaka.extern.TextDisplayer} displayer\n   */\n  setDisplayer(displayer) {\n    this.displayer_ = displayer;\n  }\n\n  /**\n   * Initialize the parser.  This can be called multiple times, but must be\n   * called at least once before appendBuffer.\n   *\n   * @param {string} mimeType\n   */\n  initParser(mimeType) {\n    // No parser for CEA, which is extracted from video and side-loaded\n    // into TextEngine and TextDisplayer.\n    if (mimeType == shaka.util.MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE ||\n        mimeType == shaka.util.MimeUtils.CEA708_CLOSED_CAPTION_MIMETYPE) {\n      this.parser_ = null;\n      return;\n    }\n\n    const factory = shaka.text.TextEngine.parserMap_[mimeType];\n    goog.asserts.assert(\n        factory, 'Text type negotiation should have happened already');\n    this.parser_ = shaka.util.Functional.callFactory(factory);\n  }\n\n  /**\n   * @param {BufferSource} buffer\n   * @param {?number} startTime relative to the start of the presentation\n   * @param {?number} endTime relative to the start of the presentation\n   * @return {!Promise}\n   */\n  async appendBuffer(buffer, startTime, endTime) {\n    goog.asserts.assert(\n        this.parser_, 'The parser should already be initialized');\n\n    // Start the operation asynchronously to avoid blocking the caller.\n    await Promise.resolve();\n\n    // Check that TextEngine hasn't been destroyed.\n    if (!this.parser_ || !this.displayer_) {\n      return;\n    }\n\n    if (startTime == null || endTime == null) {\n      this.parser_.parseInit(shaka.util.BufferUtils.toUint8(buffer));\n      return;\n    }\n\n    /** @type {shaka.extern.TextParser.TimeContext} **/\n    const time = {\n      periodStart: this.timestampOffset_,\n      segmentStart: startTime,\n      segmentEnd: endTime,\n    };\n\n    // Parse the buffer and add the new cues.\n    const allCues = this.parser_.parseMedia(\n        shaka.util.BufferUtils.toUint8(buffer), time);\n    const cuesToAppend = allCues.filter((cue) => {\n      return cue.startTime >= this.appendWindowStart_ &&\n          cue.startTime < this.appendWindowEnd_;\n    });\n\n    this.displayer_.append(cuesToAppend);\n\n    // NOTE: We update the buffered range from the start and end times\n    // passed down from the segment reference, not with the start and end\n    // times of the parsed cues.  This is important because some segments\n    // may contain no cues, but we must still consider those ranges\n    // buffered.\n    if (this.bufferStart_ == null) {\n      this.bufferStart_ = Math.max(startTime, this.appendWindowStart_);\n    } else {\n      // We already had something in buffer, and we assume we are extending\n      // the range from the end.\n      goog.asserts.assert(\n          this.bufferEnd_ != null,\n          'There should already be a buffered range end.');\n      goog.asserts.assert(\n          (startTime - this.bufferEnd_) <= 1,\n          'There should not be a gap in text references >1s');\n    }\n    this.bufferEnd_ = Math.min(endTime, this.appendWindowEnd_);\n  }\n\n  /**\n   * @param {number} startTime relative to the start of the presentation\n   * @param {number} endTime relative to the start of the presentation\n   * @return {!Promise}\n   */\n  async remove(startTime, endTime) {\n    // Start the operation asynchronously to avoid blocking the caller.\n    await Promise.resolve();\n\n    if (this.displayer_ && this.displayer_.remove(startTime, endTime)) {\n      if (this.bufferStart_ == null) {\n        goog.asserts.assert(\n            this.bufferEnd_ == null, 'end must be null if startTime is null');\n      } else {\n        goog.asserts.assert(\n            this.bufferEnd_ != null,\n            'end must be non-null if startTime is non-null');\n\n        // Update buffered range.\n        if (endTime <= this.bufferStart_ || startTime >= this.bufferEnd_) {\n          // No intersection.  Nothing was removed.\n        } else if (startTime <= this.bufferStart_ &&\n                   endTime >= this.bufferEnd_) {\n          // We wiped out everything.\n          this.bufferStart_ = this.bufferEnd_ = null;\n        } else if (startTime <= this.bufferStart_ &&\n                   endTime < this.bufferEnd_) {\n          // We removed from the beginning of the range.\n          this.bufferStart_ = endTime;\n        } else if (startTime > this.bufferStart_ &&\n                   endTime >= this.bufferEnd_) {\n          // We removed from the end of the range.\n          this.bufferEnd_ = startTime;\n        } else {\n          // We removed from the middle?  StreamingEngine isn't supposed to.\n          goog.asserts.assert(\n              false, 'removal from the middle is not supported by TextEngine');\n        }\n      }\n    }\n  }\n\n  /** @param {number} timestampOffset */\n  setTimestampOffset(timestampOffset) {\n    this.timestampOffset_ = timestampOffset;\n  }\n\n  /**\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   */\n  setAppendWindow(appendWindowStart, appendWindowEnd) {\n    this.appendWindowStart_ = appendWindowStart;\n    this.appendWindowEnd_ = appendWindowEnd;\n  }\n\n  /**\n   * @return {?number} Time in seconds of the beginning of the buffered range,\n   *   or null if nothing is buffered.\n   */\n  bufferStart() {\n    return this.bufferStart_;\n  }\n\n  /**\n   * @return {?number} Time in seconds of the end of the buffered range,\n   *   or null if nothing is buffered.\n   */\n  bufferEnd() {\n    return this.bufferEnd_;\n  }\n\n  /**\n   * @param {number} t A timestamp\n   * @return {boolean}\n   */\n  isBuffered(t) {\n    if (this.bufferStart_ == null || this.bufferEnd_ == null) {\n      return false;\n    }\n    return t >= this.bufferStart_ && t < this.bufferEnd_;\n  }\n\n  /**\n   * @param {number} t A timestamp\n   * @return {number} Number of seconds ahead of 't' we have buffered\n   */\n  bufferedAheadOf(t) {\n    if (this.bufferEnd_ == null || this.bufferEnd_ < t) {\n      return 0;\n    }\n\n    goog.asserts.assert(\n        this.bufferStart_ != null,\n        'start should not be null if end is not null');\n\n    return this.bufferEnd_ - Math.max(t, this.bufferStart_);\n  }\n\n  /**\n   * Set the selected closed captions id.\n   * Append the cues stored in the closed captions map until buffer end time.\n   * This is to fill the gap between buffered and unbuffered captions, and to\n   * avoid duplicates that would be caused by any future video segments parsed\n   * for captions.\n   *\n   * @param {string} id\n   * @param {number} bufferEndTime Load any stored cues up to this time.\n   */\n  setSelectedClosedCaptionId(id, bufferEndTime) {\n    this.selectedClosedCaptionId_ = id;\n\n    const captionsMap = this.closedCaptionsMap_.get(id);\n    if (captionsMap) {\n      for (const startAndEndTime of captionsMap.keys()) {\n        /** @type {Array.<!shaka.text.Cue>} */\n        const cues = captionsMap.get(startAndEndTime)\n            .filter((c) => c.endTime <= bufferEndTime);\n        if (cues) {\n          this.displayer_.append(cues);\n        }\n      }\n    }\n  }\n\n  /**\n  * @param {!Array<muxjs.mp4.ClosedCaption>} closedCaptions\n  * @return {!Array<!shaka.cea.ICaptionDecoder.ClosedCaption>}\n  */\n  convertMuxjsCaptionsToShakaCaptions(closedCaptions) {\n    const cues = [];\n    for (const caption of closedCaptions) {\n      const cue = new shaka.text.Cue(\n          caption.startTime, caption.endTime, caption.text);\n      cues.push({\n        stream: caption.stream,\n        cue,\n      });\n    }\n    return cues;\n  }\n\n  /**\n   * @param {!shaka.text.Cue} cue the cue to apply the timestamp to recursively\n   * @param {number} videoTimestampOffset the timestamp offset of the video\n   * @private\n   */\n  applyVideoTimestampOffsetRecursive_(cue, videoTimestampOffset) {\n    cue.startTime += videoTimestampOffset;\n    cue.endTime += videoTimestampOffset;\n    for (const nested of cue.nestedCues) {\n      this.applyVideoTimestampOffsetRecursive_(nested, videoTimestampOffset);\n    }\n  }\n\n  /**\n   * Store the closed captions in the text engine, and append the cues to the\n   * text displayer.  This is a side-channel used for embedded text only.\n   *\n   * @param {!Array.<!shaka.cea.ICaptionDecoder.ClosedCaption>} closedCaptions\n   * @param {?number} startTime relative to the start of the presentation\n   * @param {?number} endTime relative to the start of the presentation\n   * @param {number} videoTimestampOffset the timestamp offset of the video\n   *   stream in which these captions were embedded\n   */\n  storeAndAppendClosedCaptions(\n      closedCaptions, startTime, endTime, videoTimestampOffset) {\n    const startAndEndTime = startTime + ' ' + endTime;\n    /** @type {!Map.<string, !Map.<string, !Array.<!shaka.text.Cue>>>} */\n    const captionsMap = new Map();\n\n    for (const caption of closedCaptions) {\n      const id = caption.stream;\n      const cue = caption.cue;\n      if (!captionsMap.has(id)) {\n        captionsMap.set(id, new Map());\n      }\n      if (!captionsMap.get(id).has(startAndEndTime)) {\n        captionsMap.get(id).set(startAndEndTime, []);\n      }\n\n      // Adjust CEA captions with respect to the timestamp offset of the video\n      // stream in which they were embedded.\n      this.applyVideoTimestampOffsetRecursive_(cue, videoTimestampOffset);\n\n      const keepThisCue =\n          cue.startTime >= this.appendWindowStart_ &&\n          cue.startTime < this.appendWindowEnd_;\n      if (!keepThisCue) {\n        continue;\n      }\n\n      captionsMap.get(id).get(startAndEndTime).push(cue);\n      if (id == this.selectedClosedCaptionId_) {\n        this.displayer_.append([cue]);\n      }\n    }\n\n    for (const id of captionsMap.keys()) {\n      if (!this.closedCaptionsMap_.has(id)) {\n        this.closedCaptionsMap_.set(id, new Map());\n      }\n      for (const startAndEndTime of captionsMap.get(id).keys()) {\n        const cues = captionsMap.get(id).get(startAndEndTime);\n        this.closedCaptionsMap_.get(id).set(startAndEndTime, cues);\n      }\n    }\n\n    if (this.bufferStart_ == null) {\n      this.bufferStart_ = Math.max(startTime, this.appendWindowStart_);\n    } else {\n      this.bufferStart_ = Math.min(\n          this.bufferStart_, Math.max(startTime, this.appendWindowStart_));\n    }\n\n    this.bufferEnd_ = Math.max(\n        this.bufferEnd_, Math.min(endTime, this.appendWindowEnd_));\n  }\n\n  /**\n   * Get the number of closed caption channels.\n   *\n   * This function is for TESTING ONLY. DO NOT USE in the library.\n   *\n   * @return {number}\n   */\n  getNumberOfClosedCaptionChannels() {\n    return this.closedCaptionsMap_.size;\n  }\n\n  /**\n   * Get the number of closed caption cues for a given channel. If there is\n   * no channel for the given channel id, this will return 0.\n   *\n   * This function is for TESTING ONLY. DO NOT USE in the library.\n   *\n   * @param {string} channelId\n   * @return {number}\n   */\n  getNumberOfClosedCaptionsInChannel(channelId) {\n    const channel = this.closedCaptionsMap_.get(channelId);\n    return channel ? channel.size : 0;\n  }\n};\n\n/** @private {!Object.<string, !shaka.extern.TextParserPlugin>} */\nshaka.text.TextEngine.parserMap_ = {};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.LanguageUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.ManifestParserUtils');\n\n\n/**\n * @summary A set of language utility functions.\n * @final\n * @export\n */\nshaka.util.LanguageUtils = class {\n  /**\n   * Check if |locale1| and |locale2| are locale-compatible.\n   *\n   * Locale-compatible is defined as all components in each locale match. Since\n   * we only respect the language and region components, we only check that\n   * the language and region components match.\n   *\n   * Examples:\n   *  Locale A | Locale B | Locale Compatible\n   *  ---------------------------------------\n   *  en-US    | en-US    | true\n   *  en       | en-US    | false\n   *  en-US    | en-CA    | false\n   *\n   * @param {string} locale1\n   * @param {string} locale2\n   * @return {boolean}\n   * @export\n   */\n  static areLocaleCompatible(locale1, locale2) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    locale1 = LanguageUtils.normalize(locale1);\n    locale2 = LanguageUtils.normalize(locale2);\n\n    return locale1 == locale2;\n  }\n\n  /**\n   * Check if |locale1| and |locale2| are language-compatible.\n   *\n   * Language compatible is when the language component of each locale matches.\n   * This means that no matter what region they have (or don't have) as long as\n   * the language components match, they are language-compatible.\n   *\n   * Examples:\n   *  Locale A | Locale B | Language-Compatible\n   *  -----------------------------------------\n   *  en-US    | en-US    | true\n   *  en-US    | en       | true\n   *  en-US    | en-CA    | true\n   *  en-CA    | fr-CA    | false\n   *\n   * @param {string} locale1\n   * @param {string} locale2\n   * @return {boolean}\n   * @export\n   */\n  static areLanguageCompatible(locale1, locale2) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    locale1 = LanguageUtils.normalize(locale1);\n    locale2 = LanguageUtils.normalize(locale2);\n\n    // Get all components. This should only be language and region\n    // since we do not support dialect.\n    /** @type {!Array.<string>} */\n    const locale1Components = LanguageUtils.disassembleLocale_(locale1);\n    /** @type {!Array.<string>} */\n    const locale2Components = LanguageUtils.disassembleLocale_(locale2);\n\n    // We are language compatible if we have the same language.\n    return locale1Components[0] == locale2Components[0];\n  }\n\n  /**\n   * Check if |possibleParent| is the parent locale of |possibleChild|. Because\n   * we do not support dialects, the parent-child relationship is a lot simpler.\n   * In a parent child relationship:\n   *    - The parent and child have the same language-component\n   *    - The parent has no region-component\n   *    - The child has a region-component\n   *\n   * Example:\n   *  Locale A | Locale B | Is A The parent of B?\n   *  --------------------------------------------\n   *  en-US    | en-US    | no\n   *  en-US    | en       | no\n   *  en       | en-US    | yes\n   *  en       | en       | no\n   *  en       | fr       | no\n   *\n   * @param {string} possibleParent\n   * @param {string} possibleChild\n   * @return {boolean}\n   * @export\n   */\n  static isParentOf(possibleParent, possibleChild) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    possibleParent = LanguageUtils.normalize(possibleParent);\n    possibleChild = LanguageUtils.normalize(possibleChild);\n\n    // Get all components. This should only be language and region\n    // since we do not support dialect.\n    /** @type {!Array.<string>} */\n    const possibleParentComponents =\n        LanguageUtils.disassembleLocale_(possibleParent);\n    /** @type {!Array.<string>} */\n    const possibleChildComponents =\n        LanguageUtils.disassembleLocale_(possibleChild);\n\n    return possibleParentComponents[0] == possibleChildComponents[0] &&\n           possibleParentComponents.length == 1 &&\n           possibleChildComponents.length == 2;\n  }\n\n  /**\n   * Check if |localeA| shares the same parent with |localeB|. Since we don't\n   * support dialect, we will only look at language and region. For two locales\n   * to be siblings:\n   *    - Both must have language-components\n   *    - Both must have region-components\n   *    - Both must have the same language-component\n   *\n   * Example:\n   *  Locale A | Locale B | Siblings?\n   *  --------------------------------------------\n   *  en-US    | en-US    | yes\n   *  en-US    | en-CA    | yes\n   *  en-US    | en       | no\n   *  en       | en-US    | no\n   *  en       | en       | no\n   *  en       | fr       | no\n   *\n   * @param {string} localeA\n   * @param {string} localeB\n   * @return {boolean}\n   * @export\n   */\n  static isSiblingOf(localeA, localeB) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    localeA = LanguageUtils.normalize(localeA);\n    localeB = LanguageUtils.normalize(localeB);\n\n    // Get all components. This should only be language and region\n    // since we do not support dialect.\n    /** @type {!Array.<string>} */\n    const localeAComponents = LanguageUtils.disassembleLocale_(localeA);\n    /** @type {!Array.<string>} */\n    const localeBComponents = LanguageUtils.disassembleLocale_(localeB);\n\n    return localeAComponents.length == 2 &&\n           localeBComponents.length == 2 &&\n           localeAComponents[0] == localeBComponents[0];\n  }\n\n  /**\n   * Normalize a locale. This will take a locale and canonicalize it to a state\n   * that we are prepared to work with.\n   *\n   * We only support with:\n   *   - language\n   *   - language-REGION\n   *\n   * If given a dialect, we will discard it. We will convert any 3-character\n   * codes to 2-character codes. We will force language codes to lowercase and\n   * region codes to uppercase.\n   *\n   * @param {string} locale\n   * @return {string}\n   * @export\n   */\n  static normalize(locale) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const components = locale.split('-');\n\n    // We are only going to use the language and the region. If there was\n    // a dialect or anything else, we are throwing it a way.\n    let language = components[0] || '';\n    let region = components[1] || '';\n\n    // Convert the language to lower case. It is standard for the language code\n    // to be in lower case, but it will also make the map look-up easier.\n    language = language.toLowerCase();\n    language = LanguageUtils.isoMap_.get(language) || language;\n\n    // Convert the region to upper case. It is standard for the region to be in\n    // upper case. If there is no upper code, then it will be an empty string\n    // and this will be a no-op.\n    region = region.toUpperCase();\n\n    return region ?\n           language + '-' + region :\n           language;\n  }\n\n  /**\n   * Check if two language codes are siblings. Language codes are siblings if\n   * they share the same base language while neither one is the base language.\n   *\n   * For example, \"en-US\" and \"en-CA\" are siblings but \"en-US\" and \"en\" are not\n   * siblings.\n   *\n   * @param {string} a\n   * @param {string} b\n   * @return {boolean}\n   * @export\n   */\n  static areSiblings(a, b) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const baseA = LanguageUtils.getBase(a);\n    const baseB = LanguageUtils.getBase(b);\n\n    return a != baseA && b != baseB && baseA == baseB;\n  }\n\n  /**\n   * Compute a numerical relatedness for language codes.  Language codes with a\n   * higher relatedness are a better match.  Unrelated language codes have a\n   * relatedness score of 0.\n   *\n   * @param {string} target\n   * @param {string} candidate\n   * @return {number}\n   * @export\n   */\n  static relatedness(target, candidate) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    target = LanguageUtils.normalize(target);\n    candidate = LanguageUtils.normalize(candidate);\n\n    // An exact match is the top score.\n    if (candidate == target) {\n      return 4;\n    }\n\n    // Next is a parent of the target language.\n    if (LanguageUtils.isParentOf(candidate, target)) {\n      return 3;\n    }\n\n    // Next is a sibling of the target language.\n    if (LanguageUtils.isSiblingOf(candidate, target)) {\n      return 2;\n    }\n\n    // Next is a child of the target language.\n    if (LanguageUtils.isParentOf(target, candidate)) {\n      return 1;\n    }\n\n    // Otherwise, they are unrelated.\n    return 0;\n  }\n\n  /**\n   * Get the normalized base language for a language code.\n   *\n   * @param {string} lang\n   * @return {string}\n   * @export\n   */\n  static getBase(lang) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const splitAt = lang.indexOf('-');\n    let major;\n\n    if (splitAt >= 0) {\n      major = lang.substring(0, splitAt);\n    } else {\n      major = lang;\n    }\n\n    // Convert the major code to lower case. It is standard for the major code\n    // to be in lower case, but it will also make the map look-up easier.\n    major = major.toLowerCase();\n    major = LanguageUtils.isoMap_.get(major) || major;\n\n    return major;\n  }\n\n  /**\n   * Get the normalized language of the given text stream. Will return 'und' if\n   * a language is not found on the text stream.\n   *\n   * This should always be used to get the language from a text stream.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {string}\n   * @export\n   */\n  static getLocaleForText(stream) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    goog.asserts.assert(\n        stream.type == ContentType.TEXT,\n        'Can only get language from text streams');\n\n    const language = stream.language || 'und';\n    return LanguageUtils.normalize(language);\n  }\n\n  /**\n   * Get the normalized locale for the given variant. This will look through\n   * the variant to find the locale that represents the content in the variant.\n   * This will return 'und' if no language can be found.\n   *\n   * This should always be used to get the locale from a variant.\n   *\n   * @param {shaka.extern.Variant} variant\n   * @return {string}\n   * @export\n   */\n  static getLocaleForVariant(variant) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Our preference order is:\n    //  1. Variant\n    //  2. Audio Stream\n    //  3. Video Stream\n    //\n    // We are going to consider all falsy strings to be invalid locales, this\n    // will include empty strings.\n    if (variant.language) {\n      return LanguageUtils.normalize(variant.language);\n    }\n\n    if (variant.audio && variant.audio.language) {\n      return LanguageUtils.normalize(variant.audio.language);\n    }\n\n    if (variant.video && variant.video.language) {\n      return LanguageUtils.normalize(variant.video.language);\n    }\n\n    // No language was found, but we still want to return a valid string.\n    return 'und';\n  }\n\n  /**\n   * Find the locale in |searchSpace| that comes closest to |target|. If no\n   * locale is found to be close to |target|, then |null| will be returned.\n   *\n   * @param {string} target\n   * @param {!Iterable.<string>} searchSpace\n   * @return {?string}\n   * @export\n   */\n  static findClosestLocale(target, searchSpace) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {string} */\n    const safeTarget = LanguageUtils.normalize(target);\n    /** @type {!Set.<string>} */\n    const safeSearchSpace = new Set();\n    for (const option of searchSpace) {\n      safeSearchSpace.add(LanguageUtils.normalize(option));\n    }\n\n    // Preference 1 - The option is an exact match. For example, \"en-US\" is an\n    //    exact match of \"en-US\". So if there is an option that is an exact\n    //    match, it would be the best match possible.\n    for (const option of safeSearchSpace) {\n      if (option == safeTarget) {\n        return option;\n      }\n    }\n\n    // Preference 2 - The option is the parent of the target. For example,\n    //    \"en\" is the parent of \"en-US\". So if there is an option with\n    //    \"en\", it should be good enough when our preference is \"en-US\".\n    for (const option of safeSearchSpace) {\n      if (LanguageUtils.isParentOf(option, safeTarget)) {\n        return option;\n      }\n    }\n\n    // Preference 3 - The option is a sibling of the target. For example,\n    //    \"en-US\" is a sibling of \"en-CA\". So if there is an option with\n    //    \"en_CA\", it should be good enough when our preference is \"en-US\".\n    for (const option of safeSearchSpace) {\n      if (LanguageUtils.isSiblingOf(option, safeTarget)) {\n        return option;\n      }\n    }\n\n    // Preference 4 - The option is a child of the target. For example,\n    //    \"en-US\" is the child of \"en\". SO it there is an option with\n    //    \"en-US\", it should be good enough when our preference is \"en\".\n    for (const option of safeSearchSpace) {\n      if (LanguageUtils.isParentOf(safeTarget, option)) {\n        return option;\n      }\n    }\n\n    // Failed to find anything.\n    return null;\n  }\n\n  /**\n   * Take a locale string and break it into its component. Check that each\n   * component matches what we would expect internally for locales. This\n   * should ONLY be used to verify locales that have been normalized.\n   *\n   * @param {string} locale\n   * @return {!Array.<string>}\n   * @private\n   */\n  static disassembleLocale_(locale) {\n    const components = locale.split('-');\n\n    goog.asserts.assert(\n        components.length <= 2,\n        [\n          'Locales should not have more than 2 components. ',\n          locale,\n          ' has too many components.',\n        ].join());\n\n    return components;\n  }\n};\n\n\n/**\n * A map from 3-letter language codes (ISO 639-2) to 2-letter language codes\n * (ISO 639-1) for all languages which have both in the registry.\n *\n * @const {!Map.<string, string>}\n * @private\n */\nshaka.util.LanguageUtils.isoMap_ = new Map([\n  ['aar', 'aa'], ['abk', 'ab'], ['afr', 'af'], ['aka', 'ak'], ['alb', 'sq'],\n  ['amh', 'am'], ['ara', 'ar'], ['arg', 'an'], ['arm', 'hy'], ['asm', 'as'],\n  ['ava', 'av'], ['ave', 'ae'], ['aym', 'ay'], ['aze', 'az'], ['bak', 'ba'],\n  ['bam', 'bm'], ['baq', 'eu'], ['bel', 'be'], ['ben', 'bn'], ['bih', 'bh'],\n  ['bis', 'bi'], ['bod', 'bo'], ['bos', 'bs'], ['bre', 'br'], ['bul', 'bg'],\n  ['bur', 'my'], ['cat', 'ca'], ['ces', 'cs'], ['cha', 'ch'], ['che', 'ce'],\n  ['chi', 'zh'], ['chu', 'cu'], ['chv', 'cv'], ['cor', 'kw'], ['cos', 'co'],\n  ['cre', 'cr'], ['cym', 'cy'], ['cze', 'cs'], ['dan', 'da'], ['deu', 'de'],\n  ['div', 'dv'], ['dut', 'nl'], ['dzo', 'dz'], ['ell', 'el'], ['eng', 'en'],\n  ['epo', 'eo'], ['est', 'et'], ['eus', 'eu'], ['ewe', 'ee'], ['fao', 'fo'],\n  ['fas', 'fa'], ['fij', 'fj'], ['fin', 'fi'], ['fra', 'fr'], ['fre', 'fr'],\n  ['fry', 'fy'], ['ful', 'ff'], ['geo', 'ka'], ['ger', 'de'], ['gla', 'gd'],\n  ['gle', 'ga'], ['glg', 'gl'], ['glv', 'gv'], ['gre', 'el'], ['grn', 'gn'],\n  ['guj', 'gu'], ['hat', 'ht'], ['hau', 'ha'], ['heb', 'he'], ['her', 'hz'],\n  ['hin', 'hi'], ['hmo', 'ho'], ['hrv', 'hr'], ['hun', 'hu'], ['hye', 'hy'],\n  ['ibo', 'ig'], ['ice', 'is'], ['ido', 'io'], ['iii', 'ii'], ['iku', 'iu'],\n  ['ile', 'ie'], ['ina', 'ia'], ['ind', 'id'], ['ipk', 'ik'], ['isl', 'is'],\n  ['ita', 'it'], ['jav', 'jv'], ['jpn', 'ja'], ['kal', 'kl'], ['kan', 'kn'],\n  ['kas', 'ks'], ['kat', 'ka'], ['kau', 'kr'], ['kaz', 'kk'], ['khm', 'km'],\n  ['kik', 'ki'], ['kin', 'rw'], ['kir', 'ky'], ['kom', 'kv'], ['kon', 'kg'],\n  ['kor', 'ko'], ['kua', 'kj'], ['kur', 'ku'], ['lao', 'lo'], ['lat', 'la'],\n  ['lav', 'lv'], ['lim', 'li'], ['lin', 'ln'], ['lit', 'lt'], ['ltz', 'lb'],\n  ['lub', 'lu'], ['lug', 'lg'], ['mac', 'mk'], ['mah', 'mh'], ['mal', 'ml'],\n  ['mao', 'mi'], ['mar', 'mr'], ['may', 'ms'], ['mkd', 'mk'], ['mlg', 'mg'],\n  ['mlt', 'mt'], ['mon', 'mn'], ['mri', 'mi'], ['msa', 'ms'], ['mya', 'my'],\n  ['nau', 'na'], ['nav', 'nv'], ['nbl', 'nr'], ['nde', 'nd'], ['ndo', 'ng'],\n  ['nep', 'ne'], ['nld', 'nl'], ['nno', 'nn'], ['nob', 'nb'], ['nor', 'no'],\n  ['nya', 'ny'], ['oci', 'oc'], ['oji', 'oj'], ['ori', 'or'], ['orm', 'om'],\n  ['oss', 'os'], ['pan', 'pa'], ['per', 'fa'], ['pli', 'pi'], ['pol', 'pl'],\n  ['por', 'pt'], ['pus', 'ps'], ['que', 'qu'], ['roh', 'rm'], ['ron', 'ro'],\n  ['rum', 'ro'], ['run', 'rn'], ['rus', 'ru'], ['sag', 'sg'], ['san', 'sa'],\n  ['sin', 'si'], ['slk', 'sk'], ['slo', 'sk'], ['slv', 'sl'], ['sme', 'se'],\n  ['smo', 'sm'], ['sna', 'sn'], ['snd', 'sd'], ['som', 'so'], ['sot', 'st'],\n  ['spa', 'es'], ['sqi', 'sq'], ['srd', 'sc'], ['srp', 'sr'], ['ssw', 'ss'],\n  ['sun', 'su'], ['swa', 'sw'], ['swe', 'sv'], ['tah', 'ty'], ['tam', 'ta'],\n  ['tat', 'tt'], ['tel', 'te'], ['tgk', 'tg'], ['tgl', 'tl'], ['tha', 'th'],\n  ['tib', 'bo'], ['tir', 'ti'], ['ton', 'to'], ['tsn', 'tn'], ['tso', 'ts'],\n  ['tuk', 'tk'], ['tur', 'tr'], ['twi', 'tw'], ['uig', 'ug'], ['ukr', 'uk'],\n  ['urd', 'ur'], ['uzb', 'uz'], ['ven', 've'], ['vie', 'vi'], ['vol', 'vo'],\n  ['wel', 'cy'], ['wln', 'wa'], ['wol', 'wo'], ['xho', 'xh'], ['yid', 'yi'],\n  ['yor', 'yo'], ['zha', 'za'], ['zho', 'zh'], ['zul', 'zu'],\n]);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.MultiMap');\n\n\n/**\n * @summary A simple multimap template.\n * @template T\n */\nshaka.util.MultiMap = class {\n  /** */\n  constructor() {\n    /** @private {!Object.<string, !Array.<T>>} */\n    this.map_ = {};\n  }\n\n\n  /**\n   * Add a key, value pair to the map.\n   * @param {string} key\n   * @param {T} value\n   */\n  push(key, value) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (this.map_.hasOwnProperty(key)) {\n      this.map_[key].push(value);\n    } else {\n      this.map_[key] = [value];\n    }\n  }\n\n\n  /**\n   * Get a list of values by key.\n   * @param {string} key\n   * @return {Array.<T>} or null if no such key exists.\n   */\n  get(key) {\n    const list = this.map_[key];\n    // slice() clones the list so that it and the map can each be modified\n    // without affecting the other.\n    return list ? list.slice() : null;\n  }\n\n\n  /**\n   * Get a list of all values.\n   * @return {!Array.<T>}\n   */\n  getAll() {\n    const list = [];\n    for (const key in this.map_) {\n      list.push(...this.map_[key]);\n    }\n    return list;\n  }\n\n\n  /**\n   * Remove a specific value, if it exists.\n   * @param {string} key\n   * @param {T} value\n   */\n  remove(key, value) {\n    if (!(key in this.map_)) {\n      return;\n    }\n    this.map_[key] = this.map_[key].filter((i) => i != value);\n    if (this.map_[key].length == 0) {\n      // Delete the array if it's empty, so that |get| will reliably return null\n      // \"if no such key exists\", instead of sometimes returning an empty array.\n      delete this.map_[key];\n    }\n  }\n\n\n  /**\n   * Clear all keys and values from the multimap.\n   */\n  clear() {\n    this.map_ = {};\n  }\n\n\n  /**\n   * @param {function(string, !Array.<T>)} callback\n   */\n  forEach(callback) {\n    for (const key in this.map_) {\n      callback(key, this.map_[key]);\n    }\n  }\n\n  /**\n   * Returns the number of elements in the multimap.\n   * @return {number}\n   */\n  size() {\n    return Object.keys(this.map_).length;\n  }\n\n  /**\n   * Get a list of all the keys.\n   * @return {!Array.<string>}\n   */\n  keys() {\n    return Object.keys(this.map_);\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.StreamUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.MultiMap');\ngoog.require('shaka.util.Platform');\ngoog.requireType('shaka.media.DrmEngine');\n\n\n/**\n * @summary A set of utility functions for dealing with Streams and Manifests.\n */\nshaka.util.StreamUtils = class {\n  /**\n   * In case of multiple usable codecs, choose one based on lowest average\n   * bandwidth and filter out the rest.\n   * Also filters out variants that have too many audio channels.\n   * @param {!shaka.extern.Manifest} manifest\n   * @param {!Array.<string>} preferredVideoCodecs\n   * @param {!Array.<string>} preferredAudioCodecs\n   * @param {number} preferredAudioChannelCount\n   * @param {!Array.<string>} preferredDecodingAttributes\n   */\n  static chooseCodecsAndFilterManifest(manifest, preferredVideoCodecs,\n      preferredAudioCodecs, preferredAudioChannelCount,\n      preferredDecodingAttributes) {\n    const StreamUtils = shaka.util.StreamUtils;\n\n    let variants = manifest.variants;\n    // To start, choose the codecs based on configured preferences if available.\n    if (preferredVideoCodecs.length || preferredAudioCodecs.length) {\n      variants = StreamUtils.choosePreferredCodecs(variants,\n          preferredVideoCodecs, preferredAudioCodecs);\n    }\n\n    // Consider a subset of variants based on audio channel\n    // preferences.\n    // For some content (#1013), surround-sound variants will use a different\n    // codec than stereo variants, so it is important to choose codecs **after**\n    // considering the audio channel config.\n    variants = StreamUtils.filterVariantsByAudioChannelCount(\n        variants, preferredAudioChannelCount);\n\n    // Now organize variants into buckets by codecs.\n    /** @type {!shaka.util.MultiMap.<shaka.extern.Variant>} */\n    let variantsByCodecs = StreamUtils.getVariantsByCodecs_(variants);\n    variantsByCodecs = StreamUtils.filterVariantsByDensity_(variantsByCodecs);\n\n    const bestCodecs = StreamUtils.chooseCodecsByDecodingAttributes_(\n        variantsByCodecs, preferredDecodingAttributes);\n\n    // Filter out any variants that don't match, forcing AbrManager to choose\n    // from a single video codec and a single audio codec possible.\n    manifest.variants = manifest.variants.filter((variant) => {\n      const codecs = StreamUtils.getVariantCodecs_(variant);\n      if (codecs == bestCodecs) {\n        return true;\n      }\n\n      shaka.log.debug('Dropping Variant (better codec available)', variant);\n      return false;\n    });\n  }\n\n  /**\n  * Get variants by codecs.\n  *\n  * @param {!Array<shaka.extern.Variant>} variants\n  * @return {!shaka.util.MultiMap.<shaka.extern.Variant>}\n  * @private\n  */\n  static getVariantsByCodecs_(variants) {\n    const variantsByCodecs = new shaka.util.MultiMap();\n    for (const variant of variants) {\n      const variantCodecs = shaka.util.StreamUtils.getVariantCodecs_(variant);\n      variantsByCodecs.push(variantCodecs, variant);\n    }\n\n    return variantsByCodecs;\n  }\n\n  /**\n  * Filters variants by density.\n  * Get variants by codecs map with the max density where all codecs are\n  * present.\n  *\n  * @param {!shaka.util.MultiMap.<shaka.extern.Variant>} variantsByCodecs\n  * @return {!shaka.util.MultiMap.<shaka.extern.Variant>}\n  * @private\n  */\n  static filterVariantsByDensity_(variantsByCodecs) {\n    let maxDensity = 0;\n    const codecGroupsByDensity = new Map();\n    const countCodecs = variantsByCodecs.size();\n\n    variantsByCodecs.forEach((codecs, variants) => {\n      for (const variant of variants) {\n        const video = variant.video;\n        if (!video || !video.width || !video.height) {\n          continue;\n        }\n\n        const density = video.width * video.height * (video.frameRate || 1);\n        if (!codecGroupsByDensity.has(density)) {\n          codecGroupsByDensity.set(density, new shaka.util.MultiMap());\n        }\n\n        /** @type {!shaka.util.MultiMap.<shaka.extern.Variant>} */\n        const group = codecGroupsByDensity.get(density);\n        group.push(codecs, variant);\n\n        // We want to look at the groups in which all codecs are present.\n        // Take the max density from those groups where all codecs are present.\n        // Later, we will compare bandwidth numbers only within this group.\n        // Effectively, only the bandwidth differences in the highest-res and\n        // highest-framerate content will matter in choosing a codec.\n        if (group.size() === countCodecs) {\n          maxDensity = Math.max(maxDensity, density);\n        }\n      }\n    });\n\n    return maxDensity ? codecGroupsByDensity.get(maxDensity) : variantsByCodecs;\n  }\n\n  /**\n   * Choose the codecs by configured preferred audio and video codecs.\n   *\n   * @param {!Array<shaka.extern.Variant>} variants\n   * @param {!Array.<string>} preferredVideoCodecs\n   * @param {!Array.<string>} preferredAudioCodecs\n   * @return {!Array<shaka.extern.Variant>}\n   */\n  static choosePreferredCodecs(variants, preferredVideoCodecs,\n      preferredAudioCodecs) {\n    let subset = variants;\n    for (const videoCodec of preferredVideoCodecs) {\n      const filtered = subset.filter((variant) => {\n        return variant.video && variant.video.codecs.startsWith(videoCodec);\n      });\n      if (filtered.length) {\n        subset = filtered;\n        break;\n      }\n    }\n\n    for (const audioCodec of preferredAudioCodecs) {\n      const filtered = subset.filter((variant) => {\n        return variant.audio && variant.audio.codecs.startsWith(audioCodec);\n      });\n      if (filtered.length) {\n        subset = filtered;\n        break;\n      }\n    }\n    return subset;\n  }\n\n  /**\n   * Choose the codecs by configured preferred decoding attributes.\n   *\n   * @param {!shaka.util.MultiMap.<shaka.extern.Variant>} variantsByCodecs\n   * @param {!Array.<string>} attributes\n   * @return {string}\n   * @private\n   */\n  static chooseCodecsByDecodingAttributes_(variantsByCodecs, attributes) {\n    const StreamUtils = shaka.util.StreamUtils;\n\n    for (const attribute of attributes) {\n      if (attribute == StreamUtils.DecodingAttributes.SMOOTH ||\n          attribute == StreamUtils.DecodingAttributes.POWER) {\n        variantsByCodecs = StreamUtils.chooseCodecsByMediaCapabilitiesInfo_(\n            variantsByCodecs, attribute);\n        // If we only have one smooth or powerEfficient codecs, choose it as the\n        // best codecs.\n        if (variantsByCodecs.size() == 1) {\n          return variantsByCodecs.keys()[0];\n        }\n      } else if (attribute == StreamUtils.DecodingAttributes.BANDWIDTH) {\n        return StreamUtils.findCodecsByLowestBandwidth_(variantsByCodecs);\n      }\n    }\n    // If there's no configured decoding preferences, or we have multiple codecs\n    // that meets the configured decoding preferences, choose the one with\n    // the lowest bandwidth.\n    return StreamUtils.findCodecsByLowestBandwidth_(variantsByCodecs);\n  }\n\n  /**\n   * Choose the best codecs by configured preferred MediaCapabilitiesInfo\n   * attributes.\n   *\n   * @param {!shaka.util.MultiMap.<shaka.extern.Variant>} variantsByCodecs\n   * @param {string} attribute\n   * @return {!shaka.util.MultiMap.<shaka.extern.Variant>}\n   * @private\n   */\n  static chooseCodecsByMediaCapabilitiesInfo_(variantsByCodecs, attribute) {\n    let highestScore = 0;\n    const bestVariantsByCodecs = new shaka.util.MultiMap();\n    variantsByCodecs.forEach((codecs, variants) => {\n      let sum = 0;\n      let num = 0;\n\n      for (const variant of variants) {\n        if (variant.decodingInfos.length) {\n          sum += variant.decodingInfos[0][attribute] ? 1 : 0;\n          num++;\n        }\n      }\n\n      const averageScore = sum / num;\n      shaka.log.debug('codecs', codecs, 'avg', attribute, averageScore);\n\n      if (averageScore > highestScore) {\n        bestVariantsByCodecs.clear();\n        bestVariantsByCodecs.push(codecs, variants);\n        highestScore = averageScore;\n      } else if (averageScore == highestScore) {\n        bestVariantsByCodecs.push(codecs, variants);\n      }\n    });\n    return bestVariantsByCodecs;\n  }\n\n  /**\n   * Find the lowest-bandwidth (best) codecs.\n   * Compute the average bandwidth for each group of variants.\n   *\n   * @param {!shaka.util.MultiMap.<shaka.extern.Variant>} variantsByCodecs\n   * @return {string}\n   * @private\n   */\n  static findCodecsByLowestBandwidth_(variantsByCodecs) {\n    let bestCodecs = '';\n    let lowestAverageBandwidth = Infinity;\n\n    variantsByCodecs.forEach((codecs, variants) => {\n      let sum = 0;\n      let num = 0;\n      for (const variant of variants) {\n        sum += variant.bandwidth || 0;\n        ++num;\n      }\n\n      const averageBandwidth = sum / num;\n      shaka.log.debug('codecs', codecs, 'avg bandwidth', averageBandwidth);\n\n      if (averageBandwidth < lowestAverageBandwidth) {\n        bestCodecs = codecs;\n        lowestAverageBandwidth = averageBandwidth;\n      }\n    });\n\n    goog.asserts.assert(bestCodecs !== '', 'Should have chosen codecs!');\n    goog.asserts.assert(!isNaN(lowestAverageBandwidth),\n        'Bandwidth should be a number!');\n\n    return bestCodecs;\n  }\n\n  /**\n   * Get a string representing all codecs used in a variant.\n   *\n   * @param {!shaka.extern.Variant} variant\n   * @return {string}\n   * @private\n   */\n  static getVariantCodecs_(variant) {\n    // Only consider the base of the codec string.  For example, these should\n    // both be considered the same codec: avc1.42c01e, avc1.4d401f\n    let baseVideoCodec = '';\n    if (variant.video) {\n      baseVideoCodec =\n        shaka.util.MimeUtils.getNormalizedCodec(variant.video.codecs);\n    }\n\n    let baseAudioCodec = '';\n    if (variant.audio) {\n      baseAudioCodec =\n        shaka.util.MimeUtils.getNormalizedCodec(variant.audio.codecs);\n    }\n\n    return baseVideoCodec + '-' + baseAudioCodec;\n  }\n\n  /**\n   * Filter the variants in |manifest| to only include the variants that meet\n   * the given restrictions.\n   *\n   * @param {!shaka.extern.Manifest} manifest\n   * @param {shaka.extern.Restrictions} restrictions\n   * @param {{width: number, height:number}} maxHwResolution\n   */\n  static filterByRestrictions(manifest, restrictions, maxHwResolution) {\n    manifest.variants = manifest.variants.filter((variant) => {\n      return shaka.util.StreamUtils.meetsRestrictions(\n          variant, restrictions, maxHwResolution);\n    });\n  }\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @param {shaka.extern.Restrictions} restrictions\n   *   Configured restrictions from the user.\n   * @param {{width: number, height: number}} maxHwRes\n   *   The maximum resolution the hardware can handle.\n   *   This is applied separately from user restrictions because the setting\n   *   should not be easily replaced by the user's configuration.\n   * @return {boolean}\n   */\n  static meetsRestrictions(variant, restrictions, maxHwRes) {\n    /** @type {function(number, number, number):boolean} */\n    const inRange = (x, min, max) => {\n      return x >= min && x <= max;\n    };\n\n    const video = variant.video;\n\n    // |video.width| and |video.height| can be undefined, which breaks\n    // the math, so make sure they are there first.\n    if (video && video.width && video.height) {\n      if (!inRange(video.width,\n          restrictions.minWidth,\n          Math.min(restrictions.maxWidth, maxHwRes.width))) {\n        return false;\n      }\n\n      if (!inRange(video.height,\n          restrictions.minHeight,\n          Math.min(restrictions.maxHeight, maxHwRes.height))) {\n        return false;\n      }\n\n      if (!inRange(video.width * video.height,\n          restrictions.minPixels,\n          restrictions.maxPixels)) {\n        return false;\n      }\n    }\n\n    // |variant.frameRate| can be undefined, which breaks\n    // the math, so make sure they are there first.\n    if (variant && variant.video && variant.video.frameRate) {\n      if (!inRange(variant.video.frameRate,\n          restrictions.minFrameRate,\n          restrictions.maxFrameRate)) {\n        return false;\n      }\n    }\n\n    if (!inRange(variant.bandwidth,\n        restrictions.minBandwidth,\n        restrictions.maxBandwidth)) {\n      return false;\n    }\n\n    return true;\n  }\n\n\n  /**\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {shaka.extern.Restrictions} restrictions\n   * @param {{width: number, height: number}} maxHwRes\n   * @return {boolean} Whether the tracks changed.\n   */\n  static applyRestrictions(variants, restrictions, maxHwRes) {\n    let tracksChanged = false;\n\n    for (const variant of variants) {\n      const originalAllowed = variant.allowedByApplication;\n      variant.allowedByApplication = shaka.util.StreamUtils.meetsRestrictions(\n          variant, restrictions, maxHwRes);\n\n      if (originalAllowed != variant.allowedByApplication) {\n        tracksChanged = true;\n      }\n    }\n\n    return tracksChanged;\n  }\n\n\n  /**\n   * Alters the given Manifest to filter out any unplayable streams.\n   *\n   * @param {shaka.media.DrmEngine} drmEngine\n   * @param {?shaka.extern.Variant} currentVariant\n   * @param {shaka.extern.Manifest} manifest\n   */\n  static async filterManifest(\n      drmEngine, currentVariant, manifest) {\n    await shaka.util.StreamUtils.filterManifestByMediaCapabilities(manifest,\n        manifest.offlineSessionIds.length > 0);\n    shaka.util.StreamUtils.filterManifestByCurrentVariant(\n        currentVariant, manifest);\n    shaka.util.StreamUtils.filterTextStreams_(manifest);\n    shaka.util.StreamUtils.filterImageStreams_(manifest);\n  }\n\n\n  /**\n   * Alters the given Manifest to filter out any streams unsupported by the\n   * platform via MediaCapabilities.decodingInfo() API.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @param {boolean} usePersistentLicenses\n   */\n  static async filterManifestByMediaCapabilities(\n      manifest, usePersistentLicenses) {\n    goog.asserts.assert(navigator.mediaCapabilities,\n        'MediaCapabilities should be valid.');\n\n    await shaka.util.StreamUtils.getDecodingInfosForVariants(\n        manifest.variants, usePersistentLicenses, /* srcEquals= */ false);\n    manifest.variants = manifest.variants.filter((variant) => {\n      // See: https://github.com/shaka-project/shaka-player/issues/3860\n      const video = variant.video;\n      const ContentType = shaka.util.ManifestParserUtils.ContentType;\n      if (video) {\n        let videoCodecs =\n            shaka.util.StreamUtils.getCorrectVideoCodecs_(video.codecs);\n        // For multiplexed streams. Here we must check the audio of the\n        // stream to see if it is compatible.\n        if (video.codecs.includes(',')) {\n          const allCodecs = video.codecs.split(',');\n          videoCodecs = shaka.util.ManifestParserUtils.guessCodecs(\n              ContentType.VIDEO, allCodecs);\n          videoCodecs =\n              shaka.util.StreamUtils.getCorrectVideoCodecs_(videoCodecs);\n          let audioCodecs = shaka.util.ManifestParserUtils.guessCodecs(\n              ContentType.AUDIO, allCodecs);\n          audioCodecs =\n              shaka.util.StreamUtils.getCorrectAudioCodecs_(audioCodecs);\n          const audioFullType = shaka.util.MimeUtils.getFullOrConvertedType(\n              video.mimeType, audioCodecs, ContentType.AUDIO);\n          if (!MediaSource.isTypeSupported(audioFullType)) {\n            return false;\n          }\n          // Update the codec string with the (possibly) converted codecs.\n          videoCodecs = [videoCodecs, audioCodecs].join(',');\n        }\n        const fullType = shaka.util.MimeUtils.getFullOrConvertedType(\n            video.mimeType, videoCodecs, ContentType.VIDEO);\n        if (!MediaSource.isTypeSupported(fullType)) {\n          return false;\n        }\n        // Update the codec string with the (possibly) converted codecs.\n        video.codecs = videoCodecs;\n      }\n      const audio = variant.audio;\n      if (audio) {\n        const codecs =\n            shaka.util.StreamUtils.getCorrectAudioCodecs_(audio.codecs);\n        const fullType = shaka.util.MimeUtils.getFullOrConvertedType(\n            audio.mimeType, codecs, ContentType.AUDIO);\n        if (!MediaSource.isTypeSupported(fullType)) {\n          return false;\n        }\n        // Update the codec string with the (possibly) converted codecs.\n        audio.codecs = codecs;\n      }\n\n      // See: https://github.com/shaka-project/shaka-player/issues/3380\n      if (shaka.util.Platform.isXboxOne() && video &&\n          ((video.width && video.width > 1920) ||\n          (video.height && video.height > 1080)) &&\n          (video.codecs.includes('avc1.') ||\n          video.codecs.includes('avc3.'))) {\n        shaka.log.debug('Dropping variant - not compatible with platform',\n            shaka.util.StreamUtils.getVariantSummaryString_(variant));\n        return false;\n      }\n\n      const supported = variant.decodingInfos.some((decodingInfo) => {\n        return decodingInfo.supported;\n      });\n      // Filter out all unsupported variants.\n      if (!supported) {\n        shaka.log.debug('Dropping variant - not compatible with platform',\n            shaka.util.StreamUtils.getVariantSummaryString_(variant));\n      }\n      return supported;\n    });\n  }\n\n\n  /**\n   * Get the decodingInfo results of the variants via MediaCapabilities.\n   * This should be called after the DrmEngine is created and configured, and\n   * before DrmEngine sets the mediaKeys.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {boolean} usePersistentLicenses\n   * @param {boolean} srcEquals\n   * @exportDoc\n   */\n  static async getDecodingInfosForVariants(variants, usePersistentLicenses,\n      srcEquals) {\n    const gotDecodingInfo = variants.some((variant) =>\n      variant.decodingInfos.length);\n    if (gotDecodingInfo) {\n      shaka.log.debug('Already got the variants\\' decodingInfo.');\n      return;\n    }\n\n    const mediaCapabilities = navigator.mediaCapabilities;\n\n    const operations = [];\n    const getVariantDecodingInfos = (async (variant, decodingConfig) => {\n      try {\n        const result = await mediaCapabilities.decodingInfo(decodingConfig);\n        variant.decodingInfos.push(result);\n      } catch (e) {\n        shaka.log.info('MediaCapabilities.decodingInfo() failed.',\n            JSON.stringify(decodingConfig), e);\n      }\n    });\n\n    for (const variant of variants) {\n      /** @type {!Array.<!MediaDecodingConfiguration>} */\n      const decodingConfigs = shaka.util.StreamUtils.getDecodingConfigs_(\n          variant, usePersistentLicenses, srcEquals);\n\n      for (const config of decodingConfigs) {\n        operations.push(getVariantDecodingInfos(variant, config));\n      }\n    }\n    await Promise.all(operations);\n  }\n\n\n  /**\n   * Generate a MediaDecodingConfiguration object to get the decodingInfo\n   * results for each variant.\n   * @param {!shaka.extern.Variant} variant\n   * @param {boolean} usePersistentLicenses\n   * @param {boolean} srcEquals\n   * @return {!Array.<!MediaDecodingConfiguration>}\n   * @private\n   */\n  static getDecodingConfigs_(variant, usePersistentLicenses, srcEquals) {\n    const audio = variant.audio;\n    const video = variant.video;\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    /** @type {!MediaDecodingConfiguration} */\n    const mediaDecodingConfig = {\n      type: srcEquals ? 'file' : 'media-source',\n    };\n\n    if (video) {\n      let videoCodecs = video.codecs;\n      // For multiplexed streams with audio+video codecs, the config should have\n      // AudioConfiguration and VideoConfiguration.\n      if (video.codecs.includes(',')) {\n        const allCodecs = video.codecs.split(',');\n        videoCodecs = shaka.util.ManifestParserUtils.guessCodecs(\n            ContentType.VIDEO, allCodecs);\n        videoCodecs =\n            shaka.util.StreamUtils.getCorrectVideoCodecs_(videoCodecs);\n        const audioCodecs = shaka.util.ManifestParserUtils.guessCodecs(\n            ContentType.AUDIO, allCodecs);\n\n        const audioFullType = shaka.util.MimeUtils.getFullOrConvertedType(\n            video.mimeType, audioCodecs, ContentType.AUDIO);\n        mediaDecodingConfig.audio = {\n          contentType: audioFullType,\n          channels: 2,\n          bitrate: variant.bandwidth || 1,\n          samplerate: 1,\n          spatialRendering: false,\n        };\n      }\n      videoCodecs = shaka.util.StreamUtils.getCorrectVideoCodecs_(videoCodecs);\n      const fullType = shaka.util.MimeUtils.getFullOrConvertedType(\n          video.mimeType, videoCodecs, ContentType.VIDEO);\n      // VideoConfiguration\n      mediaDecodingConfig.video = {\n        contentType: fullType,\n\n        // NOTE: Some decoders strictly check the width and height fields and\n        // won't decode smaller than 64x64.  So if we don't have this info (as\n        // is the case in some of our simpler tests), assume a 64x64 resolution\n        // to fill in this required field for MediaCapabilities.\n        //\n        // This became an issue specifically on Firefox on M1 Macs.\n        width: video.width || 64,\n        height: video.height || 64,\n\n        bitrate: video.bandwidth || variant.bandwidth || 1,\n        // framerate must be greater than 0, otherwise the config is invalid.\n        framerate: video.frameRate || 1,\n      };\n      if (video.hdr) {\n        switch (video.hdr) {\n          case 'SDR':\n            mediaDecodingConfig.video.transferFunction = 'srgb';\n            break;\n          case 'PQ':\n            mediaDecodingConfig.video.transferFunction = 'pq';\n            break;\n          case 'HLG':\n            mediaDecodingConfig.video.transferFunction = 'hlg';\n            break;\n        }\n      }\n    }\n    if (audio) {\n      const codecs =\n          shaka.util.StreamUtils.getCorrectAudioCodecs_(audio.codecs);\n      const fullType = shaka.util.MimeUtils.getFullOrConvertedType(\n          audio.mimeType, codecs, ContentType.AUDIO);\n\n      // AudioConfiguration\n      mediaDecodingConfig.audio = {\n        contentType: fullType,\n        channels: audio.channelsCount || 2,\n        bitrate: audio.bandwidth || variant.bandwidth || 1,\n        samplerate: audio.audioSamplingRate || 1,\n        spatialRendering: audio.spatialAudio,\n      };\n    }\n\n    const videoDrmInfos = variant.video ? variant.video.drmInfos : [];\n    const audioDrmInfos = variant.audio ? variant.audio.drmInfos : [];\n    const allDrmInfos = videoDrmInfos.concat(audioDrmInfos);\n\n    // Return a list containing the mediaDecodingConfig for unencrypted variant.\n    if (!allDrmInfos.length) {\n      return [mediaDecodingConfig];\n    }\n\n    // A list of MediaDecodingConfiguration objects created for the variant.\n    const configs = [];\n\n    // Get all the drm info so that we can avoid using nested loops when we\n    // just need the drm info.\n    const drmInfoByKeySystems = new Map();\n    for (const info of allDrmInfos) {\n      if (!drmInfoByKeySystems.get(info.keySystem)) {\n        drmInfoByKeySystems.set(info.keySystem, []);\n      }\n      drmInfoByKeySystems.get(info.keySystem).push(info);\n    }\n\n    const persistentState =\n        usePersistentLicenses ? 'required' : 'optional';\n    const sessionTypes =\n        usePersistentLicenses ? ['persistent-license'] : ['temporary'];\n\n    for (const keySystem of drmInfoByKeySystems.keys()) {\n      // Create a copy of the mediaDecodingConfig.\n      const config = /** @type {!MediaDecodingConfiguration} */\n          (Object.assign({}, mediaDecodingConfig));\n\n      const drmInfos = drmInfoByKeySystems.get(keySystem);\n\n      /** @type {!MediaCapabilitiesKeySystemConfiguration} */\n      const keySystemConfig = {\n        keySystem: keySystem,\n        initDataType: 'cenc',\n        persistentState: persistentState,\n        distinctiveIdentifier: 'optional',\n        sessionTypes: sessionTypes,\n      };\n\n      for (const info of drmInfos) {\n        if (info.initData && info.initData.length) {\n          const initDataTypes = new Set();\n          for (const initData of info.initData) {\n            initDataTypes.add(initData.initDataType);\n          }\n          if (initDataTypes.size > 1) {\n            shaka.log.v2('DrmInfo contains more than one initDataType,',\n                'and we use the initDataType of the first initData.',\n                info);\n          }\n          keySystemConfig.initDataType = info.initData[0].initDataType;\n        }\n\n        if (info.distinctiveIdentifierRequired) {\n          keySystemConfig.distinctiveIdentifier = 'required';\n        }\n        if (info.persistentStateRequired) {\n          keySystemConfig.persistentState = 'required';\n        }\n        if (info.sessionType) {\n          keySystemConfig.sessionTypes = [info.sessionType];\n        }\n\n        if (audio) {\n          // See: https://github.com/shaka-project/shaka-player/issues/4659\n          if (info.audioRobustness != '') {\n            if (!keySystemConfig.audio) {\n              // KeySystemTrackConfiguration\n              keySystemConfig.audio = {\n                robustness: info.audioRobustness,\n              };\n            } else {\n              keySystemConfig.audio.robustness =\n                  keySystemConfig.audio.robustness || info.audioRobustness;\n            }\n          } else if (!keySystemConfig.audio) {\n            // KeySystemTrackConfiguration\n            keySystemConfig.audio = {};\n          }\n        }\n\n        if (video) {\n          // See: https://github.com/shaka-project/shaka-player/issues/4659\n          if (info.videoRobustness != '') {\n            if (!keySystemConfig.video) {\n              // KeySystemTrackConfiguration\n              keySystemConfig.video = {\n                robustness: info.videoRobustness,\n              };\n            } else {\n              keySystemConfig.video.robustness =\n                  keySystemConfig.video.robustness || info.videoRobustness;\n            }\n          } else if (!keySystemConfig.video) {\n            // KeySystemTrackConfiguration\n            keySystemConfig.video = {};\n          }\n        }\n      }\n      config.keySystemConfiguration = keySystemConfig;\n      configs.push(config);\n    }\n    return configs;\n  }\n\n\n  /**\n   * Generates the correct audio codec for MediaDecodingConfiguration and\n   * for MediaSource.isTypeSupported.\n   * @param {string} codecs\n   * @return {string}\n   * @private\n   */\n  static getCorrectAudioCodecs_(codecs) {\n    // Some Tizen devices seem to misreport AC-3 support, but correctly\n    // report EC-3 support.  So query EC-3 as a fallback for AC-3.\n    // See https://github.com/shaka-project/shaka-player/issues/2989 for\n    // details.\n    if (shaka.util.Platform.isTizen()) {\n      return codecs.toLowerCase() == 'ac-3' ? 'ec-3' : codecs;\n    } else {\n      return codecs;\n    }\n  }\n\n\n  /**\n   * Generates the correct video codec for MediaDecodingConfiguration and\n   * for MediaSource.isTypeSupported.\n   * @param {string} codec\n   * @return {string}\n   * @private\n   */\n  static getCorrectVideoCodecs_(codec) {\n    if (codec.includes('avc1')) {\n      // Convert avc1 codec string from RFC-4281 to RFC-6381 for\n      // MediaSource.isTypeSupported\n      // Example, convert avc1.66.30 to avc1.42001e (0x42 == 66 and 0x1e == 30)\n      const avcdata = codec.split('.');\n      if (avcdata.length == 3) {\n        let result = avcdata.shift() + '.';\n        result += parseInt(avcdata.shift(), 10).toString(16);\n        result +=\n            ('000' + parseInt(avcdata.shift(), 10).toString(16)).slice(-4);\n        return result;\n      }\n    } else if (codec == 'vp9') {\n      // MediaCapabilities supports 'vp09...' codecs, but not 'vp9'. Translate\n      // vp9 codec strings into 'vp09...', to allow such content to play with\n      // mediaCapabilities enabled.\n      // This means profile 0, level 4.1, 8-bit color.  This supports 1080p @\n      // 60Hz.  See https://en.wikipedia.org/wiki/VP9#Levels\n      //\n      // If we don't have more detailed codec info, assume this profile and\n      // level because it's high enough to likely accommodate the parameters we\n      // do have, such as width and height.  If an implementation is checking\n      // the profile and level very strictly, we want older VP9 content to\n      // still work to some degree.  But we don't want to set a level so high\n      // that it is rejected by a hardware decoder that can't handle the\n      // maximum requirements of the level.\n      //\n      // This became an issue specifically on Firefox on M1 Macs.\n      return 'vp09.00.41.08';\n    }\n    return codec;\n  }\n\n\n  /**\n   * Alters the given Manifest to filter out any streams uncompatible with the\n   * current variant.\n   *\n   * @param {?shaka.extern.Variant} currentVariant\n   * @param {shaka.extern.Manifest} manifest\n   */\n  static filterManifestByCurrentVariant(currentVariant, manifest) {\n    const StreamUtils = shaka.util.StreamUtils;\n    manifest.variants = manifest.variants.filter((variant) => {\n      const audio = variant.audio;\n      const video = variant.video;\n      if (audio && currentVariant && currentVariant.audio) {\n        if (!StreamUtils.areStreamsCompatible_(audio, currentVariant.audio)) {\n          shaka.log.debug('Dropping variant - not compatible with active audio',\n              'active audio',\n              StreamUtils.getStreamSummaryString_(currentVariant.audio),\n              'variant.audio',\n              StreamUtils.getStreamSummaryString_(audio));\n          return false;\n        }\n      }\n\n      if (video && currentVariant && currentVariant.video) {\n        if (!StreamUtils.areStreamsCompatible_(video, currentVariant.video)) {\n          shaka.log.debug('Dropping variant - not compatible with active video',\n              'active video',\n              StreamUtils.getStreamSummaryString_(currentVariant.video),\n              'variant.video',\n              StreamUtils.getStreamSummaryString_(video));\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Alters the given Manifest to filter out any unsupported text streams.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @private\n   */\n  static filterTextStreams_(manifest) {\n    // Filter text streams.\n    manifest.textStreams = manifest.textStreams.filter((stream) => {\n      const fullMimeType = shaka.util.MimeUtils.getFullType(\n          stream.mimeType, stream.codecs);\n      const keep = shaka.text.TextEngine.isTypeSupported(fullMimeType);\n\n      if (!keep) {\n        shaka.log.debug('Dropping text stream. Is not supported by the ' +\n                        'platform.', stream);\n      }\n\n      return keep;\n    });\n  }\n\n\n  /**\n   * Alters the given Manifest to filter out any unsupported image streams.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @private\n   */\n  static filterImageStreams_(manifest) {\n    // Filter image streams.\n    manifest.imageStreams = manifest.imageStreams.filter((stream) => {\n      // TODO: re-examine this and avoid allow-listing the MIME types we can\n      // accept.\n      const validMimeTypes = [\n        'image/svg+xml',\n        'image/png',\n        'image/jpeg',\n      ];\n      const Platform = shaka.util.Platform;\n      // Add webp support to popular platforms that support it.\n      const webpSupport = Platform.isWebOS() ||\n                          Platform.isTizen() ||\n                          Platform.isChromecast();\n      if (webpSupport) {\n        validMimeTypes.push('image/webp');\n      }\n      // TODO: add support to image/webp and image/avif\n      const keep = validMimeTypes.includes(stream.mimeType);\n\n      if (!keep) {\n        shaka.log.debug('Dropping image stream. Is not supported by the ' +\n                        'platform.', stream);\n      }\n\n      return keep;\n    });\n  }\n\n\n  /**\n   * @param {shaka.extern.Stream} s0\n   * @param {shaka.extern.Stream} s1\n   * @return {boolean}\n   * @private\n   */\n  static areStreamsCompatible_(s0, s1) {\n    // Basic mime types and basic codecs need to match.\n    // For example, we can't adapt between WebM and MP4,\n    // nor can we adapt between mp4a.* to ec-3.\n    // We can switch between text types on the fly,\n    // so don't run this check on text.\n    if (s0.mimeType != s1.mimeType) {\n      return false;\n    }\n\n    if (s0.codecs.split('.')[0] != s1.codecs.split('.')[0]) {\n      return false;\n    }\n\n    return true;\n  }\n\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @return {shaka.extern.Track}\n   */\n  static variantToTrack(variant) {\n    /** @type {?shaka.extern.Stream} */\n    const audio = variant.audio;\n    /** @type {?shaka.extern.Stream} */\n    const video = variant.video;\n\n    /** @type {?string} */\n    const audioCodec = audio ? audio.codecs : null;\n    /** @type {?string} */\n    const videoCodec = video ? video.codecs : null;\n\n    /** @type {!Array.<string>} */\n    const codecs = [];\n    if (videoCodec) {\n      codecs.push(videoCodec);\n    }\n    if (audioCodec) {\n      codecs.push(audioCodec);\n    }\n\n    /** @type {!Array.<string>} */\n    const mimeTypes = [];\n    if (video) {\n      mimeTypes.push(video.mimeType);\n    }\n    if (audio) {\n      mimeTypes.push(audio.mimeType);\n    }\n    /** @type {?string} */\n    const mimeType = mimeTypes[0] || null;\n\n    /** @type {!Array.<string>} */\n    const kinds = [];\n    if (audio) {\n      kinds.push(audio.kind);\n    }\n    if (video) {\n      kinds.push(video.kind);\n    }\n    /** @type {?string} */\n    const kind = kinds[0] || null;\n\n    /** @type {!Set.<string>} */\n    const roles = new Set();\n    if (audio) {\n      for (const role of audio.roles) {\n        roles.add(role);\n      }\n    }\n    if (video) {\n      for (const role of video.roles) {\n        roles.add(role);\n      }\n    }\n\n    /** @type {shaka.extern.Track} */\n    const track = {\n      id: variant.id,\n      active: false,\n      type: 'variant',\n      bandwidth: variant.bandwidth,\n      language: variant.language,\n      label: null,\n      kind: kind,\n      width: null,\n      height: null,\n      frameRate: null,\n      pixelAspectRatio: null,\n      hdr: null,\n      mimeType: mimeType,\n      codecs: codecs.join(', '),\n      audioCodec: audioCodec,\n      videoCodec: videoCodec,\n      primary: variant.primary,\n      roles: Array.from(roles),\n      audioRoles: null,\n      forced: false,\n      videoId: null,\n      audioId: null,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      tilesLayout: null,\n      audioBandwidth: null,\n      videoBandwidth: null,\n      originalVideoId: null,\n      originalAudioId: null,\n      originalTextId: null,\n      originalImageId: null,\n    };\n\n    if (video) {\n      track.videoId = video.id;\n      track.originalVideoId = video.originalId;\n      track.width = video.width || null;\n      track.height = video.height || null;\n      track.frameRate = video.frameRate || null;\n      track.pixelAspectRatio = video.pixelAspectRatio || null;\n      track.videoBandwidth = video.bandwidth || null;\n    }\n\n    if (audio) {\n      track.audioId = audio.id;\n      track.originalAudioId = audio.originalId;\n      track.channelsCount = audio.channelsCount;\n      track.audioSamplingRate = audio.audioSamplingRate;\n      track.audioBandwidth = audio.bandwidth || null;\n      track.spatialAudio = audio.spatialAudio;\n      track.label = audio.label;\n      track.audioRoles = audio.roles;\n    }\n\n    return track;\n  }\n\n\n  /**\n   * @param {shaka.extern.Stream} stream\n   * @return {shaka.extern.Track}\n   */\n  static textStreamToTrack(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    /** @type {shaka.extern.Track} */\n    const track = {\n      id: stream.id,\n      active: false,\n      type: ContentType.TEXT,\n      bandwidth: 0,\n      language: stream.language,\n      label: stream.label,\n      kind: stream.kind || null,\n      width: null,\n      height: null,\n      frameRate: null,\n      pixelAspectRatio: null,\n      hdr: null,\n      mimeType: stream.mimeType,\n      codecs: stream.codecs || null,\n      audioCodec: null,\n      videoCodec: null,\n      primary: stream.primary,\n      roles: stream.roles,\n      audioRoles: null,\n      forced: stream.forced,\n      videoId: null,\n      audioId: null,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      tilesLayout: null,\n      audioBandwidth: null,\n      videoBandwidth: null,\n      originalVideoId: null,\n      originalAudioId: null,\n      originalTextId: stream.originalId,\n      originalImageId: null,\n    };\n\n    return track;\n  }\n\n\n  /**\n   * @param {shaka.extern.Stream} stream\n   * @return {shaka.extern.Track}\n   */\n  static imageStreamToTrack(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    let width = stream.width || null;\n    let height = stream.height || null;\n\n    // The stream width and height represent the size of the entire thumbnail\n    // sheet, so divide by the layout.\n    let reference = null;\n    // Note: segmentIndex is built by default for HLS, but not for DASH, but\n    // in DASH this information comes at the stream level and not at the\n    // segment level.\n    if (stream.segmentIndex) {\n      reference = stream.segmentIndex.get(0);\n    }\n    let layout = stream.tilesLayout;\n    if (reference) {\n      layout = reference.getTilesLayout() || layout;\n    }\n    if (layout && width != null) {\n      width /= Number(layout.split('x')[0]);\n    }\n    if (layout && height != null) {\n      height /= Number(layout.split('x')[1]);\n    }\n    // TODO: What happens if there are multiple grids, with different\n    // layout sizes, inside this image stream?\n\n    /** @type {shaka.extern.Track} */\n    const track = {\n      id: stream.id,\n      active: false,\n      type: ContentType.IMAGE,\n      bandwidth: stream.bandwidth || 0,\n      language: '',\n      label: null,\n      kind: null,\n      width,\n      height,\n      frameRate: null,\n      pixelAspectRatio: null,\n      hdr: null,\n      mimeType: stream.mimeType,\n      codecs: null,\n      audioCodec: null,\n      videoCodec: null,\n      primary: false,\n      roles: [],\n      audioRoles: null,\n      forced: false,\n      videoId: null,\n      audioId: null,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      tilesLayout: layout || null,\n      audioBandwidth: null,\n      videoBandwidth: null,\n      originalVideoId: null,\n      originalAudioId: null,\n      originalTextId: null,\n      originalImageId: stream.originalId,\n    };\n\n    return track;\n  }\n\n\n  /**\n   * Generate and return an ID for this track, since the ID field is optional.\n   *\n   * @param {TextTrack|AudioTrack} html5Track\n   * @return {number} The generated ID.\n   */\n  static html5TrackId(html5Track) {\n    if (!html5Track['__shaka_id']) {\n      html5Track['__shaka_id'] = shaka.util.StreamUtils.nextTrackId_++;\n    }\n    return html5Track['__shaka_id'];\n  }\n\n\n  /**\n   * @param {TextTrack} textTrack\n   * @return {shaka.extern.Track}\n   */\n  static html5TextTrackToTrack(textTrack) {\n    const CLOSED_CAPTION_MIMETYPE =\n        shaka.util.MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE;\n    const StreamUtils = shaka.util.StreamUtils;\n\n    /** @type {shaka.extern.Track} */\n    const track = StreamUtils.html5TrackToGenericShakaTrack_(textTrack);\n    track.active = textTrack.mode != 'disabled';\n    track.type = 'text';\n    track.originalTextId = textTrack.id;\n    if (textTrack.kind == 'captions') {\n      track.mimeType = CLOSED_CAPTION_MIMETYPE;\n    }\n    if (textTrack.kind) {\n      track.roles = [textTrack.kind];\n    }\n    if (textTrack.kind == 'forced') {\n      track.forced = true;\n    }\n\n    return track;\n  }\n\n\n  /**\n   * @param {AudioTrack} audioTrack\n   * @return {shaka.extern.Track}\n   */\n  static html5AudioTrackToTrack(audioTrack) {\n    const StreamUtils = shaka.util.StreamUtils;\n\n    /** @type {shaka.extern.Track} */\n    const track = StreamUtils.html5TrackToGenericShakaTrack_(audioTrack);\n    track.active = audioTrack.enabled;\n    track.type = 'variant';\n    track.originalAudioId = audioTrack.id;\n\n    if (audioTrack.kind == 'main') {\n      track.primary = true;\n    }\n    if (audioTrack.kind) {\n      track.roles = [audioTrack.kind];\n      track.audioRoles = [audioTrack.kind];\n      track.label = audioTrack.label;\n    }\n\n    return track;\n  }\n\n\n  /**\n   * Creates a Track object with non-type specific fields filled out.  The\n   * caller is responsible for completing the Track object with any\n   * type-specific information (audio or text).\n   *\n   * @param {TextTrack|AudioTrack} html5Track\n   * @return {shaka.extern.Track}\n   * @private\n   */\n  static html5TrackToGenericShakaTrack_(html5Track) {\n    /** @type {shaka.extern.Track} */\n    const track = {\n      id: shaka.util.StreamUtils.html5TrackId(html5Track),\n      active: false,\n      type: '',\n      bandwidth: 0,\n      language: shaka.util.LanguageUtils.normalize(html5Track.language),\n      label: html5Track.label,\n      kind: html5Track.kind,\n      width: null,\n      height: null,\n      frameRate: null,\n      pixelAspectRatio: null,\n      hdr: null,\n      mimeType: null,\n      codecs: null,\n      audioCodec: null,\n      videoCodec: null,\n      primary: false,\n      roles: [],\n      forced: false,\n      audioRoles: null,\n      videoId: null,\n      audioId: null,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      tilesLayout: null,\n      audioBandwidth: null,\n      videoBandwidth: null,\n      originalVideoId: null,\n      originalAudioId: null,\n      originalTextId: null,\n      originalImageId: null,\n    };\n\n    return track;\n  }\n\n\n  /**\n   * Determines if the given variant is playable.\n   * @param {!shaka.extern.Variant} variant\n   * @return {boolean}\n   */\n  static isPlayable(variant) {\n    return variant.allowedByApplication && variant.allowedByKeySystem;\n  }\n\n\n  /**\n   * Filters out unplayable variants.\n   * @param {!Array.<!shaka.extern.Variant>} variants\n   * @return {!Array.<!shaka.extern.Variant>}\n   */\n  static getPlayableVariants(variants) {\n    return variants.filter((variant) => {\n      return shaka.util.StreamUtils.isPlayable(variant);\n    });\n  }\n\n\n  /**\n   * Filters variants according to the given audio channel count config.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {number} preferredAudioChannelCount\n   * @return {!Array.<!shaka.extern.Variant>}\n   */\n  static filterVariantsByAudioChannelCount(\n      variants, preferredAudioChannelCount) {\n    // Group variants by their audio channel counts.\n    const variantsWithChannelCounts =\n        variants.filter((v) => v.audio && v.audio.channelsCount);\n\n    /** @type {!Map.<number, !Array.<shaka.extern.Variant>>} */\n    const variantsByChannelCount = new Map();\n    for (const variant of variantsWithChannelCounts) {\n      const count = variant.audio.channelsCount;\n      goog.asserts.assert(count != null, 'Must have count after filtering!');\n      if (!variantsByChannelCount.has(count)) {\n        variantsByChannelCount.set(count, []);\n      }\n      variantsByChannelCount.get(count).push(variant);\n    }\n\n    /** @type {!Array.<number>} */\n    const channelCounts = Array.from(variantsByChannelCount.keys());\n\n    // If no variant has audio channel count info, return the original variants.\n    if (channelCounts.length == 0) {\n      return variants;\n    }\n\n    // Choose the variants with the largest number of audio channels less than\n    // or equal to the configured number of audio channels.\n    const countLessThanOrEqualtoConfig =\n        channelCounts.filter((count) => count <= preferredAudioChannelCount);\n    if (countLessThanOrEqualtoConfig.length) {\n      return variantsByChannelCount.get(\n          Math.max(...countLessThanOrEqualtoConfig));\n    }\n\n    // If all variants have more audio channels than the config, choose the\n    // variants with the fewest audio channels.\n    return variantsByChannelCount.get(Math.min(...channelCounts));\n  }\n\n  /**\n   * Chooses streams according to the given config.\n   *\n   * @param {!Array.<shaka.extern.Stream>} streams\n   * @param {string} preferredLanguage\n   * @param {string} preferredRole\n   * @param {boolean} preferredForced\n   * @return {!Array.<!shaka.extern.Stream>}\n   */\n  static filterStreamsByLanguageAndRole(\n      streams, preferredLanguage, preferredRole, preferredForced) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {!Array.<!shaka.extern.Stream>} */\n    let chosen = streams;\n\n    // Start with the set of primary streams.\n    /** @type {!Array.<!shaka.extern.Stream>} */\n    const primary = streams.filter((stream) => {\n      return stream.primary;\n    });\n\n    if (primary.length) {\n      chosen = primary;\n    }\n\n    // Now reduce the set to one language.  This covers both arbitrary language\n    // choice and the reduction of the \"primary\" stream set to one language.\n    const firstLanguage = chosen.length ? chosen[0].language : '';\n    chosen = chosen.filter((stream) => {\n      return stream.language == firstLanguage;\n    });\n\n    // Find the streams that best match our language preference. This will\n    // override previous selections.\n    if (preferredLanguage) {\n      const closestLocale = LanguageUtils.findClosestLocale(\n          LanguageUtils.normalize(preferredLanguage),\n          streams.map((stream) => stream.language));\n\n      // Only replace |chosen| if we found a locale that is close to our\n      // preference.\n      if (closestLocale) {\n        chosen = streams.filter((stream) => {\n          const locale = LanguageUtils.normalize(stream.language);\n          return locale == closestLocale;\n        });\n      }\n    }\n\n    // Filter by forced preference\n    chosen = chosen.filter((stream) => {\n      return stream.forced == preferredForced;\n    });\n\n    // Now refine the choice based on role preference.\n    if (preferredRole) {\n      const roleMatches = shaka.util.StreamUtils.filterTextStreamsByRole_(\n          chosen, preferredRole);\n      if (roleMatches.length) {\n        return roleMatches;\n      } else {\n        shaka.log.warning('No exact match for the text role could be found.');\n      }\n    } else {\n      // Prefer text streams with no roles, if they exist.\n      const noRoleMatches = chosen.filter((stream) => {\n        return stream.roles.length == 0;\n      });\n      if (noRoleMatches.length) {\n        return noRoleMatches;\n      }\n    }\n\n    // Either there was no role preference, or it could not be satisfied.\n    // Choose an arbitrary role, if there are any, and filter out any other\n    // roles. This ensures we never adapt between roles.\n\n    const allRoles = chosen.map((stream) => {\n      return stream.roles;\n    }).reduce(shaka.util.Functional.collapseArrays, []);\n\n    if (!allRoles.length) {\n      return chosen;\n    }\n    return shaka.util.StreamUtils.filterTextStreamsByRole_(chosen, allRoles[0]);\n  }\n\n\n  /**\n   * Filter text Streams by role.\n   *\n   * @param {!Array.<shaka.extern.Stream>} textStreams\n   * @param {string} preferredRole\n   * @return {!Array.<shaka.extern.Stream>}\n   * @private\n   */\n  static filterTextStreamsByRole_(textStreams, preferredRole) {\n    return textStreams.filter((stream) => {\n      return stream.roles.includes(preferredRole);\n    });\n  }\n\n\n  /**\n   * Checks if the given stream is an audio stream.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {boolean}\n   */\n  static isAudio(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return stream.type == ContentType.AUDIO;\n  }\n\n\n  /**\n   * Checks if the given stream is a video stream.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {boolean}\n   */\n  static isVideo(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return stream.type == ContentType.VIDEO;\n  }\n\n\n  /**\n   * Get all non-null streams in the variant as an array.\n   *\n   * @param {shaka.extern.Variant} variant\n   * @return {!Array.<shaka.extern.Stream>}\n   */\n  static getVariantStreams(variant) {\n    const streams = [];\n\n    if (variant.audio) {\n      streams.push(variant.audio);\n    }\n    if (variant.video) {\n      streams.push(variant.video);\n    }\n\n    return streams;\n  }\n\n\n  /**\n   * Returns a string of a variant, with the attribute values of its audio\n   * and/or video streams for log printing.\n   * @param {shaka.extern.Variant} variant\n   * @return {string}\n   * @private\n   */\n  static getVariantSummaryString_(variant) {\n    const summaries = [];\n    if (variant.audio) {\n      summaries.push(shaka.util.StreamUtils.getStreamSummaryString_(\n          variant.audio));\n    }\n    if (variant.video) {\n      summaries.push(shaka.util.StreamUtils.getStreamSummaryString_(\n          variant.video));\n    }\n    return summaries.join(', ');\n  }\n\n  /**\n   * Returns a string of an audio or video stream for log printing.\n   * @param {shaka.extern.Stream} stream\n   * @return {string}\n   * @private\n   */\n  static getStreamSummaryString_(stream) {\n    // Accepted parameters for Chromecast can be found (internally) at\n    // go/cast-mime-params\n\n    if (shaka.util.StreamUtils.isAudio(stream)) {\n      return 'type=audio' +\n             ' codecs=' + stream.codecs +\n             ' bandwidth='+ stream.bandwidth +\n             ' channelsCount=' + stream.channelsCount +\n             ' audioSamplingRate=' + stream.audioSamplingRate;\n    }\n\n    if (shaka.util.StreamUtils.isVideo(stream)) {\n      return 'type=video' +\n             ' codecs=' + stream.codecs +\n             ' bandwidth=' + stream.bandwidth +\n             ' frameRate=' + stream.frameRate +\n             ' width=' + stream.width +\n             ' height=' + stream.height;\n    }\n\n    return 'unexpected stream type';\n  }\n};\n\n\n/** @private {number} */\nshaka.util.StreamUtils.nextTrackId_ = 0;\n\n/**\n * @enum {string}\n */\nshaka.util.StreamUtils.DecodingAttributes = {\n  SMOOTH: 'smooth',\n  POWER: 'powerEfficient',\n  BANDWIDTH: 'bandwidth',\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.InitSegmentReference');\ngoog.provide('shaka.media.SegmentReference');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.ArrayUtils');\n\n\n/**\n * Creates an InitSegmentReference, which provides the location to an\n * initialization segment.\n *\n * @export\n */\nshaka.media.InitSegmentReference = class {\n  /**\n   * @param {function():!Array.<string>} uris A function that creates the URIs\n   *   of the resource containing the segment.\n   * @param {number} startByte The offset from the start of the resource to the\n   *   start of the segment.\n   * @param {?number} endByte The offset from the start of the resource\n   *   to the end of the segment, inclusive.  A value of null indicates that the\n   *   segment extends to the end of the resource.\n   * @param {null|shaka.extern.MediaQualityInfo=} mediaQuality Information about\n   *   the quality of the media associated with this init segment.\n   */\n  constructor(uris, startByte, endByte, mediaQuality = null) {\n    /** @type {function():!Array.<string>} */\n    this.getUris = uris;\n\n    /** @const {number} */\n    this.startByte = startByte;\n\n    /** @const {?number} */\n    this.endByte = endByte;\n\n    /** @const {shaka.extern.MediaQualityInfo|null} */\n    this.mediaQuality = mediaQuality;\n  }\n\n  /**\n   * Returns the offset from the start of the resource to the\n   * start of the segment.\n   *\n   * @return {number}\n   * @export\n   */\n  getStartByte() {\n    return this.startByte;\n  }\n\n  /**\n   * Returns the offset from the start of the resource to the end of the\n   * segment, inclusive.  A value of null indicates that the segment extends\n   * to the end of the resource.\n   *\n   * @return {?number}\n   * @export\n   */\n  getEndByte() {\n    return this.endByte;\n  }\n\n  /**\n   * Returns the size of the init segment.\n   * @return {?number}\n   */\n  getSize() {\n    if (this.endByte) {\n      return this.endByte - this.startByte;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns media quality information for the segments associated with\n   * this init segment.\n   *\n   * @return {?shaka.extern.MediaQualityInfo}\n   */\n  getMediaQuality() {\n    return this.mediaQuality;\n  }\n\n  /**\n   * Check if two initSegmentReference have all the same values.\n   * @param {?shaka.media.InitSegmentReference} reference1\n   * @param {?shaka.media.InitSegmentReference} reference2\n   * @return {boolean}\n   */\n  static equal(reference1, reference2) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n    if (!reference1 || !reference2) {\n      return reference1 == reference2;\n    } else {\n      return reference1.getStartByte() == reference2.getStartByte() &&\n          reference1.getEndByte() == reference2.getEndByte() &&\n          ArrayUtils.equal(reference1.getUris(), reference2.getUris());\n    }\n  }\n};\n\n\n/**\n * SegmentReference provides the start time, end time, and location to a media\n * segment.\n *\n * @export\n */\nshaka.media.SegmentReference = class {\n  /**\n   * @param {number} startTime The segment's start time in seconds.\n   * @param {number} endTime The segment's end time in seconds.  The segment\n   *   ends the instant before this time, so |endTime| must be strictly greater\n   *   than |startTime|.\n   * @param {function():!Array.<string>} uris\n   *   A function that creates the URIs of the resource containing the segment.\n   * @param {number} startByte The offset from the start of the resource to the\n   *   start of the segment.\n   * @param {?number} endByte The offset from the start of the resource to the\n   *   end of the segment, inclusive.  A value of null indicates that the\n   *   segment extends to the end of the resource.\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   *   The segment's initialization segment metadata, or null if the segments\n   *   are self-initializing.\n   * @param {number} timestampOffset\n   *   The amount of time, in seconds, that must be added to the segment's\n   *   internal timestamps to align it to the presentation timeline.\n   *   <br>\n   *   For DASH, this value should equal the Period start time minus the first\n   *   presentation timestamp of the first frame/sample in the Period.  For\n   *   example, for MP4 based streams, this value should equal Period start\n   *   minus the first segment's tfdt box's 'baseMediaDecodeTime' field (after\n   *   it has been converted to seconds).\n   *   <br>\n   *   For HLS, this value should be 0 to keep the presentation time at the most\n   *   recent discontinuity minus the corresponding media time.\n   * @param {number} appendWindowStart\n   *   The start of the append window for this reference, relative to the\n   *   presentation.  Any content from before this time will be removed by\n   *   MediaSource.\n   * @param {number} appendWindowEnd\n   *   The end of the append window for this reference, relative to the\n   *   presentation.  Any content from after this time will be removed by\n   *   MediaSource.\n   * @param {!Array.<!shaka.media.SegmentReference>=} partialReferences\n   *   A list of SegmentReferences for the partial segments.\n   * @param {?string=} tilesLayout\n   *   The value is a grid-item-dimension consisting of two positive decimal\n   *   integers in the format: column-x-row ('4x3'). It describes the\n   *   arrangement of Images in a Grid. The minimum valid LAYOUT is '1x1'.\n   * @param {?number=} tileDuration\n   *  The explicit duration of an individual tile within the tiles grid.\n   *  If not provided, the duration should be automatically calculated based on\n   *  the duration of the reference.\n   */\n  constructor(\n      startTime, endTime, uris, startByte, endByte, initSegmentReference,\n      timestampOffset, appendWindowStart, appendWindowEnd,\n      partialReferences = [], tilesLayout = '', tileDuration = null) {\n    // A preload hinted Partial Segment has the same startTime and endTime.\n    goog.asserts.assert(startTime <= endTime,\n        'startTime must be less than or equal to endTime');\n    goog.asserts.assert((endByte == null) || (startByte < endByte),\n        'startByte must be < endByte');\n\n    /** @type {number} */\n    this.startTime = startTime;\n\n    /** @type {number} */\n    this.endTime = endTime;\n\n    /**\n     * The \"true\" end time of the segment, without considering the period end\n     * time.  This is necessary for thumbnail segments, where timing requires us\n     * to know the original segment duration as described in the manifest.\n     * @type {number}\n     */\n    this.trueEndTime = endTime;\n\n    /** @type {function():!Array.<string>} */\n    this.getUrisInner = uris;\n\n    /** @const {number} */\n    this.startByte = startByte;\n\n    /** @const {?number} */\n    this.endByte = endByte;\n\n    /** @type {shaka.media.InitSegmentReference} */\n    this.initSegmentReference = initSegmentReference;\n\n    /** @type {number} */\n    this.timestampOffset = timestampOffset;\n\n    /** @type {number} */\n    this.appendWindowStart = appendWindowStart;\n\n    /** @type {number} */\n    this.appendWindowEnd = appendWindowEnd;\n\n    /** @type {!Array.<!shaka.media.SegmentReference>} */\n    this.partialReferences = partialReferences;\n\n    /** @type {?string} */\n    this.tilesLayout = tilesLayout;\n\n    /** @type {?number} */\n    this.tileDuration = tileDuration;\n  }\n\n  /**\n   * Creates and returns the URIs of the resource containing the segment.\n   *\n   * @return {!Array.<string>}\n   * @export\n   */\n  getUris() {\n    return this.getUrisInner();\n  }\n\n  /**\n   * Returns the segment's start time in seconds.\n   *\n   * @return {number}\n   * @export\n   */\n  getStartTime() {\n    return this.startTime;\n  }\n\n  /**\n   * Returns the segment's end time in seconds.\n   *\n   * @return {number}\n   * @export\n   */\n  getEndTime() {\n    return this.endTime;\n  }\n\n  /**\n   * Returns the offset from the start of the resource to the\n   * start of the segment.\n   *\n   * @return {number}\n   * @export\n   */\n  getStartByte() {\n    return this.startByte;\n  }\n\n  /**\n   * Returns the offset from the start of the resource to the end of the\n   * segment, inclusive.  A value of null indicates that the segment extends to\n   * the end of the resource.\n   *\n   * @return {?number}\n   * @export\n   */\n  getEndByte() {\n    return this.endByte;\n  }\n\n  /**\n   * Returns the size of the segment.\n   * @return {?number}\n   */\n  getSize() {\n    if (this.endByte) {\n      return this.endByte - this.startByte;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns true if it contains partial SegmentReferences.\n   * @return {boolean}\n   */\n  hasPartialSegments() {\n    return this.partialReferences.length > 0;\n  }\n\n  /**\n   * Returns the segment's tiles layout. Only defined in image segments.\n   *\n   * @return {?string}\n   * @export\n   */\n  getTilesLayout() {\n    return this.tilesLayout;\n  }\n\n  /**\n   * Returns the segment's explicit tile duration.\n   * Only defined in image segments.\n   *\n   * @return {?number}\n   * @export\n   */\n  getTileDuration() {\n    return this.tileDuration;\n  }\n};\n\n\n/**\n * A convenient typedef for when either type of reference is acceptable.\n *\n * @typedef {shaka.media.InitSegmentReference|shaka.media.SegmentReference}\n */\nshaka.media.AnySegmentReference;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.abr.SimpleAbrManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.abr.EwmaBandwidthEstimator');\ngoog.require('shaka.log');\ngoog.require('shaka.util.StreamUtils');\n\n\n/**\n * @summary\n * <p>\n * This defines the default ABR manager for the Player.  An instance of this\n * class is used when no ABR manager is given.\n * </p>\n * <p>\n * The behavior of this class is to take throughput samples using\n * segmentDownloaded to estimate the current network bandwidth.  Then it will\n * use that to choose the streams that best fit the current bandwidth.  It will\n * always pick the highest bandwidth variant it thinks can be played.\n * </p>\n * <p>\n * After initial choices are made, this class will call switchCallback() when\n * there is a better choice.  switchCallback() will not be called more than once\n * per ({@link shaka.abr.SimpleAbrManager.SWITCH_INTERVAL_MS}).\n * </p>\n *\n * @implements {shaka.extern.AbrManager}\n * @export\n */\nshaka.abr.SimpleAbrManager = class {\n  /** */\n  constructor() {\n    /** @private {?shaka.extern.AbrManager.SwitchCallback} */\n    this.switch_ = null;\n\n    /** @private {boolean} */\n    this.enabled_ = false;\n\n    /** @private {shaka.abr.EwmaBandwidthEstimator} */\n    this.bandwidthEstimator_ = new shaka.abr.EwmaBandwidthEstimator();\n\n    // Some browsers implement the Network Information API, which allows\n    // retrieving information about a user's network connection. We listen\n    // to the change event to be able to make quick changes in case the type\n    // of connectivity changes.\n    if (navigator.connection) {\n      navigator.connection.addEventListener('change', () => {\n        if (this.config_.useNetworkInformation && this.enabled_) {\n          this.bandwidthEstimator_ = new shaka.abr.EwmaBandwidthEstimator();\n          if (this.config_) {\n            this.bandwidthEstimator_.configure(this.config_.advanced);\n          }\n          const chosenVariant = this.chooseVariant();\n          if (chosenVariant) {\n            this.switch_(chosenVariant);\n          }\n        }\n      });\n    }\n\n    /**\n     * A filtered list of Variants to choose from.\n     * @private {!Array.<!shaka.extern.Variant>}\n     */\n    this.variants_ = [];\n\n    /** @private {number} */\n    this.playbackRate_ = 1;\n\n    /** @private {boolean} */\n    this.startupComplete_ = false;\n\n    /**\n     * The last wall-clock time, in milliseconds, when streams were chosen.\n     *\n     * @private {?number}\n     */\n    this.lastTimeChosenMs_ = null;\n\n    /** @private {?shaka.extern.AbrConfiguration} */\n    this.config_ = null;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  stop() {\n    this.switch_ = null;\n    this.enabled_ = false;\n    this.variants_ = [];\n    this.playbackRate_ = 1;\n    this.lastTimeChosenMs_ = null;\n\n    // Don't reset |startupComplete_|: if we've left the startup interval, we\n    // can start using bandwidth estimates right away after init() is called.\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  init(switchCallback) {\n    this.switch_ = switchCallback;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  chooseVariant() {\n    const SimpleAbrManager = shaka.abr.SimpleAbrManager;\n\n    // Get sorted Variants.\n    let sortedVariants = SimpleAbrManager.filterAndSortVariants_(\n        this.config_.restrictions, this.variants_);\n\n    const defaultBandwidthEstimate = this.getDefaultBandwidth_();\n    const currentBandwidth = this.bandwidthEstimator_.getBandwidthEstimate(\n        defaultBandwidthEstimate);\n\n    if (this.variants_.length && !sortedVariants.length) {\n      // If we couldn't meet the ABR restrictions, we should still play\n      // something.\n      // These restrictions are not \"hard\" restrictions in the way that\n      // top-level or DRM-based restrictions are.  Sort the variants without\n      // restrictions and keep just the first (lowest-bandwidth) one.\n      shaka.log.warning('No variants met the ABR restrictions. ' +\n                        'Choosing a variant by lowest bandwidth.');\n      sortedVariants = SimpleAbrManager.filterAndSortVariants_(\n          /* restrictions= */ null, this.variants_);\n      sortedVariants = [sortedVariants[0]];\n    }\n\n    // Start by assuming that we will use the first Stream.\n    let chosen = sortedVariants[0] || null;\n\n    for (let i = 0; i < sortedVariants.length; i++) {\n      const item = sortedVariants[i];\n      const playbackRate =\n          !isNaN(this.playbackRate_) ? Math.abs(this.playbackRate_) : 1;\n      const itemBandwidth = playbackRate * item.bandwidth;\n      const minBandwidth =\n          itemBandwidth / this.config_.bandwidthDowngradeTarget;\n      let next = {bandwidth: Infinity};\n      for (let j = i + 1; j < sortedVariants.length; j++) {\n        if (item.bandwidth != sortedVariants[j].bandwidth) {\n          next = sortedVariants[j];\n          break;\n        }\n      }\n      const nextBandwidth = playbackRate * next.bandwidth;\n      const maxBandwidth = nextBandwidth / this.config_.bandwidthUpgradeTarget;\n      shaka.log.v2('Bandwidth ranges:',\n          (itemBandwidth / 1e6).toFixed(3),\n          (minBandwidth / 1e6).toFixed(3),\n          (maxBandwidth / 1e6).toFixed(3));\n\n      if (currentBandwidth >= minBandwidth &&\n          currentBandwidth <= maxBandwidth &&\n          chosen.bandwidth != item.bandwidth) {\n        chosen = item;\n      }\n    }\n\n    this.lastTimeChosenMs_ = Date.now();\n    return chosen;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  enable() {\n    this.enabled_ = true;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  disable() {\n    this.enabled_ = false;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  segmentDownloaded(deltaTimeMs, numBytes) {\n    shaka.log.v2('Segment downloaded:',\n        'deltaTimeMs=' + deltaTimeMs,\n        'numBytes=' + numBytes,\n        'lastTimeChosenMs=' + this.lastTimeChosenMs_,\n        'enabled=' + this.enabled_);\n    goog.asserts.assert(deltaTimeMs >= 0, 'expected a non-negative duration');\n    this.bandwidthEstimator_.sample(deltaTimeMs, numBytes);\n\n    if ((this.lastTimeChosenMs_ != null) && this.enabled_) {\n      this.suggestStreams_();\n    }\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getBandwidthEstimate() {\n    const defaultBandwidthEstimate = this.getDefaultBandwidth_();\n    return this.bandwidthEstimator_.getBandwidthEstimate(\n        defaultBandwidthEstimate);\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  setVariants(variants) {\n    this.variants_ = variants;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  playbackRateChanged(rate) {\n    this.playbackRate_ = rate;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  configure(config) {\n    this.config_ = config;\n    if (this.bandwidthEstimator_ && this.config_) {\n      this.bandwidthEstimator_.configure(this.config_.advanced);\n    }\n  }\n\n\n  /**\n   * Calls switch_() with the variant chosen by chooseVariant().\n   *\n   * @private\n   */\n  suggestStreams_() {\n    shaka.log.v2('Suggesting Streams...');\n    goog.asserts.assert(this.lastTimeChosenMs_ != null,\n        'lastTimeChosenMs_ should not be null');\n\n    if (!this.startupComplete_) {\n      // Check if we've got enough data yet.\n      if (!this.bandwidthEstimator_.hasGoodEstimate()) {\n        shaka.log.v2('Still waiting for a good estimate...');\n        return;\n      }\n      this.startupComplete_ = true;\n    } else {\n      // Check if we've left the switch interval.\n      const now = Date.now();\n      const delta = now - this.lastTimeChosenMs_;\n      if (delta < this.config_.switchInterval * 1000) {\n        shaka.log.v2('Still within switch interval...');\n        return;\n      }\n    }\n\n    const chosenVariant = this.chooseVariant();\n    const defaultBandwidthEstimate = this.getDefaultBandwidth_();\n    const bandwidthEstimate = this.bandwidthEstimator_.getBandwidthEstimate(\n        defaultBandwidthEstimate);\n    const currentBandwidthKbps = Math.round(bandwidthEstimate / 1000.0);\n\n    if (chosenVariant) {\n      shaka.log.debug(\n          'Calling switch_(), bandwidth=' + currentBandwidthKbps + ' kbps');\n      // If any of these chosen streams are already chosen, Player will filter\n      // them out before passing the choices on to StreamingEngine.\n      this.switch_(chosenVariant);\n    }\n  }\n\n\n  /**\n   * @private\n   */\n  getDefaultBandwidth_() {\n    let defaultBandwidthEstimate = this.config_.defaultBandwidthEstimate;\n\n    // Some browsers implement the Network Information API, which allows\n    // retrieving information about a user's network connection.  Tizen 3 has\n    // NetworkInformation, but not the downlink attribute.\n    if (navigator.connection && navigator.connection.downlink &&\n        this.config_.useNetworkInformation) {\n      // If it's available, get the bandwidth estimate from the browser (in\n      // megabits per second) and use it as defaultBandwidthEstimate.\n      defaultBandwidthEstimate = navigator.connection.downlink * 1e6;\n    }\n    return defaultBandwidthEstimate;\n  }\n\n\n  /**\n   * @param {?shaka.extern.Restrictions} restrictions\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @return {!Array.<shaka.extern.Variant>} variants filtered according to\n   *   |restrictions| and sorted in ascending order of bandwidth.\n   * @private\n   */\n  static filterAndSortVariants_(restrictions, variants) {\n    if (restrictions) {\n      variants = variants.filter((variant) => {\n        // This was already checked in another scope, but the compiler doesn't\n        // seem to understand that.\n        goog.asserts.assert(restrictions, 'Restrictions should exist!');\n\n        return shaka.util.StreamUtils.meetsRestrictions(\n            variant, restrictions,\n            /* maxHwRes= */ {width: Infinity, height: Infinity});\n      });\n    }\n\n    return variants.sort((v1, v2) => {\n      return v1.bandwidth - v2.bandwidth;\n    });\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.AdaptationSet');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.MimeUtils');\n\n\n/**\n * A set of variants that we want to adapt between.\n *\n * @final\n */\nshaka.media.AdaptationSet = class {\n  /**\n   * @param {shaka.extern.Variant} root\n   *    The variant that all other variants will be tested against when being\n   *    added to the adaptation set. If a variant is not compatible with the\n   *    root, it will not be added.\n   * @param {!Iterable.<shaka.extern.Variant>=} candidates\n   *    Variants that may be compatible with the root and should be added if\n   *    compatible. If a candidate is not compatible, it will not end up in the\n   *    adaptation set.\n   */\n  constructor(root, candidates) {\n    /** @private {shaka.extern.Variant} */\n    this.root_ = root;\n    /** @private {!Set.<shaka.extern.Variant>} */\n    this.variants_ = new Set([root]);\n\n    // Try to add all the candidates. If they cannot be added (because they\n    // are not compatible with the root, they will be rejected by |add|.\n    candidates = candidates || [];\n    for (const candidate of candidates) {\n      this.add(candidate);\n    }\n  }\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @return {boolean}\n   */\n  add(variant) {\n    if (this.canInclude(variant)) {\n      this.variants_.add(variant);\n      return true;\n    }\n\n    // To be nice, issue a warning if someone is trying to add something that\n    // they shouldn't.\n    shaka.log.warning('Rejecting variant - not compatible with root.');\n    return false;\n  }\n\n  /**\n   * Check if |variant| can be included with the set. If |canInclude| returns\n   * |false|, calling |add| will result in it being ignored.\n   *\n   * @param {shaka.extern.Variant} variant\n   * @return {boolean}\n   */\n  canInclude(variant) {\n    return shaka.media.AdaptationSet.areAdaptable(this.root_, variant);\n  }\n\n  /**\n   * @param {shaka.extern.Variant} a\n   * @param {shaka.extern.Variant} b\n   * @return {boolean}\n   */\n  static areAdaptable(a, b) {\n    const AdaptationSet = shaka.media.AdaptationSet;\n\n    // All variants should have audio or should all not have audio.\n    if (!!a.audio != !!b.audio) {\n      return false;\n    }\n\n    // All variants should have video or should all not have video.\n    if (!!a.video != !!b.video) {\n      return false;\n    }\n\n    // If the languages don't match, we should not adapt between them.\n    if (a.language != b.language) {\n      return false;\n    }\n\n    goog.asserts.assert(\n        !!a.audio == !!b.audio,\n        'Both should either have audio or not have audio.');\n    if (a.audio && b.audio &&\n        !AdaptationSet.areAudiosCompatible_(a.audio, b.audio)) {\n      return false;\n    }\n\n    goog.asserts.assert(\n        !!a.video == !!b.video,\n        'Both should either have video or not have video.');\n    if (a.video && b.video &&\n        !AdaptationSet.areVideosCompatible_(a.video, b.video)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @return {!Iterable.<shaka.extern.Variant>}\n   */\n  values() {\n    return this.variants_.values();\n  }\n\n  /**\n   * Check if we can switch between two audio streams.\n   *\n   * @param {shaka.extern.Stream} a\n   * @param {shaka.extern.Stream} b\n   * @return {boolean}\n   * @private\n   */\n  static areAudiosCompatible_(a, b) {\n    const AdaptationSet = shaka.media.AdaptationSet;\n\n    // Don't adapt between channel counts, which could annoy the user\n    // due to volume changes on downmixing.  An exception is made for\n    // stereo and mono, which should be fine to adapt between.\n    if (!a.channelsCount || !b.channelsCount ||\n        a.channelsCount > 2 || b.channelsCount > 2) {\n      if (a.channelsCount != b.channelsCount) {\n        return false;\n      }\n    }\n\n    // We can only adapt between base-codecs.\n    if (!AdaptationSet.canTransitionBetween_(a, b)) {\n      return false;\n    }\n\n    // Audio roles must not change between adaptations.\n    if (!AdaptationSet.areRolesEqual_(a.roles, b.roles)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if we can switch between two video streams.\n   *\n   * @param {shaka.extern.Stream} a\n   * @param {shaka.extern.Stream} b\n   * @return {boolean}\n   * @private\n   */\n  static areVideosCompatible_(a, b) {\n    const AdaptationSet = shaka.media.AdaptationSet;\n\n    // We can only adapt between base-codecs.\n    if (!AdaptationSet.canTransitionBetween_(a, b)) {\n      return false;\n    }\n\n    // Video roles must not change between adaptations.\n    if (!AdaptationSet.areRolesEqual_(a.roles, b.roles)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if we can switch between two streams based on their codec and mime\n   * type.\n   *\n   * @param {shaka.extern.Stream} a\n   * @param {shaka.extern.Stream} b\n   * @return {boolean}\n   * @private\n   */\n  static canTransitionBetween_(a, b) {\n    if (a.mimeType != b.mimeType) {\n      return false;\n    }\n\n\n    // Get the base codec of each codec in each stream.\n    const codecsA = shaka.util.MimeUtils.splitCodecs(a.codecs).map((codec) => {\n      return shaka.util.MimeUtils.getCodecBase(codec);\n    });\n    const codecsB = shaka.util.MimeUtils.splitCodecs(b.codecs).map((codec) => {\n      return shaka.util.MimeUtils.getCodecBase(codec);\n    });\n\n    // We don't want to allow switching between transmuxed and non-transmuxed\n    // content so the number of codecs should be the same.\n    //\n    // To avoid the case where an codec is used for audio and video we will\n    // codecs using arrays (not sets). While at this time, there are no codecs\n    // that work for audio and video, it is possible for \"raw\" codecs to be\n    // which would share the same name.\n    if (codecsA.length != codecsB.length) {\n      return false;\n    }\n\n    // Sort them so that we can walk through them and compare them\n    // element-by-element.\n    codecsA.sort();\n    codecsB.sort();\n\n    for (let i = 0; i < codecsA.length; i++) {\n      if (codecsA[i] != codecsB[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if two role lists are the equal. This will take into account all\n   * unique behaviours when comparing roles.\n   *\n   * @param {!Iterable.<string>} a\n   * @param {!Iterable.<string>} b\n   * @return {boolean}\n   * @private\n   */\n  static areRolesEqual_(a, b) {\n    const aSet = new Set(a);\n    const bSet = new Set(b);\n\n    // Remove the main role from the role lists (we expect to see them only\n    // in dash manifests).\n    const mainRole = 'main';\n    aSet.delete(mainRole);\n    bSet.delete(mainRole);\n\n    // Make sure that we have the same number roles in each list. Make sure to\n    // do it after correcting for 'main'.\n    if (aSet.size != bSet.size) {\n      return false;\n    }\n\n    // Because we know the two sets are the same size, if any item is missing\n    // if means that they are not the same.\n    for (const x of aSet) {\n      if (!bSet.has(x)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.AdaptationSetCriteria');\ngoog.provide('shaka.media.ExampleBasedCriteria');\ngoog.provide('shaka.media.PreferenceBasedCriteria');\n\ngoog.require('shaka.log');\ngoog.require('shaka.media.AdaptationSet');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.StreamUtils');\n\n\n/**\n * An adaptation set criteria is a unit of logic that can take a set of\n * variants and return a subset of variants that should (and can) be\n * adapted between.\n *\n * @interface\n */\nshaka.media.AdaptationSetCriteria = class {\n  /**\n   * Take a set of variants, and return a subset of variants that can be\n   * adapted between.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @return {!shaka.media.AdaptationSet}\n   */\n  create(variants) {}\n};\n\n\n/**\n * @implements {shaka.media.AdaptationSetCriteria}\n * @final\n */\nshaka.media.ExampleBasedCriteria = class {\n  /**\n   * @param {shaka.extern.Variant} example\n   */\n  constructor(example) {\n    /** @private {shaka.extern.Variant} */\n    this.example_ = example;\n\n    // We can't know if role and label are really important, so we don't use\n    // role and label for this.\n    const role = '';\n    const label = '';\n    const channelCount = example.audio && example.audio.channelsCount ?\n                         example.audio.channelsCount :\n                         0;\n\n    /** @private {!shaka.media.AdaptationSetCriteria} */\n    this.fallback_ = new shaka.media.PreferenceBasedCriteria(\n        example.language, role, channelCount, label);\n  }\n\n  /** @override */\n  create(variants) {\n    // We can't assume that the example is in |variants| because it could\n    // actually be from another period.\n    const shortList = variants.filter((variant) => {\n      return shaka.media.AdaptationSet.areAdaptable(this.example_, variant);\n    });\n\n    if (shortList.length) {\n      // Use the first item in the short list as the root. It should not matter\n      // which element we use as all items in the short list should already be\n      // compatible.\n      return new shaka.media.AdaptationSet(shortList[0], shortList);\n    } else {\n      return this.fallback_.create(variants);\n    }\n  }\n};\n\n\n/**\n * @implements {shaka.media.AdaptationSetCriteria}\n * @final\n */\nshaka.media.PreferenceBasedCriteria = class {\n  /**\n   * @param {string} language\n   * @param {string} role\n   * @param {number} channelCount\n   * @param {string=} label\n   */\n  constructor(language, role, channelCount, label = '') {\n    /** @private {string} */\n    this.language_ = language;\n    /** @private {string} */\n    this.role_ = role;\n    /** @private {number} */\n    this.channelCount_ = channelCount;\n    /** @private {string} */\n    this.label_ = label;\n  }\n\n  /** @override */\n  create(variants) {\n    const Class = shaka.media.PreferenceBasedCriteria;\n    const StreamUtils = shaka.util.StreamUtils;\n\n    let current = [];\n\n    const byLanguage = Class.filterByLanguage_(variants, this.language_);\n    const byPrimary = variants.filter((variant) => variant.primary);\n\n    if (byLanguage.length) {\n      current = byLanguage;\n    } else if (byPrimary.length) {\n      current = byPrimary;\n    } else {\n      current = variants;\n    }\n\n    // Now refine the choice based on role preference.  Even the empty string\n    // works here, and will match variants without any roles.\n    const byRole = Class.filterVariantsByRole_(current, this.role_);\n    if (byRole.length) {\n      current = byRole;\n    } else {\n      shaka.log.warning('No exact match for variant role could be found.');\n    }\n\n    if (this.channelCount_) {\n      const byChannel = StreamUtils.filterVariantsByAudioChannelCount(\n          current, this.channelCount_);\n      if (byChannel.length) {\n        current = byChannel;\n      } else {\n        shaka.log.warning(\n            'No exact match for the channel count could be found.');\n      }\n    }\n\n    if (this.label_) {\n      const byLabel = Class.filterVariantsByLabel_(current, this.label_);\n      if (byLabel.length) {\n        current = byLabel;\n      } else {\n        shaka.log.warning('No exact match for variant label could be found.');\n      }\n    }\n\n    // Make sure we only return a valid adaptation set.\n    const set = new shaka.media.AdaptationSet(current[0]);\n    for (const variant of current) {\n      if (set.canInclude(variant)) {\n        set.add(variant);\n      }\n    }\n\n    return set;\n  }\n\n  /**\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {string} preferredLanguage\n   * @return {!Array.<shaka.extern.Variant>}\n   * @private\n   */\n  static filterByLanguage_(variants, preferredLanguage) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {string} */\n    const preferredLocale = LanguageUtils.normalize(preferredLanguage);\n\n    /** @type {?string} */\n    const closestLocale = LanguageUtils.findClosestLocale(\n        preferredLocale,\n        variants.map((variant) => LanguageUtils.getLocaleForVariant(variant)));\n\n    // There were no locales close to what we preferred.\n    if (!closestLocale) {\n      return [];\n    }\n\n    // Find the variants that use the closest variant.\n    return variants.filter((variant) => {\n      return closestLocale == LanguageUtils.getLocaleForVariant(variant);\n    });\n  }\n\n  /**\n   * Filter Variants by role.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {string} preferredRole\n   * @return {!Array.<shaka.extern.Variant>}\n   * @private\n   */\n  static filterVariantsByRole_(variants, preferredRole) {\n    return variants.filter((variant) => {\n      if (!variant.audio) {\n        return false;\n      }\n\n      if (preferredRole) {\n        return variant.audio.roles.includes(preferredRole);\n      } else {\n        return variant.audio.roles.length == 0;\n      }\n    });\n  }\n\n  /**\n   * Filter Variants by label.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {string} preferredLabel\n   * @return {!Array.<shaka.extern.Variant>}\n   * @private\n   */\n  static filterVariantsByLabel_(variants, preferredLabel) {\n    return variants.filter((variant) => {\n      if (!variant.audio) {\n        return false;\n      }\n\n      const label1 = variant.audio.label.toLowerCase();\n      const label2 = preferredLabel.toLowerCase();\n      return label1 == label2;\n    });\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.BufferingObserver');\n\n\n/**\n * The buffering observer watches how much content has been buffered and raises\n * events when the state changes (enough => not enough or vice versa).\n *\n * @final\n */\nshaka.media.BufferingObserver = class {\n  /**\n   * @param {number} thresholdWhenStarving\n   * @param {number} thresholdWhenSatisfied\n   */\n  constructor(thresholdWhenStarving, thresholdWhenSatisfied) {\n    const State = shaka.media.BufferingObserver.State;\n\n    /** @private {shaka.media.BufferingObserver.State} */\n    this.previousState_ = State.SATISFIED;\n\n    /** @private {!Map.<shaka.media.BufferingObserver.State, number>} */\n    this.thresholds_ = new Map()\n        .set(State.SATISFIED, thresholdWhenSatisfied)\n        .set(State.STARVING, thresholdWhenStarving);\n  }\n\n  /**\n   * @param {number} thresholdWhenStarving\n   * @param {number} thresholdWhenSatisfied\n   */\n  setThresholds(thresholdWhenStarving, thresholdWhenSatisfied) {\n    const State = shaka.media.BufferingObserver.State;\n    this.thresholds_\n        .set(State.SATISFIED, thresholdWhenSatisfied)\n        .set(State.STARVING, thresholdWhenStarving);\n  }\n\n  /**\n   * Update the observer by telling it how much content has been buffered (in\n   * seconds) and if we are buffered to the end of the presentation. If the\n   * controller believes the state has changed, it will return |true|.\n   *\n   * @param {number} bufferLead\n   * @param {boolean} bufferedToEnd\n   * @return {boolean}\n   */\n  update(bufferLead, bufferedToEnd) {\n    const State = shaka.media.BufferingObserver.State;\n\n    /**\n     * Our threshold for how much we need before we declare ourselves as\n     * starving is based on whether or not we were just starving. If we\n     * were just starving, we are more likely to starve again, so we require\n     * more content to be buffered than if we were not just starving.\n     *\n     * @type {number}\n     */\n    const threshold = this.thresholds_.get(this.previousState_);\n\n    const oldState = this.previousState_;\n    const newState = (bufferedToEnd || bufferLead >= threshold) ?\n                     (State.SATISFIED) :\n                     (State.STARVING);\n\n    // Save the new state now so that calls to |getState| from any callbacks\n    // will be accurate.\n    this.previousState_ = newState;\n\n    // Return |true| only when the state has changed.\n    return oldState != newState;\n  }\n\n  /**\n   * Set which state that the observer should think playback was in.\n   *\n   * @param {shaka.media.BufferingObserver.State} state\n   */\n  setState(state) {\n    this.previousState_ = state;\n  }\n\n  /**\n   * Get the state that the observer last thought playback was in.\n   *\n   * @return {shaka.media.BufferingObserver.State}\n   */\n  getState() {\n    return this.previousState_;\n  }\n};\n\n/**\n * Rather than using booleans to communicate what state we are in, we have this\n * enum.\n *\n * @enum {number}\n */\nshaka.media.BufferingObserver.State = {\n  STARVING: 0,\n  SATISFIED: 1,\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.Player');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.log');\ngoog.require('shaka.media.AdaptationSetCriteria');\ngoog.require('shaka.media.BufferingObserver');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.ExampleBasedCriteria');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.MediaSourceEngine');\ngoog.require('shaka.media.MediaSourcePlayhead');\ngoog.require('shaka.media.MetaSegmentIndex');\ngoog.require('shaka.media.ClosedCaptionParser');\ngoog.require('shaka.media.PlayRateController');\ngoog.require('shaka.media.Playhead');\ngoog.require('shaka.media.PlayheadObserverManager');\ngoog.require('shaka.media.PreferenceBasedCriteria');\ngoog.require('shaka.media.QualityObserver');\ngoog.require('shaka.media.RegionObserver');\ngoog.require('shaka.media.RegionTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SrcEqualsPlayhead');\ngoog.require('shaka.media.StreamingEngine');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.routing.Walker');\ngoog.require('shaka.text.SimpleTextDisplayer');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.text.UITextDisplayer');\ngoog.require('shaka.text.WebVttGenerator');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.CmcdManager');\ngoog.require('shaka.util.ConfigUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MediaReadyState');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.ObjectUtils');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.PlayerConfiguration');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.Stats');\ngoog.require('shaka.util.StreamUtils');\ngoog.require('shaka.util.Timer');\ngoog.requireType('shaka.media.IClosedCaptionParser');\ngoog.requireType('shaka.media.PresentationTimeline');\ngoog.requireType('shaka.routing.Node');\ngoog.requireType('shaka.routing.Payload');\n\n\n/**\n * @event shaka.Player.ErrorEvent\n * @description Fired when a playback error occurs.\n * @property {string} type\n *   'error'\n * @property {!shaka.util.Error} detail\n *   An object which contains details on the error.  The error's\n *   <code>category</code> and <code>code</code> properties will identify the\n *   specific error that occurred.  In an uncompiled build, you can also use the\n *   <code>message</code> and <code>stack</code> properties to debug.\n * @exportDoc\n */\n\n/**\n * @event shaka.Player.StateChangeEvent\n * @description Fired when the player changes load states.\n * @property {string} type\n *    'onstatechange'\n * @property {string} state\n *    The name of the state that the player just entered.\n * @exportDoc\n */\n\n/**\n * @event shaka.Player.StateIdleEvent\n * @description Fired when the player has stopped changing states and will\n *    remain idle until a new state change request (e.g. <code>load</code>,\n *    <code>attach</code>, etc.) is made.\n * @property {string} type\n *    'onstateidle'\n * @property {string} state\n *    The name of the state that the player stopped in.\n * @exportDoc\n */\n\n/**\n * @event shaka.Player.EmsgEvent\n * @description Fired when a non-typical emsg is found in a segment.\n * @property {string} type\n *   'emsg'\n * @property {shaka.extern.EmsgInfo} detail\n *   An object which contains the content of the emsg box.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.DownloadFailed\n * @description Fired when a download has failed, for any reason.\n *   'downloadfailed'\n * @property {!shaka.extern.Request} request\n * @property {?shaka.util.Error} error\n * @param {number} httpResponseCode\n * @param {boolean} aborted\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.DownloadHeadersReceived\n * @description Fired when the networking engine has received the headers for\n *    a download, but before the body has been downloaded.\n *    If the HTTP plugin being used does not track this information, this event\n *    will default to being fired when the body is received, instead.\n * @property {!Object.<string, string>} headers\n * @property {!shaka.extern.Request} request\n * @property {!shaka.net.NetworkingEngine.RequestType} type\n *   'downloadheadersreceived'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.DrmSessionUpdateEvent\n * @description Fired when the CDM has accepted the license response.\n * @property {string} type\n *   'drmsessionupdate'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TimelineRegionAddedEvent\n * @description Fired when a media timeline region is added.\n * @property {string} type\n *   'timelineregionadded'\n * @property {shaka.extern.TimelineRegionInfo} detail\n *   An object which contains a description of the region.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TimelineRegionEnterEvent\n * @description Fired when the playhead enters a timeline region.\n * @property {string} type\n *   'timelineregionenter'\n * @property {shaka.extern.TimelineRegionInfo} detail\n *   An object which contains a description of the region.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TimelineRegionExitEvent\n * @description Fired when the playhead exits a timeline region.\n * @property {string} type\n *   'timelineregionexit'\n * @property {shaka.extern.TimelineRegionInfo} detail\n *   An object which contains a description of the region.\n * @exportDoc\n */\n\n/**\n * @event shaka.Player.MediaQualityChangedEvent\n * @description Fired when the media quality changes at the playhead.\n * That may be caused by an adaptation change or a DASH period transition.\n * Separate events are emitted for audio and video contentTypes.\n * This is supported for only DASH streams at this time.\n * @property {string} type\n *   'mediaqualitychanged'\n * @property {shaka.extern.MediaQualityInfo} mediaQuality\n *   Information about media quality at the playhead position.\n * @property {number} position\n *   The playhead position.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.BufferingEvent\n * @description Fired when the player's buffering state changes.\n * @property {string} type\n *   'buffering'\n * @property {boolean} buffering\n *   True when the Player enters the buffering state.\n *   False when the Player leaves the buffering state.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.LoadingEvent\n * @description Fired when the player begins loading. The start of loading is\n *   defined as when the user has communicated intent to load content (i.e.\n *   <code>Player.load</code> has been called).\n * @property {string} type\n *   'loading'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.LoadedEvent\n * @description Fired when the player ends the load.\n * @property {string} type\n *   'loaded'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.UnloadingEvent\n * @description Fired when the player unloads or fails to load.\n *   Used by the Cast receiver to determine idle state.\n * @property {string} type\n *   'unloading'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TextTrackVisibilityEvent\n * @description Fired when text track visibility changes.\n * @property {string} type\n *   'texttrackvisibility'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TracksChangedEvent\n * @description Fired when the list of tracks changes.  For example, this will\n *   happen when new tracks are added/removed or when track restrictions change.\n * @property {string} type\n *   'trackschanged'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.AdaptationEvent\n * @description Fired when an automatic adaptation causes the active tracks\n *   to change.  Does not fire when the application calls\n *   <code>selectVariantTrack()</code>, <code>selectTextTrack()</code>,\n *   <code>selectAudioLanguage()</code>, or <code>selectTextLanguage()</code>.\n * @property {string} type\n *   'adaptation'\n * @property {shaka.extern.Track} oldTrack\n * @property {shaka.extern.Track} newTrack\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.VariantChangedEvent\n * @description Fired when a call from the application caused a variant change.\n *  Can be triggered by calls to <code>selectVariantTrack()</code> or\n *  <code>selectAudioLanguage()</code>. Does not fire when an automatic\n *  adaptation causes a variant change.\n * @property {string} type\n *   'variantchanged'\n * @property {shaka.extern.Track} oldTrack\n * @property {shaka.extern.Track} newTrack\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TextChangedEvent\n * @description Fired when a call from the application caused a text stream\n *  change. Can be triggered by calls to <code>selectTextTrack()</code> or\n *  <code>selectTextLanguage()</code>.\n * @property {string} type\n *   'textchanged'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.ExpirationUpdatedEvent\n * @description Fired when there is a change in the expiration times of an\n *   EME session.\n * @property {string} type\n *   'expirationupdated'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.LargeGapEvent\n * @description Fired when the playhead enters a large gap.  If the\n *   <code>streaming.jumpLargeGaps</code> configuration is set, the default\n *   action of this event is to jump the gap; this can be prevented by calling\n *   <code>preventDefault()</code> on the event object.\n * @property {string} type\n *   'largegap'\n * @property {number} currentTime\n *   The current time of the playhead.\n * @property {number} gapSize\n *   The size of the gap, in seconds.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.ManifestParsedEvent\n * @description Fired after the manifest has been parsed, but before anything\n *   else happens. The manifest may contain streams that will be filtered out,\n *   at this stage of the loading process.\n * @property {string} type\n *   'manifestparsed'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.MetadataEvent\n * @description Triggers after metadata associated with the stream is found.\n *   Usually they are metadata of type ID3.\n * @property {string} type\n *   'metadata'\n * @property {number} startTime\n *   The time that describes the beginning of the range of the metadata to\n *   which the cue applies.\n * @property {?number} endTime\n *   The time that describes the end of the range of the metadata to which\n *   the cue applies.\n * @property {string} metadataType\n *   Type of metadata. Eg: org.id3 or org.mp4ra\n * @property {shaka.extern.ID3Metadata} payload\n *   The metadata itself\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.StreamingEvent\n * @description Fired after the manifest has been parsed and track information\n *   is available, but before streams have been chosen and before any segments\n *   have been fetched.  You may use this event to configure the player based on\n *   information found in the manifest.\n * @property {string} type\n *   'streaming'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.AbrStatusChangedEvent\n * @description Fired when the state of abr has been changed.\n *    (Enabled or disabled).\n * @property {string} type\n *   'abrstatuschanged'\n * @property {boolean} newStatus\n *  The new status of the application. True for 'is enabled' and\n *  false otherwise.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.RateChangeEvent\n * @description Fired when the video's playback rate changes.\n *    This allows the PlayRateController to update it's internal rate field,\n *    before the UI updates playback button with the newest playback rate.\n * @property {string} type\n *    'ratechange'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.SessionDataEvent\n * @description Fired when the manifest parser find info about session data.\n *    Specification: https://tools.ietf.org/html/rfc8216#section-4.3.4.4\n * @property {string} type\n *   'sessiondata'\n * @property {string} id\n *   The id of the session data.\n * @property {string} uri\n *   The uri with the session data info.\n * @property {string} language\n *   The language of the session data.\n * @property {string} value\n *   The value of the session data.\n * @exportDoc\n */\n\n\n/**\n * @summary The main player object for Shaka Player.\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.Player = class extends shaka.util.FakeEventTarget {\n  /**\n   * @param {HTMLMediaElement=} mediaElement\n   *    When provided, the player will attach to <code>mediaElement</code>,\n   *    similar to calling <code>attach</code>. When not provided, the player\n   *    will remain detached.\n   * @param {function(shaka.Player)=} dependencyInjector Optional callback\n   *   which is called to inject mocks into the Player.  Used for testing.\n   */\n  constructor(mediaElement, dependencyInjector) {\n    super();\n\n    /** @private {shaka.Player.LoadMode} */\n    this.loadMode_ = shaka.Player.LoadMode.NOT_LOADED;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = null;\n\n    /** @private {HTMLElement} */\n    this.videoContainer_ = null;\n\n    /**\n     * Since we may not always have a text displayer created (e.g. before |load|\n     * is called), we need to track what text visibility SHOULD be so that we\n     * can ensure that when we create the text displayer. When we create our\n     * text displayer, we will use this to show (or not show) text as per the\n     * user's requests.\n     *\n     * @private {boolean}\n     */\n    this.isTextVisible_ = false;\n\n    /**\n     * For listeners scoped to the lifetime of the Player instance.\n     * @private {shaka.util.EventManager}\n     */\n    this.globalEventManager_ = new shaka.util.EventManager();\n\n    /**\n     * For listeners scoped to the lifetime of the media element attachment.\n     * @private {shaka.util.EventManager}\n     */\n    this.attachEventManager_ = new shaka.util.EventManager();\n\n    /**\n     * For listeners scoped to the lifetime of the loaded content.\n     * @private {shaka.util.EventManager}\n     */\n    this.loadEventManager_ = new shaka.util.EventManager();\n\n    /** @private {shaka.net.NetworkingEngine} */\n    this.networkingEngine_ = null;\n\n    /** @private {shaka.media.DrmEngine} */\n    this.drmEngine_ = null;\n\n    /** @private {shaka.media.MediaSourceEngine} */\n    this.mediaSourceEngine_ = null;\n\n    /** @private {shaka.media.Playhead} */\n    this.playhead_ = null;\n\n    /**\n     * The playhead observers are used to monitor the position of the playhead\n     * and some other source of data (e.g. buffered content), and raise events.\n     *\n     * @private {shaka.media.PlayheadObserverManager}\n     */\n    this.playheadObservers_ = null;\n\n    /**\n     * This is our control over the playback rate of the media element. This\n     * provides the missing functionality that we need to provide trick play,\n     * for example a negative playback rate.\n     *\n     * @private {shaka.media.PlayRateController}\n     */\n    this.playRateController_ = null;\n\n    // We use the buffering observer and timer to track when we move from having\n    // enough buffered content to not enough. They only exist when content has\n    // been loaded and are not re-used between loads.\n    /** @private {shaka.util.Timer} */\n    this.bufferPoller_ = null;\n\n    /** @private {shaka.media.BufferingObserver} */\n    this.bufferObserver_ = null;\n\n    /** @private {shaka.media.RegionTimeline} */\n    this.regionTimeline_ = null;\n\n    /** @private {shaka.util.CmcdManager} */\n    this.cmcdManager_ = null;\n\n    /** @private {shaka.media.QualityObserver} */\n    this.qualityObserver_ = null;\n\n    /** @private {shaka.media.StreamingEngine} */\n    this.streamingEngine_ = null;\n\n    /** @private {shaka.extern.ManifestParser} */\n    this.parser_ = null;\n\n    /** @private {?shaka.extern.ManifestParser.Factory} */\n    this.parserFactory_ = null;\n\n    /** @private {?shaka.extern.Manifest} */\n    this.manifest_ = null;\n\n    /** @private {?string} */\n    this.assetUri_ = null;\n\n    /** @private {shaka.extern.AbrManager} */\n    this.abrManager_ = null;\n\n    /**\n     * The factory that was used to create the abrManager_ instance.\n     * @private {?shaka.extern.AbrManager.Factory}\n     */\n    this.abrManagerFactory_ = null;\n\n    /**\n     * Contains an ID for use with creating streams.  The manifest parser should\n     * start with small IDs, so this starts with a large one.\n     * @private {number}\n     */\n    this.nextExternalStreamId_ = 1e9;\n\n    /** @private {?shaka.extern.PlayerConfiguration} */\n    this.config_ = this.defaultConfig_();\n\n    /**\n     * The TextDisplayerFactory that was last used to make a text displayer.\n     * Stored so that we can tell if a new type of text displayer is desired.\n     * @private {?shaka.extern.TextDisplayer.Factory}\n     */\n    this.lastTextFactory_;\n\n    /** @private {{width: number, height: number}} */\n    this.maxHwRes_ = {width: Infinity, height: Infinity};\n\n    /** @private {shaka.util.Stats} */\n    this.stats_ = null;\n\n    /** @private {!shaka.media.AdaptationSetCriteria} */\n    this.currentAdaptationSetCriteria_ =\n        new shaka.media.PreferenceBasedCriteria(\n            this.config_.preferredAudioLanguage,\n            this.config_.preferredVariantRole,\n            this.config_.preferredAudioChannelCount);\n\n    /** @private {string} */\n    this.currentTextLanguage_ = this.config_.preferredTextLanguage;\n\n    /** @private {string} */\n    this.currentTextRole_ = this.config_.preferredTextRole;\n\n    /** @private {boolean} */\n    this.currentTextForced_ = this.config_.preferForcedSubs;\n\n    /** @private {!Array.<function():(!Promise|undefined)>} */\n    this.cleanupOnUnload_ = [];\n\n    /**\n     * This playback start position will be used when\n     * <code>updateStartTime()</code> has been called to provide an updated\n     * start position during the media loading process.\n     *\n     * @private {?number}\n     */\n    this.updatedStartTime_ = null;\n\n    if (dependencyInjector) {\n      dependencyInjector(this);\n    }\n\n    this.networkingEngine_ = this.createNetworkingEngine();\n    this.networkingEngine_.setForceHTTPS(this.config_.streaming.forceHTTPS);\n\n    /** @private {shaka.extern.IAdManager} */\n    this.adManager_ = null;\n\n    if (shaka.Player.adManagerFactory_) {\n      this.adManager_ =\n          shaka.util.Functional.callFactory(shaka.Player.adManagerFactory_);\n    }\n\n    // If the browser comes back online after being offline, then try to play\n    // again.\n    this.globalEventManager_.listen(window, 'online', () => {\n      this.retryStreaming();\n    });\n\n    /** @private {shaka.routing.Node} */\n    this.detachNode_ = {name: 'detach'};\n    /** @private {shaka.routing.Node} */\n    this.attachNode_ = {name: 'attach'};\n    /** @private {shaka.routing.Node} */\n    this.unloadNode_ = {name: 'unload'};\n    /** @private {shaka.routing.Node} */\n    this.parserNode_ = {name: 'manifest-parser'};\n    /** @private {shaka.routing.Node} */\n    this.manifestNode_ = {name: 'manifest'};\n    /** @private {shaka.routing.Node} */\n    this.mediaSourceNode_ = {name: 'media-source'};\n    /** @private {shaka.routing.Node} */\n    this.drmNode_ = {name: 'drm-engine'};\n    /** @private {shaka.routing.Node} */\n    this.loadNode_ = {name: 'load'};\n    /** @private {shaka.routing.Node} */\n    this.srcEqualsDrmNode_ = {name: 'src-equals-drm-engine'};\n    /** @private {shaka.routing.Node} */\n    this.srcEqualsNode_ = {name: 'src-equals'};\n\n    const AbortableOperation = shaka.util.AbortableOperation;\n\n    const actions = new Map();\n    actions.set(this.attachNode_, (has, wants) => {\n      return AbortableOperation.notAbortable(this.onAttach_(has, wants));\n    });\n    actions.set(this.detachNode_, (has, wants) => {\n      return AbortableOperation.notAbortable(this.onDetach_(has, wants));\n    });\n    actions.set(this.unloadNode_, (has, wants) => {\n      return AbortableOperation.notAbortable(this.onUnload_(has, wants));\n    });\n    actions.set(this.mediaSourceNode_, (has, wants) => {\n      const p = this.onInitializeMediaSourceEngine_(has, wants);\n      return AbortableOperation.notAbortable(p);\n    });\n    actions.set(this.parserNode_, (has, wants) => {\n      const p = this.onInitializeParser_(has, wants);\n      return AbortableOperation.notAbortable(p);\n    });\n    actions.set(this.manifestNode_, (has, wants) => {\n      // This action is actually abortable, so unlike the other callbacks, this\n      // one will return an abortable operation.\n      return this.onParseManifest_(has, wants);\n    });\n    actions.set(this.drmNode_, (has, wants) => {\n      const p = this.onInitializeDrm_(has, wants);\n      return AbortableOperation.notAbortable(p);\n    });\n    actions.set(this.loadNode_, (has, wants) => {\n      return AbortableOperation.notAbortable(this.onLoad_(has, wants));\n    });\n\n    actions.set(this.srcEqualsDrmNode_, (has, wants) => {\n      const p = this.onInitializeSrcEqualsDrm_(has, wants);\n      return AbortableOperation.notAbortable(p);\n    });\n    actions.set(this.srcEqualsNode_, (has, wants) => {\n      return this.onSrcEquals_(has, wants);\n    });\n\n    /** @private {shaka.routing.Walker.Implementation} */\n    const walkerImplementation = {\n      getNext: (at, has, goingTo, wants) => {\n        return this.getNextStep_(at, has, goingTo, wants);\n      },\n      enterNode: (node, has, wants) => {\n        this.dispatchEvent(this.makeEvent_(\n            /* name= */ shaka.Player.EventName.OnStateChange,\n            /* data= */ (new Map()).set('state', node.name)));\n\n        const action = actions.get(node);\n        return action(has, wants);\n      },\n      handleError: async (has, error) => {\n        shaka.log.warning('The walker saw an error:');\n        if (error instanceof shaka.util.Error) {\n          shaka.log.warning('Error Code:', error.code);\n        } else {\n          shaka.log.warning('Error Message:', error.message);\n          shaka.log.warning('Error Stack:', error.stack);\n        }\n\n        // Regardless of what state we were in, if there is an error, we unload.\n        // This ensures that any initialized system will be torn-down and we\n        // will go back to a safe foundation. We assume that the media element\n        // is always safe to use after an error.\n        await this.onUnload_(has, shaka.Player.createEmptyPayload_());\n\n        // There are only two nodes that come before we start loading content,\n        // attach and detach. If we have a media element, it means we were\n        // attached to the element, and we can safely return to the attach state\n        // (we assume that the video element is always re-usable). We favor\n        // returning to the attach node since it means that the app won't need\n        // to re-attach if it saw an error.\n        return has.mediaElement ? this.attachNode_ : this.detachNode_;\n      },\n      onIdle: (node) => {\n        this.dispatchEvent(this.makeEvent_(\n            /* name= */ shaka.Player.EventName.OnStateIdle,\n            /* data= */ (new Map()).set('state', node.name)));\n      },\n    };\n\n    /** @private {shaka.routing.Walker} */\n    this.walker_ = new shaka.routing.Walker(\n        this.detachNode_,\n        shaka.Player.createEmptyPayload_(),\n        walkerImplementation);\n\n    // Even though |attach| will start in later interpreter cycles, it should be\n    // the LAST thing we do in the constructor because conceptually it relies on\n    // player having been initialized.\n    if (mediaElement) {\n      this.attach(mediaElement, /* initializeMediaSource= */ true);\n    }\n  }\n\n  /**\n   * @param {!shaka.Player.EventName} name\n   * @param {Map.<string, Object>=} data\n   * @return {!shaka.util.FakeEvent}\n   * @private\n   */\n  makeEvent_(name, data) {\n    return new shaka.util.FakeEvent(name, data);\n  }\n\n  /**\n   * After destruction, a Player object cannot be used again.\n   *\n   * @override\n   * @export\n   */\n  async destroy() {\n    // Make sure we only execute the destroy logic once.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return;\n    }\n\n    // Mark as \"dead\". This should stop external-facing calls from changing our\n    // internal state any more. This will stop calls to |attach|, |detach|, etc.\n    // from interrupting our final move to the detached state.\n    this.loadMode_ = shaka.Player.LoadMode.DESTROYED;\n\n    // Because we have set |loadMode_| to |DESTROYED| we can't call |detach|. We\n    // must talk to |this.walker_| directly.\n    const events = this.walker_.startNewRoute((currentPayload) => {\n      return {\n        node: this.detachNode_,\n        payload: shaka.Player.createEmptyPayload_(),\n        interruptible: false,\n      };\n    });\n\n    // Wait until the detach has finished so that we don't interrupt it by\n    // calling |destroy| on |this.walker_|. To avoid failing here, we always\n    // resolve the promise.\n    await new Promise((resolve) => {\n      events.onStart = () => {\n        shaka.log.info('Preparing to destroy walker...');\n      };\n      events.onEnd = () => {\n        resolve();\n      };\n      events.onCancel = () => {\n        goog.asserts.assert(false,\n            'Our final detach call should never be cancelled.');\n        resolve();\n      };\n      events.onError = () => {\n        goog.asserts.assert(false,\n            'Our final detach call should never see an error');\n        resolve();\n      };\n      events.onSkip = () => {\n        goog.asserts.assert(false,\n            'Our final detach call should never be skipped');\n        resolve();\n      };\n    });\n    await this.walker_.destroy();\n\n    // Tear-down the event managers to ensure handlers stop firing.\n    if (this.globalEventManager_) {\n      this.globalEventManager_.release();\n      this.globalEventManager_ = null;\n    }\n    if (this.attachEventManager_) {\n      this.attachEventManager_.release();\n      this.attachEventManager_ = null;\n    }\n    if (this.loadEventManager_) {\n      this.loadEventManager_.release();\n      this.loadEventManager_ = null;\n    }\n\n    this.abrManagerFactory_ = null;\n    this.abrManager_ = null;\n    this.config_ = null;\n    this.stats_ = null;\n    this.videoContainer_ = null;\n    this.cmcdManager_ = null;\n\n    if (this.networkingEngine_) {\n      await this.networkingEngine_.destroy();\n      this.networkingEngine_ = null;\n    }\n\n    // FakeEventTarget implements IReleasable\n    super.release();\n  }\n\n  /**\n   * Registers a plugin callback that will be called with\n   * <code>support()</code>.  The callback will return the value that will be\n   * stored in the return value from <code>support()</code>.\n   *\n   * @param {string} name\n   * @param {function():*} callback\n   * @export\n   */\n  static registerSupportPlugin(name, callback) {\n    shaka.Player.supportPlugins_[name] = callback;\n  }\n\n  /**\n   * Set a factory to create an ad manager during player construction time.\n   * This method needs to be called bafore instantiating the Player class.\n   *\n   * @param {!shaka.extern.IAdManager.Factory} factory\n   * @export\n   */\n  static setAdManagerFactory(factory) {\n    shaka.Player.adManagerFactory_ = factory;\n  }\n\n  /**\n   * Return whether the browser provides basic support.  If this returns false,\n   * Shaka Player cannot be used at all.  In this case, do not construct a\n   * Player instance and do not use the library.\n   *\n   * @return {boolean}\n   * @export\n   */\n  static isBrowserSupported() {\n    if (!window.Promise) {\n      shaka.log.alwaysWarn('A Promise implementation or polyfill is required');\n    }\n\n    // Basic features needed for the library to be usable.\n    const basicSupport = !!window.Promise && !!window.Uint8Array &&\n                         // eslint-disable-next-line no-restricted-syntax\n                         !!Array.prototype.forEach;\n    if (!basicSupport) {\n      return false;\n    }\n\n    // We do not support IE\n    if (shaka.util.Platform.isIE()) {\n      return false;\n    }\n\n    // We do not support iOS 9, 10, or 11, nor those same versions of desktop\n    // Safari.\n    const safariVersion = shaka.util.Platform.safariVersion();\n    if (safariVersion && safariVersion < 12) {\n      return false;\n    }\n\n    // DRM support is not strictly necessary, but the APIs at least need to be\n    // there.  Our no-op DRM polyfill should handle that.\n    // TODO(#1017): Consider making even DrmEngine optional.\n    const drmSupport = shaka.media.DrmEngine.isBrowserSupported();\n    if (!drmSupport) {\n      return false;\n    }\n\n    // If we have MediaSource (MSE) support, we should be able to use Shaka.\n    if (shaka.util.Platform.supportsMediaSource()) {\n      return true;\n    }\n\n    // If we don't have MSE, we _may_ be able to use Shaka.  Look for native HLS\n    // support, and call this platform usable if we have it.\n    return shaka.util.Platform.supportsMediaType('application/x-mpegurl');\n  }\n\n  /**\n   * Probes the browser to determine what features are supported.  This makes a\n   * number of requests to EME/MSE/etc which may result in user prompts.  This\n   * should only be used for diagnostics.\n   *\n   * <p>\n   * NOTE: This may show a request to the user for permission.\n   *\n   * @see https://bit.ly/2ywccmH\n   * @param {boolean=} promptsOkay\n   * @return {!Promise.<shaka.extern.SupportType>}\n   * @export\n   */\n  static async probeSupport(promptsOkay=true) {\n    goog.asserts.assert(shaka.Player.isBrowserSupported(),\n        'Must have basic support');\n    let drm = {};\n    if (promptsOkay) {\n      drm = await shaka.media.DrmEngine.probeSupport();\n    }\n    const manifest = shaka.media.ManifestParser.probeSupport();\n    const media = shaka.media.MediaSourceEngine.probeSupport();\n    const ret = {\n      manifest: manifest,\n      media: media,\n      drm: drm,\n    };\n\n    const plugins = shaka.Player.supportPlugins_;\n    for (const name in plugins) {\n      ret[name] = plugins[name]();\n    }\n\n    return ret;\n  }\n\n  /**\n   * Tell the player to use <code>mediaElement</code> for all <code>load</code>\n   * requests until <code>detach</code> or <code>destroy</code> are called.\n   *\n   * <p>\n   * Calling <code>attach</code> with <code>initializedMediaSource=true</code>\n   * will tell the player to take the initial load step and initialize media\n   * source.\n   *\n   * <p>\n   * Calls to <code>attach</code> will interrupt any in-progress calls to\n   * <code>load</code> but cannot interrupt calls to <code>attach</code>,\n   * <code>detach</code>, or <code>unload</code>.\n   *\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {boolean=} initializeMediaSource\n   * @return {!Promise}\n   * @export\n   */\n  attach(mediaElement, initializeMediaSource = true) {\n    // Do not allow the player to be used after |destroy| is called.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return Promise.reject(this.createAbortLoadError_());\n    }\n\n    const payload = shaka.Player.createEmptyPayload_();\n    payload.mediaElement = mediaElement;\n\n    // If the platform does not support media source, we will never want to\n    // initialize media source.\n    if (!shaka.util.Platform.supportsMediaSource()) {\n      initializeMediaSource = false;\n    }\n\n    const destination = initializeMediaSource ?\n                        this.mediaSourceNode_ :\n                        this.attachNode_;\n\n    // Do not allow this route to be interrupted because calls after this attach\n    // call will depend on the media element being attached.\n    const events = this.walker_.startNewRoute((currentPayload) => {\n      return {\n        node: destination,\n        payload: payload,\n        interruptible: false,\n      };\n    });\n\n    // List to the events that can occur with our request.\n    events.onStart = () => shaka.log.info('Starting attach...');\n    return this.wrapWalkerListenersWithPromise_(events);\n  }\n\n  /**\n   * Tell the player to stop using its current media element. If the player is:\n   * <ul>\n   *  <li>detached, this will do nothing,\n   *  <li>attached, this will release the media element,\n   *  <li>loading, this will abort loading, unload, and release the media\n   *      element,\n   *  <li>playing content, this will stop playback, unload, and release the\n   *      media element.\n   * </ul>\n   *\n   * <p>\n   * Calls to <code>detach</code> will interrupt any in-progress calls to\n   * <code>load</code> but cannot interrupt calls to <code>attach</code>,\n   * <code>detach</code>, or <code>unload</code>.\n   *\n   * @return {!Promise}\n   * @export\n   */\n  detach() {\n    // Do not allow the player to be used after |destroy| is called.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return Promise.reject(this.createAbortLoadError_());\n    }\n\n    // Tell the walker to go \"detached\", but do not allow it to be interrupted.\n    // If it could be interrupted it means that our media element could fall out\n    // of sync.\n    const events = this.walker_.startNewRoute((currentPayload) => {\n      return {\n        node: this.detachNode_,\n        payload: shaka.Player.createEmptyPayload_(),\n        interruptible: false,\n      };\n    });\n\n    events.onStart = () => shaka.log.info('Starting detach...');\n    return this.wrapWalkerListenersWithPromise_(events);\n  }\n\n  /**\n   * Tell the player to either return to:\n   * <ul>\n   *   <li>detached (when it does not have a media element),\n   *   <li>attached (when it has a media element and\n   *     <code>initializedMediaSource=false</code>)\n   *   <li>media source initialized (when it has a media element and\n   *     <code>initializedMediaSource=true</code>)\n   * </ul>\n   *\n   * <p>\n   * Calls to <code>unload</code> will interrupt any in-progress calls to\n   * <code>load</code> but cannot interrupt calls to <code>attach</code>,\n   * <code>detach</code>, or <code>unload</code>.\n   *\n   * @param {boolean=} initializeMediaSource\n   * @return {!Promise}\n   * @export\n   */\n  unload(initializeMediaSource = true) {\n    // Do not allow the player to be used after |destroy| is called.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return Promise.reject(this.createAbortLoadError_());\n    }\n\n    // If the platform does not support media source, we will never want to\n    // initialize media source.\n    if (!shaka.util.Platform.supportsMediaSource()) {\n      initializeMediaSource = false;\n    }\n\n    // Since we are going either to attached or detached (through unloaded), we\n    // can't allow it to be interrupted or else we could lose track of what\n    // media element we are suppose to use.\n    //\n    // Using the current payload, we can determine which node we want to go to.\n    // If we have a media element, we want to go back to attached. If we have no\n    // media element, we want to go back to detached.\n    const payload = shaka.Player.createEmptyPayload_();\n\n    const events = this.walker_.startNewRoute((currentPayload) => {\n      // When someone calls |unload| we can either be before attached or\n      // detached (there is nothing stopping someone from calling |detach| when\n      // we are already detached).\n      //\n      // If we are attached to the correct element, we can tear down the\n      // previous playback components and go to the attached media source node\n      // depending on whether or not the caller wants to pre-init media source.\n      //\n      // If we don't have a media element, we assume that we are already at the\n      // detached node - but only the walker knows that. To ensure we are\n      // actually there, we tell the walker to go to detach. While this is\n      // technically unnecessary, it ensures that we are in the state we want\n      // to be in and ready for the next request.\n      let destination = null;\n\n      if (currentPayload.mediaElement && initializeMediaSource) {\n        destination = this.mediaSourceNode_;\n      } else if (currentPayload.mediaElement) {\n        destination = this.attachNode_;\n      } else {\n        destination = this.detachNode_;\n      }\n\n      goog.asserts.assert(destination, 'We should have picked a destination.');\n\n      // Copy over the media element because we want to keep using the same\n      // element - the other values don't matter.\n      payload.mediaElement = currentPayload.mediaElement;\n\n      return {\n        node: destination,\n        payload: payload,\n        interruptible: false,\n      };\n    });\n\n    events.onStart = () => shaka.log.info('Starting unload...');\n    return this.wrapWalkerListenersWithPromise_(events);\n  }\n\n  /**\n   * Provides a way to update the stream start position during the media loading\n   * process. Can for example be called from the <code>manifestparsed</code>\n   * event handler to update the start position based on information in the\n   * manifest.\n   *\n   * @param {number} startTime\n   * @export\n   */\n  updateStartTime(startTime) {\n    this.updatedStartTime_ = startTime;\n  }\n\n  /**\n   * Tell the player to load the content at <code>assetUri</code> and start\n   * playback at <code>startTime</code>. Before calling <code>load</code>,\n   * a call to <code>attach</code> must have succeeded.\n   *\n   * <p>\n   * Calls to <code>load</code> will interrupt any in-progress calls to\n   * <code>load</code> but cannot interrupt calls to <code>attach</code>,\n   * <code>detach</code>, or <code>unload</code>.\n   *\n   * @param {string} assetUri\n   * @param {?number=} startTime\n   *    When <code>startTime</code> is <code>null</code> or\n   *    <code>undefined</code>, playback will start at the default start time (0\n   *    for VOD and liveEdge for LIVE).\n   * @param {string=} mimeType\n   * @return {!Promise}\n   * @export\n   */\n  load(assetUri, startTime, mimeType) {\n    this.updatedStartTime_ = null;\n\n    // Do not allow the player to be used after |destroy| is called.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return Promise.reject(this.createAbortLoadError_());\n    }\n\n    // We dispatch the loading event when someone calls |load| because we want\n    // to surface the user intent.\n    this.dispatchEvent(this.makeEvent_(shaka.Player.EventName.Loading));\n\n    // Right away we know what the asset uri and start-of-load time are. We will\n    // fill-in the rest of the information later.\n    const payload = shaka.Player.createEmptyPayload_();\n    payload.uri = assetUri;\n    payload.startTimeOfLoad = Date.now() / 1000;\n    if (mimeType) {\n      payload.mimeType = mimeType;\n    }\n\n    // Because we allow |startTime| to be optional, it means that it will be\n    // |undefined| when not provided. This means that we need to re-map\n    // |undefined| to |null| while preserving |0| as a meaningful value.\n    if (startTime !== undefined) {\n      payload.startTime = startTime;\n    }\n\n    // TODO: Refactor to determine whether it's a manifest or not, and whether\n    // or not we can play it.  Then we could return a better error than\n    // UNABLE_TO_GUESS_MANIFEST_TYPE for WebM in Safari.\n    const useSrcEquals = this.shouldUseSrcEquals_(payload);\n    const destination = useSrcEquals ? this.srcEqualsNode_ : this.loadNode_;\n\n    // Allow this request to be interrupted, this will allow other requests to\n    // cancel a load and quickly start a new load.\n    const events = this.walker_.startNewRoute((currentPayload) => {\n      if (currentPayload.mediaElement == null) {\n        // Because we return null, this \"new route\" will not be used.\n        return null;\n      }\n\n      // Keep using whatever media element we have right now.\n      payload.mediaElement = currentPayload.mediaElement;\n\n      return {\n        node: destination,\n        payload: payload,\n        interruptible: true,\n      };\n    });\n\n    // Stats are for a single playback/load session. Stats must be initialized\n    // before we allow calls to |updateStateHistory|.\n    this.stats_ = new shaka.util.Stats();\n\n    // Create the CMCD manager so client data can be attached to all requests\n    this.cmcdManager_ = this.createCmcd_();\n\n    // Load's request is a little different, so we can't use our normal\n    // listeners-to-promise method. It is the only request where we may skip the\n    // request, so we need to set the on skip callback to reject with a specific\n    // error.\n    events.onStart =\n        () => shaka.log.info('Starting load of ' + assetUri + '...');\n    return new Promise((resolve, reject) => {\n      events.onSkip = () => reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.NO_VIDEO_ELEMENT));\n\n      events.onEnd = () => {\n        resolve();\n        // We dispatch the loaded event when the load promise is resolved\n        this.dispatchEvent(this.makeEvent_(shaka.Player.EventName.Loaded));\n      };\n      events.onCancel = () => reject(this.createAbortLoadError_());\n      events.onError = (e) => reject(e);\n    });\n  }\n\n  /**\n   * Check if src= should be used to load the asset at |uri|. Assume that media\n   * source is the default option, and that src= is for special cases.\n   *\n   * @param {shaka.routing.Payload} payload\n   * @return {boolean}\n   *    |true| if the content should be loaded with src=, |false| if the content\n   *    should be loaded with MediaSource.\n   * @private\n   */\n  shouldUseSrcEquals_(payload) {\n    const Platform = shaka.util.Platform;\n    const MimeUtils = shaka.util.MimeUtils;\n\n    // If we are using a platform that does not support media source, we will\n    // fall back to src= to handle all playback.\n    if (!Platform.supportsMediaSource()) {\n      return true;\n    }\n\n    // The most accurate way to tell the player how to load the content is via\n    // MIME type.  We can fall back to features of the URI if needed.\n    let mimeType = payload.mimeType;\n    const uri = payload.uri || '';\n\n    // If we don't have a MIME type, try to guess based on the file extension.\n    // TODO: Too generic to belong to ManifestParser now.  Refactor.\n    if (!mimeType) {\n      // Try using the uri extension.\n      const extension = shaka.media.ManifestParser.getExtension(uri);\n      mimeType = shaka.Player.SRC_EQUAL_EXTENSIONS_TO_MIME_TYPES_[extension];\n    }\n\n    // TODO: The load graph system has a design limitation that requires routing\n    // destination to be chosen synchronously.  This means we can only make the\n    // right choice about src= consistently if we have a well-known file\n    // extension or API-provided MIME type.  Detection of MIME type from a HEAD\n    // request (as is done for manifest types) can't be done yet.\n\n    if (mimeType) {\n      // If we have a MIME type, check if the browser can play it natively.\n      // This will cover both single files and native HLS.\n      const mediaElement = payload.mediaElement || Platform.anyMediaElement();\n      const canPlayNatively = mediaElement.canPlayType(mimeType) != '';\n\n      // If we can't play natively, then src= isn't an option.\n      if (!canPlayNatively) {\n        return false;\n      }\n\n      const canPlayMediaSource =\n          shaka.media.ManifestParser.isSupported(uri, mimeType);\n\n      // If MediaSource isn't an option, the native option is our only chance.\n      if (!canPlayMediaSource) {\n        return true;\n      }\n\n      // If we land here, both are feasible.\n      goog.asserts.assert(canPlayNatively && canPlayMediaSource,\n          'Both native and MSE playback should be possible!');\n\n      // We would prefer MediaSource in some cases, and src= in others.  For\n      // example, Android has native HLS, but we'd prefer our own MediaSource\n      // version there.\n\n      // Native HLS can be preferred on any platform via this flag:\n      if (MimeUtils.isHlsType(mimeType) &&\n          this.config_.streaming.preferNativeHls) {\n        return true;\n      }\n\n      // For Safari, we have an older flag which only applies to this one\n      // browser:\n      if (Platform.isApple()) {\n        return this.config_.streaming.useNativeHlsOnSafari;\n      }\n\n      // In all other cases, we prefer MediaSource.\n      return false;\n    }\n\n    // Unless there are good reasons to use src= (single-file playback or native\n    // HLS), we prefer MediaSource.  So the final return value for choosing src=\n    // is false.\n    return false;\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to attach to\n   * a media element. The only times this may be called are when we are being\n   * asked to re-attach to the current media element, or attach to a new media\n   * element while not attached to a media element.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * Attaching to a media element is defined as:\n   *  - Registering error listeners to the media element.\n   *  - Caching the video element for use outside of the load graph.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  onAttach_(has, wants) {\n    // If we don't have a media element yet, it means we are entering\n    // \"attach\" from another node.\n    //\n    // If we have a media element, it should match |wants.mediaElement|\n    // because it means we are going from \"attach\" to \"attach\".\n    //\n    // These constraints should be maintained and guaranteed by the routing\n    // logic in |getNextStep_|.\n    goog.asserts.assert(\n        has.mediaElement == null || has.mediaElement == wants.mediaElement,\n        'The routing logic failed. MediaElement requirement failed.');\n\n    if (has.mediaElement == null) {\n      has.mediaElement = wants.mediaElement;\n\n      const onError = (error) => this.onVideoError_(error);\n      this.attachEventManager_.listen(has.mediaElement, 'error', onError);\n    }\n\n    this.video_ = has.mediaElement;\n\n    return Promise.resolve();\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to detach from\n   * a media element. The only times this may be called are when we are being\n   * asked to detach from the current media element, or detach when we are\n   * already detached.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * Detaching from a media element is defined as:\n   *  - Removing error listeners from the media element.\n   *  - Dropping the cached reference to the video element.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  onDetach_(has, wants) {\n    // If we were going from \"detached\" to \"detached\" we wouldn't have\n    // a media element to detach from.\n    if (has.mediaElement) {\n      this.attachEventManager_.removeAll();\n      has.mediaElement = null;\n    }\n\n    if (this.adManager_) {\n      // The ad manager is specific to the video, so detach it too.\n      this.adManager_.release();\n    }\n\n    // Clear our cached copy of the media element.\n    this.video_ = null;\n\n    return Promise.resolve();\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to unload all\n   * currently initialized playback components. Unlike the other load actions,\n   * this action is built to be more general. We need to do this because we\n   * don't know what state the player will be in before unloading (including\n   * after an error occurred in the middle of a transition).\n   *\n   * This method assumes that any component could be |null| and should be safe\n   * to call from any point in the load graph.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  async onUnload_(has, wants) {\n    // Set the load mode to unload right away so that all the public methods\n    // will stop using the internal components. We need to make sure that we\n    // are not overriding the destroyed state because we will unload when we are\n    // destroying the player.\n    if (this.loadMode_ != shaka.Player.LoadMode.DESTROYED) {\n      this.loadMode_ = shaka.Player.LoadMode.NOT_LOADED;\n    }\n\n    // Run any general cleanup tasks now.  This should be here at the top, right\n    // after setting loadMode_, so that internal components still exist as they\n    // did when the cleanup tasks were registered in the array.\n    const cleanupTasks = this.cleanupOnUnload_.map((cb) => cb());\n    this.cleanupOnUnload_ = [];\n    await Promise.all(cleanupTasks);\n\n    // Dispatch the unloading event.\n    this.dispatchEvent(this.makeEvent_(shaka.Player.EventName.Unloading));\n\n    // Remove everything that has to do with loading content from our payload\n    // since we are releasing everything that depended on it.\n    has.mimeType = null;\n    has.startTime = null;\n    has.uri = null;\n\n    // Release the region timeline, which is created when parsing the manifest.\n    if (this.regionTimeline_) {\n      this.regionTimeline_.release();\n      this.regionTimeline_ = null;\n    }\n\n    // In most cases we should have a media element. The one exception would\n    // be if there was an error and we, by chance, did not have a media element.\n    if (has.mediaElement) {\n      this.loadEventManager_.removeAll();\n    }\n\n    // Some observers use some playback components, shutting down the observers\n    // first ensures that they don't try to use the playback components\n    // mid-destroy.\n    if (this.playheadObservers_) {\n      this.playheadObservers_.release();\n      this.playheadObservers_ = null;\n    }\n\n    if (this.bufferPoller_) {\n      this.bufferPoller_.stop();\n      this.bufferPoller_ = null;\n    }\n\n    // Stop the parser early. Since it is at the start of the pipeline, it\n    // should be start early to avoid is pushing new data downstream.\n    if (this.parser_) {\n      await this.parser_.stop();\n      this.parser_ = null;\n      this.parserFactory_ = null;\n    }\n\n    // Abr Manager will tell streaming engine what to do, so we need to stop\n    // it before we destroy streaming engine. Unlike with the other components,\n    // we do not release the instance, we will reuse it in later loads.\n    if (this.abrManager_) {\n      await this.abrManager_.stop();\n    }\n\n    // Streaming engine will push new data to media source engine, so we need\n    // to shut it down before destroy media source engine.\n    if (this.streamingEngine_) {\n      await this.streamingEngine_.destroy();\n      this.streamingEngine_ = null;\n    }\n\n    if (this.playRateController_) {\n      this.playRateController_.release();\n      this.playRateController_ = null;\n    }\n\n    // Playhead is used by StreamingEngine, so we can't destroy this until after\n    // StreamingEngine has stopped.\n    if (this.playhead_) {\n      this.playhead_.release();\n      this.playhead_ = null;\n    }\n\n    // Media source engine holds onto the media element, and in order to detach\n    // the media keys (with drm engine), we need to break the connection between\n    // media source engine and the media element.\n    if (this.mediaSourceEngine_) {\n      await this.mediaSourceEngine_.destroy();\n      this.mediaSourceEngine_ = null;\n    }\n\n    if (this.adManager_) {\n      this.adManager_.onAssetUnload();\n    }\n\n    // In order to unload a media element, we need to remove the src attribute\n    // and then load again. When we destroy media source engine, this will be\n    // done for us, but for src=, we need to do it here.\n    //\n    // DrmEngine requires this to be done before we destroy DrmEngine itself.\n    if (has.mediaElement && has.mediaElement.src) {\n      // TODO: Investigate this more.  Only reproduces on Firefox 69.\n      // Introduce a delay before detaching the video source.  We are seeing\n      // spurious Promise rejections involving an AbortError in our tests\n      // otherwise.\n      await new Promise(\n          (resolve) => new shaka.util.Timer(resolve).tickAfter(0.1));\n\n      has.mediaElement.removeAttribute('src');\n      has.mediaElement.load();\n      // Remove all track nodes\n      while (has.mediaElement.lastChild) {\n        has.mediaElement.removeChild(has.mediaElement.firstChild);\n      }\n    }\n\n    if (this.drmEngine_) {\n      await this.drmEngine_.destroy();\n      this.drmEngine_ = null;\n    }\n\n    this.assetUri_ = null;\n    this.bufferObserver_ = null;\n\n    if (this.manifest_) {\n      for (const variant of this.manifest_.variants) {\n        for (const stream of [variant.audio, variant.video]) {\n          if (stream && stream.segmentIndex) {\n            stream.segmentIndex.release();\n          }\n        }\n      }\n      for (const stream of this.manifest_.textStreams) {\n        if (stream.segmentIndex) {\n          stream.segmentIndex.release();\n        }\n      }\n    }\n\n    this.manifest_ = null;\n    this.stats_ = new shaka.util.Stats(); // Replace with a clean stats object.\n    this.lastTextFactory_ = null;\n\n    // Make sure that the app knows of the new buffering state.\n    this.updateBufferState_();\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to initialize\n   * media source engine. The only time this may be called is when we are\n   * attached to the same media element as in the request.\n   *\n   * This method assumes that it is safe for it to execute. The load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async onInitializeMediaSourceEngine_(has, wants) {\n    goog.asserts.assert(\n        shaka.util.Platform.supportsMediaSource(),\n        'We should not be initializing media source on a platform that does ' +\n            'not support media source.');\n    goog.asserts.assert(\n        has.mediaElement,\n        'We should have a media element when initializing media source.');\n    goog.asserts.assert(\n        has.mediaElement == wants.mediaElement,\n        '|has| and |wants| should have the same media element when ' +\n            'initializing media source.');\n\n    goog.asserts.assert(\n        this.mediaSourceEngine_ == null,\n        'We should not have a media source engine yet.');\n\n    const closedCaptionsParser = new shaka.media.ClosedCaptionParser();\n\n    // When changing text visibility we need to update both the text displayer\n    // and streaming engine because we don't always stream text. To ensure that\n    // text displayer and streaming engine are always in sync, wait until they\n    // are both initialized before setting the initial value.\n    const textDisplayerFactory = this.config_.textDisplayFactory;\n    const textDisplayer =\n        shaka.util.Functional.callFactory(textDisplayerFactory);\n    this.lastTextFactory_ = textDisplayerFactory;\n\n    const mediaSourceEngine = this.createMediaSourceEngine(\n        has.mediaElement,\n        closedCaptionsParser,\n        textDisplayer,\n        (metadata, offset, endTime) => {\n          this.processTimedMetadataMediaSrc_(metadata, offset, endTime);\n        });\n\n    // Wait for media source engine to finish opening. This promise should\n    // NEVER be rejected as per the media source engine implementation.\n    await mediaSourceEngine.open();\n\n    // Wait until it is ready to actually store the reference.\n    this.mediaSourceEngine_ = mediaSourceEngine;\n  }\n\n  /**\n   * Create the parser for the asset located at |wants.uri|. This should only be\n   * called as part of the load graph.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  async onInitializeParser_(has, wants) {\n    goog.asserts.assert(\n        has.mediaElement,\n        'We should have a media element when initializing the parser.');\n    goog.asserts.assert(\n        has.mediaElement == wants.mediaElement,\n        '|has| and |wants| should have the same media element when ' +\n            'initializing the parser.');\n\n    goog.asserts.assert(\n        this.networkingEngine_,\n        'Need networking engine when initializing the parser.');\n    goog.asserts.assert(\n        this.config_,\n        'Need player config when initializing the parser.');\n\n    // We are going to \"lock-in\" the mime type and uri since they are\n    // what we are going to use to create our parser and parse the manifest.\n    has.mimeType = wants.mimeType;\n    has.uri = wants.uri;\n\n    goog.asserts.assert(\n        has.uri,\n        'We should have an asset uri when initializing the parsing.');\n\n    // Store references to things we asserted so that we don't need to reassert\n    // them again later.\n    const assetUri = has.uri;\n    const networkingEngine = this.networkingEngine_;\n\n    // Save the uri so that it can be used outside of the load-graph.\n    this.assetUri_ = assetUri;\n\n    // Create the parser that we will use to parse the manifest.\n    this.parserFactory_ = await shaka.media.ManifestParser.getFactory(\n        assetUri,\n        networkingEngine,\n        this.config_.manifest.retryParameters,\n        has.mimeType);\n    goog.asserts.assert(this.parserFactory_, 'Must have manifest parser');\n    this.parser_ = shaka.util.Functional.callFactory(this.parserFactory_);\n\n    const manifestConfig =\n        shaka.util.ObjectUtils.cloneObject(this.config_.manifest);\n    // Don't read video segments if the player is attached to an audio element\n    if (wants.mediaElement && wants.mediaElement.nodeName === 'AUDIO') {\n      manifestConfig.disableVideo = true;\n    }\n\n    this.parser_.configure(manifestConfig);\n  }\n\n  /**\n   * Parse the manifest at |has.uri| using the parser that should have already\n   * been created. This should only be called as part of the load graph.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!shaka.util.AbortableOperation}\n   * @private\n   */\n  onParseManifest_(has, wants) {\n    goog.asserts.assert(\n        has.mimeType == wants.mimeType,\n        '|has| and |wants| should have the same mime type when parsing.');\n    goog.asserts.assert(\n        has.uri == wants.uri,\n        '|has| and |wants| should have the same uri when parsing.');\n\n    goog.asserts.assert(\n        has.uri,\n        '|has| should have a valid uri when parsing.');\n    goog.asserts.assert(\n        has.uri == this.assetUri_,\n        '|has.uri| should match the cached asset uri.');\n\n    goog.asserts.assert(\n        this.networkingEngine_,\n        'Need networking engine to parse manifest.');\n    goog.asserts.assert(\n        this.cmcdManager_,\n        'Need CMCD manager to populate manifest request data.');\n    goog.asserts.assert(\n        this.config_,\n        'Need player config to parse manifest.');\n\n    goog.asserts.assert(\n        this.parser_,\n        '|this.parser_| should have been set in an earlier step.');\n\n    // Store references to things we asserted so that we don't need to reassert\n    // them again later.\n    const assetUri = has.uri;\n    const networkingEngine = this.networkingEngine_;\n\n    // This will be needed by the parser once it starts parsing, so we will\n    // initialize it now even through it appears a little out-of-place.\n    this.regionTimeline_ =\n        new shaka.media.RegionTimeline(() => this.seekRange());\n    this.regionTimeline_.addEventListener('regionadd', (event) => {\n      /** @type {shaka.extern.TimelineRegionInfo} */\n      const region = event['region'];\n      this.onRegionEvent_(shaka.Player.EventName.TimelineRegionAdded, region);\n\n      if (this.adManager_) {\n        this.adManager_.onDashTimedMetadata(region);\n      }\n    });\n\n    this.qualityObserver_ = null;\n    if (this.config_.streaming.observeQualityChanges) {\n      this.qualityObserver_ = new shaka.media.QualityObserver(\n          () => this.getBufferedInfo());\n\n      this.qualityObserver_.addEventListener('qualitychange', (event) => {\n        /** @type {shaka.extern.MediaQualityInfo} */\n        const mediaQualityInfo = event['quality'];\n        /** @type {number} */\n        const position = event['position'];\n        this.onMediaQualityChange_(mediaQualityInfo, position);\n      });\n    }\n\n    const playerInterface = {\n      networkingEngine: networkingEngine,\n      modifyManifestRequest: (request, manifestInfo) => {\n        this.cmcdManager_.applyManifestData(request, manifestInfo);\n      },\n      modifySegmentRequest: (request, segmentInfo) => {\n        this.cmcdManager_.applySegmentData(request, segmentInfo);\n      },\n      filter: (manifest) => this.filterManifest_(manifest),\n      makeTextStreamsForClosedCaptions: (manifest) => {\n        return this.makeTextStreamsForClosedCaptions_(manifest);\n      },\n\n      // Called when the parser finds a timeline region. This can be called\n      // before we start playback or during playback (live/in-progress\n      // manifest).\n      onTimelineRegionAdded: (region) => this.regionTimeline_.addRegion(region),\n\n      onEvent: (event) => this.dispatchEvent(event),\n      onError: (error) => this.onError_(error),\n      isLowLatencyMode: () => this.isLowLatencyMode_(),\n      isAutoLowLatencyMode: () => this.isAutoLowLatencyMode_(),\n      enableLowLatencyMode: () => {\n        this.configure('streaming.lowLatencyMode', true);\n      },\n    };\n\n    const startTime = Date.now() / 1000;\n\n    return new shaka.util.AbortableOperation(/* promise= */ (async () => {\n      this.manifest_ = await this.parser_.start(assetUri, playerInterface);\n\n      // This event is fired after the manifest is parsed, but before any\n      // filtering takes place.\n      const event = this.makeEvent_(shaka.Player.EventName.ManifestParsed);\n      this.dispatchEvent(event);\n\n      // We require all manifests to have at least one variant.\n      if (this.manifest_.variants.length == 0) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.NO_VARIANTS);\n      }\n\n      // Make sure that all variants are either: audio-only, video-only, or\n      // audio-video.\n      shaka.Player.filterForAVVariants_(this.manifest_);\n\n      const now = Date.now() / 1000;\n      const delta = now - startTime;\n      this.stats_.setManifestTime(delta);\n    })(), /* onAbort= */ () => {\n      shaka.log.info('Aborting parser step...');\n      return this.parser_.stop();\n    });\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to initialize\n   * drmEngine. The only time this may be called is when we are attached a\n   * media element and have parsed a manifest.\n   *\n   * The load-graph is responsible for ensuring all assumptions made by this\n   * method are valid before executing it.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  async onInitializeDrm_(has, wants) {\n    goog.asserts.assert(\n        has.mimeType == wants.mimeType,\n        'The load graph should have ensured the mime types matched.');\n    goog.asserts.assert(\n        has.uri == wants.uri,\n        'The load graph should have ensured the uris matched');\n\n    goog.asserts.assert(\n        this.networkingEngine_,\n        '|onInitializeDrm_| should never be called after |destroy|');\n    goog.asserts.assert(\n        this.config_,\n        '|onInitializeDrm_| should never be called after |destroy|');\n    goog.asserts.assert(\n        this.manifest_,\n        '|this.manifest_| should have been set in an earlier step.');\n    goog.asserts.assert(\n        has.mediaElement,\n        'We should have a media element when initializing the DRM Engine.');\n\n    const startTime = Date.now() / 1000;\n    let firstEvent = true;\n\n    this.drmEngine_ = this.createDrmEngine({\n      netEngine: this.networkingEngine_,\n      onError: (e) => {\n        this.onError_(e);\n      },\n      onKeyStatus: (map) => {\n        this.onKeyStatus_(map);\n      },\n      onExpirationUpdated: (id, expiration) => {\n        this.onExpirationUpdated_(id, expiration);\n      },\n      onEvent: (e) => {\n        this.dispatchEvent(e);\n        if (e.type == shaka.Player.EventName.DrmSessionUpdate && firstEvent) {\n          firstEvent = false;\n          const now = Date.now() / 1000;\n          const delta = now - startTime;\n          this.stats_.setDrmTime(delta);\n        }\n      },\n    });\n\n    this.drmEngine_.configure(this.config_.drm);\n\n    await this.drmEngine_.initForPlayback(\n        this.manifest_.variants,\n        this.manifest_.offlineSessionIds);\n\n    await this.drmEngine_.attach(has.mediaElement);\n\n    // Now that we have drm information, filter the manifest (again) so that we\n    // can ensure we only use variants with the selected key system.\n    await this.filterManifest_(this.manifest_);\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to load all\n   * playback components needed for playback. The only times this may be called\n   * is when we are attached to the same media element as in the request.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * Loading is defined as:\n   *  - Attaching all playback-related listeners to the media element\n   *  - Initializing playback and observers\n   *  - Initializing ABR Manager\n   *  - Initializing Streaming Engine\n   *  - Starting playback at |wants.startTime|\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @private\n   */\n  async onLoad_(has, wants) {\n    goog.asserts.assert(\n        has.mimeType == wants.mimeType,\n        '|has| and |wants| should have the same mime type when loading.');\n    goog.asserts.assert(\n        has.uri == wants.uri,\n        '|has| and |wants| should have the same uri when loading.');\n\n    goog.asserts.assert(\n        has.mediaElement,\n        'We should have a media element when loading.');\n    goog.asserts.assert(\n        !isNaN(wants.startTimeOfLoad),\n        '|wants| should tell us when the load was originally requested');\n\n    // Since we are about to start playback, we will lock in the start time as\n    // something we are now depending on.\n    has.startTime = wants.startTime;\n\n    // If updateStartTime() has been called since load() was invoked use the\n    // requested startTime\n    if (this.updatedStartTime_ != null) {\n      has.startTime = this.updatedStartTime_;\n      this.updatedStartTime_ = null;\n    }\n\n    // Store a reference to values in |has| after asserting so that closure will\n    // know that they will still be non-null between calls to await.\n    const mediaElement = has.mediaElement;\n    const assetUri = has.uri;\n\n    // Save the uri so that it can be used outside of the load-graph.\n    this.assetUri_ = assetUri;\n\n    this.playRateController_ = new shaka.media.PlayRateController({\n      getRate: () => mediaElement.playbackRate,\n      getDefaultRate: () => mediaElement.defaultPlaybackRate,\n      setRate: (rate) => { mediaElement.playbackRate = rate; },\n      movePlayhead: (delta) => { mediaElement.currentTime += delta; },\n    });\n\n    const updateStateHistory = () => this.updateStateHistory_();\n    const onRateChange = () => this.onRateChange_();\n    this.loadEventManager_.listen(mediaElement, 'playing', updateStateHistory);\n    this.loadEventManager_.listen(mediaElement, 'pause', updateStateHistory);\n    this.loadEventManager_.listen(mediaElement, 'ended', updateStateHistory);\n    this.loadEventManager_.listen(mediaElement, 'ratechange', onRateChange);\n\n    const abrFactory = this.config_.abrFactory;\n    if (!this.abrManager_ || this.abrManagerFactory_ != abrFactory) {\n      this.abrManagerFactory_ = abrFactory;\n      this.abrManager_ = shaka.util.Functional.callFactory(abrFactory);\n      if (typeof this.abrManager_.playbackRateChanged != 'function') {\n        shaka.Deprecate.deprecateFeature(4,\n            'AbrManager',\n            'Please use an AbrManager with playbackRateChanged function.');\n        this.abrManager_.playbackRateChanged = (rate) => {};\n      }\n      this.abrManager_.configure(this.config_.abr);\n    }\n\n    // Copy preferred languages from the config again, in case the config was\n    // changed between construction and playback.\n    this.currentAdaptationSetCriteria_ =\n        new shaka.media.PreferenceBasedCriteria(\n            this.config_.preferredAudioLanguage,\n            this.config_.preferredVariantRole,\n            this.config_.preferredAudioChannelCount);\n\n    this.currentTextLanguage_ = this.config_.preferredTextLanguage;\n    this.currentTextRole_ = this.config_.preferredTextRole;\n    this.currentTextForced_ = this.config_.preferForcedSubs;\n\n    shaka.Player.applyPlayRange_(this.manifest_.presentationTimeline,\n        this.config_.playRangeStart,\n        this.config_.playRangeEnd);\n\n    this.abrManager_.init((variant, clearBuffer, safeMargin) => {\n      return this.switch_(variant, clearBuffer, safeMargin);\n    });\n\n    this.playhead_ = this.createPlayhead(has.startTime);\n    this.playheadObservers_ = this.createPlayheadObserversForMSE_();\n\n    // We need to start the buffer management code near the end because it will\n    // set the initial buffering state and that depends on other components\n    // being initialized.\n    const rebufferThreshold = Math.max(\n        this.manifest_.minBufferTime, this.config_.streaming.rebufferingGoal);\n    this.startBufferManagement_(rebufferThreshold);\n\n    // If the content is multi-codec and the browser can play more than one of\n    // them, choose codecs now before we initialize streaming.\n    shaka.util.StreamUtils.chooseCodecsAndFilterManifest(\n        this.manifest_,\n        this.config_.preferredVideoCodecs,\n        this.config_.preferredAudioCodecs,\n        this.config_.preferredAudioChannelCount,\n        this.config_.preferredDecodingAttributes);\n\n    this.streamingEngine_ = this.createStreamingEngine();\n    this.streamingEngine_.configure(this.config_.streaming);\n\n    // Set the load mode to \"loaded with media source\" as late as possible so\n    // that public methods won't try to access internal components until\n    // they're all initialized. We MUST switch to loaded before calling\n    // \"streaming\" so that they can access internal information.\n    this.loadMode_ = shaka.Player.LoadMode.MEDIA_SOURCE;\n\n    if (mediaElement.textTracks) {\n      this.loadEventManager_.listen(\n          mediaElement.textTracks, 'addtrack', (e) => {\n            const trackEvent = /** @type {!TrackEvent} */(e);\n            if (trackEvent.track) {\n              const track = trackEvent.track;\n              goog.asserts.assert(\n                  track instanceof TextTrack, 'Wrong track type!');\n\n              switch (track.kind) {\n                case 'chapters':\n                  this.activateChaptersTrack_(track);\n                  break;\n              }\n            }\n          });\n    }\n\n    // The event must be fired after we filter by restrictions but before the\n    // active stream is picked to allow those listening for the \"streaming\"\n    // event to make changes before streaming starts.\n    this.dispatchEvent(this.makeEvent_(shaka.Player.EventName.Streaming));\n\n    // Pick the initial streams to play.\n    // however, we would skip switch to initial variant\n    // if user already pick variant track (via selectVariantTrack api)\n    let initialVariant = null;\n    const activeVariantTrack = this.getVariantTracks().find((t) => t.active);\n\n    if (!activeVariantTrack) {\n      initialVariant = this.chooseVariant_();\n      goog.asserts.assert(initialVariant, 'Must choose an initial variant!');\n      this.switchVariant_(initialVariant, /* fromAdaptation= */ true,\n          /* clearBuffer= */ false, /* safeMargin= */ 0);\n\n      // Now that we have initial streams, we may adjust the start time to align\n      // to a segment boundary.\n      if (this.config_.streaming.startAtSegmentBoundary) {\n        const startTime = this.playhead_.getTime();\n        const adjustedTime =\n            await this.adjustStartTime_(initialVariant, startTime);\n\n        this.playhead_.setStartTime(adjustedTime);\n      }\n\n      // Since the first streams just became active, send an adaptation event.\n      this.onAdaptation_(null,\n          shaka.util.StreamUtils.variantToTrack(initialVariant));\n    }\n\n    this.playhead_.ready();\n\n    // Decide if text should be shown automatically.\n    // similar to video/audio track, we would skip switch initial text track\n    // if user already pick text track (via selectTextTrack api)\n    const activeTextTrack = this.getTextTracks().find((t) => t.active);\n\n    if (!activeTextTrack) {\n      const initialTextStream = this.chooseTextStream_();\n\n      if (initialTextStream) {\n        this.addTextStreamToSwitchHistory_(\n            initialTextStream, /* fromAdaptation= */ true);\n      }\n\n      if (initialVariant) {\n        this.setInitialTextState_(initialVariant, initialTextStream);\n      }\n\n      // Don't initialize with a text stream unless we should be streaming text.\n      if (initialTextStream && this.shouldStreamText_()) {\n        this.streamingEngine_.switchTextStream(initialTextStream);\n      }\n    }\n\n\n    // Start streaming content. This will start the flow of content down to\n    // media source.\n    await this.streamingEngine_.start();\n\n    if (this.config_.abr.enabled) {\n      this.abrManager_.enable();\n      this.onAbrStatusChanged_();\n    }\n\n    // Re-filter the manifest after streams have been chosen.\n    this.filterManifestByCurrentVariant_();\n    // Dispatch a 'trackschanged' event now that all initial filtering is done.\n    this.onTracksChanged_();\n\n    // Now that we've filtered out variants that aren't compatible with the\n    // active one, update abr manager with filtered variants.\n    // NOTE: This may be unnecessary.  We've already chosen one codec in\n    // chooseCodecsAndFilterManifest_ before we started streaming.  But it\n    // doesn't hurt, and this will all change when we start using\n    // MediaCapabilities and codec switching.\n    // TODO(#1391): Re-evaluate with MediaCapabilities and codec switching.\n    this.updateAbrManagerVariants_();\n\n    const hasPrimary = this.manifest_.variants.some((v) => v.primary);\n    if (!this.config_.preferredAudioLanguage && !hasPrimary) {\n      shaka.log.warning('No preferred audio language set.  We have chosen an ' +\n                        'arbitrary language initially');\n    }\n\n    // Wait for the 'loadedmetadata' event to measure load() latency.\n    this.loadEventManager_.listenOnce(mediaElement, 'loadedmetadata', () => {\n      const now = Date.now() / 1000;\n      const delta = now - wants.startTimeOfLoad;\n      this.stats_.setLoadLatency(delta);\n    });\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to initialize\n   * drmEngine for src= playbacks.\n   *\n   * The load-graph is responsible for ensuring all assumptions made by this\n   * method are valid before executing it.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  async onInitializeSrcEqualsDrm_(has, wants) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    goog.asserts.assert(\n        this.networkingEngine_,\n        '|onInitializeSrcEqualsDrm_| should never be called after |destroy|');\n    goog.asserts.assert(\n        this.config_,\n        '|onInitializeSrcEqualsDrm_| should never be called after |destroy|');\n\n    const startTime = Date.now() / 1000;\n    let firstEvent = true;\n\n    this.drmEngine_ = this.createDrmEngine({\n      netEngine: this.networkingEngine_,\n      onError: (e) => {\n        this.onError_(e);\n      },\n      onKeyStatus: (map) => {\n        this.onKeyStatus_(map);\n      },\n      onExpirationUpdated: (id, expiration) => {\n        this.onExpirationUpdated_(id, expiration);\n      },\n      onEvent: (e) => {\n        this.dispatchEvent(e);\n        if (e.type == shaka.Player.EventName.DrmSessionUpdate && firstEvent) {\n          firstEvent = false;\n          const now = Date.now() / 1000;\n          const delta = now - startTime;\n          this.stats_.setDrmTime(delta);\n        }\n      },\n    });\n\n    this.drmEngine_.configure(this.config_.drm);\n\n    const uri = wants.uri || '';\n    const extension = shaka.media.ManifestParser.getExtension(uri);\n    let mimeType = shaka.Player.SRC_EQUAL_EXTENSIONS_TO_MIME_TYPES_[extension];\n    if (mimeType == 'application/x-mpegurl' && shaka.util.Platform.isApple()) {\n      mimeType = 'application/vnd.apple.mpegurl';\n    }\n    if (!mimeType) {\n      mimeType = 'video/mp4';\n    }\n\n    // TODO: Instead of feeding DrmEngine with Variants, we should refactor\n    // DrmEngine so that it takes a minimal config derived from Variants.  In\n    // cases like this one or in removal of stored content, the details are\n    // largely unimportant.  We should have a saner way to initialize DrmEngine.\n    // That would also insulate DrmEngine from manifest changes in the future.\n    // For now, that is time-consuming and this synthetic Variant is easy, so\n    // I'm putting it off.  Since this is only expected to be used for native\n    // HLS in Safari, this should be safe. -JCP\n    /** @type {shaka.extern.Variant} */\n    const variant = {\n      id: 0,\n      language: 'und',\n      primary: false,\n      audio: null,\n      video: {\n        id: 0,\n        originalId: null,\n        createSegmentIndex: () => Promise.resolve(),\n        segmentIndex: null,\n        mimeType: wants.mimeType ?\n            shaka.util.MimeUtils.getBasicType(wants.mimeType) : mimeType,\n        codecs: wants.mimeType ?\n            shaka.util.MimeUtils.getCodecs(wants.mimeType) : '',\n        encrypted: true,\n        drmInfos: [],  // Filled in by DrmEngine config.\n        keyIds: new Set(),\n        language: 'und',\n        label: null,\n        type: ContentType.VIDEO,\n        primary: false,\n        trickModeVideo: null,\n        emsgSchemeIdUris: null,\n        roles: [],\n        forced: false,\n        channelsCount: null,\n        audioSamplingRate: null,\n        spatialAudio: false,\n        closedCaptions: null,\n      },\n      bandwidth: 100,\n      allowedByApplication: true,\n      allowedByKeySystem: true,\n      decodingInfos: [],\n    };\n\n    this.drmEngine_.setSrcEquals(/* srcEquals= */ true);\n    await this.drmEngine_.initForPlayback(\n        [variant], /* offlineSessionIds= */ []);\n    await this.drmEngine_.attach(has.mediaElement);\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to set-up the\n   * media element to play content using src=. The only times this may be called\n   * is when we are attached to the same media element as in the request.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!shaka.util.AbortableOperation}\n   *\n   * @private\n   */\n  onSrcEquals_(has, wants) {\n    goog.asserts.assert(\n        has.mediaElement,\n        'We should have a media element when loading.');\n    goog.asserts.assert(\n        wants.uri,\n        '|has| should have a valid uri when loading.');\n    goog.asserts.assert(\n        !isNaN(wants.startTimeOfLoad),\n        '|wants| should tell us when the load was originally requested');\n    goog.asserts.assert(\n        this.video_ == has.mediaElement,\n        'The video element should match our media element');\n\n    // Lock-in the values that we are using so that the routing logic knows what\n    // we have.\n    has.uri = wants.uri;\n    has.startTime = wants.startTime;\n\n    // Save the uri so that it can be used outside of the load-graph.\n    this.assetUri_ = has.uri;\n\n    const mediaElement = has.mediaElement;\n\n    this.playhead_ = new shaka.media.SrcEqualsPlayhead(mediaElement);\n\n    // This flag is used below in the language preference setup to check if\n    // this load was canceled before the necessary awaits completed.\n    let unloaded = false;\n    this.cleanupOnUnload_.push(() => {\n      unloaded = true;\n    });\n\n    if (has.startTime != null) {\n      this.playhead_.setStartTime(has.startTime);\n    }\n\n    this.playRateController_ = new shaka.media.PlayRateController({\n      getRate: () => mediaElement.playbackRate,\n      getDefaultRate: () => mediaElement.defaultPlaybackRate,\n      setRate: (rate) => { mediaElement.playbackRate = rate; },\n      movePlayhead: (delta) => { mediaElement.currentTime += delta; },\n    });\n\n    // We need to start the buffer management code near the end because it will\n    // set the initial buffering state and that depends on other components\n    // being initialized.\n    const rebufferThreshold = this.config_.streaming.rebufferingGoal;\n    this.startBufferManagement_(rebufferThreshold);\n\n    // Add all media element listeners.\n    const updateStateHistory = () => this.updateStateHistory_();\n    const onRateChange = () => this.onRateChange_();\n    this.loadEventManager_.listen(mediaElement, 'playing', updateStateHistory);\n    this.loadEventManager_.listen(mediaElement, 'pause', updateStateHistory);\n    this.loadEventManager_.listen(mediaElement, 'ended', updateStateHistory);\n    this.loadEventManager_.listen(mediaElement, 'ratechange', onRateChange);\n\n    // Wait for the 'loadedmetadata' event to measure load() latency, but only\n    // if preload is set in a way that would result in this event firing\n    // automatically.\n    // See https://github.com/shaka-project/shaka-player/issues/2483\n    if (mediaElement.preload != 'none') {\n      this.loadEventManager_.listenOnce(mediaElement, 'loadedmetadata', () => {\n        const now = Date.now() / 1000;\n        const delta = now - wants.startTimeOfLoad;\n        this.stats_.setLoadLatency(delta);\n      });\n    }\n\n    // The audio tracks are only available on Safari at the moment, but this\n    // drives the tracks API for Safari's native HLS. So when they change,\n    // fire the corresponding Shaka Player event.\n    if (mediaElement.audioTracks) {\n      this.loadEventManager_.listen(\n          mediaElement.audioTracks, 'addtrack', () => this.onTracksChanged_());\n      this.loadEventManager_.listen(\n          mediaElement.audioTracks, 'removetrack',\n          () => this.onTracksChanged_());\n      this.loadEventManager_.listen(\n          mediaElement.audioTracks, 'change', () => this.onTracksChanged_());\n    }\n\n    if (mediaElement.textTracks) {\n      this.loadEventManager_.listen(\n          mediaElement.textTracks, 'addtrack', (e) => {\n            const trackEvent = /** @type {!TrackEvent} */(e);\n            if (trackEvent.track) {\n              const track = trackEvent.track;\n              goog.asserts.assert(\n                  track instanceof TextTrack, 'Wrong track type!');\n\n              switch (track.kind) {\n                case 'metadata':\n                  this.processTimedMetadataSrcEqls_(track);\n                  break;\n\n                case 'chapters':\n                  this.activateChaptersTrack_(track);\n                  break;\n\n                default:\n                  this.onTracksChanged_();\n                  break;\n              }\n            }\n          });\n\n      this.loadEventManager_.listen(\n          mediaElement.textTracks, 'removetrack',\n          () => this.onTracksChanged_());\n      this.loadEventManager_.listen(\n          mediaElement.textTracks, 'change',\n          () => this.onTracksChanged_());\n    }\n\n    const extension = shaka.media.ManifestParser.getExtension(has.uri);\n    const mimeType =\n      shaka.Player.SRC_EQUAL_EXTENSIONS_TO_MIME_TYPES_[extension];\n\n    // By setting |src| we are done \"loading\" with src=. We don't need to set\n    // the current time because |playhead| will do that for us.\n    mediaElement.src = this.cmcdManager_.appendSrcData(has.uri, mimeType);\n\n    // Tizen 3 / WebOS won't load anything unless you call load() explicitly,\n    // no matter the value of the preload attribute.  This is harmful on some\n    // other platforms by triggering unbounded loading of media data, but is\n    // necessary here.\n    if (shaka.util.Platform.isTizen() || shaka.util.Platform.isWebOS()) {\n      mediaElement.load();\n    }\n\n    // Set the load mode last so that we know that all our components are\n    // initialized.\n    this.loadMode_ = shaka.Player.LoadMode.SRC_EQUALS;\n\n    // The event doesn't mean as much for src= playback, since we don't control\n    // streaming.  But we should fire it in this path anyway since some\n    // applications may be expecting it as a life-cycle event.\n    this.dispatchEvent(this.makeEvent_(shaka.Player.EventName.Streaming));\n\n    // The \"load\" Promise is resolved when we have loaded the metadata.  If we\n    // wait for the full data, that won't happen on Safari until the play button\n    // is hit.\n    const fullyLoaded = new shaka.util.PublicPromise();\n    shaka.util.MediaReadyState.waitForReadyState(mediaElement,\n        HTMLMediaElement.HAVE_METADATA,\n        this.loadEventManager_,\n        () => {\n          this.playhead_.ready();\n          fullyLoaded.resolve();\n        });\n\n    // We can't switch to preferred languages, though, until the data is loaded.\n    shaka.util.MediaReadyState.waitForReadyState(mediaElement,\n        HTMLMediaElement.HAVE_CURRENT_DATA,\n        this.loadEventManager_,\n        async () => {\n          this.setupPreferredAudioOnSrc_();\n\n          // Applying the text preference too soon can result in it being\n          // reverted.  Wait for native HLS to pick something first.\n          const textTracks = this.getFilteredTextTracks_();\n          if (!textTracks.find((t) => t.mode != 'disabled')) {\n            await new Promise((resolve) => {\n              this.loadEventManager_.listenOnce(\n                  mediaElement.textTracks, 'change', resolve);\n\n              // We expect the event to fire because it does on Safari.\n              // But in case it doesn't on some other platform or future\n              // version, move on in 1 second no matter what.  This keeps the\n              // language settings from being completely ignored if something\n              // goes wrong.\n              new shaka.util.Timer(resolve).tickAfter(1);\n            });\n          } else if (textTracks.length > 0) {\n            this.isTextVisible_ = true;\n          }\n\n          // If we have moved on to another piece of content while waiting for\n          // the above event/timer, we should not change tracks here.\n          if (unloaded) {\n            return;\n          }\n\n          this.setupPreferredTextOnSrc_();\n        });\n\n    if (mediaElement.error) {\n      // Already failed!\n      fullyLoaded.reject(this.videoErrorToShakaError_());\n    } else if (mediaElement.preload == 'none') {\n      shaka.log.alwaysWarn(\n          'With <video preload=\"none\">, the browser will not load anything ' +\n          'until play() is called. We are unable to measure load latency in ' +\n          'a meaningful way, and we cannot provide track info yet. Please do ' +\n          'not use preload=\"none\" with Shaka Player.');\n      // We can't wait for an event load loadedmetadata, since that will be\n      // blocked until a user interaction.  So resolve the Promise now.\n      fullyLoaded.resolve();\n    }\n\n    this.loadEventManager_.listenOnce(mediaElement, 'error', () => {\n      fullyLoaded.reject(this.videoErrorToShakaError_());\n    });\n\n    return new shaka.util.AbortableOperation(fullyLoaded, /* onAbort= */ () => {\n      const abortedError = new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED);\n      fullyLoaded.reject(abortedError);\n      return Promise.resolve();  // Abort complete.\n    });\n  }\n\n  /**\n   * This method setup the preferred audio using src=..\n   *\n   * @private\n   */\n  setupPreferredAudioOnSrc_() {\n    const preferredAudioLanguage = this.config_.preferredAudioLanguage;\n\n    // If the user has not selected a preference, the browser preference is\n    // left.\n    if (preferredAudioLanguage == '') {\n      return;\n    }\n\n    this.selectAudioLanguage(preferredAudioLanguage);\n\n    const preferredVariantRole = this.config_.preferredVariantRole;\n\n    // If the user has not selected a role preference, the previous match is\n    // selected.\n    if (preferredVariantRole == '') {\n      return;\n    }\n\n    this.selectAudioLanguage(preferredAudioLanguage, preferredVariantRole);\n  }\n\n  /**\n   * This method setup the preferred text using src=.\n   *\n   * @private\n   */\n  setupPreferredTextOnSrc_() {\n    const preferredTextLanguage = this.config_.preferredTextLanguage;\n    const preferForcedSubs = this.config_.preferForcedSubs;\n\n    // If the user has not selected a preference, the browser preference is\n    // left.\n    if (preferredTextLanguage == '') {\n      return;\n    }\n\n    this.selectTextLanguage(preferredTextLanguage, '', preferForcedSubs);\n\n    const preferredTextRole = this.config_.preferredTextRole;\n\n    // If the user has not selected a role preference, the previous match is\n    // selected.\n    if (preferredTextRole == '') {\n      return;\n    }\n\n    this.selectTextLanguage(preferredTextLanguage, preferredTextRole,\n        preferForcedSubs);\n  }\n\n  /**\n   * We're looking for metadata tracks to process id3 tags. One of the uses is\n   * for ad info on LIVE streams\n   *\n   * @param {!TextTrack} track\n   * @private\n   */\n  processTimedMetadataSrcEqls_(track) {\n    if (track.kind != 'metadata') {\n      return;\n    }\n\n    // Hidden mode is required for the cuechange event to launch correctly\n    track.mode = 'hidden';\n    this.loadEventManager_.listen(track, 'cuechange', () => {\n      if (!track.activeCues) {\n        return;\n      }\n\n      for (const cue of track.activeCues) {\n        this.dispatchMetadataEvent_(cue.startTime, cue.endTime,\n            cue.type, cue.value);\n\n        if (this.adManager_) {\n          this.adManager_.onCueMetadataChange(cue.value);\n        }\n      }\n    });\n\n    // In Safari the initial assignment does not always work, so we schedule\n    // this process to be repeated several times to ensure that it has been put\n    // in the correct mode.\n    const timer = new shaka.util.Timer(() => {\n      const textTracks = this.getMetadataTracks_();\n      for (const textTrack of textTracks) {\n        textTrack.mode = 'hidden';\n      }\n    }).tickNow().tickAfter(0.5);\n\n    this.cleanupOnUnload_.push(() => {\n      timer.stop();\n    });\n  }\n\n\n  /**\n   * @param {!Array.<shaka.extern.ID3Metadata>} metadata\n   * @param {number} offset\n   * @param {?number} segmentEndTime\n   * @private\n   */\n  processTimedMetadataMediaSrc_(metadata, offset, segmentEndTime) {\n    for (const sample of metadata) {\n      if (sample['data'] && sample['cueTime'] && sample['frames']) {\n        const start = sample['cueTime'] + offset;\n        const end = segmentEndTime;\n        const metadataType = 'ID3';\n        for (const frame of sample['frames']) {\n          const payload = frame;\n          this.dispatchMetadataEvent_(start, end, metadataType, payload);\n        }\n\n        if (this.adManager_) {\n          this.adManager_.onHlsTimedMetadata(sample, start);\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Construct and fire a Player.Metadata event\n   *\n   * @param {number} startTime\n   * @param {?number} endTime\n   * @param {string} metadataType\n   * @param {shaka.extern.ID3Metadata} payload\n   * @private\n   */\n  dispatchMetadataEvent_(startTime, endTime, metadataType, payload) {\n    goog.asserts.assert(!endTime || startTime <= endTime,\n        'Metadata start time should be less or equal to the end time!');\n    const eventName = shaka.Player.EventName.Metadata;\n    const data = new Map()\n        .set('startTime', startTime)\n        .set('endTime', endTime)\n        .set('metadataType', metadataType)\n        .set('payload', payload);\n    this.dispatchEvent(this.makeEvent_(eventName, data));\n  }\n\n  /**\n   * Set the mode on a chapters track so that it loads.\n   *\n   * @param {?TextTrack} track\n   * @private\n   */\n  activateChaptersTrack_(track) {\n    if (!track || track.kind != 'chapters') {\n      return;\n    }\n\n    // Hidden mode is required for the cuechange event to launch correctly and\n    // get the cues and the activeCues\n    track.mode = 'hidden';\n\n    // In Safari the initial assignment does not always work, so we schedule\n    // this process to be repeated several times to ensure that it has been put\n    // in the correct mode.\n    const timer = new shaka.util.Timer(() => {\n      track.mode = 'hidden';\n    }).tickNow().tickAfter(0.5);\n\n    this.cleanupOnUnload_.push(() => {\n      timer.stop();\n    });\n  }\n\n  /**\n   * Take a series of variants and ensure that they only contain one type of\n   * variant. The different options are:\n   *  1. Audio-Video\n   *  2. Audio-Only\n   *  3. Video-Only\n   *\n   * A manifest can only contain a single type because once we initialize media\n   * source to expect specific streams, it must always have content for those\n   * streams. If we were to start with audio+video and switch to an audio-only\n   * variant, media source would block waiting for video content.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @private\n   */\n  static filterForAVVariants_(manifest) {\n    const isAVVariant = (variant) => {\n      // Audio-video variants may include both streams separately or may be\n      // single multiplexed streams with multiple codecs.\n      return (variant.video && variant.audio) ||\n             (variant.video && variant.video.codecs.includes(','));\n    };\n    if (manifest.variants.some(isAVVariant)) {\n      shaka.log.debug('Found variant with audio and video content, ' +\n          'so filtering out audio-only content.');\n      manifest.variants = manifest.variants.filter(isAVVariant);\n    }\n  }\n\n  /**\n   * Create a new DrmEngine instance. This may be replaced by tests to create\n   * fake instances. Configuration and initialization will be handled after\n   * |createDrmEngine|.\n   *\n   * @param {shaka.media.DrmEngine.PlayerInterface} playerInterface\n   * @return {!shaka.media.DrmEngine}\n   */\n  createDrmEngine(playerInterface) {\n    const updateExpirationTime = this.config_.drm.updateExpirationTime;\n    return new shaka.media.DrmEngine(playerInterface, updateExpirationTime);\n  }\n\n  /**\n   * Creates a new instance of NetworkingEngine.  This can be replaced by tests\n   * to create fake instances instead.\n   *\n   * @return {!shaka.net.NetworkingEngine}\n   */\n  createNetworkingEngine() {\n    /** @type {function(number, number)} */\n    const onProgressUpdated_ = (deltaTimeMs, bytesDownloaded) => {\n      // In some situations, such as during offline storage, the abr manager\n      // might not yet exist. Therefore, we need to check if abr manager has\n      // been initialized before using it.\n      if (this.abrManager_) {\n        this.abrManager_.segmentDownloaded(deltaTimeMs, bytesDownloaded);\n      }\n    };\n    /** @type {shaka.net.NetworkingEngine.OnHeadersReceived} */\n    const onHeadersReceived_ = (headers, request, requestType) => {\n      // Release a 'downloadheadersreceived' event.\n      const name = shaka.Player.EventName.DownloadHeadersReceived;\n      const data = new Map()\n          .set('headers', headers)\n          .set('request', request)\n          .set('requestType', requestType);\n      this.dispatchEvent(this.makeEvent_(name, data));\n    };\n    /** @type {shaka.net.NetworkingEngine.OnDownloadFailed} */\n    const onDownloadFailed_ = (request, error, httpResponseCode, aborted) => {\n      // Release a 'downloadfailed' event.\n      const name = shaka.Player.EventName.DownloadFailed;\n      const data = new Map()\n          .set('request', request)\n          .set('error', error)\n          .set('httpResponseCode', httpResponseCode)\n          .set('aborted', aborted);\n      this.dispatchEvent(this.makeEvent_(name, data));\n    };\n\n    return new shaka.net.NetworkingEngine(\n        onProgressUpdated_, onHeadersReceived_, onDownloadFailed_);\n  }\n\n  /**\n   * Creates a new instance of Playhead.  This can be replaced by tests to\n   * create fake instances instead.\n   *\n   * @param {?number} startTime\n   * @return {!shaka.media.Playhead}\n   */\n  createPlayhead(startTime) {\n    goog.asserts.assert(this.manifest_, 'Must have manifest');\n    goog.asserts.assert(this.video_, 'Must have video');\n    return new shaka.media.MediaSourcePlayhead(\n        this.video_,\n        this.manifest_,\n        this.config_.streaming,\n        startTime,\n        () => this.onSeek_(),\n        (event) => this.dispatchEvent(event));\n  }\n\n  /**\n   * Create the observers for MSE playback. These observers are responsible for\n   * notifying the app and player of specific events during MSE playback.\n   *\n   * @return {!shaka.media.PlayheadObserverManager}\n   * @private\n   */\n  createPlayheadObserversForMSE_() {\n    goog.asserts.assert(this.manifest_, 'Must have manifest');\n    goog.asserts.assert(this.regionTimeline_, 'Must have region timeline');\n    goog.asserts.assert(this.video_, 'Must have video element');\n\n    // Create the region observer. This will allow us to notify the app when we\n    // move in and out of timeline regions.\n    const regionObserver = new shaka.media.RegionObserver(this.regionTimeline_);\n\n    regionObserver.addEventListener('enter', (event) => {\n      /** @type {shaka.extern.TimelineRegionInfo} */\n      const region = event['region'];\n      this.onRegionEvent_(shaka.Player.EventName.TimelineRegionEnter, region);\n    });\n\n    regionObserver.addEventListener('exit', (event) => {\n      /** @type {shaka.extern.TimelineRegionInfo} */\n      const region = event['region'];\n      this.onRegionEvent_(shaka.Player.EventName.TimelineRegionExit, region);\n    });\n\n    regionObserver.addEventListener('skip', (event) => {\n      /** @type {shaka.extern.TimelineRegionInfo} */\n      const region = event['region'];\n      /** @type {boolean} */\n      const seeking = event['seeking'];\n      // If we are seeking, we don't want to surface the enter/exit events since\n      // they didn't play through them.\n      if (!seeking) {\n        this.onRegionEvent_(shaka.Player.EventName.TimelineRegionEnter, region);\n        this.onRegionEvent_(shaka.Player.EventName.TimelineRegionExit, region);\n      }\n    });\n\n    // Now that we have all our observers, create a manager for them.\n    const manager = new shaka.media.PlayheadObserverManager(this.video_);\n    manager.manage(regionObserver);\n    if (this.qualityObserver_) {\n      manager.manage(this.qualityObserver_);\n    }\n    return manager;\n  }\n\n  /**\n   * Initialize and start the buffering system (observer and timer) so that we\n   * can monitor our buffer lead during playback.\n   *\n   * @param {number} rebufferingGoal\n   * @private\n   */\n  startBufferManagement_(rebufferingGoal) {\n    goog.asserts.assert(\n        !this.bufferObserver_,\n        'No buffering observer should exist before initialization.');\n\n    goog.asserts.assert(\n        !this.bufferPoller_,\n        'No buffer timer should exist before initialization.');\n\n    // Give dummy values, will be updated below.\n    this.bufferObserver_ = new shaka.media.BufferingObserver(1, 2);\n\n    // Force us back to a buffering state. This ensure everything is starting in\n    // the same state.\n    this.bufferObserver_.setState(shaka.media.BufferingObserver.State.STARVING);\n    this.updateBufferingSettings_(rebufferingGoal);\n    this.updateBufferState_();\n\n    // TODO: We should take some time to look into the effects of our\n    //       quarter-second refresh practice. We often use a quarter-second\n    //       but we have no documentation about why.\n    this.bufferPoller_ = new shaka.util.Timer(() => {\n      this.pollBufferState_();\n    }).tickEvery(/* seconds= */ 0.25);\n  }\n\n  /**\n   * Updates the buffering thresholds based on the new rebuffering goal.\n   *\n   * @param {number} rebufferingGoal\n   * @private\n   */\n  updateBufferingSettings_(rebufferingGoal) {\n    // The threshold to transition back to satisfied when starving.\n    const starvingThreshold = rebufferingGoal;\n    // The threshold to transition into starving when satisfied.\n    // We use a \"typical\" threshold, unless the rebufferingGoal is unusually\n    // low.\n    // Then we force the value down to half the rebufferingGoal, since\n    // starvingThreshold must be strictly larger than satisfiedThreshold for the\n    // logic in BufferingObserver to work correctly.\n    const satisfiedThreshold = Math.min(\n        shaka.Player.TYPICAL_BUFFERING_THRESHOLD_, rebufferingGoal / 2);\n\n    this.bufferObserver_.setThresholds(starvingThreshold, satisfiedThreshold);\n  }\n\n  /**\n   * This method is called periodically to check what the buffering observer\n   * says so that we can update the rest of the buffering behaviours.\n   *\n   * @private\n   */\n  pollBufferState_() {\n    goog.asserts.assert(\n        this.video_,\n        'Need a media element to update the buffering observer');\n\n    goog.asserts.assert(\n        this.bufferObserver_,\n        'Need a buffering observer to update');\n\n    let bufferedToEnd;\n    switch (this.loadMode_) {\n      case shaka.Player.LoadMode.SRC_EQUALS:\n        bufferedToEnd = this.isBufferedToEndSrc_();\n        break;\n      case shaka.Player.LoadMode.MEDIA_SOURCE:\n        bufferedToEnd = this.isBufferedToEndMS_();\n        break;\n      default:\n        bufferedToEnd = false;\n        break;\n    }\n\n    const bufferLead = shaka.media.TimeRangesUtils.bufferedAheadOf(\n        this.video_.buffered,\n        this.video_.currentTime);\n\n    const stateChanged = this.bufferObserver_.update(bufferLead, bufferedToEnd);\n\n    // If the state changed, we need to surface the event.\n    if (stateChanged) {\n      this.updateBufferState_();\n    }\n  }\n\n  /**\n   * Create a new media source engine. This will ONLY be replaced by tests as a\n   * way to inject fake media source engine instances.\n   *\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {!shaka.media.IClosedCaptionParser} closedCaptionsParser\n   * @param {!shaka.extern.TextDisplayer} textDisplayer\n   * @param {!function(!Array.<shaka.extern.ID3Metadata>, number, ?number)}\n   *  onMetadata\n   *\n   * @return {!shaka.media.MediaSourceEngine}\n   */\n  createMediaSourceEngine(mediaElement, closedCaptionsParser, textDisplayer,\n      onMetadata) {\n    return new shaka.media.MediaSourceEngine(\n        mediaElement, closedCaptionsParser, textDisplayer, onMetadata);\n  }\n\n  /**\n   * Create a new CMCD manager.\n   *\n   * @private\n   */\n  createCmcd_() {\n    /** @type {shaka.util.CmcdManager.PlayerInterface} */\n    const playerInterface = {\n      getBandwidthEstimate: () => this.abrManager_ ?\n        this.abrManager_.getBandwidthEstimate() : NaN,\n      getBufferedInfo: () => this.getBufferedInfo(),\n      getCurrentTime: () => this.video_ ? this.video_.currentTime : 0,\n      getVariantTracks: () => this.getVariantTracks(),\n      getPlaybackRate: () => this.getPlaybackRate(),\n      isLive: () => this.isLive(),\n    };\n\n    return new shaka.util.CmcdManager(playerInterface, this.config_.cmcd);\n  }\n\n  /**\n   * Creates a new instance of StreamingEngine.  This can be replaced by tests\n   * to create fake instances instead.\n   *\n   * @return {!shaka.media.StreamingEngine}\n   */\n  createStreamingEngine() {\n    goog.asserts.assert(\n        this.playhead_ && this.abrManager_ && this.mediaSourceEngine_ &&\n        this.cmcdManager_ && this.manifest_,\n        'Must not be destroyed');\n\n    /** @type {shaka.media.StreamingEngine.PlayerInterface} */\n    const playerInterface = {\n      getPresentationTime: () => this.playhead_.getTime(),\n      getBandwidthEstimate: () => this.abrManager_.getBandwidthEstimate(),\n      modifySegmentRequest: (request, segmentInfo) => {\n        this.cmcdManager_.applySegmentData(request, segmentInfo);\n      },\n      mediaSourceEngine: this.mediaSourceEngine_,\n      netEngine: this.networkingEngine_,\n      onError: (error) => this.onError_(error),\n      onEvent: (event) => this.dispatchEvent(event),\n      onManifestUpdate: () => this.onManifestUpdate_(),\n      onSegmentAppended: () => this.onSegmentAppended_(),\n      onInitSegmentAppended: (position, initSegment) => {\n        const mediaQuality = initSegment.getMediaQuality();\n        if (mediaQuality && this.qualityObserver_) {\n          this.qualityObserver_.addMediaQualityChange(mediaQuality, position);\n        }\n      },\n    };\n\n    return new shaka.media.StreamingEngine(this.manifest_, playerInterface);\n  }\n\n  /**\n   * Changes configuration settings on the Player.  This checks the names of\n   * keys and the types of values to avoid coding errors.  If there are errors,\n   * this logs them to the console and returns false.  Correct fields are still\n   * applied even if there are other errors.  You can pass an explicit\n   * <code>undefined</code> value to restore the default value.  This has two\n   * modes of operation:\n   *\n   * <p>\n   * First, this can be passed a single \"plain\" object.  This object should\n   * follow the {@link shaka.extern.PlayerConfiguration} object.  Not all fields\n   * need to be set; unset fields retain their old values.\n   *\n   * <p>\n   * Second, this can be passed two arguments.  The first is the name of the key\n   * to set.  This should be a '.' separated path to the key.  For example,\n   * <code>'streaming.alwaysStreamText'</code>.  The second argument is the\n   * value to set.\n   *\n   * @param {string|!Object} config This should either be a field name or an\n   *   object.\n   * @param {*=} value In the second mode, this is the value to set.\n   * @return {boolean} True if the passed config object was valid, false if\n   *   there were invalid entries.\n   * @export\n   */\n  configure(config, value) {\n    goog.asserts.assert(this.config_, 'Config must not be null!');\n    goog.asserts.assert(typeof(config) == 'object' || arguments.length == 2,\n        'String configs should have values!');\n\n    // ('fieldName', value) format\n    if (arguments.length == 2 && typeof(config) == 'string') {\n      config = shaka.util.ConfigUtils.convertToConfigObject(config, value);\n    }\n\n    goog.asserts.assert(typeof(config) == 'object', 'Should be an object!');\n\n    // Deprecate 'manifest.dash.defaultPresentationDelay' configuration.\n    if (config['manifest'] && config['manifest']['dash'] &&\n          'defaultPresentationDelay' in config['manifest']['dash']) {\n      shaka.Deprecate.deprecateFeature(4,\n          'manifest.dash.defaultPresentationDelay configuration',\n          'Please Use manifest.defaultPresentationDelay instead.');\n      config['manifest']['defaultPresentationDelay'] =\n          config['manifest']['dash']['defaultPresentationDelay'];\n      delete config['manifest']['dash']['defaultPresentationDelay'];\n    }\n\n    // If lowLatencyMode is enabled, and inaccurateManifestTolerance and\n    // rebufferingGoal are not specified, set inaccurateManifestTolerance to 0\n    // and rebufferingGoal to 0.01 by default for low latency streaming.\n    if (config['streaming'] && config['streaming']['lowLatencyMode']) {\n      if (config['streaming']['inaccurateManifestTolerance'] == undefined) {\n        config['streaming']['inaccurateManifestTolerance'] = 0;\n      }\n      if (config['streaming']['rebufferingGoal'] == undefined) {\n        config['streaming']['rebufferingGoal'] = 0.01;\n      }\n    }\n    const ret = shaka.util.PlayerConfiguration.mergeConfigObjects(\n        this.config_, config, this.defaultConfig_());\n\n    this.applyConfig_();\n    return ret;\n  }\n\n  /**\n   * Apply config changes.\n   * @private\n   */\n  applyConfig_() {\n    if (this.parser_) {\n      const manifestConfig =\n          shaka.util.ObjectUtils.cloneObject(this.config_.manifest);\n      // Don't read video segments if the player is attached to an audio element\n      if (this.video_ && this.video_.nodeName === 'AUDIO') {\n        manifestConfig.disableVideo = true;\n      }\n      this.parser_.configure(manifestConfig);\n    }\n    if (this.drmEngine_) {\n      this.drmEngine_.configure(this.config_.drm);\n    }\n    if (this.streamingEngine_) {\n      this.streamingEngine_.configure(this.config_.streaming);\n\n      // Need to apply the restrictions.\n      try {\n        // this.filterManifestWithRestrictions_() may throw.\n        this.filterManifestWithRestrictions_(this.manifest_);\n      } catch (error) {\n        this.onError_(error);\n      }\n\n      if (this.abrManager_) {\n        // Update AbrManager variants to match these new settings.\n        this.updateAbrManagerVariants_();\n      }\n\n      // If the streams we are playing are restricted, we need to switch.\n      const activeVariant = this.streamingEngine_.getCurrentVariant();\n      if (activeVariant) {\n        if (!activeVariant.allowedByApplication ||\n            !activeVariant.allowedByKeySystem) {\n          shaka.log.debug('Choosing new variant after changing configuration');\n          this.chooseVariantAndSwitch_();\n        }\n      }\n    }\n    if (this.networkingEngine_) {\n      this.networkingEngine_.setForceHTTPS(this.config_.streaming.forceHTTPS);\n    }\n\n    if (this.mediaSourceEngine_) {\n      const textDisplayerFactory = this.config_.textDisplayFactory;\n      if (this.lastTextFactory_ != textDisplayerFactory) {\n        const displayer =\n            shaka.util.Functional.callFactory(textDisplayerFactory);\n        this.mediaSourceEngine_.setTextDisplayer(displayer);\n        this.lastTextFactory_ = textDisplayerFactory;\n\n        if (this.streamingEngine_) {\n          // Reload the text stream, so the cues will load again.\n          this.streamingEngine_.reloadTextStream();\n        }\n      }\n    }\n    if (this.abrManager_) {\n      this.abrManager_.configure(this.config_.abr);\n      // Simply enable/disable ABR with each call, since multiple calls to these\n      // methods have no effect.\n      if (this.config_.abr.enabled) {\n        this.abrManager_.enable();\n      } else {\n        this.abrManager_.disable();\n      }\n\n      this.onAbrStatusChanged_();\n    }\n    if (this.bufferObserver_) {\n      let rebufferThreshold = this.config_.streaming.rebufferingGoal;\n      if (this.manifest_) {\n        rebufferThreshold =\n            Math.max(rebufferThreshold, this.manifest_.minBufferTime);\n      }\n      this.updateBufferingSettings_(rebufferThreshold);\n    }\n\n    if (this.manifest_) {\n      shaka.Player.applyPlayRange_(this.manifest_.presentationTimeline,\n          this.config_.playRangeStart,\n          this.config_.playRangeEnd);\n    }\n  }\n\n  /**\n   * Return a copy of the current configuration.  Modifications of the returned\n   * value will not affect the Player's active configuration.  You must call\n   * <code>player.configure()</code> to make changes.\n   *\n   * @return {shaka.extern.PlayerConfiguration}\n   * @export\n   */\n  getConfiguration() {\n    goog.asserts.assert(this.config_, 'Config must not be null!');\n\n    const ret = this.defaultConfig_();\n    shaka.util.PlayerConfiguration.mergeConfigObjects(\n        ret, this.config_, this.defaultConfig_());\n    return ret;\n  }\n\n  /**\n   * Return a reference to the current configuration. Modifications to the\n   * returned value will affect the Player's active configuration. This method\n   * is not exported as sharing configuration with external objects is not\n   * supported.\n   *\n   * @return {shaka.extern.PlayerConfiguration}\n   */\n  getSharedConfiguration() {\n    goog.asserts.assert(\n        this.config_, 'Cannot call getSharedConfiguration after call destroy!');\n    return this.config_;\n  }\n\n  /**\n   * Returns the ratio of video length buffered compared to buffering Goal\n   * @return {number}\n   * @export\n   */\n  getBufferFullness() {\n    if (this.video_) {\n      const bufferedLength = this.video_.buffered.length;\n      const bufferedEnd =\n          bufferedLength ? this.video_.buffered.end(bufferedLength - 1) : 0;\n      const bufferingGoal = this.getConfiguration().streaming.bufferingGoal;\n      const lengthToBeBuffered = Math.min(this.video_.currentTime +\n          bufferingGoal, this.seekRange().end);\n\n      if (bufferedEnd >= lengthToBeBuffered) {\n        return 1;\n      } else if (bufferedEnd <= this.video_.currentTime) {\n        return 0;\n      } else if (bufferedEnd < lengthToBeBuffered) {\n        return ((bufferedEnd - this.video_.currentTime) /\n            (lengthToBeBuffered - this.video_.currentTime));\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * Reset configuration to default.\n   * @export\n   */\n  resetConfiguration() {\n    goog.asserts.assert(this.config_, 'Cannot be destroyed');\n    // Remove the old keys so we remove open-ended dictionaries like drm.servers\n    // but keeps the same object reference.\n    for (const key in this.config_) {\n      delete this.config_[key];\n    }\n\n    shaka.util.PlayerConfiguration.mergeConfigObjects(\n        this.config_, this.defaultConfig_(), this.defaultConfig_());\n    this.applyConfig_();\n  }\n\n  /**\n   * Get the current load mode.\n   *\n   * @return {shaka.Player.LoadMode}\n   * @export\n   */\n  getLoadMode() {\n    return this.loadMode_;\n  }\n\n  /**\n   * Get the media element that the player is currently using to play loaded\n   * content. If the player has not loaded content, this will return\n   * <code>null</code>.\n   *\n   * @return {HTMLMediaElement}\n   * @export\n   */\n  getMediaElement() {\n    return this.video_;\n  }\n\n  /**\n   * @return {shaka.net.NetworkingEngine} A reference to the Player's networking\n   *     engine.  Applications may use this to make requests through Shaka's\n   *     networking plugins.\n   * @export\n   */\n  getNetworkingEngine() {\n    return this.networkingEngine_;\n  }\n\n  /**\n   * Get the uri to the asset that the player has loaded. If the player has not\n   * loaded content, this will return <code>null</code>.\n   *\n   * @return {?string}\n   * @export\n   */\n  getAssetUri() {\n    return this.assetUri_;\n  }\n\n  /**\n   * Returns a shaka.ads.AdManager instance, responsible for Dynamic\n   * Ad Insertion functionality.\n   *\n   * @return {shaka.extern.IAdManager}\n   * @export\n   */\n  getAdManager() {\n    // NOTE: this clause is redundant, but it keeps the compiler from\n    // inlining this function. Inlining leads to setting the adManager\n    // not taking effect in the compiled build.\n    // Closure has a @noinline flag, but apparently not all cases are\n    // supported by it, and ours isn't.\n    // If they expand support, we might be able to get rid of this\n    // clause.\n    if (!this.adManager_) {\n      return null;\n    }\n\n    return this.adManager_;\n  }\n\n  /**\n   * Get if the player is playing live content. If the player has not loaded\n   * content, this will return <code>false</code>.\n   *\n   * @return {boolean}\n   * @export\n   */\n  isLive() {\n    if (this.manifest_) {\n      return this.manifest_.presentationTimeline.isLive();\n    }\n\n    // For native HLS, the duration for live streams seems to be Infinity.\n    if (this.video_ && this.video_.src) {\n      return this.video_.duration == Infinity;\n    }\n\n    return false;\n  }\n\n  /**\n   * Get if the player is playing in-progress content. If the player has not\n   * loaded content, this will return <code>false</code>.\n   *\n   * @return {boolean}\n   * @export\n   */\n  isInProgress() {\n    return this.manifest_ ?\n           this.manifest_.presentationTimeline.isInProgress() :\n           false;\n  }\n\n  /**\n   * Check if the manifest contains only audio-only content. If the player has\n   * not loaded content, this will return <code>false</code>.\n   *\n   * <p>\n   * The player does not support content that contain more than one type of\n   * variants (i.e. mixing audio-only, video-only, audio-video). Content will be\n   * filtered to only contain one type of variant.\n   *\n   * @return {boolean}\n   * @export\n   */\n  isAudioOnly() {\n    if (this.manifest_) {\n      const variants = this.manifest_.variants;\n      if (!variants.length) {\n        return false;\n      }\n\n      // Note that if there are some audio-only variants and some audio-video\n      // variants, the audio-only variants are removed during filtering.\n      // Therefore if the first variant has no video, that's sufficient to say\n      // it is audio-only content.\n      return !variants[0].video;\n    } else if (this.video_ && this.video_.src) {\n      // If we have video track info, use that.  It will be the least\n      // error-prone way with native HLS.  In contrast, videoHeight might be\n      // unset until the first frame is loaded.  Since isAudioOnly is queried\n      // by the UI on the 'trackschanged' event, the videoTracks info should be\n      // up-to-date.\n      if (this.video_.videoTracks) {\n        return this.video_.videoTracks.length == 0;\n      }\n\n      // We cast to the more specific HTMLVideoElement to access videoHeight.\n      // This might be an audio element, though, in which case videoHeight will\n      // be undefined at runtime.  For audio elements, this will always return\n      // true.\n      const video = /** @type {HTMLVideoElement} */(this.video_);\n      return video.videoHeight == 0;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Return the value of lowLatencyMode configuration.\n   * @return {boolean}\n   * @private\n   */\n  isLowLatencyMode_() {\n    return this.config_.streaming.lowLatencyMode;\n  }\n\n  /**\n   * Return the value of autoLowLatencyMode configuration.\n   * @return {boolean}\n   * @private\n   */\n  isAutoLowLatencyMode_() {\n    return this.config_.streaming.autoLowLatencyMode;\n  }\n\n  /**\n   * Get the range of time (in seconds) that seeking is allowed. If the player\n   * has not loaded content, this will return a range from 0 to 0.\n   *\n   * @return {{start: number, end: number}}\n   * @export\n   */\n  seekRange() {\n    if (this.manifest_) {\n      const timeline = this.manifest_.presentationTimeline;\n\n      return {\n        'start': timeline.getSeekRangeStart(),\n        'end': timeline.getSeekRangeEnd(),\n      };\n    }\n\n    // If we have loaded content with src=, we ask the video element for its\n    // seekable range.  This covers both plain mp4s and native HLS playbacks.\n    if (this.video_ && this.video_.src) {\n      const seekable = this.video_.seekable;\n      if (seekable.length) {\n        return {\n          'start': seekable.start(0),\n          'end': seekable.end(seekable.length - 1),\n        };\n      }\n    }\n\n    return {'start': 0, 'end': 0};\n  }\n\n  /**\n   * Go to live in a live stream.\n   *\n   * @export\n   */\n  goToLive() {\n    if (this.isLive()) {\n      this.video_.currentTime = this.seekRange().end;\n    } else {\n      shaka.log.warning('goToLive is for live streams!');\n    }\n  }\n\n  /**\n   * Get the key system currently used by EME. If EME is not being used, this\n   * will return an empty string. If the player has not loaded content, this\n   * will return an empty string.\n   *\n   * @return {string}\n   * @export\n   */\n  keySystem() {\n    return shaka.media.DrmEngine.keySystem(this.drmInfo());\n  }\n\n  /**\n   * Get the drm info used to initialize EME. If EME is not being used, this\n   * will return <code>null</code>. If the player is idle or has not initialized\n   * EME yet, this will return <code>null</code>.\n   *\n   * @return {?shaka.extern.DrmInfo}\n   * @export\n   */\n  drmInfo() {\n    return this.drmEngine_ ? this.drmEngine_.getDrmInfo() : null;\n  }\n\n\n  /**\n   * Get the drm engine.\n   * This method should only be used for testing. Applications SHOULD NOT\n   * use this in production.\n   *\n   * @return {?shaka.media.DrmEngine}\n   */\n  getDrmEngine() {\n    return this.drmEngine_;\n  }\n\n\n  /**\n   * Get the next known expiration time for any EME session. If the session\n   * never expires, this will return <code>Infinity</code>. If there are no EME\n   * sessions, this will return <code>Infinity</code>. If the player has not\n   * loaded content, this will return <code>Infinity</code>.\n   *\n   * @return {number}\n   * @export\n   */\n  getExpiration() {\n    return this.drmEngine_ ? this.drmEngine_.getExpiration() : Infinity;\n  }\n\n  /**\n   * Gets a map of EME key ID to the current key status.\n   *\n   * @return {!Object<string, string>}\n   * @export\n   */\n  getKeyStatuses() {\n    return this.drmEngine_ ? this.drmEngine_.getKeyStatuses() : {};\n  }\n\n  /**\n   * Check if the player is currently in a buffering state (has too little\n   * content to play smoothly). If the player has not loaded content, this will\n   * return <code>false</code>.\n   *\n   * @return {boolean}\n   * @export\n   */\n  isBuffering() {\n    const State = shaka.media.BufferingObserver.State;\n    return this.bufferObserver_ ?\n           this.bufferObserver_.getState() == State.STARVING :\n           false;\n  }\n\n  /**\n   * Get the playback rate of what is playing right now. If we are using trick\n   * play, this will return the trick play rate.\n   * If no content is playing, this will return 0.\n   * If content is buffering, this will return the expected playback rate once\n   * the video starts playing.\n   *\n   * <p>\n   * If the player has not loaded content, this will return a playback rate of\n   * 0.\n   *\n   * @return {number}\n   * @export\n   */\n  getPlaybackRate() {\n    if (!this.video_) {\n      return 0;\n    }\n    return this.playRateController_ ?\n           this.playRateController_.getRealRate() :\n           1;\n  }\n\n  /**\n   * Enable trick play to skip through content without playing by repeatedly\n   * seeking. For example, a rate of 2.5 would result in 2.5 seconds of content\n   * being skipped every second. A negative rate will result in moving\n   * backwards.\n   *\n   * <p>\n   * If the player has not loaded content or is still loading content this will\n   * be a no-op. Wait until <code>load</code> has completed before calling.\n   *\n   * <p>\n   * Trick play will be canceled automatically if the playhead hits the\n   * beginning or end of the seekable range for the content.\n   *\n   * @param {number} rate\n   * @export\n   */\n  trickPlay(rate) {\n    // A playbackRate of 0 is used internally when we are in a buffering state,\n    // and doesn't make sense for trick play.  If you set a rate of 0 for trick\n    // play, we will reject it and issue a warning.  If it happens during a\n    // test, we will fail the test through this assertion.\n    goog.asserts.assert(rate != 0, 'Should never set a trick play rate of 0!');\n    if (rate == 0) {\n      shaka.log.alwaysWarn('A trick play rate of 0 is unsupported!');\n      return;\n    }\n\n    if (this.video_.paused) {\n      // Our fast forward is implemented with playbackRate and needs the video\n      // to be playing (to not be paused) to take immediate effect.\n      // If the video is paused, \"unpause\" it.\n      this.video_.play();\n    }\n    this.playRateController_.set(rate);\n\n    if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n      this.abrManager_.playbackRateChanged(rate);\n      this.streamingEngine_.setTrickPlay(Math.abs(rate) > 1);\n    }\n  }\n\n  /**\n   * Cancel trick-play. If the player has not loaded content or is still loading\n   * content this will be a no-op.\n   *\n   * @export\n   */\n  cancelTrickPlay() {\n    const defaultPlaybackRate = this.playRateController_.getDefaultRate();\n    if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n      this.playRateController_.set(defaultPlaybackRate);\n    }\n\n    if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n      this.playRateController_.set(defaultPlaybackRate);\n      this.abrManager_.playbackRateChanged(defaultPlaybackRate);\n      this.streamingEngine_.setTrickPlay(false);\n    }\n  }\n\n  /**\n   * Return a list of variant tracks that can be switched to.\n   *\n   * <p>\n   * If the player has not loaded content, this will return an empty list.\n   *\n   * @return {!Array.<shaka.extern.Track>}\n   * @export\n   */\n  getVariantTracks() {\n    if (this.manifest_) {\n      const currentVariant = this.streamingEngine_ ?\n          this.streamingEngine_.getCurrentVariant() : null;\n\n      const tracks = [];\n\n      let activeTracks = 0;\n\n      // Convert each variant to a track.\n      for (const variant of this.manifest_.variants) {\n        if (!shaka.util.StreamUtils.isPlayable(variant)) {\n          continue;\n        }\n\n        const track = shaka.util.StreamUtils.variantToTrack(variant);\n        track.active = variant == currentVariant;\n        if (!track.active && activeTracks != 1 && currentVariant != null &&\n          variant.video == currentVariant.video &&\n          variant.audio == currentVariant.audio) {\n          track.active = true;\n        }\n\n        if (track.active) {\n          activeTracks++;\n        }\n\n        tracks.push(track);\n      }\n\n      goog.asserts.assert(activeTracks <= 1,\n          'It should only have one active track');\n\n      return tracks;\n    } else if (this.video_ && this.video_.audioTracks) {\n      // Safari's native HLS always shows a single element in videoTracks.\n      // You can't use that API to change resolutions.  But we can use\n      // audioTracks to generate a variant list that is usable for changing\n      // languages.\n      const audioTracks = Array.from(this.video_.audioTracks);\n      return audioTracks.map((audio) =>\n        shaka.util.StreamUtils.html5AudioTrackToTrack(audio));\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * Return a list of text tracks that can be switched to.\n   *\n   * <p>\n   * If the player has not loaded content, this will return an empty list.\n   *\n   * @return {!Array.<shaka.extern.Track>}\n   * @export\n   */\n  getTextTracks() {\n    if (this.manifest_) {\n      const currentTextStream = this.streamingEngine_ ?\n          this.streamingEngine_.getCurrentTextStream() : null;\n      const tracks = [];\n\n      // Convert all selectable text streams to tracks.\n      for (const text of this.manifest_.textStreams) {\n        const track = shaka.util.StreamUtils.textStreamToTrack(text);\n        track.active = text == currentTextStream;\n\n        tracks.push(track);\n      }\n\n      return tracks;\n    } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n      const textTracks = this.getFilteredTextTracks_();\n      const StreamUtils = shaka.util.StreamUtils;\n      return textTracks.map((text) => StreamUtils.html5TextTrackToTrack(text));\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * Return a list of image tracks that can be switched to.\n   *\n   * If the player has not loaded content, this will return an empty list.\n   *\n   * @return {!Array.<shaka.extern.Track>}\n   * @export\n   */\n  getImageTracks() {\n    if (this.manifest_) {\n      const imageStreams = this.manifest_.imageStreams;\n      const StreamUtils = shaka.util.StreamUtils;\n      return imageStreams.map((image) => StreamUtils.imageStreamToTrack(image));\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * Return a Thumbnail object from a image track Id and time.\n   *\n   * If the player has not loaded content, this will return a null.\n   *\n   * @param {number} trackId\n   * @param {number} time\n   * @return {!Promise.<?shaka.extern.Thumbnail>}\n   * @export\n   */\n  async getThumbnails(trackId, time) {\n    if (this.manifest_) {\n      const imageStream = this.manifest_.imageStreams.find(\n          (stream) => stream.id == trackId);\n      if (!imageStream) {\n        return null;\n      }\n      if (!imageStream.segmentIndex) {\n        await imageStream.createSegmentIndex();\n      }\n      const referencePosition = imageStream.segmentIndex.find(time);\n      if (referencePosition == null) {\n        return null;\n      }\n      const reference = imageStream.segmentIndex.get(referencePosition);\n      const tilesLayout =\n          reference.getTilesLayout() || imageStream.tilesLayout;\n      // This expression is used to detect one or more numbers (0-9) followed\n      // by an x and after one or more numbers (0-9)\n      const match = /(\\d+)x(\\d+)/.exec(tilesLayout);\n      if (!match) {\n        shaka.log.warning('Tiles layout does not contain a valid format ' +\n            ' (columns x rows)');\n        return null;\n      }\n      const fullImageWidth = imageStream.width || 0;\n      const fullImageHeight = imageStream.height || 0;\n      const columns = parseInt(match[1], 10);\n      const rows = parseInt(match[2], 10);\n      const width = fullImageWidth / columns;\n      const height = fullImageHeight / rows;\n      const totalImages = columns * rows;\n      const segmentDuration = reference.trueEndTime - reference.startTime;\n      const thumbnailDuration =\n          reference.getTileDuration() || (segmentDuration / totalImages);\n      let thumbnailTime = reference.startTime;\n      let positionX = 0;\n      let positionY = 0;\n      // If the number of images in the segment is greater than 1, we have to\n      // find the correct image. For that we will return to the app the\n      // coordinates of the position of the correct image.\n      // Image search is always from left to right and top to bottom.\n      // Note: The time between images within the segment is always\n      // equidistant.\n      //\n      // Eg: Total images 5, tileLayout 5x1, segmentDuration 5, thumbnailTime 2\n      // positionX = 0.4 * fullImageWidth\n      // positionY = 0\n      if (totalImages > 1) {\n        const thumbnailPosition =\n            Math.floor((time - reference.startTime) / thumbnailDuration);\n        thumbnailTime = reference.startTime +\n            (thumbnailPosition * thumbnailDuration);\n        positionX = (thumbnailPosition % columns) * width;\n        positionY = Math.floor(thumbnailPosition / columns) * height;\n      }\n      return {\n        imageHeight: fullImageHeight,\n        imageWidth: fullImageWidth,\n        height: height,\n        positionX: positionX,\n        positionY: positionY,\n        startTime: thumbnailTime,\n        duration: thumbnailDuration,\n        uris: reference.getUris(),\n        width: width,\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Select a specific text track. <code>track</code> should come from a call to\n   * <code>getTextTracks</code>. If the track is not found, this will be a\n   * no-op. If the player has not loaded content, this will be a no-op.\n   *\n   * <p>\n   * Note that <code>AdaptationEvents</code> are not fired for manual track\n   * selections.\n   *\n   * @param {shaka.extern.Track} track\n   * @export\n   */\n  selectTextTrack(track) {\n    if (this.manifest_ && this.streamingEngine_) {\n      const stream = this.manifest_.textStreams.find(\n          (stream) => stream.id == track.id);\n\n      if (!stream) {\n        shaka.log.error('No stream with id', track.id);\n        return;\n      }\n\n      if (stream == this.streamingEngine_.getCurrentTextStream()) {\n        shaka.log.debug('Text track already selected.');\n        return;\n      }\n\n      // Add entries to the history.\n      this.addTextStreamToSwitchHistory_(stream, /* fromAdaptation= */ false);\n      this.streamingEngine_.switchTextStream(stream);\n      this.onTextChanged_();\n\n      // Workaround for\n      // https://github.com/shaka-project/shaka-player/issues/1299\n      // When track is selected, back-propagate the language to\n      // currentTextLanguage_.\n      this.currentTextLanguage_ = stream.language;\n    } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n      const textTracks = this.getFilteredTextTracks_();\n      for (const textTrack of textTracks) {\n        if (shaka.util.StreamUtils.html5TrackId(textTrack) == track.id) {\n          // Leave the track in 'hidden' if it's selected but not showing.\n          textTrack.mode = this.isTextVisible_ ? 'showing' : 'hidden';\n        } else {\n          // Safari allows multiple text tracks to have mode == 'showing', so be\n          // explicit in resetting the others.\n          textTrack.mode = 'disabled';\n        }\n      }\n      this.onTextChanged_();\n    }\n  }\n\n  /**\n   * Select a specific variant track to play.  <code>track</code> should come\n   * from a call to <code>getVariantTracks</code>. If <code>track</code> cannot\n   * be found, this will be a no-op. If the player has not loaded content, this\n   * will be a no-op.\n   *\n   * <p>\n   * Changing variants will take effect once the currently buffered content has\n   * been played. To force the change to happen sooner, use\n   * <code>clearBuffer</code> with <code>safeMargin</code>. Setting\n   * <code>clearBuffer</code> to <code>true</code> will clear all buffered\n   * content after <code>safeMargin</code>, allowing the new variant to start\n   * playing sooner.\n   *\n   * <p>\n   * Note that <code>AdaptationEvents</code> are not fired for manual track\n   * selections.\n   *\n   * @param {shaka.extern.Track} track\n   * @param {boolean=} clearBuffer\n   * @param {number=} safeMargin Optional amount of buffer (in seconds) to\n   *   retain when clearing the buffer. Useful for switching variant quickly\n   *   without causing a buffering event. Defaults to 0 if not provided. Ignored\n   *   if clearBuffer is false. Can cause hiccups on some browsers if chosen too\n   *   small, e.g. The amount of two segments is a fair minimum to consider as\n   *   safeMargin value.\n   * @export\n   */\n  selectVariantTrack(track, clearBuffer = false, safeMargin = 0) {\n    if (this.manifest_ && this.streamingEngine_) {\n      if (this.config_.abr.enabled) {\n        shaka.log.alwaysWarn('Changing tracks while abr manager is enabled ' +\n                             'will likely result in the selected track ' +\n                             'being overriden. Consider disabling abr before ' +\n                             'calling selectVariantTrack().');\n      }\n\n      const variant = this.manifest_.variants.find(\n          (variant) => variant.id == track.id);\n      if (!variant) {\n        shaka.log.error('No variant with id', track.id);\n        return;\n      }\n\n      // Double check that the track is allowed to be played. The track list\n      // should only contain playable variants, but if restrictions change and\n      // |selectVariantTrack| is called before the track list is updated, we\n      // could get a now-restricted variant.\n      if (!shaka.util.StreamUtils.isPlayable(variant)) {\n        shaka.log.error('Unable to switch to restricted track', track.id);\n        return;\n      }\n\n      this.switchVariant_(variant, /* fromAdaptation= */ false, clearBuffer,\n          safeMargin);\n\n      // Workaround for\n      // https://github.com/shaka-project/shaka-player/issues/1299\n      // When track is selected, back-propagate the language to\n      // currentAudioLanguage_.\n      this.currentAdaptationSetCriteria_ = new shaka.media.ExampleBasedCriteria(\n          variant);\n\n      // Update AbrManager variants to match these new settings.\n      this.updateAbrManagerVariants_();\n    } else if (this.video_ && this.video_.audioTracks) {\n      // Safari's native HLS won't let you choose an explicit variant, though\n      // you can choose audio languages this way.\n      const audioTracks = Array.from(this.video_.audioTracks);\n      for (const audioTrack of audioTracks) {\n        if (shaka.util.StreamUtils.html5TrackId(audioTrack) == track.id) {\n          // This will reset the \"enabled\" of other tracks to false.\n          this.switchHtml5Track_(audioTrack);\n          return;\n        }\n      }\n    }\n  }\n\n  /**\n   * Return a list of audio language-role combinations available.  If the\n   * player has not loaded any content, this will return an empty list.\n   *\n   * @return {!Array.<shaka.extern.LanguageRole>}\n   * @export\n   */\n  getAudioLanguagesAndRoles() {\n    return shaka.Player.getLanguageAndRolesFrom_(this.getVariantTracks());\n  }\n\n  /**\n   * Return a list of text language-role combinations available.  If the player\n   * has not loaded any content, this will be return an empty list.\n   *\n   * @return {!Array.<shaka.extern.LanguageRole>}\n   * @export\n   */\n  getTextLanguagesAndRoles() {\n    return shaka.Player.getLanguageAndRolesFrom_(this.getTextTracks());\n  }\n\n  /**\n   * Return a list of audio languages available. If the player has not loaded\n   * any content, this will return an empty list.\n   *\n   * @return {!Array.<string>}\n   * @export\n   */\n  getAudioLanguages() {\n    return Array.from(shaka.Player.getLanguagesFrom_(this.getVariantTracks()));\n  }\n\n  /**\n   * Return a list of text languages available. If the player has not loaded\n   * any content, this will return an empty list.\n   *\n   * @return {!Array.<string>}\n   * @export\n   */\n  getTextLanguages() {\n    return Array.from(shaka.Player.getLanguagesFrom_(this.getTextTracks()));\n  }\n\n  /**\n   * Sets the current audio language and current variant role to the selected\n   * language and role, and chooses a new variant if need be. If the player has\n   * not loaded any content, this will be a no-op.\n   *\n   * @param {string} language\n   * @param {string=} role\n   * @export\n   */\n  selectAudioLanguage(language, role) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    if (this.manifest_ && this.playhead_) {\n      this.currentAdaptationSetCriteria_ =\n          new shaka.media.PreferenceBasedCriteria(language, role || '',\n          /* channelCount= */ 0, /* label= */ '');\n\n      const diff = (a, b) => {\n        if (!a.video && !b.video) {\n          return 0;\n        } else if (!a.video || !b.video) {\n          return Infinity;\n        } else {\n          return Math.abs((a.video.height || 0) - (b.video.height || 0)) +\n                Math.abs((a.video.width || 0) - (b.video.width || 0));\n        }\n      };\n        // Find the variant whose size is closest to the active variant.  This\n        // ensures we stay at about the same resolution when just changing the\n        // language/role.\n      const active = this.streamingEngine_.getCurrentVariant();\n      const set =\n            this.currentAdaptationSetCriteria_.create(this.manifest_.variants);\n      let bestVariant = null;\n      for (const curVariant of set.values()) {\n        if (!bestVariant ||\n              diff(bestVariant, active) > diff(curVariant, active)) {\n          bestVariant = curVariant;\n        }\n      }\n      if (bestVariant) {\n        const track = shaka.util.StreamUtils.variantToTrack(bestVariant);\n        this.selectVariantTrack(track, /* clearBuffer= */ true);\n        return;\n      }\n\n      // If we haven't switched yet, just use ABR to find a new track.\n      this.chooseVariantAndSwitch_();\n    } else if (this.video_ && this.video_.audioTracks) {\n      const audioTracks = Array.from(this.video_.audioTracks);\n      const selectedLanguage = LanguageUtils.normalize(language);\n\n      let languageMatch = null;\n      let languageAndRoleMatch = null;\n\n      for (const audioTrack of audioTracks) {\n        const track = shaka.util.StreamUtils.html5AudioTrackToTrack(audioTrack);\n\n        if (LanguageUtils.normalize(track.language) == selectedLanguage) {\n          languageMatch = audioTrack;\n\n          if (role) {\n            if (track.roles.includes(role)) {\n              languageAndRoleMatch = audioTrack;\n            }\n          } else {  // no role\n            if (track.roles.length == 0) {\n              languageAndRoleMatch = audioTrack;\n            }\n          }\n        }\n      }\n      if (languageAndRoleMatch) {\n        this.switchHtml5Track_(languageAndRoleMatch);\n      } else if (languageMatch) {\n        this.switchHtml5Track_(languageMatch);\n      }\n    }\n  }\n\n  /**\n   * Sets the current text language and current text role to the selected\n   * language and role, and chooses a new variant if need be. If the player has\n   * not loaded any content, this will be a no-op.\n   *\n   * @param {string} language\n   * @param {string=} role\n   * @param {boolean=} forced\n   * @export\n   */\n  selectTextLanguage(language, role, forced = false) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    if (this.manifest_ && this.playhead_) {\n      this.currentTextLanguage_ = language;\n      this.currentTextRole_ = role || '';\n      this.currentTextForced_ = forced;\n\n      const chosenText = this.chooseTextStream_();\n      if (chosenText) {\n        if (chosenText == this.streamingEngine_.getCurrentTextStream()) {\n          shaka.log.debug('Text track already selected.');\n          return;\n        }\n\n        this.addTextStreamToSwitchHistory_(\n            chosenText, /* fromAdaptation= */ false);\n        if (this.shouldStreamText_()) {\n          this.streamingEngine_.switchTextStream(chosenText);\n          this.onTextChanged_();\n        }\n      }\n    } else {\n      const selectedLanguage = LanguageUtils.normalize(language);\n\n      const track = this.getTextTracks().find((t) => {\n        return LanguageUtils.normalize(t.language) == selectedLanguage &&\n          (!role || t.roles.includes(role)) && t.forced == forced;\n      });\n\n      if (track) {\n        this.selectTextTrack(track);\n      }\n    }\n  }\n\n  /**\n   * Select variant tracks that have a given label. This assumes the\n   * label uniquely identifies an audio stream, so all the variants\n   * are expected to have the same variant.audio.\n   *\n   * @param {string} label\n   * @export\n   */\n  selectVariantsByLabel(label) {\n    if (this.manifest_ && this.playhead_) {\n      let firstVariantWithLabel = null;\n      for (const variant of this.manifest_.variants) {\n        if (variant.audio.label == label) {\n          firstVariantWithLabel = variant;\n          break;\n        }\n      }\n\n      if (firstVariantWithLabel == null) {\n        shaka.log.warning('No variants were found with label: ' +\n            label + '. Ignoring the request to switch.');\n\n        return;\n      }\n\n      // Label is a unique identifier of a variant's audio stream.\n      // Because of that we assume that all the variants with the same\n      // label have the same language.\n      this.currentAdaptationSetCriteria_ =\n          new shaka.media.PreferenceBasedCriteria(\n              firstVariantWithLabel.language, '', 0, label);\n\n      this.chooseVariantAndSwitch_();\n    } else if (this.video_ && this.video_.audioTracks) {\n      const audioTracks = Array.from(this.video_.audioTracks);\n\n      let trackMatch = null;\n\n      for (const audioTrack of audioTracks) {\n        if (audioTrack.label == label) {\n          trackMatch = audioTrack;\n        }\n      }\n      if (trackMatch) {\n        this.switchHtml5Track_(trackMatch);\n      }\n    }\n  }\n\n  /**\n   * Check if the text displayer is enabled.\n   *\n   * @return {boolean}\n   * @export\n   */\n  isTextTrackVisible() {\n    const expected = this.isTextVisible_;\n\n    if (this.mediaSourceEngine_) {\n      // Make sure our values are still in-sync.\n      const actual = this.mediaSourceEngine_.getTextDisplayer().isTextVisible();\n      goog.asserts.assert(\n          actual == expected, 'text visibility has fallen out of sync');\n\n      // Always return the actual value so that the app has the most accurate\n      // information (in the case that the values come out of sync in prod).\n      return actual;\n    } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n      const textTracks = this.getFilteredTextTracks_();\n      return textTracks.some((t) => t.mode == 'showing');\n    }\n\n    return expected;\n  }\n\n  /**\n   * Return a list of chapters tracks.\n   *\n   * @return {!Array.<shaka.extern.Track>}\n   * @export\n   */\n  getChaptersTracks() {\n    if (this.video_ && this.video_.src && this.video_.textTracks) {\n      const textTracks = this.getChaptersTracks_();\n      const StreamUtils = shaka.util.StreamUtils;\n      return textTracks.map((text) => StreamUtils.html5TextTrackToTrack(text));\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * This returns the list of chapters.\n   *\n   * @param {string} language\n   * @return {!Array.<shaka.extern.Chapter>}\n   * @export\n   */\n  getChapters(language) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n    const inputlanguage = LanguageUtils.normalize(language);\n    const chaptersTracks = this.getChaptersTracks_();\n    const chaptersTracksWithLanguage = chaptersTracks\n        .filter((t) => LanguageUtils.normalize(t.language) == inputlanguage);\n    if (!chaptersTracksWithLanguage || !chaptersTracksWithLanguage.length) {\n      return [];\n    }\n    const chapters = [];\n    const uniqueChapters = new Set();\n    for (const chaptersTrack of chaptersTracksWithLanguage) {\n      if (chaptersTrack && chaptersTrack.cues) {\n        for (const cue of chaptersTrack.cues) {\n          let id = cue.id;\n          if (!id || id == '') {\n            id = cue.startTime + '-' + cue.endTime + '-' + cue.text;\n          }\n          /** @type {shaka.extern.Chapter} */\n          const chapter = {\n            id: id,\n            title: cue.text,\n            startTime: cue.startTime,\n            endTime: cue.endTime,\n          };\n          if (!uniqueChapters.has(id)) {\n            chapters.push(chapter);\n            uniqueChapters.add(id);\n          }\n        }\n      }\n    }\n    return chapters;\n  }\n\n  /**\n   * Ignore the TextTracks with the 'metadata' or 'chapters' kind, or the one\n   * generated by the SimpleTextDisplayer.\n   *\n   * @return {!Array.<TextTrack>}\n   * @private\n   */\n  getFilteredTextTracks_() {\n    goog.asserts.assert(this.video_.textTracks,\n        'TextTracks should be valid.');\n    return Array.from(this.video_.textTracks)\n        .filter((t) => t.kind != 'metadata' && t.kind != 'chapters' &&\n                       t.label != shaka.Player.TextTrackLabel);\n  }\n\n  /**\n   * Get the TextTracks with the 'metadata' kind.\n   *\n   * @return {!Array.<TextTrack>}\n   * @private\n   */\n  getMetadataTracks_() {\n    goog.asserts.assert(this.video_.textTracks,\n        'TextTracks should be valid.');\n    return Array.from(this.video_.textTracks)\n        .filter((t) => t.kind == 'metadata');\n  }\n\n  /**\n   * Get the TextTracks with the 'chapters' kind.\n   *\n   * @return {!Array.<TextTrack>}\n   * @private\n   */\n  getChaptersTracks_() {\n    goog.asserts.assert(this.video_.textTracks,\n        'TextTracks should be valid.');\n    return Array.from(this.video_.textTracks)\n        .filter((t) => t.kind == 'chapters');\n  }\n\n  /**\n   * Enable or disable the text displayer.  If the player is in an unloaded\n   * state, the request will be applied next time content is loaded.\n   *\n   * @param {boolean} isVisible\n   * @export\n   */\n  setTextTrackVisibility(isVisible) {\n    const oldVisibilty = this.isTextVisible_;\n    // Convert to boolean in case apps pass 0/1 instead false/true.\n    const newVisibility = !!isVisible;\n\n    if (oldVisibilty == newVisibility) {\n      return;\n    }\n\n    this.isTextVisible_ = newVisibility;\n\n    // Hold of on setting the text visibility until we have all the components\n    // we need. This ensures that they stay in-sync.\n    if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n      this.mediaSourceEngine_.getTextDisplayer()\n          .setTextVisibility(newVisibility);\n\n      // When the user wants to see captions, we stream captions. When the user\n      // doesn't want to see captions, we don't stream captions. This is to\n      // avoid bandwidth consumption by an unused resource. The app developer\n      // can override this and configure us to always stream captions.\n      if (!this.config_.streaming.alwaysStreamText) {\n        if (newVisibility) {\n          if (this.streamingEngine_.getCurrentTextStream()) {\n            // We already have a selected text stream.\n          } else {\n            // Find the text stream that best matches the user's preferences.\n            const streams =\n                shaka.util.StreamUtils.filterStreamsByLanguageAndRole(\n                    this.manifest_.textStreams,\n                    this.currentTextLanguage_,\n                    this.currentTextRole_,\n                    this.currentTextForced_);\n\n            // It is possible that there are no streams to play.\n            if (streams.length > 0) {\n              this.streamingEngine_.switchTextStream(streams[0]);\n              this.onTextChanged_();\n            }\n          }\n        } else {\n          this.streamingEngine_.unloadTextStream();\n        }\n      }\n    } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n      const textTracks = this.getFilteredTextTracks_();\n      // Find the active track by looking for one which is not disabled.  This\n      // is the only way to identify the track which is currently displayed.\n      // Set it to 'showing' or 'hidden' based on newVisibility.\n      for (const textTrack of textTracks) {\n        if (textTrack.mode != 'disabled') {\n          textTrack.mode = newVisibility ? 'showing' : 'hidden';\n        }\n      }\n    }\n\n    // We need to fire the event after we have updated everything so that\n    // everything will be in a stable state when the app responds to the\n    // event.\n    this.onTextTrackVisibility_();\n  }\n\n  /**\n   * Get the current playhead position as a date. This should only be called\n   * when the player has loaded a live stream. If the player has not loaded a\n   * live stream, this will return <code>null</code>.\n   *\n   * @return {Date}\n   * @export\n   */\n  getPlayheadTimeAsDate() {\n    if (!this.isLive()) {\n      shaka.log.warning('getPlayheadTimeAsDate is for live streams!');\n      return null;\n    }\n\n    const walkerPayload = this.walker_.getCurrentPayload();\n\n    let presentationTime = 0;\n    if (this.playhead_) {\n      presentationTime = this.playhead_.getTime();\n    } else if (walkerPayload) {\n      if (walkerPayload.startTime == null) {\n        // A live stream with no requested start time and no playhead yet.  We\n        // would start at the live edge, but we don't have that yet, so return\n        // the current date & time.\n        return new Date();\n      } else {\n        // A specific start time has been requested.  This is what Playhead will\n        // use once it is created.\n        presentationTime = walkerPayload.startTime;\n      }\n    }\n\n    if (this.manifest_) {\n      const timeline = this.manifest_.presentationTimeline;\n      const startTime = timeline.getPresentationStartTime();\n      return new Date(/* ms= */ (startTime + presentationTime) * 1000);\n    } else if (this.video_ && this.video_.getStartDate) {\n      // Apple's native HLS gives us getStartDate(), which is only available if\n      // EXT-X-PROGRAM-DATETIME is in the playlist.\n      const startDate = this.video_.getStartDate();\n      if (isNaN(startDate.getTime())) {\n        shaka.log.warning(\n            'EXT-X-PROGRAM-DATETIME required to get playhead time as Date!');\n        return null;\n      }\n      return new Date(startDate.getTime() + (presentationTime * 1000));\n    } else {\n      shaka.log.warning('No way to get playhead time as Date!');\n      return null;\n    }\n  }\n\n  /**\n   * Get the presentation start time as a date. This should only be called when\n   * the player has loaded a live stream. If the player has not loaded a live\n   * stream, this will return <code>null</code>.\n   *\n   * @return {Date}\n   * @export\n   */\n  getPresentationStartTimeAsDate() {\n    if (!this.isLive()) {\n      shaka.log.warning('getPresentationStartTimeAsDate is for live streams!');\n      return null;\n    }\n\n    if (this.manifest_) {\n      const timeline = this.manifest_.presentationTimeline;\n      const startTime = timeline.getPresentationStartTime();\n      goog.asserts.assert(startTime != null,\n          'Presentation start time should not be null!');\n      return new Date(/* ms= */ startTime * 1000);\n    } else if (this.video_ && this.video_.getStartDate) {\n      // Apple's native HLS gives us getStartDate(), which is only available if\n      // EXT-X-PROGRAM-DATETIME is in the playlist.\n      const startDate = this.video_.getStartDate();\n      if (isNaN(startDate.getTime())) {\n        shaka.log.warning(\n            'EXT-X-PROGRAM-DATETIME required to get presentation start time ' +\n            'as Date!');\n        return null;\n      }\n      return startDate;\n    } else {\n      shaka.log.warning('No way to get presentation start time as Date!');\n      return null;\n    }\n  }\n\n  /**\n   * Get information about what the player has buffered. If the player has not\n   * loaded content or is currently loading content, the buffered content will\n   * be empty.\n   *\n   * @return {shaka.extern.BufferedInfo}\n   * @export\n   */\n  getBufferedInfo() {\n    if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n      return this.mediaSourceEngine_.getBufferedInfo();\n    }\n\n    const info = {\n      total: [],\n      audio: [],\n      video: [],\n      text: [],\n    };\n\n    if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n      const TimeRangesUtils = shaka.media.TimeRangesUtils;\n      info.total = TimeRangesUtils.getBufferedInfo(this.video_.buffered);\n    }\n\n    return info;\n  }\n\n  /**\n   * Get statistics for the current playback session. If the player is not\n   * playing content, this will return an empty stats object.\n   *\n   * @return {shaka.extern.Stats}\n   * @export\n   */\n  getStats() {\n    // If the Player is not in a fully-loaded state, then return an empty stats\n    // blob so that this call will never fail.\n    const loaded = this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE ||\n                   this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS;\n    if (!loaded) {\n      return shaka.util.Stats.getEmptyBlob();\n    }\n\n    this.updateStateHistory_();\n\n    goog.asserts.assert(this.video_, 'If we have stats, we should have video_');\n    const element = /** @type {!HTMLVideoElement} */ (this.video_);\n\n    const completionRatio = element.currentTime / element.duration;\n    if (!isNaN(completionRatio)) {\n      this.stats_.setCompletionPercent(Math.round(100 * completionRatio));\n    }\n\n    if (element.getVideoPlaybackQuality) {\n      const info = element.getVideoPlaybackQuality();\n\n      this.stats_.setDroppedFrames(\n          Number(info.droppedVideoFrames),\n          Number(info.totalVideoFrames));\n      this.stats_.setCorruptedFrames(Number(info.corruptedVideoFrames));\n    }\n\n    const licenseSeconds =\n        this.drmEngine_ ? this.drmEngine_.getLicenseTime() : NaN;\n    this.stats_.setLicenseTime(licenseSeconds);\n\n    if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n      // Event through we are loaded, it is still possible that we don't have a\n      // variant yet because we set the load mode before we select the first\n      // variant to stream.\n      const variant = this.streamingEngine_.getCurrentVariant();\n\n      if (variant) {\n        const rate = this.playRateController_ ?\n           this.playRateController_.getRealRate() : 1;\n        const variantBandwidth = rate * variant.bandwidth;\n        // TODO: Should include text bandwidth if it enabled.\n        const currentStreamBandwidth = variantBandwidth;\n        this.stats_.setCurrentStreamBandwidth(currentStreamBandwidth);\n      }\n\n      if (variant && variant.video) {\n        this.stats_.setResolution(\n            /* width= */ variant.video.width || NaN,\n            /* height= */ variant.video.height || NaN);\n      }\n\n      if (this.isLive()) {\n        const now = this.getPresentationStartTimeAsDate().valueOf() +\n            this.seekRange().end * 1000;\n        const latency = (Date.now() - now) / 1000;\n        this.stats_.setLiveLatency(latency);\n      }\n\n      if (this.manifest_ && this.manifest_.presentationTimeline) {\n        const maxSegmentDuration =\n            this.manifest_.presentationTimeline.getMaxSegmentDuration();\n        this.stats_.setMaxSegmentDuration(maxSegmentDuration);\n      }\n\n      const estimate = this.abrManager_.getBandwidthEstimate();\n      this.stats_.setBandwidthEstimate(estimate);\n    }\n\n    if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n      this.stats_.setResolution(\n          /* width= */ element.videoWidth || NaN,\n          /* height= */ element.videoHeight || NaN);\n    }\n\n    return this.stats_.getBlob();\n  }\n\n  /**\n   * Adds the given text track to the loaded manifest.  <code>load()</code> must\n   * resolve before calling.  The presentation must have a duration.\n   *\n   * This returns the created track, which can immediately be selected by the\n   * application.  The track will not be automatically selected.\n   *\n   * @param {string} uri\n   * @param {string} language\n   * @param {string} kind\n   * @param {string=} mimeType\n   * @param {string=} codec\n   * @param {string=} label\n   * @param {boolean=} forced\n   * @return {shaka.extern.Track}\n   * @export\n   */\n  addTextTrack(uri, language, kind, mimeType, codec, label, forced = false) {\n    shaka.Deprecate.deprecateFeature(4,\n        'addTextTrack',\n        'Please use an addTextTrackAsync.');\n    if (this.loadMode_ != shaka.Player.LoadMode.MEDIA_SOURCE &&\n        this.loadMode_ != shaka.Player.LoadMode.SRC_EQUALS) {\n      shaka.log.error(\n          'Must call load() and wait for it to resolve before adding text ' +\n          'tracks.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.CONTENT_NOT_LOADED);\n    }\n\n    if (!mimeType) {\n      // Try using the uri extension.\n      const extension = shaka.media.ManifestParser.getExtension(uri);\n      mimeType = shaka.Player.TEXT_EXTENSIONS_TO_MIME_TYPES_[extension];\n\n      if (!mimeType) {\n        shaka.log.error(\n            'The mimeType has not been provided and it could not be deduced ' +\n            'from its extension.');\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.TEXT,\n            shaka.util.Error.Code.TEXT_COULD_NOT_GUESS_MIME_TYPE,\n            extension);\n      }\n    }\n\n    if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n      if (mimeType != 'text/vtt') {\n        shaka.log.error('Only WebVTT is supported when using src=');\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.TEXT,\n            shaka.util.Error.Code.TEXT_ONLY_WEBVTT_SRC_EQUALS,\n            mimeType);\n      }\n      if (forced) {\n        // See: https://github.com/whatwg/html/issues/4472\n        kind = 'forced';\n      }\n      const trackElement =\n        /** @type {!HTMLTrackElement} */(document.createElement('track'));\n      trackElement.src = this.cmcdManager_.appendTextTrackData(uri);\n      trackElement.label = label || '';\n      trackElement.kind = kind;\n      trackElement.srclang = language;\n      // Because we're pulling in the text track file via Javascript, the\n      // same-origin policy applies. If you'd like to have a player served\n      // from one domain, but the text track served from another, you'll\n      // need to enable CORS in order to do so. In addition to enabling CORS\n      // on the server serving the text tracks, you will need to add the\n      // crossorigin attribute to the video element itself.\n      if (!this.video_.getAttribute('crossorigin')) {\n        this.video_.setAttribute('crossorigin', 'anonymous');\n      }\n      this.video_.appendChild(trackElement);\n      const textTracks = this.getTextTracks();\n      const srcTrack = textTracks.find((t) => {\n        return t.language == language &&\n            t.label == (label || '') &&\n            t.kind == kind;\n      });\n      if (srcTrack) {\n        this.onTracksChanged_();\n        return srcTrack;\n      }\n      // This should not happen, but there are browser implementations that may\n      // not support the Track element.\n      shaka.log.error('Cannot add this text when loaded with src=');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_SRC_EQUALS);\n    }\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const duration = this.manifest_.presentationTimeline.getDuration();\n    if (duration == Infinity) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM);\n    }\n\n    /** @type {shaka.extern.Stream} */\n    const stream = {\n      id: this.nextExternalStreamId_++,\n      originalId: null,\n      createSegmentIndex: () => Promise.resolve(),\n      segmentIndex: shaka.media.SegmentIndex.forSingleSegment(\n          /* startTime= */ 0,\n          /* duration= */ duration,\n          /* uris= */ [uri]),\n      mimeType: mimeType || '',\n      codecs: codec || '',\n      kind: kind,\n      encrypted: false,\n      drmInfos: [],\n      keyIds: new Set(),\n      language: language,\n      label: label || null,\n      type: ContentType.TEXT,\n      primary: false,\n      trickModeVideo: null,\n      emsgSchemeIdUris: null,\n      roles: [],\n      forced: !!forced,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      closedCaptions: null,\n    };\n\n    const fullMimeType = shaka.util.MimeUtils.getFullType(\n        stream.mimeType, stream.codecs);\n    const supported = shaka.text.TextEngine.isTypeSupported(fullMimeType);\n    if (!supported) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.MISSING_TEXT_PLUGIN,\n          mimeType);\n    }\n\n    this.manifest_.textStreams.push(stream);\n    this.onTracksChanged_();\n    return shaka.util.StreamUtils.textStreamToTrack(stream);\n  }\n\n  /**\n   * Adds the given text track to the loaded manifest.  <code>load()</code> must\n   * resolve before calling.  The presentation must have a duration.\n   *\n   * This returns the created track, which can immediately be selected by the\n   * application.  The track will not be automatically selected.\n   *\n   * @param {string} uri\n   * @param {string} language\n   * @param {string} kind\n   * @param {string=} mimeType\n   * @param {string=} codec\n   * @param {string=} label\n   * @param {boolean=} forced\n   * @return {!Promise.<shaka.extern.Track>}\n   * @export\n   */\n  async addTextTrackAsync(uri, language, kind, mimeType, codec, label,\n      forced = false) {\n    if (this.loadMode_ != shaka.Player.LoadMode.MEDIA_SOURCE &&\n        this.loadMode_ != shaka.Player.LoadMode.SRC_EQUALS) {\n      shaka.log.error(\n          'Must call load() and wait for it to resolve before adding text ' +\n          'tracks.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.CONTENT_NOT_LOADED);\n    }\n\n    if (!mimeType) {\n      mimeType = await this.getTextMimetype_(uri);\n    }\n\n    let adCuePoints = [];\n    if (this.adManager_) {\n      try {\n        adCuePoints = this.adManager_.getServerSideCuePoints();\n      } catch (error) {}\n    }\n\n    if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n      if (forced) {\n        // See: https://github.com/whatwg/html/issues/4472\n        kind = 'forced';\n      }\n      await this.addSrcTrackElement_(uri, language, kind, mimeType, label || '',\n          adCuePoints);\n      const textTracks = this.getTextTracks();\n      const srcTrack = textTracks.find((t) => {\n        return t.language == language &&\n            t.label == (label || '') &&\n            t.kind == kind;\n      });\n      if (srcTrack) {\n        this.onTracksChanged_();\n        return srcTrack;\n      }\n      // This should not happen, but there are browser implementations that may\n      // not support the Track element.\n      shaka.log.error('Cannot add this text when loaded with src=');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_SRC_EQUALS);\n    }\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const duration = this.manifest_.presentationTimeline.getDuration();\n    if (duration == Infinity) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM);\n    }\n\n    if (adCuePoints.length) {\n      goog.asserts.assert(\n          this.networkingEngine_, 'Need networking engine.');\n      const data = await this.getTextData_(uri,\n          this.networkingEngine_,\n          this.config_.streaming.retryParameters);\n      const vvtText = this.convertToWebVTT_(data, mimeType, adCuePoints);\n      const blob = new Blob([vvtText], {type: 'text/vtt'});\n      uri = shaka.media.MediaSourceEngine.createObjectURL(blob);\n      mimeType = 'text/vtt';\n    }\n\n    /** @type {shaka.extern.Stream} */\n    const stream = {\n      id: this.nextExternalStreamId_++,\n      originalId: null,\n      createSegmentIndex: () => Promise.resolve(),\n      segmentIndex: shaka.media.SegmentIndex.forSingleSegment(\n          /* startTime= */ 0,\n          /* duration= */ duration,\n          /* uris= */ [uri]),\n      mimeType: mimeType || '',\n      codecs: codec || '',\n      kind: kind,\n      encrypted: false,\n      drmInfos: [],\n      keyIds: new Set(),\n      language: language,\n      label: label || null,\n      type: ContentType.TEXT,\n      primary: false,\n      trickModeVideo: null,\n      emsgSchemeIdUris: null,\n      roles: [],\n      forced: !!forced,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      closedCaptions: null,\n    };\n\n    const fullMimeType = shaka.util.MimeUtils.getFullType(\n        stream.mimeType, stream.codecs);\n    const supported = shaka.text.TextEngine.isTypeSupported(fullMimeType);\n    if (!supported) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.MISSING_TEXT_PLUGIN,\n          mimeType);\n    }\n\n    this.manifest_.textStreams.push(stream);\n    this.onTracksChanged_();\n    return shaka.util.StreamUtils.textStreamToTrack(stream);\n  }\n\n  /**\n   * Adds the given chapters track to the loaded manifest.  <code>load()</code>\n   * must resolve before calling.  The presentation must have a duration.\n   *\n   * This returns the created track.\n   *\n   * @param {string} uri\n   * @param {string} language\n   * @param {string=} mimeType\n   * @return {!Promise.<shaka.extern.Track>}\n   * @export\n   */\n  async addChaptersTrack(uri, language, mimeType) {\n    if (this.loadMode_ != shaka.Player.LoadMode.MEDIA_SOURCE &&\n        this.loadMode_ != shaka.Player.LoadMode.SRC_EQUALS) {\n      shaka.log.error(\n          'Must call load() and wait for it to resolve before adding ' +\n          'chapters tracks.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.CONTENT_NOT_LOADED);\n    }\n\n    if (!mimeType) {\n      mimeType = await this.getTextMimetype_(uri);\n    }\n\n    let adCuePoints = [];\n    if (this.adManager_) {\n      try {\n        adCuePoints = this.adManager_.getServerSideCuePoints();\n      } catch (error) {}\n    }\n\n    /** @type {!HTMLTrackElement} */\n    const trackElement = await this.addSrcTrackElement_(\n        uri, language, /* kind= */ 'chapters', mimeType, /* label= */ '',\n        adCuePoints);\n\n    const chaptersTracks = this.getChaptersTracks();\n    const chaptersTrack = chaptersTracks.find((t) => {\n      return t.language == language;\n    });\n\n    if (chaptersTrack) {\n      await new Promise((resolve, reject) => {\n        // The chapter data isn't available until the 'load' event fires, and\n        // that won't happen until the chapters track is activated by the\n        // activateChaptersTrack_ method.\n        this.loadEventManager_.listenOnce(trackElement, 'load', resolve);\n        this.loadEventManager_.listenOnce(trackElement, 'error', (event) => {\n          reject(new shaka.util.Error(\n              shaka.util.Error.Severity.RECOVERABLE,\n              shaka.util.Error.Category.TEXT,\n              shaka.util.Error.Code.CHAPTERS_TRACK_FAILED));\n        });\n      });\n\n      return chaptersTrack;\n    }\n\n    // This should not happen, but there are browser implementations that may\n    // not support the Track element.\n    shaka.log.error('Cannot add this text when loaded with src=');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.RECOVERABLE,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_SRC_EQUALS);\n  }\n\n  /**\n   * @param {string} uri\n   * @return {!Promise.<string>}\n   * @private\n   */\n  async getTextMimetype_(uri) {\n    // Try using the uri extension.\n    const extension = shaka.media.ManifestParser.getExtension(uri);\n    let mimeType = shaka.Player.TEXT_EXTENSIONS_TO_MIME_TYPES_[extension];\n\n    if (mimeType) {\n      return mimeType;\n    }\n\n    try {\n      goog.asserts.assert(\n          this.networkingEngine_, 'Need networking engine.');\n      // eslint-disable-next-line require-atomic-updates\n      mimeType = await shaka.media.ManifestParser.getMimeType(uri,\n          this.networkingEngine_,\n          this.config_.streaming.retryParameters);\n    } catch (error) {}\n\n    if (mimeType) {\n      return mimeType;\n    }\n\n    shaka.log.error(\n        'The mimeType has not been provided and it could not be deduced ' +\n        'from its extension.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.RECOVERABLE,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.TEXT_COULD_NOT_GUESS_MIME_TYPE,\n        extension);\n  }\n\n  /**\n   * @param {string} uri\n   * @param {string} language\n   * @param {string} kind\n   * @param {string} mimeType\n   * @param {string} label\n   * @param {!Array.<!shaka.extern.AdCuePoint>} adCuePoints\n   * @return {!Promise.<!HTMLTrackElement>}\n   * @private\n   */\n  async addSrcTrackElement_(uri, language, kind, mimeType, label,\n      adCuePoints) {\n    if (mimeType != 'text/vtt' || adCuePoints.length) {\n      goog.asserts.assert(\n          this.networkingEngine_, 'Need networking engine.');\n      const data = await this.getTextData_(uri,\n          this.networkingEngine_,\n          this.config_.streaming.retryParameters);\n      const vvtText = this.convertToWebVTT_(data, mimeType, adCuePoints);\n      const blob = new Blob([vvtText], {type: 'text/vtt'});\n      uri = shaka.media.MediaSourceEngine.createObjectURL(blob);\n      mimeType = 'text/vtt';\n    }\n\n    const trackElement =\n      /** @type {!HTMLTrackElement} */(document.createElement('track'));\n    trackElement.src = this.cmcdManager_.appendTextTrackData(uri);\n    trackElement.label = label;\n    trackElement.kind = kind;\n    trackElement.srclang = language;\n\n    // Because we're pulling in the text track file via Javascript, the\n    // same-origin policy applies. If you'd like to have a player served\n    // from one domain, but the text track served from another, you'll\n    // need to enable CORS in order to do so. In addition to enabling CORS\n    // on the server serving the text tracks, you will need to add the\n    // crossorigin attribute to the video element itself.\n    if (!this.video_.getAttribute('crossorigin')) {\n      this.video_.setAttribute('crossorigin', 'anonymous');\n    }\n\n    this.video_.appendChild(trackElement);\n    return trackElement;\n  }\n\n  /**\n   * @param {string} uri\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {shaka.extern.RetryParameters} retryParams\n   * @return {!Promise.<BufferSource>}\n   * @private\n   */\n  async getTextData_(uri, netEngine, retryParams) {\n    const type = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n    const request = shaka.net.NetworkingEngine.makeRequest([uri], retryParams);\n    request.method = 'GET';\n\n    this.cmcdManager_.applyTextData(request);\n\n    const response = await netEngine.request(type, request).promise;\n\n    return response.data;\n  }\n\n\n  /**\n   * Converts an input string to a WebVTT format string.\n   *\n   * @param {BufferSource} buffer\n   * @param {string} mimeType\n   * @param {!Array.<!shaka.extern.AdCuePoint>} adCuePoints\n   * @return {string}\n   * @private\n   */\n  convertToWebVTT_(buffer, mimeType, adCuePoints) {\n    const factory = shaka.text.TextEngine.findParser(mimeType);\n    if (factory) {\n      const obj = factory();\n      const time = {\n        periodStart: 0,\n        segmentStart: 0,\n        segmentEnd: this.video_.duration,\n      };\n      const data = shaka.util.BufferUtils.toUint8(buffer);\n      const cues = obj.parseMedia(data, time);\n      return shaka.text.WebVttGenerator.convert(cues, adCuePoints);\n    }\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.MISSING_TEXT_PLUGIN,\n        mimeType);\n  }\n\n  /**\n   * Set the maximum resolution that the platform's hardware can handle.\n   * This will be called automatically by <code>shaka.cast.CastReceiver</code>\n   * to enforce limitations of the Chromecast hardware.\n   *\n   * @param {number} width\n   * @param {number} height\n   * @export\n   */\n  setMaxHardwareResolution(width, height) {\n    this.maxHwRes_.width = width;\n    this.maxHwRes_.height = height;\n  }\n\n  /**\n   * Retry streaming after a streaming failure has occurred. When the player has\n   * not loaded content or is loading content, this will be a no-op and will\n   * return <code>false</code>.\n   *\n   * <p>\n   * If the player has loaded content, and streaming has not seen an error, this\n   * will return <code>false</code>.\n   *\n   * <p>\n   * If the player has loaded content, and streaming seen an error, but the\n   * could not resume streaming, this will return <code>false</code>.\n   *\n   * @param {number=} retryDelaySeconds\n   * @return {boolean}\n   * @export\n   */\n  retryStreaming(retryDelaySeconds = 0.1) {\n    return this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE ?\n           this.streamingEngine_.retry(retryDelaySeconds) :\n           false;\n  }\n\n  /**\n   * Get the manifest that the player has loaded. If the player has not loaded\n   * any content, this will return <code>null</code>.\n   *\n   * NOTE: This structure is NOT covered by semantic versioning compatibility\n   * guarantees.  It may change at any time!\n   *\n   * This is marked as deprecated to warn Closure Compiler users at compile-time\n   * to avoid using this method.\n   *\n   * @return {?shaka.extern.Manifest}\n   * @export\n   * @deprecated\n   */\n  getManifest() {\n    shaka.log.alwaysWarn(\n        'Shaka Player\\'s internal Manifest structure is NOT covered by ' +\n        'semantic versioning compatibility guarantees.  It may change at any ' +\n        'time!  Please consider filing a feature request for whatever you ' +\n        'use getManifest() for.');\n    return this.manifest_;\n  }\n\n  /**\n   * Get the type of manifest parser that the player is using. If the player has\n   * not loaded any content, this will return <code>null</code>.\n   *\n   * @return {?shaka.extern.ManifestParser.Factory}\n   * @export\n   */\n  getManifestParserFactory() {\n    return this.parserFactory_;\n  }\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @param {boolean} fromAdaptation\n   * @private\n   */\n  addVariantToSwitchHistory_(variant, fromAdaptation) {\n    const switchHistory = this.stats_.getSwitchHistory();\n    switchHistory.updateCurrentVariant(variant, fromAdaptation);\n  }\n\n  /**\n   * @param {shaka.extern.Stream} textStream\n   * @param {boolean} fromAdaptation\n   * @private\n   */\n  addTextStreamToSwitchHistory_(textStream, fromAdaptation) {\n    const switchHistory = this.stats_.getSwitchHistory();\n    switchHistory.updateCurrentText(textStream, fromAdaptation);\n  }\n\n  /**\n   * @return {shaka.extern.PlayerConfiguration}\n   * @private\n   */\n  defaultConfig_() {\n    const config = shaka.util.PlayerConfiguration.createDefault();\n\n    config.streaming.failureCallback = (error) => {\n      this.defaultStreamingFailureCallback_(error);\n    };\n\n    // Because this.video_ may not be set when the config is built, the default\n    // TextDisplay factory must capture a reference to \"this\".\n    config.textDisplayFactory = () => {\n      if (this.videoContainer_) {\n        return new shaka.text.UITextDisplayer(\n            this.video_, this.videoContainer_);\n      } else {\n        return new shaka.text.SimpleTextDisplayer(this.video_);\n      }\n    };\n    return config;\n  }\n\n  /**\n   * Set the videoContainer to construct UITextDisplayer.\n   * @param {HTMLElement} videoContainer\n   * @export\n   */\n  setVideoContainer(videoContainer) {\n    this.videoContainer_ = videoContainer;\n  }\n\n  /**\n   * @param {!shaka.util.Error} error\n   * @private\n   */\n  defaultStreamingFailureCallback_(error) {\n    // For live streams, we retry streaming automatically for certain errors.\n    // For VOD streams, all streaming failures are fatal.\n    if (!this.isLive()) {\n      return;\n    }\n\n    let retryDelaySeconds = null;\n    if (error.code == shaka.util.Error.Code.BAD_HTTP_STATUS ||\n        error.code == shaka.util.Error.Code.HTTP_ERROR) {\n      // These errors can be near-instant, so delay a bit before retrying.\n      retryDelaySeconds = 1;\n    } else if (error.code == shaka.util.Error.Code.TIMEOUT) {\n      // We already waited for a timeout, so retry quickly.\n      retryDelaySeconds = 0.1;\n    }\n\n    if (retryDelaySeconds != null) {\n      error.severity = shaka.util.Error.Severity.RECOVERABLE;\n      shaka.log.warning('Live streaming error.  Retrying automatically...');\n      this.retryStreaming(retryDelaySeconds);\n    }\n  }\n\n  /**\n   * For CEA closed captions embedded in the video streams, create dummy text\n   * stream.  This can be safely called again on existing manifests, for\n   * manifest updates.\n   * @param {!shaka.extern.Manifest} manifest\n   * @private\n   */\n  makeTextStreamsForClosedCaptions_(manifest) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const TextStreamKind = shaka.util.ManifestParserUtils.TextStreamKind;\n    const CEA608_MIME = shaka.util.MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE;\n    const CEA708_MIME = shaka.util.MimeUtils.CEA708_CLOSED_CAPTION_MIMETYPE;\n\n    // A set, to make sure we don't create two text streams for the same video.\n    const closedCaptionsSet = new Set();\n    for (const textStream of manifest.textStreams) {\n      if (textStream.mimeType == CEA608_MIME ||\n          textStream.mimeType == CEA708_MIME) {\n        // This function might be called on a manifest update, so don't make a\n        // new text stream for closed caption streams we have seen before.\n        closedCaptionsSet.add(textStream.originalId);\n      }\n    }\n    for (const variant of manifest.variants) {\n      const video = variant.video;\n      if (video && video.closedCaptions) {\n        for (const id of video.closedCaptions.keys()) {\n          if (!closedCaptionsSet.has(id)) {\n            const mimeType = id.startsWith('CC') ? CEA608_MIME : CEA708_MIME;\n\n            // Add an empty segmentIndex, for the benefit of the period combiner\n            // in our builtin DASH parser.\n            const segmentIndex = new shaka.media.MetaSegmentIndex();\n            const textStream = {\n              id: this.nextExternalStreamId_++,  // A globally unique ID.\n              originalId: id, // The CC ID string, like 'CC1', 'CC3', etc.\n              createSegmentIndex: () => Promise.resolve(),\n              segmentIndex,\n              mimeType,\n              codecs: '',\n              kind: TextStreamKind.CLOSED_CAPTION,\n              encrypted: false,\n              drmInfos: [],\n              keyIds: new Set(),\n              language: video.closedCaptions.get(id),\n              label: null,\n              type: ContentType.TEXT,\n              primary: false,\n              trickModeVideo: null,\n              emsgSchemeIdUris: null,\n              roles: video.roles,\n              forced: false,\n              channelsCount: null,\n              audioSamplingRate: null,\n              spatialAudio: false,\n              closedCaptions: null,\n            };\n            manifest.textStreams.push(textStream);\n            closedCaptionsSet.add(id);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Filters a manifest, removing unplayable streams/variants.\n   *\n   * @param {?shaka.extern.Manifest} manifest\n   * @private\n   */\n  async filterManifest_(manifest) {\n    await this.filterManifestWithStreamUtils_(manifest);\n    this.filterManifestWithRestrictions_(manifest);\n  }\n\n  /**\n   * Filters a manifest, removing unplayable streams/variants.\n   *\n   * @param {?shaka.extern.Manifest} manifest\n   * @private\n   */\n  async filterManifestWithStreamUtils_(manifest) {\n    goog.asserts.assert(manifest, 'Manifest should exist!');\n    goog.asserts.assert(this.video_, 'Must not be destroyed');\n\n    /** @type {?shaka.extern.Variant} */\n    const currentVariant = this.streamingEngine_ ?\n        this.streamingEngine_.getCurrentVariant() : null;\n\n    await shaka.util.StreamUtils.filterManifest(\n        this.drmEngine_, currentVariant, manifest);\n    this.checkPlayableVariants_(manifest);\n  }\n\n\n  /**\n   * Apply the restrictions configuration to the manifest, and check if there's\n   * a variant that meets the restrictions.\n   *\n   * @param {?shaka.extern.Manifest} manifest\n   * @private\n   */\n  filterManifestWithRestrictions_(manifest) {\n    // Return if |destroy| is called.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return;\n    }\n    const tracksChanged = shaka.util.StreamUtils.applyRestrictions(\n        manifest.variants, this.config_.restrictions, this.maxHwRes_);\n    if (tracksChanged && this.streamingEngine_) {\n      this.onTracksChanged_();\n    }\n\n    // We may need to create new sessions for any new init data.\n    const curDrmInfo = this.drmEngine_ ? this.drmEngine_.getDrmInfo() : null;\n    // DrmEngine.newInitData() requires mediaKeys to be available.\n    if (curDrmInfo && this.drmEngine_.getMediaKeys()) {\n      for (const variant of manifest.variants) {\n        const videoDrmInfos = variant.video ? variant.video.drmInfos : [];\n        const audioDrmInfos = variant.audio ? variant.audio.drmInfos : [];\n        const drmInfos = videoDrmInfos.concat(audioDrmInfos);\n        for (const drmInfo of drmInfos) {\n          // Ignore any data for different key systems.\n          if (drmInfo.keySystem == curDrmInfo.keySystem) {\n            for (const initData of (drmInfo.initData || [])) {\n              this.drmEngine_.newInitData(\n                  initData.initDataType, initData.initData);\n            }\n          }\n        }\n      }\n    }\n\n    this.checkRestrictedVariants_(manifest);\n  }\n\n  /**\n   * @private\n   */\n  filterManifestByCurrentVariant_() {\n    goog.asserts.assert(this.manifest_, 'Manifest should be valid');\n    goog.asserts.assert(this.streamingEngine_,\n        'StreamingEngine should be valid');\n\n    const currentVariant = this.streamingEngine_ ?\n        this.streamingEngine_.getCurrentVariant() : null;\n    shaka.util.StreamUtils.filterManifestByCurrentVariant(currentVariant,\n        this.manifest_);\n    this.checkPlayableVariants_(this.manifest_);\n  }\n\n  /**\n   * @param {shaka.extern.Variant} initialVariant\n   * @param {number} time\n   * @return {!Promise.<number>}\n   * @private\n   */\n  async adjustStartTime_(initialVariant, time) {\n    /** @type {?shaka.extern.Stream} */\n    const activeAudio = initialVariant.audio;\n    /** @type {?shaka.extern.Stream} */\n    const activeVideo = initialVariant.video;\n\n    /**\n     * @param {?shaka.extern.Stream} stream\n     * @param {number} time\n     * @return {!Promise.<?number>}\n     */\n    const getAdjustedTime = async (stream, time) => {\n      if (!stream) {\n        return null;\n      }\n\n      await stream.createSegmentIndex();\n      const iter = stream.segmentIndex.getIteratorForTime(time);\n      const ref = iter ? iter.next().value : null;\n      if (!ref) {\n        return null;\n      }\n\n      const refTime = ref.startTime;\n      goog.asserts.assert(refTime <= time,\n          'Segment should start before target time!');\n      return refTime;\n    };\n\n    const audioStartTime = await getAdjustedTime(activeAudio, time);\n    const videoStartTime = await getAdjustedTime(activeVideo, time);\n\n    // If we have both video and audio times, pick the larger one.  If we picked\n    // the smaller one, that one will download an entire segment to buffer the\n    // difference.\n    if (videoStartTime != null && audioStartTime != null) {\n      return Math.max(videoStartTime, audioStartTime);\n    } else if (videoStartTime != null) {\n      return videoStartTime;\n    } else if (audioStartTime != null) {\n      return audioStartTime;\n    } else {\n      return time;\n    }\n  }\n\n  /**\n   * Update the buffering state to be either \"we are buffering\" or \"we are not\n   * buffering\", firing events to the app as needed.\n   *\n   * @private\n   */\n  updateBufferState_() {\n    const isBuffering = this.isBuffering();\n    shaka.log.v2('Player changing buffering state to', isBuffering);\n\n    // Make sure we have all the components we need before we consider ourselves\n    // as being loaded.\n    // TODO: Make the check for \"loaded\" simpler.\n    const loaded = this.stats_ && this.bufferObserver_ && this.playhead_;\n\n    if (loaded) {\n      this.playRateController_.setBuffering(isBuffering);\n      if (this.cmcdManager_) {\n        this.cmcdManager_.setBuffering(isBuffering);\n      }\n      this.updateStateHistory_();\n    }\n\n    // Surface the buffering event so that the app knows if/when we are\n    // buffering.\n    const eventName = shaka.Player.EventName.Buffering;\n    const data = (new Map()).set('buffering', isBuffering);\n    this.dispatchEvent(this.makeEvent_(eventName, data));\n  }\n\n  /**\n   * A callback for when the playback rate changes. We need to watch the\n   * playback rate so that if the playback rate on the media element changes\n   * (that was not caused by our play rate controller) we can notify the\n   * controller so that it can stay in-sync with the change.\n   *\n   * @private\n   */\n  onRateChange_() {\n    /** @type {number} */\n    const newRate = this.video_.playbackRate;\n\n    // On Edge, when someone seeks using the native controls, it will set the\n    // playback rate to zero until they finish seeking, after which it will\n    // return the playback rate.\n    //\n    // If the playback rate changes while seeking, Edge will cache the playback\n    // rate and use it after seeking.\n    //\n    // https://github.com/shaka-project/shaka-player/issues/951\n    if (newRate == 0) {\n      return;\n    }\n\n    if (this.playRateController_) {\n      // The playback rate has changed. This could be us or someone else.\n      // If this was us, setting the rate again will be a no-op.\n      this.playRateController_.set(newRate);\n    }\n\n    const event = this.makeEvent_(shaka.Player.EventName.RateChange);\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * Try updating the state history. If the player has not finished\n   * initializing, this will be a no-op.\n   *\n   * @private\n   */\n  updateStateHistory_() {\n    // If we have not finish initializing, this will be a no-op.\n    if (!this.stats_) {\n      return;\n    }\n    if (!this.bufferObserver_) {\n      return;\n    }\n\n    const State = shaka.media.BufferingObserver.State;\n\n    const history = this.stats_.getStateHistory();\n\n    if (this.bufferObserver_.getState() == State.STARVING) {\n      history.update('buffering');\n    } else if (this.video_.paused) {\n      history.update('paused');\n    } else if (this.video_.ended) {\n      history.update('ended');\n    } else {\n      history.update('playing');\n    }\n  }\n\n  /**\n   * Callback from Playhead.\n   *\n   * @private\n   */\n  onSeek_() {\n    if (this.playheadObservers_) {\n      this.playheadObservers_.notifyOfSeek();\n    }\n    if (this.streamingEngine_) {\n      this.streamingEngine_.seeked();\n    }\n    if (this.bufferObserver_) {\n      // If we seek into an unbuffered range, we should fire a 'buffering' event\n      // immediately.  If StreamingEngine can buffer fast enough, we may not\n      // update our buffering tracking otherwise.\n      this.pollBufferState_();\n    }\n  }\n\n  /**\n   * Update AbrManager with variants while taking into account restrictions,\n   * preferences, and ABR.\n   *\n   * On error, this dispatches an error event and returns false.\n   *\n   * @return {boolean} True if successful.\n   * @private\n   */\n  updateAbrManagerVariants_() {\n    try {\n      goog.asserts.assert(this.manifest_, 'Manifest should exist by now!');\n      this.checkRestrictedVariants_(this.manifest_);\n    } catch (e) {\n      this.onError_(e);\n      return false;\n    }\n\n    const playableVariants = this.manifest_.variants.filter((variant) => {\n      return shaka.util.StreamUtils.isPlayable(variant);\n    });\n\n    // Update the abr manager with newly filtered variants.\n    const adaptationSet = this.currentAdaptationSetCriteria_.create(\n        playableVariants);\n    this.abrManager_.setVariants(Array.from(adaptationSet.values()));\n    return true;\n  }\n\n  /**\n   * Chooses a variant from all possible variants while taking into account\n   * restrictions, preferences, and ABR.\n   *\n   * On error, this dispatches an error event and returns null.\n   *\n   * @return {?shaka.extern.Variant}\n   * @private\n   */\n  chooseVariant_() {\n    if (this.updateAbrManagerVariants_()) {\n      return this.abrManager_.chooseVariant();\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Choose a text stream from all possible text streams while taking into\n   * account user preference.\n   *\n   * @return {?shaka.extern.Stream}\n   * @private\n   */\n  chooseTextStream_() {\n    const subset = shaka.util.StreamUtils.filterStreamsByLanguageAndRole(\n        this.manifest_.textStreams,\n        this.currentTextLanguage_,\n        this.currentTextRole_,\n        this.currentTextForced_);\n    return subset[0] || null;\n  }\n\n  /**\n   * Chooses a new Variant.  If the new variant differs from the old one, it\n   * adds the new one to the switch history and switches to it.\n   *\n   * Called after a config change, a key status event, or an explicit language\n   * change.\n   *\n   * @private\n   */\n  chooseVariantAndSwitch_() {\n    goog.asserts.assert(this.config_, 'Must not be destroyed');\n\n    // Because we're running this after a config change (manual language\n    // change) or a key status event, it is always okay to clear the buffer\n    // here.\n    const chosenVariant = this.chooseVariant_();\n    if (chosenVariant) {\n      this.switchVariant_(chosenVariant, /* fromAdaptation= */ true,\n          /* clearBuffers= */ true, /* safeMargin= */ 0);\n    }\n  }\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @param {boolean} fromAdaptation\n   * @param {boolean} clearBuffer\n   * @param {number} safeMargin\n   * @private\n   */\n  switchVariant_(variant, fromAdaptation, clearBuffer, safeMargin) {\n    const currentVariant = this.streamingEngine_.getCurrentVariant();\n    if (variant == currentVariant) {\n      shaka.log.debug('Variant already selected.');\n      // If you want to clear the buffer, we force to reselect the same variant\n      if (clearBuffer) {\n        this.streamingEngine_.switchVariant(variant, clearBuffer, safeMargin,\n            /* force= */ true);\n      }\n      return;\n    }\n\n    // Add entries to the history.\n    this.addVariantToSwitchHistory_(variant, fromAdaptation);\n    this.streamingEngine_.switchVariant(variant, clearBuffer, safeMargin);\n    let oldTrack = null;\n    if (currentVariant) {\n      oldTrack = shaka.util.StreamUtils.variantToTrack(currentVariant);\n    }\n    const newTrack = shaka.util.StreamUtils.variantToTrack(variant);\n\n    if (fromAdaptation) {\n      // Dispatch an 'adaptation' event\n      this.onAdaptation_(oldTrack, newTrack);\n    } else {\n      // Dispatch a 'variantchanged' event\n      this.onVariantChanged_(oldTrack, newTrack);\n    }\n  }\n\n  /**\n   * @param {AudioTrack} track\n   * @private\n   */\n  switchHtml5Track_(track) {\n    goog.asserts.assert(this.video_ && this.video_.audioTracks,\n        'Video and video.audioTracks should not be null!');\n    const audioTracks = Array.from(this.video_.audioTracks);\n    const currentTrack = audioTracks.find((t) => t.enabled);\n\n    // This will reset the \"enabled\" of other tracks to false.\n    track.enabled = true;\n\n    // AirPlay does not reset the \"enabled\" of other tracks to false, so\n    // it must be changed by hand.\n    if (track.id !== currentTrack.id) {\n      currentTrack.enabled = false;\n    }\n\n    const oldTrack =\n      shaka.util.StreamUtils.html5AudioTrackToTrack(currentTrack);\n    const newTrack =\n      shaka.util.StreamUtils.html5AudioTrackToTrack(track);\n    this.onVariantChanged_(oldTrack, newTrack);\n  }\n\n  /**\n   * Decide during startup if text should be streamed/shown.\n   * @private\n   */\n  setInitialTextState_(initialVariant, initialTextStream) {\n    // Check if we should show text (based on difference between audio and text\n    // languages).\n    if (initialTextStream) {\n      if (initialVariant.audio && this.shouldInitiallyShowText_(\n          initialVariant.audio, initialTextStream)) {\n        this.isTextVisible_ = true;\n      }\n      if (this.isTextVisible_) {\n        // If the cached value says to show text, then update the text displayer\n        // since it defaults to not shown.\n        this.mediaSourceEngine_.getTextDisplayer().setTextVisibility(true);\n        goog.asserts.assert(this.shouldStreamText_(),\n            'Should be streaming text');\n      }\n      this.onTextTrackVisibility_();\n    } else {\n      this.isTextVisible_ = false;\n    }\n  }\n\n  /**\n   * Check if we should show text on screen automatically.\n   *\n   * The text should automatically be shown if the text is language-compatible\n   * with the user's text language preference, but not compatible with the\n   * audio.\n   *\n   * For example:\n   *   preferred | chosen | chosen |\n   *   text      | text   | audio  | show\n   *   -----------------------------------\n   *   en-CA     | en     | jp     | true\n   *   en        | en-US  | fr     | true\n   *   fr-CA     | en-US  | jp     | false\n   *   en-CA     | en-US  | en-US  | false\n   *\n   * @param {shaka.extern.Stream} audioStream\n   * @param {shaka.extern.Stream} textStream\n   * @return {boolean}\n   * @private\n   */\n  shouldInitiallyShowText_(audioStream, textStream) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {string} */\n    const preferredTextLocale =\n        LanguageUtils.normalize(this.config_.preferredTextLanguage);\n    /** @type {string} */\n    const audioLocale = LanguageUtils.normalize(audioStream.language);\n    /** @type {string} */\n    const textLocale = LanguageUtils.normalize(textStream.language);\n\n    return (\n      LanguageUtils.areLanguageCompatible(textLocale, preferredTextLocale) &&\n      !LanguageUtils.areLanguageCompatible(audioLocale, textLocale));\n  }\n\n  /**\n   * Callback from StreamingEngine.\n   *\n   * @private\n   */\n  onManifestUpdate_() {\n    if (this.parser_ && this.parser_.update) {\n      this.parser_.update();\n    }\n  }\n\n  /**\n   * Callback from StreamingEngine.\n   *\n   * @private\n   */\n  onSegmentAppended_() {\n    // When we append a segment to media source (via streaming engine) we are\n    // changing what data we have buffered, so notify the playhead of the\n    // change.\n    if (this.playhead_) {\n      this.playhead_.notifyOfBufferingChange();\n    }\n    this.pollBufferState_();\n  }\n\n  /**\n   * Callback from AbrManager.\n   *\n   * @param {shaka.extern.Variant} variant\n   * @param {boolean=} clearBuffer\n   * @param {number=} safeMargin Optional amount of buffer (in seconds) to\n   *   retain when clearing the buffer.\n   *   Defaults to 0 if not provided. Ignored if clearBuffer is false.\n   * @private\n   */\n  switch_(variant, clearBuffer = false, safeMargin = 0) {\n    shaka.log.debug('switch_');\n    goog.asserts.assert(this.config_.abr.enabled,\n        'AbrManager should not call switch while disabled!');\n    goog.asserts.assert(this.manifest_, 'We need a manifest to switch ' +\n                                        'variants.');\n\n    if (!this.streamingEngine_) {\n      // There's no way to change it.\n      return;\n    }\n\n    if (variant == this.streamingEngine_.getCurrentVariant()) {\n      // This isn't a change.\n      return;\n    }\n\n    this.switchVariant_(variant, /* fromAdaptation= */ true,\n        clearBuffer, safeMargin);\n  }\n\n  /**\n   * Dispatches an 'adaptation' event.\n   * @param {?shaka.extern.Track} from\n   * @param {shaka.extern.Track} to\n   * @private\n   */\n  onAdaptation_(from, to) {\n    // Delay the 'adaptation' event so that StreamingEngine has time to absorb\n    // the changes before the user tries to query it.\n    const data = new Map()\n        .set('oldTrack', from)\n        .set('newTrack', to);\n    const event = this.makeEvent_(shaka.Player.EventName.Adaptation, data);\n    this.delayDispatchEvent_(event);\n  }\n\n  /**\n   * Dispatches a 'trackschanged' event.\n   * @private\n   */\n  onTracksChanged_() {\n    // Delay the 'trackschanged' event so StreamingEngine has time to absorb the\n    // changes before the user tries to query it.\n    const event = this.makeEvent_(shaka.Player.EventName.TracksChanged);\n    this.delayDispatchEvent_(event);\n  }\n\n  /**\n   * Dispatches a 'variantchanged' event.\n   * @param {?shaka.extern.Track} from\n   * @param {shaka.extern.Track} to\n   * @private\n   */\n  onVariantChanged_(from, to) {\n    // Delay the 'variantchanged' event so StreamingEngine has time to absorb\n    // the changes before the user tries to query it.\n    const data = new Map()\n        .set('oldTrack', from)\n        .set('newTrack', to);\n    const event = this.makeEvent_(shaka.Player.EventName.VariantChanged, data);\n    this.delayDispatchEvent_(event);\n  }\n\n  /**\n   * Dispatches a 'textchanged' event.\n   * @private\n   */\n  onTextChanged_() {\n    // Delay the 'textchanged' event so StreamingEngine time to absorb the\n    // changes before the user tries to query it.\n    const event = this.makeEvent_(shaka.Player.EventName.TextChanged);\n    this.delayDispatchEvent_(event);\n  }\n\n  /** @private */\n  onTextTrackVisibility_() {\n    const event = this.makeEvent_(shaka.Player.EventName.TextTrackVisibility);\n    this.delayDispatchEvent_(event);\n  }\n\n  /** @private */\n  onAbrStatusChanged_() {\n    const data = (new Map()).set('newStatus', this.config_.abr.enabled);\n    this.delayDispatchEvent_(this.makeEvent_(\n        shaka.Player.EventName.AbrStatusChanged, data));\n  }\n\n  /**\n   * @param {!shaka.util.Error} error\n   * @private\n   */\n  onError_(error) {\n    goog.asserts.assert(error instanceof shaka.util.Error, 'Wrong error type!');\n\n    // Errors dispatched after |destroy| is called are not meaningful and should\n    // be safe to ignore.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return;\n    }\n\n    const eventName = shaka.Player.EventName.Error;\n    const event = this.makeEvent_(eventName, (new Map()).set('detail', error));\n    this.dispatchEvent(event);\n    if (event.defaultPrevented) {\n      error.handled = true;\n    }\n  }\n\n  /**\n   * When we fire region events, we need to copy the information out of the\n   * region to break the connection with the player's internal data. We do the\n   * copy here because this is the transition point between the player and the\n   * app.\n   *\n   * @param {!shaka.Player.EventName} eventName\n   * @param {shaka.extern.TimelineRegionInfo} region\n   *\n   * @private\n   */\n  onRegionEvent_(eventName, region) {\n    // Always make a copy to avoid exposing our internal data to the app.\n    const clone = {\n      schemeIdUri: region.schemeIdUri,\n      value: region.value,\n      startTime: region.startTime,\n      endTime: region.endTime,\n      id: region.id,\n      eventElement: region.eventElement,\n    };\n\n    const data = (new Map()).set('detail', clone);\n    this.dispatchEvent(this.makeEvent_(eventName, data));\n  }\n\n  /**\n   * When notified of a media quality change we need to emit a\n   * MediaQualityChange event to the app.\n   *\n   * @param {shaka.extern.MediaQualityInfo} mediaQuality\n   * @param {number} position\n   *\n   * @private\n   */\n  onMediaQualityChange_(mediaQuality, position) {\n    // Always make a copy to avoid exposing our internal data to the app.\n    const clone = {\n      bandwidth: mediaQuality.bandwidth,\n      audioSamplingRate: mediaQuality.audioSamplingRate,\n      codecs: mediaQuality.codecs,\n      contentType: mediaQuality.contentType,\n      frameRate: mediaQuality.frameRate,\n      height: mediaQuality.height,\n      mimeType: mediaQuality.mimeType,\n      channelsCount: mediaQuality.channelsCount,\n      pixelAspectRatio: mediaQuality.pixelAspectRatio,\n      width: mediaQuality.width,\n    };\n\n    const data = new Map()\n        .set('mediaQuality', clone)\n        .set('position', position);\n\n    this.dispatchEvent(this.makeEvent_(\n        shaka.Player.EventName.MediaQualityChanged, data));\n  }\n\n  /**\n   * Turn the media element's error object into a Shaka Player error object.\n   *\n   * @return {shaka.util.Error}\n   * @private\n   */\n  videoErrorToShakaError_() {\n    goog.asserts.assert(this.video_.error,\n        'Video error expected, but missing!');\n    if (!this.video_.error) {\n      return null;\n    }\n\n    const code = this.video_.error.code;\n    if (code == 1 /* MEDIA_ERR_ABORTED */) {\n      // Ignore this error code, which should only occur when navigating away or\n      // deliberately stopping playback of HTTP content.\n      return null;\n    }\n\n    // Extra error information from MS Edge:\n    let extended = this.video_.error.msExtendedCode;\n    if (extended) {\n      // Convert to unsigned:\n      if (extended < 0) {\n        extended += Math.pow(2, 32);\n      }\n      // Format as hex:\n      extended = extended.toString(16);\n    }\n\n    // Extra error information from Chrome:\n    const message = this.video_.error.message;\n\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.VIDEO_ERROR,\n        code, extended, message);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   */\n  onVideoError_(event) {\n    const error = this.videoErrorToShakaError_();\n    if (!error) {\n      return;\n    }\n    this.onError_(error);\n  }\n\n  /**\n   * @param {!Object.<string, string>} keyStatusMap A map of hex key IDs to\n   *   statuses.\n   * @private\n   */\n  onKeyStatus_(keyStatusMap) {\n    if (!this.streamingEngine_) {\n      // We can't use this info to manage restrictions in src= mode, so ignore\n      // it.\n      return;\n    }\n\n    const keyIds = Object.keys(keyStatusMap);\n    if (keyIds.length == 0) {\n      shaka.log.warning(\n          'Got a key status event without any key statuses, so we don\\'t ' +\n          'know the real key statuses. If we don\\'t have all the keys, ' +\n          'you\\'ll need to set restrictions so we don\\'t select those tracks.');\n    }\n\n    // If EME is using a synthetic key ID, the only key ID is '00' (a single 0\n    // byte).  In this case, it is only used to report global success/failure.\n    // See note about old platforms in: https://bit.ly/2tpez5Z\n    const isGlobalStatus = keyIds.length == 1 && keyIds[0] == '00';\n    if (isGlobalStatus) {\n      shaka.log.warning(\n          'Got a synthetic key status event, so we don\\'t know the real key ' +\n          'statuses. If we don\\'t have all the keys, you\\'ll need to set ' +\n          'restrictions so we don\\'t select those tracks.');\n    }\n\n    const restrictedStatuses = shaka.Player.restrictedStatuses_;\n    let tracksChanged = false;\n\n    // Only filter tracks for keys if we have some key statuses to look at.\n    if (keyIds.length) {\n      for (const variant of this.manifest_.variants) {\n        const streams = shaka.util.StreamUtils.getVariantStreams(variant);\n\n        for (const stream of streams) {\n          const originalAllowed = variant.allowedByKeySystem;\n\n          // Only update if we have key IDs for the stream.  If the keys aren't\n          // all present, then the track should be restricted.\n          if (stream.keyIds.size) {\n            variant.allowedByKeySystem = true;\n\n            for (const keyId of stream.keyIds) {\n              const keyStatus = keyStatusMap[isGlobalStatus ? '00' : keyId];\n              variant.allowedByKeySystem = variant.allowedByKeySystem &&\n                  !!keyStatus && !restrictedStatuses.includes(keyStatus);\n            }\n          }\n\n          if (originalAllowed != variant.allowedByKeySystem) {\n            tracksChanged = true;\n          }\n        }  // for (const stream of streams)\n      }  // for (const variant of this.manifest_.variants)\n    }  // if (keyIds.size)\n\n    if (tracksChanged) {\n      const variantsUpdated = this.updateAbrManagerVariants_();\n      if (!variantsUpdated) {\n        return;\n      }\n    }\n\n    const currentVariant = this.streamingEngine_.getCurrentVariant();\n    if (currentVariant && !currentVariant.allowedByKeySystem) {\n      shaka.log.debug('Choosing new streams after key status changed');\n      this.chooseVariantAndSwitch_();\n    }\n\n    if (tracksChanged) {\n      this.onTracksChanged_();\n    }\n  }\n\n  /**\n   * Callback from DrmEngine\n   * @param {string} keyId\n   * @param {number} expiration\n   * @private\n   */\n  onExpirationUpdated_(keyId, expiration) {\n    if (this.parser_ && this.parser_.onExpirationUpdated) {\n      this.parser_.onExpirationUpdated(keyId, expiration);\n    }\n\n    const event = this.makeEvent_(shaka.Player.EventName.ExpirationUpdated);\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * @return {boolean} true if we should stream text right now.\n   * @private\n   */\n  shouldStreamText_() {\n    return this.config_.streaming.alwaysStreamText || this.isTextTrackVisible();\n  }\n\n  /**\n   * Applies playRangeStart and playRangeEnd to the given timeline. This will\n   * only affect non-live content.\n   *\n   * @param {shaka.media.PresentationTimeline} timeline\n   * @param {number} playRangeStart\n   * @param {number} playRangeEnd\n   *\n   * @private\n   */\n  static applyPlayRange_(timeline, playRangeStart, playRangeEnd) {\n    if (playRangeStart > 0) {\n      if (timeline.isLive()) {\n        shaka.log.warning(\n            '|playRangeStart| has been configured for live content. ' +\n            'Ignoring the setting.');\n      } else {\n        timeline.setUserSeekStart(playRangeStart);\n      }\n    }\n\n    // If the playback has been configured to end before the end of the\n    // presentation, update the duration unless it's live content.\n    const fullDuration = timeline.getDuration();\n    if (playRangeEnd < fullDuration) {\n      if (timeline.isLive()) {\n        shaka.log.warning(\n            '|playRangeEnd| has been configured for live content. ' +\n            'Ignoring the setting.');\n      } else {\n        timeline.setDuration(playRangeEnd);\n      }\n    }\n  }\n\n  /**\n   * Checks if the variants are all restricted, and throw an appropriate\n   * exception if so.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   *\n   * @private\n   */\n  checkRestrictedVariants_(manifest) {\n    const restrictedStatuses = shaka.Player.restrictedStatuses_;\n    const keyStatusMap =\n        this.drmEngine_ ? this.drmEngine_.getKeyStatuses() : {};\n    const keyIds = Object.keys(keyStatusMap);\n    const isGlobalStatus = keyIds.length && keyIds[0] == '00';\n\n    let hasPlayable = false;\n    let hasAppRestrictions = false;\n\n    /** @type {!Set.<string>} */\n    const missingKeys = new Set();\n\n    /** @type {!Set.<string>} */\n    const badKeyStatuses = new Set();\n\n    for (const variant of manifest.variants) {\n      // TODO: Combine with onKeyStatus_.\n      const streams = [];\n      if (variant.audio) {\n        streams.push(variant.audio);\n      }\n      if (variant.video) {\n        streams.push(variant.video);\n      }\n\n      for (const stream of streams) {\n        if (stream.keyIds.size) {\n          for (const keyId of stream.keyIds) {\n            const keyStatus = keyStatusMap[isGlobalStatus ? '00' : keyId];\n            if (!keyStatus) {\n              missingKeys.add(keyId);\n            } else if (restrictedStatuses.includes(keyStatus)) {\n              badKeyStatuses.add(keyStatus);\n            }\n          }\n        }  // if (stream.keyIds.size)\n      }\n\n      if (!variant.allowedByApplication) {\n        hasAppRestrictions = true;\n      } else if (variant.allowedByKeySystem) {\n        hasPlayable = true;\n      }\n    }\n\n    if (!hasPlayable) {\n      /** @type {shaka.extern.RestrictionInfo} */\n      const data = {\n        hasAppRestrictions,\n        missingKeys: Array.from(missingKeys),\n        restrictedKeyStatuses: Array.from(badKeyStatuses),\n      };\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.RESTRICTIONS_CANNOT_BE_MET,\n          data);\n    }\n  }\n\n  /**\n   * Confirm some variants are playable. Otherwise, throw an exception.\n   * @param {!shaka.extern.Manifest} manifest\n   * @private\n   */\n  checkPlayableVariants_(manifest) {\n    const valid = manifest.variants.some(shaka.util.StreamUtils.isPlayable);\n\n    // If none of the variants are playable, throw\n    // CONTENT_UNSUPPORTED_BY_BROWSER.\n    if (!valid) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.CONTENT_UNSUPPORTED_BY_BROWSER);\n    }\n  }\n\n  /**\n   * Fire an event, but wait a little bit so that the immediate execution can\n   * complete before the event is handled.\n   *\n   * @param {!shaka.util.FakeEvent} event\n   * @private\n   */\n  async delayDispatchEvent_(event) {\n    // Wait until the next interpreter cycle.\n    await Promise.resolve();\n\n    // Only dispatch the event if we are still alive.\n    if (this.loadMode_ != shaka.Player.LoadMode.DESTROYED) {\n      this.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * Get the normalized languages for a group of tracks.\n   *\n   * @param {!Array.<?shaka.extern.Track>} tracks\n   * @return {!Set.<string>}\n   * @private\n   */\n  static getLanguagesFrom_(tracks) {\n    const languages = new Set();\n\n    for (const track of tracks) {\n      if (track.language) {\n        languages.add(shaka.util.LanguageUtils.normalize(track.language));\n      } else {\n        languages.add('und');\n      }\n    }\n\n    return languages;\n  }\n\n  /**\n   * Get all permutations of normalized languages and role for a group of\n   * tracks.\n   *\n   * @param {!Array.<?shaka.extern.Track>} tracks\n   * @return {!Array.<shaka.extern.LanguageRole>}\n   * @private\n   */\n  static getLanguageAndRolesFrom_(tracks) {\n    /** @type {!Map.<string, !Set>} */\n    const languageToRoles = new Map();\n    /** @type {!Map.<string, !Map.<string, string>>} */\n    const languageRoleToLabel = new Map();\n\n    for (const track of tracks) {\n      let language = 'und';\n      let roles = [];\n\n      if (track.language) {\n        language = shaka.util.LanguageUtils.normalize(track.language);\n      }\n\n      if (track.type == 'variant') {\n        roles = track.audioRoles;\n      } else {\n        roles = track.roles;\n      }\n\n      if (!roles || !roles.length) {\n        // We must have an empty role so that we will still get a language-role\n        // entry from our Map.\n        roles = [''];\n      }\n\n      if (!languageToRoles.has(language)) {\n        languageToRoles.set(language, new Set());\n      }\n\n      for (const role of roles) {\n        languageToRoles.get(language).add(role);\n        if (track.label) {\n          if (!languageRoleToLabel.has(language)) {\n            languageRoleToLabel.set(language, new Map());\n          }\n          languageRoleToLabel.get(language).set(role, track.label);\n        }\n      }\n    }\n\n    // Flatten our map to an array of language-role pairs.\n    const pairings = [];\n    languageToRoles.forEach((roles, language) => {\n      for (const role of roles) {\n        let label = null;\n        if (languageRoleToLabel.has(language) &&\n            languageRoleToLabel.get(language).has(role)) {\n          label = languageRoleToLabel.get(language).get(role);\n        }\n        pairings.push({language, role, label});\n      }\n    });\n    return pairings;\n  }\n\n  /**\n   * Assuming the player is playing content with media source, check if the\n   * player has buffered enough content to make it to the end of the\n   * presentation.\n   *\n   * @return {boolean}\n   * @private\n   */\n  isBufferedToEndMS_() {\n    goog.asserts.assert(\n        this.video_,\n        'We need a video element to get buffering information');\n    goog.asserts.assert(\n        this.mediaSourceEngine_,\n        'We need a media source engine to get buffering information');\n    goog.asserts.assert(\n        this.manifest_,\n        'We need a manifest to get buffering information');\n\n    // This is a strong guarantee that we are buffered to the end, because it\n    // means the playhead is already at that end.\n    if (this.video_.ended) {\n      return true;\n    }\n\n    // This means that MediaSource has buffered the final segment in all\n    // SourceBuffers and is no longer accepting additional segments.\n    if (this.mediaSourceEngine_.ended()) {\n      return true;\n    }\n\n    // Live streams are \"buffered to the end\" when they have buffered to the\n    // live edge or beyond (into the region covered by the presentation delay).\n    if (this.manifest_.presentationTimeline.isLive()) {\n      const liveEdge =\n          this.manifest_.presentationTimeline.getSegmentAvailabilityEnd();\n      const bufferEnd =\n          shaka.media.TimeRangesUtils.bufferEnd(this.video_.buffered);\n\n      if (bufferEnd != null && bufferEnd >= liveEdge) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Assuming the player is playing content with src=, check if the player has\n   * buffered enough content to make it to the end of the presentation.\n   *\n   * @return {boolean}\n   * @private\n   */\n  isBufferedToEndSrc_() {\n    goog.asserts.assert(\n        this.video_,\n        'We need a video element to get buffering information');\n\n    // This is a strong guarantee that we are buffered to the end, because it\n    // means the playhead is already at that end.\n    if (this.video_.ended) {\n      return true;\n    }\n\n    // If we have buffered to the duration of the content, it means we will have\n    // enough content to buffer to the end of the presentation.\n    const bufferEnd =\n        shaka.media.TimeRangesUtils.bufferEnd(this.video_.buffered);\n\n    // Because Safari's native HLS reports slightly inaccurate values for\n    // bufferEnd here, we use a fudge factor.  Without this, we can end up in a\n    // buffering state at the end of the stream.  See issue #2117.\n    // TODO: Try to remove the fudge here once we no longer manage buffering\n    // state above the browser with playbackRate=0.\n    const fudge = 1;  // 1000 ms\n    return bufferEnd != null && bufferEnd >= this.video_.duration - fudge;\n  }\n\n  /**\n   * Create an error for when we purposely interrupt a load operation.\n   *\n   * @return {!shaka.util.Error}\n   * @private\n   */\n  createAbortLoadError_() {\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.LOAD_INTERRUPTED);\n  }\n\n  /**\n   * Key\n   * ----------------------\n   * D   : Detach Node\n   * A   : Attach Node\n   * MS  : Media Source Node\n   * P   : Manifest Parser Node\n   * M   : Manifest Node\n   * DRM : Drm Engine Node\n   * L   : Load Node\n   * U   : Unloading Node\n   * SRC : Src Equals Node\n   *\n   * Graph Topology\n   * ----------------------\n   *\n   *        [SRC]-----+\n   *         ^        |\n   *         |        v\n   * [D]<-->[A]<-----[U]\n   *         |        ^\n   *         v        |\n   *        [MS]------+\n   *         |        |\n   *         v        |\n   *        [P]-------+\n   *         |        |\n   *         v        |\n   *        [M]-------+\n   *         |        |\n   *         v        |\n   *        [DRM]-----+\n   *         |        |\n   *         v        |\n   *        [L]-------+\n   *\n   * @param {!shaka.routing.Node} currentlyAt\n   * @param {shaka.routing.Payload} currentlyWith\n   * @param {!shaka.routing.Node} wantsToBeAt\n   * @param {shaka.routing.Payload} wantsToHave\n   * @return {?shaka.routing.Node}\n   * @private\n   */\n  getNextStep_(currentlyAt, currentlyWith, wantsToBeAt, wantsToHave) {\n    let next = null;\n\n    // Detach is very simple, either stay in detach (because |detach| was called\n    // while in detached) or go somewhere that requires us to attach to an\n    // element.\n    if (currentlyAt == this.detachNode_) {\n      next = wantsToBeAt == this.detachNode_ ?\n             this.detachNode_ :\n             this.attachNode_;\n    }\n\n    if (currentlyAt == this.attachNode_) {\n      next = this.getNextAfterAttach_(wantsToBeAt, currentlyWith, wantsToHave);\n    }\n\n    if (currentlyAt == this.mediaSourceNode_) {\n      next = this.getNextAfterMediaSource_(\n          wantsToBeAt, currentlyWith, wantsToHave);\n    }\n\n    if (currentlyAt == this.parserNode_) {\n      next = this.getNextMatchingAllDependencies_(\n          /* destination= */ this.loadNode_,\n          /* next= */ this.manifestNode_,\n          /* reset= */ this.unloadNode_,\n          /* goingTo= */ wantsToBeAt,\n          /* has= */ currentlyWith,\n          /* wants= */ wantsToHave);\n    }\n\n    if (currentlyAt == this.manifestNode_) {\n      next = this.getNextMatchingAllDependencies_(\n          /* destination= */ this.loadNode_,\n          /* next= */ this.drmNode_,\n          /* reset= */ this.unloadNode_,\n          /* goingTo= */ wantsToBeAt,\n          /* has= */ currentlyWith,\n          /* wants= */ wantsToHave);\n    }\n\n    // For DRM, we have two options \"load\" or \"unload\". If all our constraints\n    // are met, we can go to \"load\". If anything is off, we must go back to\n    // \"unload\" to reset.\n    if (currentlyAt == this.drmNode_) {\n      next = this.getNextMatchingAllDependencies_(\n          /* destination= */ this.loadNode_,\n          /* next= */ this.loadNode_,\n          /* reset= */ this.unloadNode_,\n          /* goingTo= */ wantsToBeAt,\n          /* has= */ currentlyWith,\n          /* wants= */ wantsToHave);\n    }\n\n    // For DRM w/ src= playback, we only care about destination and media\n    // element.\n    if (currentlyAt == this.srcEqualsDrmNode_) {\n      if (wantsToBeAt == this.srcEqualsNode_ &&\n          currentlyWith.mediaElement == wantsToHave.mediaElement) {\n        next = this.srcEqualsNode_;\n      } else {\n        next = this.unloadNode_;\n      }\n    }\n\n    // After we load content, always go through unload because we can't safely\n    // use components after we have started playback.\n    if (currentlyAt == this.loadNode_ || currentlyAt == this.srcEqualsNode_) {\n      next = this.unloadNode_;\n    }\n\n    if (currentlyAt == this.unloadNode_) {\n      next = this.getNextAfterUnload_(wantsToBeAt, currentlyWith, wantsToHave);\n    }\n\n    goog.asserts.assert(next, 'Missing next step!');\n    return next;\n  }\n\n  /**\n   * @param {!shaka.routing.Node} goingTo\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {?shaka.routing.Node}\n   * @private\n   */\n  getNextAfterAttach_(goingTo, has, wants) {\n    // Attach and detach are the only two nodes that we can directly go\n    // back-and-forth between.\n    if (goingTo == this.detachNode_) {\n      return this.detachNode_;\n    }\n\n    // If we are going anywhere other than detach, then we need the media\n    // element to match, if they don't match, we need to go through detach\n    // first.\n    if (has.mediaElement != wants.mediaElement) {\n      return this.detachNode_;\n    }\n\n    // If we are already in attached, and someone calls |attach| again (to the\n    // same video element), we can handle the redundant request by re-entering\n    // our current state.\n    if (goingTo == this.attachNode_) {\n      return this.attachNode_;\n    }\n\n    // The next step from attached to loaded is through media source.\n    if (goingTo == this.mediaSourceNode_ || goingTo == this.loadNode_) {\n      return this.mediaSourceNode_;\n    }\n\n    // If we are going to src=, then we should set up DRM first.  This will\n    // support cases like FairPlay HLS on Safari.\n    if (goingTo == this.srcEqualsNode_) {\n      return this.srcEqualsDrmNode_;\n    }\n\n    // We are missing a rule, the null will get caught by a common check in\n    // the routing system.\n    return null;\n  }\n\n  /**\n   * @param {!shaka.routing.Node} goingTo\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {?shaka.routing.Node}\n   * @private\n   */\n  getNextAfterMediaSource_(goingTo, has, wants) {\n    // We can only go to parse manifest or unload. If we want to go to load and\n    // we have the right media element, we can go to parse manifest. If we\n    // don't, no matter where we want to go, we must go through unload.\n    if (goingTo == this.loadNode_ && has.mediaElement == wants.mediaElement) {\n      return this.parserNode_;\n    }\n\n    // Right now the unload node is responsible for tearing down all playback\n    // components (including media source). So since we have created media\n    // source, we need to unload since our dependencies are not compatible.\n    //\n    // TODO: We are structured this way to maintain a historic structure. Going\n    //       forward, there is no reason to restrict ourselves to this. Going\n    //       forward we should explore breaking apart |onUnload| and develop\n    //       more meaningful terminology around tearing down playback resources.\n    return this.unloadNode_;\n  }\n\n  /**\n   * After unload there are only two options, attached or detached. This choice\n   * is based on whether or not we have a media element. If we have a media\n   * element, then we go to attach. If we don't have a media element, we go to\n   * detach.\n   *\n   * @param {!shaka.routing.Node} goingTo\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {?shaka.routing.Node}\n   * @private\n   */\n  getNextAfterUnload_(goingTo, has, wants) {\n    // If we don't want a media element, detach.\n    // If we have the wrong media element, detach.\n    // Otherwise it means we want to attach to a media element and it is safe to\n    // do so.\n    return !wants.mediaElement || has.mediaElement != wants.mediaElement ?\n           this.detachNode_ :\n           this.attachNode_;\n  }\n\n  /**\n   * A general method used to handle routing when we can either than one step\n   * toward our destination (while all our dependencies match) or go to a node\n   * that will reset us so we can try again.\n   *\n   * @param {!shaka.routing.Node} destinationNode\n   *   What |goingTo| must be for us to step toward |nextNode|. Otherwise we\n   *   will go to |resetNode|.\n   * @param {!shaka.routing.Node} nextNode\n   *   The node we will go to next if |goingTo == destinationNode| and all\n   *   dependencies match.\n   * @param {!shaka.routing.Node} resetNode\n   *   The node we will go to next if |goingTo != destinationNode| or any\n   *   dependency does not match.\n   * @param {!shaka.routing.Node} goingTo\n   *   The node that the walker is trying to go to.\n   * @param {shaka.routing.Payload} has\n   *   The payload that the walker currently has.\n   * @param {shaka.routing.Payload} wants\n   *   The payload that the walker wants to have when iy gets to |goingTo|.\n   * @return {shaka.routing.Node}\n   * @private\n   */\n  getNextMatchingAllDependencies_(destinationNode, nextNode, resetNode, goingTo,\n      has, wants) {\n    if (goingTo == destinationNode &&\n        has.mediaElement == wants.mediaElement &&\n        has.uri == wants.uri &&\n        has.mimeType == wants.mimeType) {\n      return nextNode;\n    }\n\n    return resetNode;\n  }\n\n  /**\n   * @return {shaka.routing.Payload}\n   * @private\n   */\n  static createEmptyPayload_() {\n    return {\n      mediaElement: null,\n      mimeType: null,\n      startTime: null,\n      startTimeOfLoad: NaN,\n      uri: null,\n    };\n  }\n\n  /**\n   * Using a promise, wrap the listeners returned by |Walker.startNewRoute|.\n   * This will work for most usages in |Player| but should not be used for\n   * special cases.\n   *\n   * This will connect |onCancel|, |onEnd|, |onError|, and |onSkip| with\n   * |resolve| and |reject| but will leave |onStart| unset.\n   *\n   * @param {shaka.routing.Walker.Listeners} listeners\n   * @return {!Promise}\n   * @private\n   */\n  wrapWalkerListenersWithPromise_(listeners) {\n    return new Promise((resolve, reject) => {\n      listeners.onCancel = () => reject(this.createAbortLoadError_());\n      listeners.onEnd = () => resolve();\n      listeners.onError = (e) => reject(e);\n      listeners.onSkip = () => reject(this.createAbortLoadError_());\n    });\n  }\n};\n\n/**\n * An internal enum that contains the string values of all of the player events.\n * This exists primarily to act as an implicit list of events, for tests.\n *\n * @enum {string}\n */\nshaka.Player.EventName = {\n  AbrStatusChanged: 'abrstatuschanged',\n  Adaptation: 'adaptation',\n  Buffering: 'buffering',\n  DownloadFailed: 'downloadfailed',\n  DownloadHeadersReceived: 'downloadheadersreceived',\n  DrmSessionUpdate: 'drmsessionupdate',\n  Emsg: 'emsg',\n  Error: 'error',\n  ExpirationUpdated: 'expirationupdated',\n  LargeGap: 'largegap',\n  Loaded: 'loaded',\n  Loading: 'loading',\n  ManifestParsed: 'manifestparsed',\n  MediaQualityChanged: 'mediaqualitychanged',\n  Metadata: 'metadata',\n  OnStateChange: 'onstatechange',\n  OnStateIdle: 'onstateidle',\n  RateChange: 'ratechange',\n  SessionDataEvent: 'sessiondata',\n  Streaming: 'streaming',\n  TextChanged: 'textchanged',\n  TextTrackVisibility: 'texttrackvisibility',\n  TimelineRegionAdded: 'timelineregionadded',\n  TimelineRegionEnter: 'timelineregionenter',\n  TimelineRegionExit: 'timelineregionexit',\n  TracksChanged: 'trackschanged',\n  Unloading: 'unloading',\n  VariantChanged: 'variantchanged',\n};\n\n\n/**\n * In order to know what method of loading the player used for some content, we\n * have this enum. It lets us know if content has not been loaded, loaded with\n * media source, or loaded with src equals.\n *\n * This enum has a low resolution, because it is only meant to express the\n * outer limits of the various states that the player is in. For example, when\n * someone calls a public method on player, it should not matter if they have\n * initialized drm engine, it should only matter if they finished loading\n * content.\n *\n * @enum {number}\n * @export\n */\nshaka.Player.LoadMode = {\n  'DESTROYED': 0,\n  'NOT_LOADED': 1,\n  'MEDIA_SOURCE': 2,\n  'SRC_EQUALS': 3,\n};\n\n/**\n * The typical buffering threshold.  When we have less than this buffered (in\n * seconds), we enter a buffering state.  This specific value is based on manual\n * testing and evaluation across a variety of platforms.\n *\n * To make the buffering logic work in all cases, this \"typical\" threshold will\n * be overridden if the rebufferingGoal configuration is too low.\n *\n * @const {number}\n * @private\n */\nshaka.Player.TYPICAL_BUFFERING_THRESHOLD_ = 0.5;\n\n/**\n * @define {string} A version number taken from git at compile time.\n * @export\n */\nshaka.Player.version = 'v3.3.19-uncompiled';\n\n// Initialize the deprecation system using the version string we just set\n// on the player.\nshaka.Deprecate.init(shaka.Player.version);\n\n\n/**\n * These are the EME key statuses that represent restricted playback.\n * 'usable', 'released', 'output-downscaled', 'status-pending' are statuses\n * of the usable keys.  'expired' status is being handled separately in\n * DrmEngine.\n *\n * @const {!Array.<string>}\n * @private\n */\nshaka.Player.restrictedStatuses_ = ['output-restricted', 'internal-error'];\n\n\n/** @private {!Object.<string, function():*>} */\nshaka.Player.supportPlugins_ = {};\n\n\n/** @private {?shaka.extern.IAdManager.Factory} */\nshaka.Player.adManagerFactory_ = null;\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.Player.SRC_EQUAL_EXTENSIONS_TO_MIME_TYPES_ = {\n  'mp4': 'video/mp4',\n  'm4v': 'video/mp4',\n  'm4a': 'audio/mp4',\n  'webm': 'video/webm',\n  'weba': 'audio/webm',\n  'mkv': 'video/webm', // Chromium browsers supports it.\n  'ts': 'video/mp2t',\n  'ogv': 'video/ogg',\n  'ogg': 'audio/ogg',\n  'mpg': 'video/mpeg',\n  'mpeg': 'video/mpeg',\n  'm3u8': 'application/x-mpegurl',\n  'mpd': 'application/dash+xml',\n  'mp3': 'audio/mpeg',\n  'aac': 'audio/aac',\n  'flac': 'audio/flac',\n  'wav': 'audio/wav',\n};\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.Player.TEXT_EXTENSIONS_TO_MIME_TYPES_ = {\n  'sbv': 'text/x-subviewer',\n  'srt': 'text/srt',\n  'vtt': 'text/vtt',\n  'webvtt': 'text/vtt',\n  'ttml': 'application/ttml+xml',\n  'lrc': 'application/x-subtitle-lrc',\n  'ssa': 'text/x-ssa',\n  'ass': 'text/x-ssa',\n};\n\n\n/**\n * @const {string}\n */\nshaka.Player.TextTrackLabel = 'Shaka Player TextTrack';\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.Backoff');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * Backoff represents delay and backoff state.  This is used by NetworkingEngine\n * for individual requests and by StreamingEngine to retry streaming failures.\n *\n * @final\n */\nshaka.net.Backoff = class {\n  /**\n   * @param {shaka.extern.RetryParameters} parameters\n   * @param {boolean=} autoReset  If true, start at a \"first retry\" state and\n   *   and auto-reset that state when we reach maxAttempts.\n   *   Default set to false.\n   */\n  constructor(parameters, autoReset = false) {\n    // Set defaults as we unpack these, so that individual app-level requests in\n    // NetworkingEngine can be missing parameters.\n\n    const defaults = shaka.net.Backoff.defaultRetryParameters();\n\n    /**\n     * @const\n     * @private {number}\n     */\n    this.maxAttempts_ = (parameters.maxAttempts == null) ?\n        defaults.maxAttempts : parameters.maxAttempts;\n\n    goog.asserts.assert(this.maxAttempts_ >= 1, 'maxAttempts should be >= 1');\n\n    /**\n     * @const\n     * @private {number}\n     */\n    this.baseDelay_ = (parameters.baseDelay == null) ?\n        defaults.baseDelay : parameters.baseDelay;\n\n    goog.asserts.assert(this.baseDelay_ >= 0, 'baseDelay should be >= 0');\n\n    /**\n     * @const\n     * @private {number}\n     */\n    this.fuzzFactor_ = (parameters.fuzzFactor == null) ?\n        defaults.fuzzFactor : parameters.fuzzFactor;\n\n    goog.asserts.assert(this.fuzzFactor_ >= 0, 'fuzzFactor should be >= 0');\n\n    /**\n     * @const\n     * @private {number}\n     */\n    this.backoffFactor_ = (parameters.backoffFactor == null) ?\n        defaults.backoffFactor : parameters.backoffFactor;\n\n    goog.asserts.assert(\n        this.backoffFactor_ >= 0, 'backoffFactor should be >= 0');\n\n    /** @private {number} */\n    this.numAttempts_ = 0;\n\n    /** @private {number} */\n    this.nextUnfuzzedDelay_ = this.baseDelay_;\n\n    /** @private {boolean} */\n    this.autoReset_ = autoReset;\n\n    if (this.autoReset_) {\n      // There is no delay before the first attempt.  In StreamingEngine (the\n      // intended user of auto-reset mode), the first attempt was implied, so we\n      // reset numAttempts to 1.  Therefore maxAttempts (which includes the\n      // first attempt) must be at least 2 for us to see a delay.\n      goog.asserts.assert(this.maxAttempts_ >= 2,\n          'maxAttempts must be >= 2 for autoReset == true');\n      this.numAttempts_ = 1;\n    }\n  }\n\n  /**\n   * @return {!Promise} Resolves when the caller may make an attempt, possibly\n   *   after a delay.  Rejects if no more attempts are allowed.\n   */\n  async attempt() {\n    if (this.numAttempts_ >= this.maxAttempts_) {\n      if (this.autoReset_) {\n        this.reset_();\n      } else {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.PLAYER,\n            shaka.util.Error.Code.ATTEMPTS_EXHAUSTED);\n      }\n    }\n\n    const currentAttempt = this.numAttempts_;\n    this.numAttempts_++;\n\n    if (currentAttempt == 0) {\n      goog.asserts.assert(!this.autoReset_, 'Failed to delay with auto-reset!');\n      return;\n    }\n\n    // We've already tried before, so delay the Promise.\n\n    // Fuzz the delay to avoid tons of clients hitting the server at once\n    // after it recovers from whatever is causing it to fail.\n    const fuzzedDelayMs = shaka.net.Backoff.fuzz_(\n        this.nextUnfuzzedDelay_, this.fuzzFactor_);\n\n    await new Promise((resolve) => {\n      shaka.net.Backoff.defer(fuzzedDelayMs, resolve);\n    });\n\n    // Update delay_ for next time.\n    this.nextUnfuzzedDelay_ *= this.backoffFactor_;\n  }\n\n  /**\n   * Gets a copy of the default retry parameters.\n   *\n   * @return {shaka.extern.RetryParameters}\n   */\n  static defaultRetryParameters() {\n    // Use a function rather than a constant member so the calling code can\n    // modify the values without affecting other call results.\n    return {\n      maxAttempts: 2,\n      baseDelay: 1000,\n      backoffFactor: 2,\n      fuzzFactor: 0.5,\n      timeout: 30000,\n      stallTimeout: 5000,\n      connectionTimeout: 10000,\n    };\n  }\n\n  /**\n   * Fuzz the input value by +/- fuzzFactor.  For example, a fuzzFactor of 0.5\n   * will create a random value that is between 50% and 150% of the input value.\n   *\n   * @param {number} value\n   * @param {number} fuzzFactor\n   * @return {number} The fuzzed value\n   * @private\n   */\n  static fuzz_(value, fuzzFactor) {\n    // A random number between -1 and +1.\n    const negToPosOne = (Math.random() * 2.0) - 1.0;\n\n    // A random number between -fuzzFactor and +fuzzFactor.\n    const negToPosFuzzFactor = negToPosOne * fuzzFactor;\n\n    // The original value, fuzzed by +/- fuzzFactor.\n    return value * (1.0 + negToPosFuzzFactor);\n  }\n\n  /**\n   * Reset state in autoReset mode.\n   * @private\n   */\n  reset_() {\n    goog.asserts.assert(this.autoReset_, 'Should only be used for auto-reset!');\n    this.numAttempts_ = 1;\n    this.nextUnfuzzedDelay_ = this.baseDelay_;\n  }\n\n  /**\n   * This method is only public for testing. It allows us to intercept the\n   * time-delay call.\n   *\n   * @param {number} delayInMs\n   * @param {function()} callback\n   */\n  static defer(delayInMs, callback) {\n    const timer = new shaka.util.Timer(callback);\n    timer.tickAfter(delayInMs / 1000);\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.AbortableOperation');\n\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.PublicPromise');\n\n/**\n * A utility to wrap abortable operations.  Note that these are not cancelable.\n * Cancelation implies undoing what has been done so far, whereas aborting only\n * means that further work is stopped.\n *\n * @implements {shaka.extern.IAbortableOperation.<T>}\n * @template T\n * @export\n */\nshaka.util.AbortableOperation = class {\n  /**\n   * @param {!Promise.<T>} promise\n   *   A Promise which represents the underlying operation.  It is resolved when\n   *   the operation is complete, and rejected if the operation fails or is\n   *   aborted.  Aborted operations should be rejected with a shaka.util.Error\n   *   object using the error code OPERATION_ABORTED.\n   * @param {function():!Promise} onAbort\n   *   Will be called by this object to abort the underlying operation.\n   *   This is not cancelation, and will not necessarily result in any work\n   *   being undone.  abort() should return a Promise which is resolved when the\n   *   underlying operation has been aborted.  The returned Promise should never\n   *   be rejected.\n   */\n  constructor(promise, onAbort) {\n    /** @const {!Promise.<T>} */\n    this.promise = promise;\n\n    /** @private {function():!Promise} */\n    this.onAbort_ = onAbort;\n\n    /** @private {boolean} */\n    this.aborted_ = false;\n  }\n\n  /**\n   * @param {!shaka.util.Error} error\n   * @return {!shaka.util.AbortableOperation} An operation which has already\n   *   failed with the error given by the caller.\n   * @export\n   */\n  static failed(error) {\n    return new shaka.util.AbortableOperation(\n        Promise.reject(error),\n        () => Promise.resolve());\n  }\n\n  /**\n   * @return {!shaka.util.AbortableOperation} An operation which has already\n   *   failed with the error OPERATION_ABORTED.\n   * @export\n   */\n  static aborted() {\n    const p = Promise.reject(shaka.util.AbortableOperation.abortError());\n    // Silence uncaught rejection errors, which may otherwise occur any place\n    // we don't explicitly handle aborted operations.\n    p.catch(() => {});\n    return new shaka.util.AbortableOperation(p, () => Promise.resolve());\n  }\n\n  /** @return {!shaka.util.Error} */\n  static abortError() {\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.OPERATION_ABORTED);\n  }\n\n  /**\n   * @param {U} value\n   * @return {!shaka.util.AbortableOperation.<U>} An operation which has already\n   *   completed with the given value.\n   * @template U\n   * @export\n   */\n  static completed(value) {\n    return new shaka.util.AbortableOperation(\n        Promise.resolve(value),\n        () => Promise.resolve());\n  }\n\n  /**\n   * @param {!Promise.<U>} promise\n   * @return {!shaka.util.AbortableOperation.<U>} An operation which cannot be\n   *   aborted.  It will be completed when the given Promise is resolved, or\n   *   will be failed when the given Promise is rejected.\n   * @template U\n   * @export\n   */\n  static notAbortable(promise) {\n    return new shaka.util.AbortableOperation(\n        promise,\n        // abort() here will return a Promise which is resolved when the input\n        // promise either resolves or fails.\n        () => promise.catch(() => {}));\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  abort() {\n    this.aborted_ = true;\n    return this.onAbort_();\n  }\n\n  /**\n   * @param {!Array.<!shaka.util.AbortableOperation>} operations\n   * @return {!shaka.util.AbortableOperation} An operation which is resolved\n   *   when all operations are successful and fails when any operation fails.\n   *   For this operation, abort() aborts all given operations.\n   * @export\n   */\n  static all(operations) {\n    return new shaka.util.AbortableOperation(\n        Promise.all(operations.map((op) => op.promise)),\n        () => Promise.all(operations.map((op) => op.abort())));\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  finally(onFinal) {\n    this.promise.then((value) => onFinal(true), (e) => onFinal(false));\n    return this;\n  }\n\n  /**\n   * @param {(undefined|\n   *          function(T):U|\n   *          function(T):!Promise.<U>|\n   *          function(T):!shaka.util.AbortableOperation.<U>)} onSuccess\n   *   A callback to be invoked after this operation is complete, to chain to\n   *   another operation.  The callback can return a plain value, a Promise to\n   *   an asynchronous value, or another AbortableOperation.\n   * @param {function(*)=} onError\n   *   An optional callback to be invoked if this operation fails, to perform\n   *   some cleanup or error handling.  Analogous to the second parameter of\n   *   Promise.prototype.then.\n   * @return {!shaka.util.AbortableOperation.<U>} An operation which is resolved\n   *   when this operation and the operation started by the callback are both\n   *   complete.\n   * @template U\n   * @export\n   */\n  chain(onSuccess, onError) {\n    const newPromise = new shaka.util.PublicPromise();\n    const abortError = shaka.util.AbortableOperation.abortError();\n\n    // If called before \"this\" completes, just abort \"this\".\n    let abort = () => {\n      newPromise.reject(abortError);\n      return this.abort();\n    };\n\n    const makeCallback = (isSuccess) => {\n      return (value) => {\n        if (this.aborted_ && isSuccess) {\n          // If \"this\" is not abortable(), or if abort() is called after \"this\"\n          // is complete but before the next stage in the chain begins, we\n          // should stop right away.\n          newPromise.reject(abortError);\n          return;\n        }\n\n        const cb = isSuccess ? onSuccess : onError;\n        if (!cb) {\n          // No callback?  Pass it along.\n          const next = isSuccess ? newPromise.resolve : newPromise.reject;\n          next(value);\n          return;\n        }\n\n        // Call the callback, interpret the return value, set the Promise state,\n        // and get the next abort function.\n        abort = shaka.util.AbortableOperation.wrapChainCallback_(\n            cb, value, newPromise);\n      };\n    };\n    this.promise.then(makeCallback(true), makeCallback(false));\n\n    return new shaka.util.AbortableOperation(\n        newPromise,\n        // By creating a closure around abort(), we can update the value of\n        // abort() at various stages.\n        () => abort());\n  }\n\n  /**\n   * @param {(function(T):U|\n   *          function(T):!Promise.<U>|\n   *          function(T):!shaka.util.AbortableOperation.<U>|\n   *          function(*))} callback\n   *   A callback to be invoked with the given value.\n   * @param {T} value\n   * @param {!shaka.util.PublicPromise} newPromise The promise for the next\n   *   stage in the chain.\n   * @return {function():!Promise} The next abort() function for the chain.\n   * @private\n   * @template T, U\n   */\n  static wrapChainCallback_(callback, value, newPromise) {\n    try {\n      const ret = callback(value);\n\n      if (ret && ret.promise && ret.abort) {\n        // This is an abortable operation, with its own abort() method.\n        // After this point, abort() should abort the operation from the\n        // callback, and the new promise should be tied to the promise\n        // from the callback's operation.\n        newPromise.resolve(ret.promise);\n        // This used to say \"return ret.abort;\", but it caused subtle issues by\n        // unbinding part of the abort chain.  There is now a test to ensure\n        // that we don't call abort with the wrong \"this\".\n        return () => ret.abort();\n      } else {\n        // This is a Promise or a plain value, and this step cannot be aborted.\n        newPromise.resolve(ret);\n        // Abort is complete when the returned value/Promise is resolved or\n        // fails, but never fails itself nor returns a value.\n        return () => Promise.resolve(ret).then(() => {}, () => {});\n      }\n    } catch (exception) {\n      // The callback threw an exception or error.  Reject the new Promise and\n      // resolve any future abort call right away.\n      newPromise.reject(exception);\n      return () => Promise.resolve();\n    }\n  }\n};\n\n/**\n * @const {!Promise.<T>}\n * @exportInterface\n */\n// eslint-disable-next-line no-restricted-syntax\nshaka.util.AbortableOperation.prototype.promise;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.FakeEvent');\n\ngoog.require('goog.asserts');\n\n\n/**\n * @summary Create an Event work-alike object based on the provided dictionary.\n * The event should contain all of the same properties from the dict.\n *\n * @extends {Event}\n * @export\n */\nshaka.util.FakeEvent = class {\n  /**\n   * @param {!Event} event\n   * @return {!shaka.util.FakeEvent}\n   */\n  static fromRealEvent(event) {\n    const fakeEvent = new shaka.util.FakeEvent(event.type);\n    for (const key in event) {\n      Object.defineProperty(fakeEvent, key, {\n        value: event[key],\n        writable: true,\n        enumerable: true,\n      });\n    }\n    return fakeEvent;\n  }\n\n  /**\n   * Allows us to tell the compiler that the dictionary \"map\" is actually a\n   * generic object, for backwards compatibility.\n   * @param {!Map.<string, Object>} dict\n   * @return {!Object}\n   * @suppress {invalidCasts}\n   * @private\n   */\n  static recastDictAsObject_(dict) {\n    goog.asserts.assert(!(dict instanceof Map), 'dict should not be a map');\n    return /** @type {!Object} */ (dict);\n  }\n\n  /**\n   * @param {string} type\n   * @param {Map.<string, Object>=} dict\n   */\n  constructor(type, dict) {\n    if (dict) {\n      if (dict instanceof Map) {\n        // Take properties from dict if present.\n        for (const key of dict.keys()) {\n          Object.defineProperty(this, key, {\n            value: dict.get(key),\n            writable: true,\n            enumerable: true,\n          });\n        }\n      } else {\n        // For backwards compatibility with external apps that may make use of\n        // this public constructor, this should still accept generic objects.\n        const obj = shaka.util.FakeEvent.recastDictAsObject_(dict);\n        for (const key in obj) {\n          Object.defineProperty(this, key, {\n            value: obj[key],\n            writable: true,\n            enumerable: true,\n          });\n        }\n      }\n    }\n\n    // The properties below cannot be set by the dict.  They are all provided\n    // for compatibility with native events.\n\n    /** @const {boolean} */\n    this.bubbles = false;\n\n    /** @type {boolean} */\n    this.cancelable = false;\n\n    /** @type {boolean} */\n    this.defaultPrevented = false;\n\n    /**\n     * According to MDN, Chrome uses high-res timers instead of epoch time.\n     * Follow suit so that timeStamps on FakeEvents use the same base as\n     * on native Events.\n     * @const {number}\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/timeStamp\n     */\n    this.timeStamp = window.performance && window.performance.now ?\n        window.performance.now() : Date.now();\n\n    /** @const {string} */\n    this.type = type;\n\n    /** @const {boolean} */\n    this.isTrusted = false;\n\n    /** @type {EventTarget} */\n    this.currentTarget = null;\n\n    /** @type {EventTarget} */\n    this.target = null;\n\n    /**\n     * Non-standard property read by FakeEventTarget to stop processing\n     * listeners.\n     * @type {boolean}\n     */\n    this.stopped = false;\n  }\n\n  /**\n   * Prevents the default action of the event.  Has no effect if the event isn't\n   * cancellable.\n   * @override\n   */\n  preventDefault() {\n    if (this.cancelable) {\n      this.defaultPrevented = true;\n    }\n  }\n\n  /**\n   * Stops processing event listeners for this event.  Provided for\n   * compatibility with native Events.\n   * @override\n   */\n  stopImmediatePropagation() {\n    this.stopped = true;\n  }\n\n  /**\n   * Does nothing, since FakeEvents do not bubble.  Provided for compatibility\n   * with native Events.\n   * @override\n   */\n  stopPropagation() {}\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.FakeEventTarget');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.MultiMap');\n\n\n/**\n * @summary A work-alike for EventTarget.  Only DOM elements may be true\n * EventTargets, but this can be used as a base class to provide event dispatch\n * to non-DOM classes.  Only FakeEvents should be dispatched.\n *\n * @implements {EventTarget}\n * @implements {shaka.util.IReleasable}\n * @exportInterface\n */\nshaka.util.FakeEventTarget = class {\n  /** */\n  constructor() {\n    /**\n     * @private {shaka.util.MultiMap.<shaka.util.FakeEventTarget.ListenerType>}\n     */\n    this.listeners_ = new shaka.util.MultiMap();\n\n    /**\n     * The target of all dispatched events.  Defaults to |this|.\n     * @type {EventTarget}\n     */\n    this.dispatchTarget = this;\n  }\n\n  /**\n   * Add an event listener to this object.\n   *\n   * @param {string} type The event type to listen for.\n   * @param {shaka.util.FakeEventTarget.ListenerType} listener The callback or\n   *   listener object to invoke.\n   * @param {(!AddEventListenerOptions|boolean)=} options Ignored.\n   * @override\n   * @exportInterface\n   */\n  addEventListener(type, listener, options) {\n    if (!this.listeners_) {\n      return;\n    }\n    this.listeners_.push(type, listener);\n  }\n\n  /**\n   * Add an event listener to this object that is invoked for all events types\n   * the object fires.\n   *\n   * @param {shaka.util.FakeEventTarget.ListenerType} listener The callback or\n   *   listener object to invoke.\n   * @exportInterface\n   */\n  listenToAllEvents(listener) {\n    this.addEventListener(shaka.util.FakeEventTarget.ALL_EVENTS_, listener);\n  }\n\n  /**\n   * Remove an event listener from this object.\n   *\n   * @param {string} type The event type for which you wish to remove a\n   *   listener.\n   * @param {shaka.util.FakeEventTarget.ListenerType} listener The callback or\n   *   listener object to remove.\n   * @param {(EventListenerOptions|boolean)=} options Ignored.\n   * @override\n   * @exportInterface\n   */\n  removeEventListener(type, listener, options) {\n    if (!this.listeners_) {\n      return;\n    }\n    this.listeners_.remove(type, listener);\n  }\n\n  /**\n   * Dispatch an event from this object.\n   *\n   * @param {!Event} event The event to be dispatched from this object.\n   * @return {boolean} True if the default action was prevented.\n   * @override\n   * @exportInterface\n   */\n  dispatchEvent(event) {\n    // In many browsers, it is complex to overwrite properties of actual Events.\n    // Here we expect only to dispatch FakeEvents, which are simpler.\n    goog.asserts.assert(event instanceof shaka.util.FakeEvent,\n        'FakeEventTarget can only dispatch FakeEvents!');\n\n    if (!this.listeners_) {\n      return true;\n    }\n\n    let listeners = this.listeners_.get(event.type) || [];\n    const universalListeners =\n      this.listeners_.get(shaka.util.FakeEventTarget.ALL_EVENTS_);\n    if (universalListeners) {\n      listeners = listeners.concat(universalListeners);\n    }\n\n    // Execute this event on listeners until the event has been stopped or we\n    // run out of listeners.\n    for (const listener of listeners) {\n      // Do this every time, since events can be re-dispatched from handlers.\n      event.target = this.dispatchTarget;\n      event.currentTarget = this.dispatchTarget;\n\n      try {\n        // Check for the |handleEvent| member to test if this is a\n        // |EventListener| instance or a basic function.\n        if (listener.handleEvent) {\n          listener.handleEvent(event);\n        } else {\n          // eslint-disable-next-line no-restricted-syntax\n          listener.call(this, event);\n        }\n      } catch (exception) {\n        // Exceptions during event handlers should not affect the caller,\n        // but should appear on the console as uncaught, according to MDN:\n        // https://mzl.la/2JXgwRo\n        shaka.log.error('Uncaught exception in event handler', exception,\n            exception ? exception.message : null,\n            exception ? exception.stack : null);\n      }\n\n      if (event.stopped) {\n        break;\n      }\n    }\n\n    return event.defaultPrevented;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  release() {\n    this.listeners_ = null;\n  }\n};\n\n/**\n * These are the listener types defined in the closure extern for EventTarget.\n * @typedef {EventListener|function(!Event):*}\n * @exportInterface\n */\nshaka.util.FakeEventTarget.ListenerType;\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.util.FakeEventTarget.ALL_EVENTS_ = 'All';\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.ObjectUtils');\n\n\nshaka.util.ObjectUtils = class {\n  /**\n   * Performs a deep clone of the given simple object.  This does not copy\n   * prototypes, custom properties (e.g. read-only), or multiple references to\n   * the same object.  If the caller needs these fields, it will need to set\n   * them after this returns.\n   *\n   * @template T\n   * @param {T} arg\n   * @return {T}\n   */\n  static cloneObject(arg) {\n    const seenObjects = new Set();\n    // This recursively clones the value |val|, using the captured variable\n    // |seenObjects| to track the objects we have already cloned.\n    /** @suppress {strictMissingProperties} */\n    const clone = (val) => {\n      switch (typeof val) {\n        case 'undefined':\n        case 'boolean':\n        case 'number':\n        case 'string':\n        case 'symbol':\n        case 'function':\n          return val;\n        case 'object':\n        default: {\n          // typeof null === 'object'\n          if (!val) {\n            return val;\n          }\n\n          // This covers Uint8Array and friends, even without a TypedArray\n          // base-class constructor.\n          const isTypedArray =\n              val.buffer && val.buffer.constructor == ArrayBuffer;\n          if (isTypedArray) {\n            return val;\n          }\n\n          if (seenObjects.has(val)) {\n            return null;\n          }\n\n          const isArray = val.constructor == Array;\n          if (val.constructor != Object && !isArray) {\n            return null;\n          }\n\n          seenObjects.add(val);\n          const ret = isArray ? [] : {};\n          // Note |name| will equal a number for arrays.\n          for (const name in val) {\n            ret[name] = clone(val[name]);\n          }\n\n          // Length is a non-enumerable property, but we should copy it over in\n          // case it is not the default.\n          if (isArray) {\n            ret.length = val.length;\n          }\n          return ret;\n        }\n      }\n    };\n    return clone(arg);\n  }\n\n  /**\n   * Performs a shallow clone of the given simple object.  This does not copy\n   * prototypes or custom properties (e.g. read-only).\n   *\n   * @template T\n   * @param {T} original\n   * @return {T}\n   */\n  static shallowCloneObject(original) {\n    const clone = /** @type {?} */({});\n    for (const k in original) {\n      clone[k] = original[k];\n    }\n    return clone;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.OperationManager');\n\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.IDestroyable');\n\n/**\n * A utility for cleaning up AbortableOperations, to help simplify common\n * patterns and reduce code duplication.\n *\n * @implements {shaka.util.IDestroyable}\n */\nshaka.util.OperationManager = class {\n  /** */\n  constructor() {\n    /** @private {!Array.<!shaka.extern.IAbortableOperation>} */\n    this.operations_ = [];\n  }\n\n  /**\n   * Manage an operation.  This means aborting it on destroy() and removing it\n   * from the management set when it complete.\n   *\n   * @param {!shaka.extern.IAbortableOperation} operation\n   */\n  manage(operation) {\n    this.operations_.push(operation.finally(() => {\n      shaka.util.ArrayUtils.remove(this.operations_, operation);\n    }));\n  }\n\n  /** @override */\n  destroy() {\n    const cleanup = [];\n    for (const op of this.operations_) {\n      // Catch and ignore any failures.  This silences error logs in the\n      // JavaScript console about uncaught Promise failures.\n      op.promise.catch(() => {});\n\n      // Now abort the operation.\n      cleanup.push(op.abort());\n    }\n\n    this.operations_ = [];\n    return Promise.all(cleanup);\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.NetworkingEngine');\ngoog.provide('shaka.net.NetworkingEngine.RequestType');\ngoog.provide('shaka.net.NetworkingEngine.PendingRequest');\n\ngoog.require('goog.Uri');\ngoog.require('goog.asserts');\ngoog.require('shaka.net.Backoff');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.ObjectUtils');\ngoog.require('shaka.util.OperationManager');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * @event shaka.net.NetworkingEngine.RetryEvent\n * @description Fired when the networking engine receives a recoverable error\n *   and retries.\n * @property {string} type\n *   'retry'\n * @property {?shaka.util.Error} error\n *   The error that caused the retry. If it was a non-Shaka error, this is set\n *   to null.\n * @exportDoc\n */\n\n\n/**\n * NetworkingEngine wraps all networking operations.  This accepts plugins that\n * handle the actual request.  A plugin is registered using registerScheme.\n * Each scheme has at most one plugin to handle the request.\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.net.NetworkingEngine = class extends shaka.util.FakeEventTarget {\n  /**\n   * @param {function(number, number)=} onProgressUpdated Called when a progress\n   *   event is triggered. Passed the duration, in milliseconds, that the\n   *   request took, and the number of bytes transferred.\n   * @param {shaka.net.NetworkingEngine.OnHeadersReceived=} onHeadersReceived\n   *   Called when the headers are received for a download.\n   * @param {shaka.net.NetworkingEngine.OnDownloadFailed=} onDownloadFailed\n   *   Called when a download fails, for any reason.\n   */\n  constructor(onProgressUpdated, onHeadersReceived, onDownloadFailed) {\n    super();\n\n    /** @private {boolean} */\n    this.destroyed_ = false;\n\n    /** @private {!shaka.util.OperationManager} */\n    this.operationManager_ = new shaka.util.OperationManager();\n\n    /** @private {!Set.<shaka.extern.RequestFilter>} */\n    this.requestFilters_ = new Set();\n\n    /** @private {!Set.<shaka.extern.ResponseFilter>} */\n    this.responseFilters_ = new Set();\n\n    /** @private {?function(number, number)} */\n    this.onProgressUpdated_ = onProgressUpdated || null;\n\n    /** @private {?shaka.net.NetworkingEngine.OnHeadersReceived} */\n    this.onHeadersReceived_ = onHeadersReceived || null;\n\n    /** @private {?shaka.net.NetworkingEngine.OnDownloadFailed} */\n    this.onDownloadFailed_ = onDownloadFailed || null;\n\n    /** @private {boolean} */\n    this.forceHTTPS_ = false;\n  }\n\n  /**\n   * @param {boolean} forceHTTPS\n   * @export\n   */\n  setForceHTTPS(forceHTTPS) {\n    this.forceHTTPS_ = forceHTTPS;\n  }\n\n  /**\n   * Registers a scheme plugin.  This plugin will handle all requests with the\n   * given scheme.  If a plugin with the same scheme already exists, it is\n   * replaced, unless the existing plugin is of higher priority.\n   * If no priority is provided, this defaults to the highest priority of\n   * APPLICATION.\n   *\n   * @param {string} scheme\n   * @param {shaka.extern.SchemePlugin} plugin\n   * @param {number=} priority\n   * @param {boolean=} progressSupport\n   * @export\n   */\n  static registerScheme(scheme, plugin, priority, progressSupport = false) {\n    goog.asserts.assert(\n        priority == undefined || priority > 0, 'explicit priority must be > 0');\n    priority =\n        priority || shaka.net.NetworkingEngine.PluginPriority.APPLICATION;\n    const existing = shaka.net.NetworkingEngine.schemes_[scheme];\n    if (!existing || priority >= existing.priority) {\n      shaka.net.NetworkingEngine.schemes_[scheme] = {\n        priority: priority,\n        plugin: plugin,\n        progressSupport: progressSupport,\n      };\n    }\n  }\n\n  /**\n   * Removes a scheme plugin.\n   *\n   * @param {string} scheme\n   * @export\n   */\n  static unregisterScheme(scheme) {\n    delete shaka.net.NetworkingEngine.schemes_[scheme];\n  }\n\n  /**\n   * Registers a new request filter.  All filters are applied in the order they\n   * are registered.\n   *\n   * @param {shaka.extern.RequestFilter} filter\n   * @export\n   */\n  registerRequestFilter(filter) {\n    this.requestFilters_.add(filter);\n  }\n\n  /**\n   * Removes a request filter.\n   *\n   * @param {shaka.extern.RequestFilter} filter\n   * @export\n   */\n  unregisterRequestFilter(filter) {\n    this.requestFilters_.delete(filter);\n  }\n\n  /**\n   * Clears all request filters.\n   *\n   * @export\n   */\n  clearAllRequestFilters() {\n    this.requestFilters_.clear();\n  }\n\n  /**\n   * Registers a new response filter.  All filters are applied in the order they\n   * are registered.\n   *\n   * @param {shaka.extern.ResponseFilter} filter\n   * @export\n   */\n  registerResponseFilter(filter) {\n    this.responseFilters_.add(filter);\n  }\n\n  /**\n   * Removes a response filter.\n   *\n   * @param {shaka.extern.ResponseFilter} filter\n   * @export\n   */\n  unregisterResponseFilter(filter) {\n    this.responseFilters_.delete(filter);\n  }\n\n  /**\n   * Clears all response filters.\n   *\n   * @export\n   */\n  clearAllResponseFilters() {\n    this.responseFilters_.clear();\n  }\n\n  /**\n   * Gets a copy of the default retry parameters.\n   *\n   * @return {shaka.extern.RetryParameters}\n   *\n   * NOTE: The implementation moved to shaka.net.Backoff to avoid a circular\n   * dependency between the two classes.\n   *\n   * @export\n   */\n  static defaultRetryParameters() {\n    return shaka.net.Backoff.defaultRetryParameters();\n  }\n\n  /**\n   * Makes a simple network request for the given URIs.\n   *\n   * @param {!Array.<string>} uris\n   * @param {shaka.extern.RetryParameters} retryParams\n   * @param {?function(BufferSource):!Promise=} streamDataCallback\n   * @return {shaka.extern.Request}\n   * @export\n   */\n  static makeRequest(uris, retryParams, streamDataCallback = null) {\n    return {\n      uris: uris,\n      method: 'GET',\n      body: null,\n      headers: {},\n      allowCrossSiteCredentials: false,\n      retryParameters: retryParams,\n      licenseRequestType: null,\n      sessionId: null,\n      streamDataCallback: streamDataCallback,\n    };\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  destroy() {\n    this.destroyed_ = true;\n    this.requestFilters_.clear();\n    this.responseFilters_.clear();\n\n    // FakeEventTarget implements IReleasable\n    super.release();\n\n    return this.operationManager_.destroy();\n  }\n\n  /**\n   * Makes a network request and returns the resulting data.\n   *\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Request} request\n   * @return {!shaka.net.NetworkingEngine.PendingRequest}\n   * @export\n   */\n  request(type, request) {\n    const ObjectUtils = shaka.util.ObjectUtils;\n    const numBytesRemainingObj =\n        new shaka.net.NetworkingEngine.NumBytesRemainingClass();\n\n    // Reject all requests made after destroy is called.\n    if (this.destroyed_) {\n      const p = Promise.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED));\n      // Silence uncaught rejection errors, which may otherwise occur any place\n      // we don't explicitly handle aborted operations.\n      p.catch(() => {});\n      return new shaka.net.NetworkingEngine.PendingRequest(\n          p, () => Promise.resolve(), numBytesRemainingObj);\n    }\n\n    goog.asserts.assert(\n        request.uris && request.uris.length, 'Request without URIs!');\n\n    // If a request comes from outside the library, some parameters may be left\n    // undefined.  To make it easier for application developers, we will fill\n    // them in with defaults if necessary.\n    //\n    // We clone retryParameters and uris so that if a filter modifies the\n    // request, it doesn't contaminate future requests.\n    request.method = request.method || 'GET';\n    request.headers = request.headers || {};\n    request.retryParameters = request.retryParameters ?\n        ObjectUtils.cloneObject(request.retryParameters) :\n        shaka.net.NetworkingEngine.defaultRetryParameters();\n    request.uris = ObjectUtils.cloneObject(request.uris);\n\n    // Apply the registered filters to the request.\n    const requestFilterOperation = this.filterRequest_(type, request);\n    const requestOperation = requestFilterOperation.chain(\n        () => this.makeRequestWithRetry_(type, request, numBytesRemainingObj));\n    const responseFilterOperation = requestOperation.chain(\n        (responseAndGotProgress) =>\n          this.filterResponse_(type, responseAndGotProgress));\n\n    // Keep track of time spent in filters.\n    const requestFilterStartTime = Date.now();\n    let requestFilterMs = 0;\n    requestFilterOperation.promise.then(() => {\n      requestFilterMs = Date.now() - requestFilterStartTime;\n    }, () => {});  // Silence errors in this fork of the Promise chain.\n\n    let responseFilterStartTime = 0;\n    requestOperation.promise.then(() => {\n      responseFilterStartTime = Date.now();\n    }, () => {});  // Silence errors in this fork of the Promise chain.\n\n    const op = responseFilterOperation.chain((responseAndGotProgress) => {\n      const responseFilterMs = Date.now() - responseFilterStartTime;\n      const response = responseAndGotProgress.response;\n      response.timeMs += requestFilterMs;\n      response.timeMs += responseFilterMs;\n      if (!responseAndGotProgress.gotProgress &&\n          this.onProgressUpdated_ &&\n          !response.fromCache &&\n          request.method != 'HEAD' &&\n          type == shaka.net.NetworkingEngine.RequestType.SEGMENT) {\n        this.onProgressUpdated_(response.timeMs, response.data.byteLength);\n      }\n      return response;\n    }, (e) => {\n      // Any error thrown from elsewhere should be recategorized as CRITICAL\n      // here.  This is because by the time it gets here, we've exhausted\n      // retries.\n      if (e) {\n        goog.asserts.assert(e instanceof shaka.util.Error, 'Wrong error type');\n        e.severity = shaka.util.Error.Severity.CRITICAL;\n      }\n\n      throw e;\n    });\n\n    // Return the pending request, which carries the response operation, and the\n    // number of bytes remaining to be downloaded, updated by the progress\n    // events.  Add the operation to the manager for later cleanup.\n    const pendingRequest =\n        new shaka.net.NetworkingEngine.PendingRequest(\n            op.promise, () => op.abort(), numBytesRemainingObj);\n    this.operationManager_.manage(pendingRequest);\n    return pendingRequest;\n  }\n\n  /**\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Request} request\n   * @return {!shaka.util.AbortableOperation.<undefined>}\n   * @private\n   */\n  filterRequest_(type, request) {\n    let filterOperation = shaka.util.AbortableOperation.completed(undefined);\n\n    for (const requestFilter of this.requestFilters_) {\n      // Request filters are run sequentially.\n      filterOperation = filterOperation.chain(() => {\n        if (request.body) {\n          // TODO: For v4.0 we should remove this or change to always pass a\n          // Uint8Array.  To make it easier for apps to write filters, it may be\n          // better to always pass a Uint8Array so they know what they are\n          // getting; but we shouldn't use ArrayBuffer since that would require\n          // copying buffers if this is a partial view.\n          request.body = shaka.util.BufferUtils.toArrayBuffer(request.body);\n        }\n        return requestFilter(type, request);\n      });\n    }\n\n    // Catch any errors thrown by request filters, and substitute\n    // them with a Shaka-native error.\n    return filterOperation.chain(undefined, (e) => {\n      if (e instanceof shaka.util.Error &&\n          e.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n        // Don't change anything if the operation was aborted.\n        throw e;\n      }\n\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.REQUEST_FILTER_ERROR, e);\n    });\n  }\n\n  /**\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.NumBytesRemainingClass}\n   *            numBytesRemainingObj\n   * @return {!shaka.extern.IAbortableOperation.<\n   *            shaka.net.NetworkingEngine.ResponseAndGotProgress>}\n   * @private\n   */\n  makeRequestWithRetry_(type, request, numBytesRemainingObj) {\n    const backoff = new shaka.net.Backoff(\n        request.retryParameters, /* autoReset= */ false);\n    const index = 0;\n    return this.send_(\n        type, request, backoff, index, /* lastError= */ null,\n        numBytesRemainingObj);\n  }\n\n  /**\n   * Sends the given request to the correct plugin and retry using Backoff.\n   *\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Request} request\n   * @param {!shaka.net.Backoff} backoff\n   * @param {number} index\n   * @param {?shaka.util.Error} lastError\n   * @param {shaka.net.NetworkingEngine.NumBytesRemainingClass}\n   *     numBytesRemainingObj\n   * @return {!shaka.extern.IAbortableOperation.<\n   *               shaka.net.NetworkingEngine.ResponseAndGotProgress>}\n   * @private\n   */\n  send_(type, request, backoff, index, lastError, numBytesRemainingObj) {\n    if (this.forceHTTPS_) {\n      request.uris[index] = request.uris[index].replace('http://', 'https://');\n    }\n\n    const uri = new goog.Uri(request.uris[index]);\n    let scheme = uri.getScheme();\n    // Whether it got a progress event.\n    let gotProgress = false;\n    if (!scheme) {\n      // If there is no scheme, infer one from the location.\n      scheme = shaka.net.NetworkingEngine.getLocationProtocol_();\n      goog.asserts.assert(\n          scheme[scheme.length - 1] == ':',\n          'location.protocol expected to end with a colon!');\n      // Drop the colon.\n      scheme = scheme.slice(0, -1);\n\n      // Override the original URI to make the scheme explicit.\n      uri.setScheme(scheme);\n      request.uris[index] = uri.toString();\n    }\n\n    // Schemes are meant to be case-insensitive.\n    // See https://github.com/shaka-project/shaka-player/issues/2173\n    // and https://tools.ietf.org/html/rfc3986#section-3.1\n    scheme = scheme.toLowerCase();\n\n    const object = shaka.net.NetworkingEngine.schemes_[scheme];\n    const plugin = object ? object.plugin : null;\n    if (!plugin) {\n      return shaka.util.AbortableOperation.failed(\n          new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.NETWORK,\n              shaka.util.Error.Code.UNSUPPORTED_SCHEME,\n              uri));\n    }\n    const progressSupport = object.progressSupport;\n\n\n    // Every attempt must have an associated backoff.attempt() call so that the\n    // accounting is correct.\n    const backoffOperation =\n        shaka.util.AbortableOperation.notAbortable(backoff.attempt());\n\n    /** @type {?shaka.util.Timer} */\n    let connectionTimer = null;\n\n    /** @type {?shaka.util.Timer} */\n    let stallTimer = null;\n\n    let aborted = false;\n\n    let headersReceivedCalled = false;\n\n    let startTimeMs;\n    const sendOperation = backoffOperation.chain(() => {\n      if (this.destroyed_) {\n        return shaka.util.AbortableOperation.aborted();\n      }\n\n      startTimeMs = Date.now();\n      const segment = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n      const progressUpdated = (time, bytes, numBytesRemaining) => {\n        if (connectionTimer) {\n          connectionTimer.stop();\n        }\n        if (stallTimer) {\n          stallTimer.tickAfter(stallTimeoutMs / 1000);\n        }\n        if (this.onProgressUpdated_ && type == segment) {\n          this.onProgressUpdated_(time, bytes);\n          gotProgress = true;\n          numBytesRemainingObj.setBytes(numBytesRemaining);\n        }\n      };\n      const headersReceived = (headers) => {\n        if (this.onHeadersReceived_) {\n          this.onHeadersReceived_(headers, request, type);\n        }\n        headersReceivedCalled = true;\n      };\n      const requestPlugin = plugin(\n          request.uris[index], request, type, progressUpdated, headersReceived);\n\n      if (!progressSupport) {\n        return requestPlugin;\n      }\n\n      const connectionTimeoutMs = request.retryParameters.connectionTimeout;\n      if (connectionTimeoutMs) {\n        connectionTimer = new shaka.util.Timer(() => {\n          aborted = true;\n          requestPlugin.abort();\n        });\n\n        connectionTimer.tickAfter(connectionTimeoutMs / 1000);\n      }\n\n      const stallTimeoutMs = request.retryParameters.stallTimeout;\n      if (stallTimeoutMs) {\n        stallTimer = new shaka.util.Timer(() => {\n          aborted = true;\n          requestPlugin.abort();\n        });\n      }\n\n      return requestPlugin;\n    }).chain((response) => {\n      if (connectionTimer) {\n        connectionTimer.stop();\n      }\n      if (stallTimer) {\n        stallTimer.stop();\n      }\n      if (response.timeMs == undefined) {\n        response.timeMs = Date.now() - startTimeMs;\n      }\n      const responseAndGotProgress = {\n        response: response,\n        gotProgress: gotProgress,\n      };\n      if (!headersReceivedCalled) {\n        // The plugin did not call headersReceived, perhaps because it is not\n        // able to track that information. So, fire the event manually.\n        if (this.onHeadersReceived_) {\n          this.onHeadersReceived_(response.headers, request, type);\n        }\n      }\n\n      return responseAndGotProgress;\n    }, (error) => {\n      if (connectionTimer) {\n        connectionTimer.stop();\n      }\n      if (stallTimer) {\n        stallTimer.stop();\n      }\n      if (this.onDownloadFailed_) {\n        let shakaError = null;\n        let httpResponseCode = 0;\n        if (error instanceof shaka.util.Error) {\n          shakaError = error;\n          if (error.code == shaka.util.Error.Code.BAD_HTTP_STATUS) {\n            httpResponseCode = /** @type {number} */ (error.data[1]);\n          }\n        }\n        this.onDownloadFailed_(request, shakaError, httpResponseCode, aborted);\n      }\n      if (this.destroyed_) {\n        return shaka.util.AbortableOperation.aborted();\n      }\n\n      if (aborted) {\n        // It is necessary to change the error code to the correct one because\n        // otherwise the retry logic would not work.\n        error = new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.TIMEOUT,\n            request.uris[index], type);\n      }\n\n      if (error instanceof shaka.util.Error) {\n        if (error.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n          // Don't change anything if the operation was aborted.\n          throw error;\n        } else if (error.code == shaka.util.Error.Code.ATTEMPTS_EXHAUSTED) {\n          goog.asserts.assert(lastError, 'Should have last error');\n          throw lastError;\n        }\n\n        if (error.severity == shaka.util.Error.Severity.RECOVERABLE) {\n          const data = (new Map()).set('error', error);\n          const event = new shaka.util.FakeEvent('retry', data);\n          this.dispatchEvent(event);\n\n          // Move to the next URI.\n          index = (index + 1) % request.uris.length;\n          return this.send_(\n              type, request, backoff, index, error, numBytesRemainingObj);\n        }\n      }\n\n      // The error was not recoverable, so do not try again.\n      throw error;\n    });\n\n    return sendOperation;\n  }\n\n  /**\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.net.NetworkingEngine.ResponseAndGotProgress}\n   *        responseAndGotProgress\n   * @return {!shaka.extern.IAbortableOperation.<\n   *               shaka.net.NetworkingEngine.ResponseAndGotProgress>}\n   * @private\n   */\n  filterResponse_(type, responseAndGotProgress) {\n    let filterOperation = shaka.util.AbortableOperation.completed(undefined);\n    for (const responseFilter of this.responseFilters_) {\n      // Response filters are run sequentially.\n      filterOperation = filterOperation.chain(() => {\n        const resp = responseAndGotProgress.response;\n        if (resp.data) {\n          // TODO: See TODO in filterRequest_.\n          resp.data = shaka.util.BufferUtils.toArrayBuffer(resp.data);\n        }\n        return responseFilter(type, resp);\n      });\n    }\n    // If successful, return the filtered response with whether it got\n    // progress.\n    return filterOperation.chain(() => {\n      return responseAndGotProgress;\n    }, (e) => {\n      // Catch any errors thrown by request filters, and substitute\n      // them with a Shaka-native error.\n\n      // The error is assumed to be critical if the original wasn't a Shaka\n      // error.\n      let severity = shaka.util.Error.Severity.CRITICAL;\n      if (e instanceof shaka.util.Error) {\n        if (e.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n          // Don't change anything if the operation was aborted.\n          throw e;\n        }\n\n        severity = e.severity;\n      }\n\n      throw new shaka.util.Error(\n          severity,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.RESPONSE_FILTER_ERROR, e);\n    });\n  }\n\n  /**\n   * This is here only for testability.  We can't mock location in our tests on\n   * all browsers, so instead we mock this.\n   *\n   * @return {string} The value of location.protocol.\n   * @private\n   */\n  static getLocationProtocol_() {\n    return location.protocol;\n  }\n};\n\n/**\n * A wrapper class for the number of bytes remaining to be downloaded for the\n * request.\n * Instead of using PendingRequest directly, this class is needed to be sent to\n * plugin as a parameter, and a Promise is returned, before PendingRequest is\n * created.\n *\n * @export\n */\nshaka.net.NetworkingEngine.NumBytesRemainingClass = class {\n  /**\n   * Constructor\n   */\n  constructor() {\n    /** @private {number} */\n    this.bytesToLoad_ = 0;\n  }\n\n  /**\n   * @param {number} bytesToLoad\n   */\n  setBytes(bytesToLoad) {\n    this.bytesToLoad_ = bytesToLoad;\n  }\n\n  /**\n   * @return {number}\n   */\n  getBytes() {\n    return this.bytesToLoad_;\n  }\n};\n\n/**\n * A pending network request. This can track the current progress of the\n * download, and allows the request to be aborted if the network is slow.\n *\n * @implements {shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n * @extends {shaka.util.AbortableOperation}\n * @export\n */\nshaka.net.NetworkingEngine.PendingRequest =\nclass extends shaka.util.AbortableOperation {\n  /**\n   * @param {!Promise} promise\n   *   A Promise which represents the underlying operation.  It is resolved\n   *   when the operation is complete, and rejected if the operation fails or\n   *   is aborted.  Aborted operations should be rejected with a\n   *   shaka.util.Error object using the error code OPERATION_ABORTED.\n   * @param {function():!Promise} onAbort\n   *   Will be called by this object to abort the underlying operation.  This\n   *   is not cancelation, and will not necessarily result in any work being\n   *   undone.  abort() should return a Promise which is resolved when the\n   *   underlying operation has been aborted.  The returned Promise should\n   *   never be rejected.\n   * @param {shaka.net.NetworkingEngine.NumBytesRemainingClass}\n   *   numBytesRemainingObj\n   */\n  constructor(promise, onAbort, numBytesRemainingObj) {\n    super(promise, onAbort);\n\n    /** @private {shaka.net.NetworkingEngine.NumBytesRemainingClass} */\n    this.bytesRemaining_ = numBytesRemainingObj;\n  }\n\n  /**\n   * @return {number}\n   */\n  getBytesRemaining() {\n    return this.bytesRemaining_.getBytes();\n  }\n};\n\n/**\n * Request types.  Allows a filter to decide which requests to read/alter.\n *\n * @enum {number}\n * @export\n */\nshaka.net.NetworkingEngine.RequestType = {\n  'MANIFEST': 0,\n  'SEGMENT': 1,\n  'LICENSE': 2,\n  'APP': 3,\n  'TIMING': 4,\n  'SERVER_CERTIFICATE': 5,\n};\n\n\n/**\n * Priority level for network scheme plugins.\n * If multiple plugins are provided for the same scheme, only the\n * highest-priority one is used.\n *\n * @enum {number}\n * @export\n */\nshaka.net.NetworkingEngine.PluginPriority = {\n  'FALLBACK': 1,\n  'PREFERRED': 2,\n  'APPLICATION': 3,\n};\n\n\n/**\n * @typedef {{\n *   plugin: shaka.extern.SchemePlugin,\n *   priority: number,\n *   progressSupport: boolean\n * }}\n * @property {shaka.extern.SchemePlugin} plugin\n *   The associated plugin.\n * @property {number} priority\n *   The plugin's priority.\n * @property {boolean} progressSupport\n *   The plugin's supports progress events\n */\nshaka.net.NetworkingEngine.SchemeObject;\n\n\n/**\n * Contains the scheme plugins.\n *\n * @private {!Object.<string, shaka.net.NetworkingEngine.SchemeObject>}\n */\nshaka.net.NetworkingEngine.schemes_ = {};\n\n/**\n * @typedef {{\n *   response: shaka.extern.Response,\n *   gotProgress: boolean\n * }}\n *\n * @description\n * Defines a response wrapper object, including the response object and whether\n * progress event is fired by the scheme plugin.\n *\n * @property {shaka.extern.Response} response\n * @property {boolean} gotProgress\n * @private\n */\nshaka.net.NetworkingEngine.ResponseAndGotProgress;\n\n\n/**\n * @typedef {function(\n *    !Object.<string, string>,\n *    !shaka.extern.Request,\n *    !shaka.net.NetworkingEngine.RequestType)}\n *\n * @description\n * A callback function that passes the shaka.extern.HeadersReceived along to\n * the player, plus some extra data.\n * @export\n */\nshaka.net.NetworkingEngine.OnHeadersReceived;\n\n\n/**\n * @typedef {function(\n *    !shaka.extern.Request,\n *    ?shaka.util.Error,\n *    number,\n *    boolean)}\n *\n * @description\n * A callback function that notifies the player when a download fails, for any\n * reason (e.g. even if the download was aborted).\n * @export\n */\nshaka.net.NetworkingEngine.OnDownloadFailed;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Destroyer');\n\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * @summary\n * A utility class to help work with |shaka.util.IDestroyable| objects.\n *\n * @final\n */\nshaka.util.Destroyer = class {\n  /**\n   * @param {function():!Promise} callback\n   *    A callback to destroy an object. This callback will only be called once\n   *    regardless of how many times |destroy| is called.\n   */\n  constructor(callback) {\n    /** @private {boolean} */\n    this.destroyed_ = false;\n\n    /** @private {!shaka.util.PublicPromise} */\n    this.waitOnDestroy_ = new shaka.util.PublicPromise();\n\n    /** @private {function():!Promise} */\n    this.onDestroy_ = callback;\n  }\n\n  /**\n   * Check if |destroy| has been called. This returning |true| does not mean\n   * that the promise returned by |destroy| has resolved yet.\n   *\n   * @return {boolean}\n   * @final\n   */\n  destroyed() {\n    return this.destroyed_;\n  }\n\n  /**\n   * Request that the destroy callback be called. Will return a promise that\n   * will resolve once the callback terminates. The promise will never be\n   * rejected.\n   *\n   * @return {!Promise}\n   * @final\n   */\n  destroy() {\n    if (this.destroyed_) {\n      return this.waitOnDestroy_;\n    }\n\n    // We have started destroying this object, so we should never get here\n    // again.\n    this.destroyed_ = true;\n\n    return this.onDestroy_().then(\n        () => { this.waitOnDestroy_.resolve(); },\n        () => { this.waitOnDestroy_.resolve(); });\n  }\n\n  /**\n   * Checks if the object is destroyed and throws an error if it is.\n   * @param {*=} error The inner error, if any.\n   */\n  ensureNotDestroyed(error) {\n    if (this.destroyed_) {\n      if (error instanceof shaka.util.Error &&\n          error.code == shaka.util.Error.Code.OBJECT_DESTROYED) {\n        throw error;\n      }\n      throw shaka.util.Destroyer.destroyedError(error);\n    }\n  }\n\n  /**\n   * @param {*=} error The inner error, if any.\n   * @return {!shaka.util.Error}\n   */\n  static destroyedError(error) {\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.OBJECT_DESTROYED,\n        error);\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.EventManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.MultiMap');\n\n\n/**\n * @summary\n * An EventManager maintains a collection of \"event\n * bindings\" between event targets and event listeners.\n *\n * @implements {shaka.util.IReleasable}\n * @export\n */\nshaka.util.EventManager = class {\n  /** */\n  constructor() {\n    /**\n     * Maps an event type to an array of event bindings.\n     * @private {shaka.util.MultiMap.<!shaka.util.EventManager.Binding_>}\n     */\n    this.bindingMap_ = new shaka.util.MultiMap();\n  }\n\n\n  /**\n   * Detaches all event listeners.\n   * @override\n   * @export\n   */\n  release() {\n    this.removeAll();\n    this.bindingMap_ = null;\n  }\n\n\n  /**\n   * Attaches an event listener to an event target.\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType} listener The event listener.\n   * @param {(boolean|!AddEventListenerOptions)=} options An object that\n   *    specifies characteristics about the event listener.\n   *    The passive option, if true, indicates that this function will never\n   *    call preventDefault(), which improves scrolling performance.\n   * @export\n   */\n  listen(target, type, listener, options) {\n    if (!this.bindingMap_) {\n      return;\n    }\n\n    const binding =\n        new shaka.util.EventManager.Binding_(target, type, listener, options);\n    this.bindingMap_.push(type, binding);\n  }\n\n\n  /**\n   * Attaches an event listener to an event target.  The listener will be\n   * removed when the first instance of the event is fired.\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType} listener The event listener.\n   * @param {(boolean|!AddEventListenerOptions)=} options An object that\n   *    specifies characteristics about the event listener.\n   *    The passive option, if true, indicates that this function will never\n   *    call preventDefault(), which improves scrolling performance.\n   * @export\n   */\n  listenOnce(target, type, listener, options) {\n    // Install a shim listener that will stop listening after the first event.\n    const shim = (event) => {\n      // Stop listening to this event.\n      this.unlisten(target, type, shim);\n      // Call the original listener.\n      listener(event);\n    };\n    this.listen(target, type, shim, options);\n  }\n\n\n  /**\n   * Detaches an event listener from an event target.\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType=} listener The event listener.\n   * @export\n   */\n  unlisten(target, type, listener) {\n    if (!this.bindingMap_) {\n      return;\n    }\n\n    const list = this.bindingMap_.get(type) || [];\n\n    for (const binding of list) {\n      if (binding.target == target) {\n        if (listener == binding.listener || !listener) {\n          binding.unlisten();\n          this.bindingMap_.remove(type, binding);\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Detaches all event listeners from all targets.\n   * @export\n   */\n  removeAll() {\n    if (!this.bindingMap_) {\n      return;\n    }\n\n    const list = this.bindingMap_.getAll();\n\n    for (const binding of list) {\n      binding.unlisten();\n    }\n\n    this.bindingMap_.clear();\n  }\n};\n\n\n/**\n * @typedef {function(!Event)}\n * @export\n */\nshaka.util.EventManager.ListenerType;\n\n\n/**\n * Creates a new Binding_ and attaches the event listener to the event target.\n *\n * @private\n */\nshaka.util.EventManager.Binding_ = class {\n  /**\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType} listener The event listener.\n   * @param {(boolean|!AddEventListenerOptions)=} options An object that\n   *    specifies characteristics about the event listener.\n   *    The passive option, if true, indicates that this function will never\n   *    call preventDefault(), which improves scrolling performance.\n   */\n  constructor(target, type, listener, options) {\n    /** @type {EventTarget} */\n    this.target = target;\n\n    /** @type {string} */\n    this.type = type;\n\n    /** @type {?shaka.util.EventManager.ListenerType} */\n    this.listener = listener;\n\n    /** @type {(boolean|!AddEventListenerOptions)} */\n    this.options =\n        shaka.util.EventManager.Binding_.convertOptions_(target, options);\n\n    this.target.addEventListener(type, listener, this.options);\n  }\n\n\n  /**\n   * Detaches the event listener from the event target. This does nothing if\n   * the event listener is already detached.\n   */\n  unlisten() {\n    goog.asserts.assert(this.target, 'Missing target');\n    this.target.removeEventListener(this.type, this.listener, this.options);\n\n    this.target = null;\n    this.listener = null;\n    this.options = false;\n  }\n\n  /**\n   * Converts the provided options value into a value accepted by the browser.\n   * Some browsers (e.g. Tizen) don't support passing options as an\n   * object.  So this detects this case and converts it.\n   *\n   * @param {EventTarget} target\n   * @param {(boolean|!AddEventListenerOptions)=} value\n   * @return {(boolean|!AddEventListenerOptions)}\n   * @private\n   */\n  static convertOptions_(target, value) {\n    if (value == undefined) {\n      return false;\n    } else if (typeof value == 'boolean') {\n      return value;\n    } else {\n      // Ignore the 'passive' option since it is just an optimization and\n      // doesn't affect behavior.  Assert there aren't any other settings to\n      // ensure we don't have different behavior on different browsers by\n      // ignoring an important option.\n      const ignored = new Set(['passive', 'capture']);\n      const keys = Object.keys(value).filter((k) => !ignored.has(k));\n      goog.asserts.assert(\n          keys.length == 0,\n          'Unsupported flag(s) to addEventListener: ' + keys.join(','));\n\n      const supports =\n          shaka.util.EventManager.Binding_.doesSupportObject_(target);\n      if (supports) {\n        return value;\n      } else {\n        return value['capture'] || false;\n      }\n    }\n  }\n\n  /**\n   * Checks whether the browser supports passing objects as the third argument\n   * to addEventListener.  This caches the result value in a static field to\n   * avoid a bunch of checks.\n   *\n   * @param {EventTarget} target\n   * @return {boolean}\n   * @private\n   */\n  static doesSupportObject_(target) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n    let supports = shaka.util.EventManager.Binding_.supportsObject_;\n    if (supports == undefined) {\n      supports = false;\n      try {\n        const options = {};\n        // This defines a getter that will set this variable if called.  So if\n        // the browser gets this property, it supports using an object.  If the\n        // browser doesn't get these fields, it won't support objects.\n        const prop = {\n          get: () => {\n            supports = true;\n            return false;\n          },\n        };\n        Object.defineProperty(options, 'passive', prop);\n        Object.defineProperty(options, 'capture', prop);\n\n        const call = () => {};\n        target.addEventListener('test', call, options);\n        target.removeEventListener('test', call, options);\n      } catch (e) {\n        supports = false;\n      }\n      shaka.util.EventManager.Binding_.supportsObject_ = supports;\n    }\n    return supports || false;  // \"false\" fallback needed for compiler.\n  }\n};\n\n/** @private {(boolean|undefined)} */\nshaka.util.EventManager.Binding_.supportsObject_ = undefined;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.FairPlayUtils');\n\ngoog.require('goog.Uri');\ngoog.require('goog.asserts');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @summary A set of FairPlay utility functions.\n * @export\n */\nshaka.util.FairPlayUtils = class {\n  /**\n   * Using the default method, extract a content ID from the init data.  This is\n   * based on the FairPlay example documentation.\n   *\n   * @param {!BufferSource} initData\n   * @return {string}\n   * @export\n   */\n  static defaultGetContentId(initData) {\n    const uriString = shaka.util.StringUtils.fromBytesAutoDetect(initData);\n\n    // The domain of that URI is the content ID according to Apple's FPS\n    // sample.\n    const uri = new goog.Uri(uriString);\n    return uri.getDomain();\n  }\n\n  /**\n   * Transforms the init data buffer using the given data.  The format is:\n   *\n   * <pre>\n   * [4 bytes] initDataSize\n   * [initDataSize bytes] initData\n   * [4 bytes] contentIdSize\n   * [contentIdSize bytes] contentId\n   * [4 bytes] certSize\n   * [certSize bytes] cert\n   * </pre>\n   *\n   * @param {!BufferSource} initData\n   * @param {!BufferSource|string} contentId\n   * @param {?BufferSource} cert  The server certificate; this will throw if not\n   *   provided.\n   * @return {!Uint8Array}\n   * @export\n   */\n  static initDataTransform(initData, contentId, cert) {\n    if (!cert || !cert.byteLength) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.SERVER_CERTIFICATE_REQUIRED);\n    }\n\n    // From that, we build a new init data to use in the session.  This is\n    // composed of several parts.  First, the init data as a UTF-16 sdk:// URL.\n    // Second, a 4-byte LE length followed by the content ID in UTF-16-LE.\n    // Third, a 4-byte LE length followed by the certificate.\n    /** @type {BufferSource} */\n    let contentIdArray;\n    if (typeof contentId == 'string') {\n      contentIdArray =\n          shaka.util.StringUtils.toUTF16(contentId, /* littleEndian= */ true);\n    } else {\n      contentIdArray = contentId;\n    }\n\n    // The init data we get is a UTF-8 string; convert that to a UTF-16 string.\n    const sdkUri = shaka.util.StringUtils.fromBytesAutoDetect(initData);\n    const utf16 =\n        shaka.util.StringUtils.toUTF16(sdkUri, /* littleEndian= */ true);\n\n    const rebuiltInitData = new Uint8Array(\n        12 + utf16.byteLength + contentIdArray.byteLength + cert.byteLength);\n\n    let offset = 0;\n    /** @param {BufferSource} array */\n    const append = (array) => {\n      rebuiltInitData.set(shaka.util.BufferUtils.toUint8(array), offset);\n      offset += array.byteLength;\n    };\n    /** @param {BufferSource} array */\n    const appendWithLength = (array) => {\n      const view = shaka.util.BufferUtils.toDataView(rebuiltInitData);\n      const value = array.byteLength;\n      view.setUint32(offset, value, /* littleEndian= */ true);\n      offset += 4;\n      append(array);\n    };\n\n    appendWithLength(utf16);\n    appendWithLength(contentIdArray);\n    appendWithLength(cert);\n\n    goog.asserts.assert(\n        offset == rebuiltInitData.length, 'Inconsistent init data length');\n    return rebuiltInitData;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Iterables');\n\n\n/**\n * Recreations of Array-like functions so that they work on any iterable\n * type.\n * @final\n */\nshaka.util.Iterables = class {\n  /**\n   * @param {!Iterable.<FROM>} iterable\n   * @param {function(FROM):TO} mapping\n   * @return {!Iterable.<TO>}\n   * @template FROM,TO\n   */\n  static map(iterable, mapping) {\n    const array = [];\n    for (const x of iterable) {\n      array.push(mapping(x));\n    }\n    return array;\n  }\n\n  /**\n   * @param {!Iterable.<T>} iterable\n   * @param {function(T):boolean} test\n   * @return {boolean}\n   * @template T\n   */\n  static every(iterable, test) {\n    for (const x of iterable) {\n      if (!test(x)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {!Iterable.<T>} iterable\n   * @param {function(T):boolean} test\n   * @return {boolean}\n   * @template T\n   */\n  static some(iterable, test) {\n    for (const x of iterable) {\n      if (test(x)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate over an iterable object and return only the items that |filter|\n   * returns true for.\n   *\n   * @param {!Iterable.<T>} iterable\n   * @param {function(T):boolean} filter\n   * @return {!Array.<T>}\n   * @template T\n   */\n  static filter(iterable, filter) {\n    const out = [];\n    for (const x of iterable) {\n      if (filter(x)) {\n        out.push(x);\n      }\n    }\n    return out;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.MapUtils');\n\n\n/**\n * @summary A set of map/object utility functions.\n */\nshaka.util.MapUtils = class {\n  /**\n   * @param {!Object.<KEY, VALUE>} object\n   * @return {!Map.<KEY, VALUE>}\n   * @template KEY,VALUE\n   */\n  static asMap(object) {\n    const map = new Map();\n    for (const key of Object.keys(object)) {\n      map.set(key, object[key]);\n    }\n\n    return map;\n  }\n\n\n  /**\n   * @param {!Map.<KEY, VALUE>} map\n   * @return {!Object.<KEY, VALUE>}\n   * @template KEY,VALUE\n   */\n  static asObject(map) {\n    const obj = {};\n    map.forEach((value, key) => {\n      obj[key] = value;\n    });\n\n    return obj;\n  }\n\n  /**\n   * NOTE: This only works for simple value types and\n   * will not be accurate if map values are objects!\n   *\n   * @param {Map.<KEY, VALUE>} map1\n   * @param {Map.<KEY, VALUE>} map2\n   * @return {boolean}\n   * @template KEY,VALUE\n   */\n  static hasSameElements(map1, map2) {\n    if (!map1 && !map2) {\n      return true;\n    } else if (map1 && !map2) {\n      return false;\n    } else if (map2 && !map1) {\n      return false;\n    }\n\n    if (map1.size != map2.size) {\n      return false;\n    }\n\n    for (const [key, val] of map1) {\n      if (!map2.has(key)) {\n        return false;\n      }\n\n      const val2 = map2.get(key);\n      if (val2 != val || (val2 == undefined)) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.XmlUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Lazy');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @summary A set of XML utility functions.\n */\nshaka.util.XmlUtils = class {\n  /**\n   * Finds a child XML element.\n   * @param {!Node} elem The parent XML element.\n   * @param {string} name The child XML element's tag name.\n   * @return {Element} The child XML element, or null if a child XML element\n   *   does not exist with the given tag name OR if there exists more than one\n   *   child XML element with the given tag name.\n   */\n  static findChild(elem, name) {\n    const children = shaka.util.XmlUtils.findChildren(elem, name);\n    if (children.length != 1) {\n      return null;\n    }\n    return children[0];\n  }\n\n\n  /**\n   * Finds a namespace-qualified child XML element.\n   * @param {!Node} elem The parent XML element.\n   * @param {string} ns The child XML element's namespace URI.\n   * @param {string} name The child XML element's local name.\n   * @return {Element} The child XML element, or null if a child XML element\n   *   does not exist with the given tag name OR if there exists more than one\n   *   child XML element with the given tag name.\n   */\n  static findChildNS(elem, ns, name) {\n    const children = shaka.util.XmlUtils.findChildrenNS(elem, ns, name);\n    if (children.length != 1) {\n      return null;\n    }\n    return children[0];\n  }\n\n\n  /**\n   * Finds child XML elements.\n   * @param {!Node} elem The parent XML element.\n   * @param {string} name The child XML element's tag name.\n   * @return {!Array.<!Element>} The child XML elements.\n   */\n  static findChildren(elem, name) {\n    const found = [];\n    for (const child of elem.childNodes) {\n      if (child instanceof Element && child.tagName == name) {\n        found.push(child);\n      }\n    }\n    return found;\n  }\n\n\n  /**\n   * @param {!Node} elem the parent XML element.\n   * @return {!Array.<!Element>} The child XML elements.\n   */\n  static getChildren(elem) {\n    return Array.from(elem.childNodes).filter((child) => {\n      return child instanceof Element;\n    });\n  }\n\n\n  /**\n   * Finds namespace-qualified child XML elements.\n   * @param {!Node} elem The parent XML element.\n   * @param {string} ns The child XML element's namespace URI.\n   * @param {string} name The child XML element's local name.\n   * @return {!Array.<!Element>} The child XML elements.\n   */\n  static findChildrenNS(elem, ns, name) {\n    const found = [];\n    for (const child of elem.childNodes) {\n      if (child instanceof Element && child.localName == name &&\n          child.namespaceURI == ns) {\n        found.push(child);\n      }\n    }\n    return found;\n  }\n\n\n  /**\n   * Gets a namespace-qualified attribute.\n   * @param {!Element} elem The element to get from.\n   * @param {string} ns The namespace URI.\n   * @param {string} name The local name of the attribute.\n   * @return {?string} The attribute's value, or null if not present.\n   */\n  static getAttributeNS(elem, ns, name) {\n    // Some browsers return the empty string when the attribute is missing,\n    // so check if it exists first.  See: https://mzl.la/2L7F0UK\n    return elem.hasAttributeNS(ns, name) ? elem.getAttributeNS(ns, name) : null;\n  }\n\n\n  /**\n   * Gets a namespace-qualified attribute.\n   * @param {!Element} elem The element to get from.\n   * @param {!Array.<string>} nsList The lis of namespace URIs.\n   * @param {string} name The local name of the attribute.\n   * @return {?string} The attribute's value, or null if not present.\n   */\n  static getAttributeNSList(elem, nsList, name) {\n    // Some browsers return the empty string when the attribute is missing,\n    // so check if it exists first.  See: https://mzl.la/2L7F0UK\n    for (const ns of nsList) {\n      if (elem.hasAttributeNS(ns, name)) {\n        return elem.getAttributeNS(ns, name);\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * Gets the text contents of a node.\n   * @param {!Node} elem The XML element.\n   * @return {?string} The text contents, or null if there are none.\n   */\n  static getContents(elem) {\n    const XmlUtils = shaka.util.XmlUtils;\n    if (!Array.from(elem.childNodes).every(XmlUtils.isText)) {\n      return null;\n    }\n\n    // Read merged text content from all text nodes.\n    return elem.textContent.trim();\n  }\n\n  /**\n   * Checks if a node is of type text.\n   * @param {!Node} elem The XML element.\n   * @return {boolean} True if it is a text node.\n   */\n  static isText(elem) {\n    return elem.nodeType == Node.TEXT_NODE ||\n        elem.nodeType == Node.CDATA_SECTION_NODE;\n  }\n\n  /**\n   * Parses an attribute by its name.\n   * @param {!Element} elem The XML element.\n   * @param {string} name The attribute name.\n   * @param {function(string): (T|null)} parseFunction A function that parses\n   *   the attribute.\n   * @param {(T|null)=} defaultValue The attribute's default value, if not\n   *   specified, the attibute's default value is null.\n   * @return {(T|null)} The parsed attribute on success, or the attribute's\n   *   default value if the attribute does not exist or could not be parsed.\n   * @template T\n   */\n  static parseAttr(\n      elem, name, parseFunction, defaultValue = null) {\n    let parsedValue = null;\n\n    const value = elem.getAttribute(name);\n    if (value != null) {\n      parsedValue = parseFunction(value);\n    }\n    return parsedValue == null ? defaultValue : parsedValue;\n  }\n\n\n  /**\n   * Parses an XML date string.\n   * @param {string} dateString\n   * @return {?number} The parsed date in seconds on success; otherwise, return\n   *   null.\n   */\n  static parseDate(dateString) {\n    if (!dateString) {\n      return null;\n    }\n\n    // Times in the manifest should be in UTC. If they don't specify a timezone,\n    // Date.parse() will use the local timezone instead of UTC.  So manually add\n    // the timezone if missing ('Z' indicates the UTC timezone).\n    // Format: YYYY-MM-DDThh:mm:ss.ssssss\n    if (/^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/.test(dateString)) {\n      dateString += 'Z';\n    }\n\n    const result = Date.parse(dateString);\n    return (!isNaN(result) ? Math.floor(result / 1000.0) : null);\n  }\n\n\n  /**\n   * Parses an XML duration string.\n   * Negative values are not supported. Years and months are treated as exactly\n   * 365 and 30 days respectively.\n   * @param {string} durationString The duration string, e.g., \"PT1H3M43.2S\",\n   *   which means 1 hour, 3 minutes, and 43.2 seconds.\n   * @return {?number} The parsed duration in seconds on success; otherwise,\n   *   return null.\n   * @see {@link http://www.datypic.com/sc/xsd/t-xsd_duration.html}\n   */\n  static parseDuration(durationString) {\n    if (!durationString) {\n      return null;\n    }\n\n    const re = '^P(?:([0-9]*)Y)?(?:([0-9]*)M)?(?:([0-9]*)D)?' +\n             '(?:T(?:([0-9]*)H)?(?:([0-9]*)M)?(?:([0-9.]*)S)?)?$';\n    const matches = new RegExp(re).exec(durationString);\n\n    if (!matches) {\n      shaka.log.warning('Invalid duration string:', durationString);\n      return null;\n    }\n\n    // Note: Number(null) == 0 but Number(undefined) == NaN.\n    const years = Number(matches[1] || null);\n    const months = Number(matches[2] || null);\n    const days = Number(matches[3] || null);\n    const hours = Number(matches[4] || null);\n    const minutes = Number(matches[5] || null);\n    const seconds = Number(matches[6] || null);\n\n    // Assume a year always has 365 days and a month always has 30 days.\n    const d = (60 * 60 * 24 * 365) * years +\n            (60 * 60 * 24 * 30) * months +\n            (60 * 60 * 24) * days +\n            (60 * 60) * hours +\n            60 * minutes +\n            seconds;\n    return isFinite(d) ? d : null;\n  }\n\n\n  /**\n   * Parses a range string.\n   * @param {string} rangeString The range string, e.g., \"101-9213\".\n   * @return {?{start: number, end: number}} The parsed range on success;\n   *   otherwise, return null.\n   */\n  static parseRange(rangeString) {\n    const matches = /([0-9]+)-([0-9]+)/.exec(rangeString);\n\n    if (!matches) {\n      return null;\n    }\n\n    const start = Number(matches[1]);\n    if (!isFinite(start)) {\n      return null;\n    }\n\n    const end = Number(matches[2]);\n    if (!isFinite(end)) {\n      return null;\n    }\n\n    return {start: start, end: end};\n  }\n\n\n  /**\n   * Parses an integer.\n   * @param {string} intString The integer string.\n   * @return {?number} The parsed integer on success; otherwise, return null.\n   */\n  static parseInt(intString) {\n    const n = Number(intString);\n    return (n % 1 === 0) ? n : null;\n  }\n\n\n  /**\n   * Parses a positive integer.\n   * @param {string} intString The integer string.\n   * @return {?number} The parsed positive integer on success; otherwise,\n   *   return null.\n   */\n  static parsePositiveInt(intString) {\n    const n = Number(intString);\n    return (n % 1 === 0) && (n > 0) ? n : null;\n  }\n\n\n  /**\n   * Parses a non-negative integer.\n   * @param {string} intString The integer string.\n   * @return {?number} The parsed non-negative integer on success; otherwise,\n   *   return null.\n   */\n  static parseNonNegativeInt(intString) {\n    const n = Number(intString);\n    return (n % 1 === 0) && (n >= 0) ? n : null;\n  }\n\n\n  /**\n   * Parses a floating point number.\n   * @param {string} floatString The floating point number string.\n   * @return {?number} The parsed floating point number on success; otherwise,\n   *   return null. May return -Infinity or Infinity.\n   */\n  static parseFloat(floatString) {\n    const n = Number(floatString);\n    return !isNaN(n) ? n : null;\n  }\n\n\n  /**\n   * Evaluate a division expressed as a string.\n   * @param {string} exprString\n   *   The expression to evaluate, e.g. \"200/2\". Can also be a single number.\n   * @return {?number} The evaluated expression as floating point number on\n   *   success; otherwise return null.\n   */\n  static evalDivision(exprString) {\n    let res;\n    let n;\n    if ((res = exprString.match(/^(\\d+)\\/(\\d+)$/))) {\n      n = Number(res[1]) / Number(res[2]);\n    } else {\n      n = Number(exprString);\n    }\n    return !isNaN(n) ? n : null;\n  }\n\n\n  /**\n   * Parse a string and return the resulting root element if it was valid XML.\n   *\n   * @param {string} xmlString\n   * @param {string} expectedRootElemName\n   * @return {Element}\n   */\n  static parseXmlString(xmlString, expectedRootElemName) {\n    const parser = new DOMParser();\n    const unsafeXmlString =\n        shaka.util.XmlUtils.trustedHTMLFromString_.value()(xmlString);\n    let unsafeXml = null;\n    try {\n      unsafeXml = parser.parseFromString(unsafeXmlString, 'text/xml');\n    } catch (exception) {\n      shaka.log.error('XML parsing exception:', exception);\n      return null;\n    }\n\n    // According to MDN, parseFromString never returns null.\n    goog.asserts.assert(unsafeXml, 'Parsed XML document cannot be null!');\n\n    // Check for empty documents.\n    const rootElem = unsafeXml.documentElement;\n    if (!rootElem) {\n      shaka.log.error('XML document was empty!');\n      return null;\n    }\n\n    // Check for parser errors.\n    const parserErrorElements = rootElem.getElementsByTagName('parsererror');\n    if (parserErrorElements.length) {\n      shaka.log.error('XML parser error found:', parserErrorElements[0]);\n      return null;\n    }\n\n    // The top-level element in the loaded XML should have the name we expect.\n    if (rootElem.tagName != expectedRootElemName) {\n      shaka.log.error(\n          `XML tag name does not match expected \"${expectedRootElemName}\":`,\n          rootElem.tagName);\n      return null;\n    }\n\n    // SECURITY: Verify that the document does not contain elements from the\n    // HTML or SVG namespaces, which could trigger script execution and XSS.\n    const iterator = document.createNodeIterator(\n        unsafeXml,\n        NodeFilter.SHOW_ALL,\n    );\n    let currentNode;\n    while (currentNode = iterator.nextNode()) {\n      if (currentNode instanceof HTMLElement ||\n          currentNode instanceof SVGElement) {\n        shaka.log.error('XML document embeds unsafe content!');\n        return null;\n      }\n    }\n\n    return rootElem;\n  }\n\n\n  /**\n   * Parse some UTF8 data and return the resulting root element if\n   * it was valid XML.\n   * @param {BufferSource} data\n   * @param {string} expectedRootElemName\n   * @return {Element}\n   */\n  static parseXml(data, expectedRootElemName) {\n    try {\n      const string = shaka.util.StringUtils.fromUTF8(data);\n      return shaka.util.XmlUtils.parseXmlString(string, expectedRootElemName);\n    } catch (exception) {\n      shaka.log.error('parseXmlString threw!', exception);\n      return null;\n    }\n  }\n};\n\n/**\n * Promote a string to TrustedHTML. This function is security-sensitive and\n * should only be used with security approval where the string is guaranteed not\n * to cause an XSS vulnerability.\n *\n * @private {!shaka.util.Lazy.<function(!string): (!TrustedHTML|!string)>}\n */\nshaka.util.XmlUtils.trustedHTMLFromString_ = new shaka.util.Lazy(() => {\n  if (typeof trustedTypes !== 'undefined') {\n    // Create a Trusted Types policy for promoting the string to TrustedHTML.\n    // The Lazy wrapper ensures this policy is only created once.\n    const policy = trustedTypes.createPolicy('shaka-player#xml', {\n      createHTML: (s) => s,\n    });\n    return (s) => policy.createHTML(s);\n  }\n  // Fall back to strings in environments that don't support Trusted Types.\n  return (s) => s;\n});\n\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.DrmEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.Transmuxer');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FairPlayUtils');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.Lazy');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StreamUtils');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Timer');\ngoog.require('shaka.util.Uint8ArrayUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n/** @implements {shaka.util.IDestroyable} */\nshaka.media.DrmEngine = class {\n  /**\n   * @param {shaka.media.DrmEngine.PlayerInterface} playerInterface\n   * @param {number=} updateExpirationTime\n   */\n  constructor(playerInterface, updateExpirationTime = 1) {\n    /** @private {?shaka.media.DrmEngine.PlayerInterface} */\n    this.playerInterface_ = playerInterface;\n\n    /** @private {!Set.<string>} */\n    this.supportedTypes_ = new Set();\n\n    /** @private {MediaKeys} */\n    this.mediaKeys_ = null;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = null;\n\n    /** @private {boolean} */\n    this.initialized_ = false;\n\n    /** @private {boolean} */\n    this.initializedForStorage_ = false;\n\n    /** @private {number} */\n    this.licenseTimeSeconds_ = 0;\n\n    /** @private {?shaka.extern.DrmInfo} */\n    this.currentDrmInfo_ = null;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /**\n     * @private {!Map.<MediaKeySession,\n     *           shaka.media.DrmEngine.SessionMetaData>}\n     */\n    this.activeSessions_ = new Map();\n\n    /** @private {!Array.<string>} */\n    this.offlineSessionIds_ = [];\n\n    /** @private {!shaka.util.PublicPromise} */\n    this.allSessionsLoaded_ = new shaka.util.PublicPromise();\n\n    /** @private {?shaka.extern.DrmConfiguration} */\n    this.config_ = null;\n\n    /** @private {function(!shaka.util.Error)} */\n    this.onError_ = (err) => {\n      this.allSessionsLoaded_.reject(err);\n      playerInterface.onError(err);\n    };\n\n    /**\n     * The most recent key status information we have.\n     * We may not have announced this information to the outside world yet,\n     * which we delay to batch up changes and avoid spurious \"missing key\"\n     * errors.\n     * @private {!Map.<string, string>}\n     */\n    this.keyStatusByKeyId_ = new Map();\n\n    /**\n     * The key statuses most recently announced to other classes.\n     * We may have more up-to-date information being collected in\n     * this.keyStatusByKeyId_, which has not been batched up and released yet.\n     * @private {!Map.<string, string>}\n     */\n    this.announcedKeyStatusByKeyId_ = new Map();\n\n    /** @private {shaka.util.Timer} */\n    this.keyStatusTimer_ =\n        new shaka.util.Timer(() => this.processKeyStatusChanges_());\n\n    /** @private {boolean} */\n    this.usePersistentLicenses_ = false;\n\n    /** @private {!Array.<!MediaKeyMessageEvent>} */\n    this.mediaKeyMessageEvents_ = [];\n\n    /** @private {boolean} */\n    this.initialRequestsSent_ = false;\n\n    /** @private {?shaka.util.Timer} */\n    this.expirationTimer_ = new shaka.util.Timer(() => {\n      this.pollExpiration_();\n    }).tickEvery(/* seconds= */ updateExpirationTime);\n\n    // Add a catch to the Promise to avoid console logs about uncaught errors.\n    const noop = () => {};\n    this.allSessionsLoaded_.catch(noop);\n\n    /** @const {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(() => this.destroyNow_());\n\n    /** @private {boolean} */\n    this.srcEquals_ = false;\n  }\n\n  /** @override */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /**\n   * Destroy this instance of DrmEngine. This assumes that all other checks\n   * about \"if it should\" have passed.\n   *\n   * @private\n   */\n  async destroyNow_() {\n    // |eventManager_| should only be |null| after we call |destroy|. Destroy it\n    // first so that we will stop responding to events.\n    this.eventManager_.release();\n    this.eventManager_ = null;\n\n    // Since we are destroying ourselves, we don't want to react to the \"all\n    // sessions loaded\" event.\n    this.allSessionsLoaded_.reject();\n\n    // Stop all timers. This will ensure that they do not start any new work\n    // while we are destroying ourselves.\n    this.expirationTimer_.stop();\n    this.expirationTimer_ = null;\n\n    this.keyStatusTimer_.stop();\n    this.keyStatusTimer_ = null;\n\n    // Close all open sessions.\n    await this.closeOpenSessions_();\n\n    // |video_| will be |null| if we never attached to a video element.\n    if (this.video_) {\n      goog.asserts.assert(!this.video_.src, 'video src must be removed first!');\n\n      try {\n        await this.video_.setMediaKeys(null);\n      } catch (error) {\n        // Ignore any failures while removing media keys from the video element.\n      }\n\n      this.video_ = null;\n    }\n\n    // Break references to everything else we hold internally.\n    this.currentDrmInfo_ = null;\n    this.supportedTypes_.clear();\n    this.mediaKeys_ = null;\n    this.offlineSessionIds_ = [];\n    this.config_ = null;\n    this.onError_ = () => {};\n    this.playerInterface_ = null;\n    this.srcEquals_ = false;\n  }\n\n  /**\n   * Called by the Player to provide an updated configuration any time it\n   * changes.\n   * Must be called at least once before init().\n   *\n   * @param {shaka.extern.DrmConfiguration} config\n   */\n  configure(config) {\n    this.config_ = config;\n  }\n\n  /**\n   * @param {!boolean} value\n   */\n  setSrcEquals(value) {\n    this.srcEquals_ = value;\n  }\n\n  /**\n   * Initialize the drm engine for storing and deleting stored content.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   *    The variants that are going to be stored.\n   * @param {boolean} usePersistentLicenses\n   *    Whether or not persistent licenses should be requested and stored for\n   *    |manifest|.\n   * @return {!Promise}\n   */\n  initForStorage(variants, usePersistentLicenses) {\n    this.initializedForStorage_ = true;\n    // There are two cases for this call:\n    //  1. We are about to store a manifest - in that case, there are no offline\n    //     sessions and therefore no offline session ids.\n    //  2. We are about to remove the offline sessions for this manifest - in\n    //     that case, we don't need to know about them right now either as\n    //     we will be told which ones to remove later.\n    this.offlineSessionIds_ = [];\n\n    // What we really need to know is whether or not they are expecting to use\n    // persistent licenses.\n    this.usePersistentLicenses_ = usePersistentLicenses;\n\n    return this.init_(variants);\n  }\n\n  /**\n   * Initialize the drm engine for playback operations.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   *    The variants that we want to support playing.\n   * @param {!Array.<string>} offlineSessionIds\n   * @return {!Promise}\n   */\n  initForPlayback(variants, offlineSessionIds) {\n    this.offlineSessionIds_ = offlineSessionIds;\n    this.usePersistentLicenses_ = offlineSessionIds.length > 0;\n\n    return this.init_(variants);\n  }\n\n  /**\n   * Initializes the drm engine for removing persistent sessions.  Only the\n   * removeSession(s) methods will work correctly, creating new sessions may not\n   * work as desired.\n   *\n   * @param {string} keySystem\n   * @param {string} licenseServerUri\n   * @param {Uint8Array} serverCertificate\n   * @param {!Array.<MediaKeySystemMediaCapability>} audioCapabilities\n   * @param {!Array.<MediaKeySystemMediaCapability>} videoCapabilities\n   * @return {!Promise}\n   */\n  initForRemoval(keySystem, licenseServerUri, serverCertificate,\n      audioCapabilities, videoCapabilities) {\n    /** @type {!Map.<string, MediaKeySystemConfiguration>} */\n    const configsByKeySystem = new Map();\n\n    /** @type {MediaKeySystemConfiguration} */\n    const config = {\n      audioCapabilities: audioCapabilities,\n      videoCapabilities: videoCapabilities,\n      distinctiveIdentifier: 'optional',\n      persistentState: 'required',\n      sessionTypes: ['persistent-license'],\n      label: keySystem,  // Tracked by us, ignored by EME.\n    };\n\n    // TODO: refactor, don't stick drmInfos onto MediaKeySystemConfiguration\n    config['drmInfos'] = [{  // Non-standard attribute, ignored by EME.\n      keySystem: keySystem,\n      licenseServerUri: licenseServerUri,\n      distinctiveIdentifierRequired: false,\n      persistentStateRequired: true,\n      audioRobustness: '',  // Not required by queryMediaKeys_\n      videoRobustness: '',  // Same\n      serverCertificate: serverCertificate,\n      serverCertificateUri: '',\n      initData: null,\n      keyIds: null,\n    }];\n\n    configsByKeySystem.set(keySystem, config);\n    return this.queryMediaKeys_(configsByKeySystem,\n        /* variants= */ []);\n  }\n\n  /**\n   * Negotiate for a key system and set up MediaKeys.\n   * This will assume that both |usePersistentLicences_| and\n   * |offlineSessionIds_| have been properly set.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   *    The variants that we expect to operate with during the drm engine's\n   *    lifespan of the drm engine.\n   * @return {!Promise} Resolved if/when a key system has been chosen.\n   * @private\n   */\n  async init_(variants) {\n    goog.asserts.assert(this.config_,\n        'DrmEngine configure() must be called before init()!');\n\n    // ClearKey config overrides the manifest DrmInfo if present. The variants\n    // are modified so that filtering in Player still works.\n    // This comes before hadDrmInfo because it influences the value of that.\n    /** @type {?shaka.extern.DrmInfo} */\n    const clearKeyDrmInfo = this.configureClearKey_();\n    if (clearKeyDrmInfo) {\n      for (const variant of variants) {\n        if (variant.video) {\n          variant.video.drmInfos = [clearKeyDrmInfo];\n        }\n        if (variant.audio) {\n          variant.audio.drmInfos = [clearKeyDrmInfo];\n        }\n      }\n    }\n\n    const hadDrmInfo = variants.some((variant) => {\n      if (variant.video && variant.video.drmInfos.length) {\n        return true;\n      }\n      if (variant.audio && variant.audio.drmInfos.length) {\n        return true;\n      }\n      return false;\n    });\n\n    // When preparing to play live streams, it is possible that we won't know\n    // about some upcoming encrypted content. If we initialize the drm engine\n    // with no key systems, we won't be able to play when the encrypted content\n    // comes.\n    //\n    // To avoid this, we will set the drm engine up to work with as many key\n    // systems as possible so that we will be ready.\n    if (!hadDrmInfo) {\n      const servers = shaka.util.MapUtils.asMap(this.config_.servers);\n      shaka.media.DrmEngine.replaceDrmInfo_(variants, servers);\n    }\n\n    // Make sure all the drm infos are valid and filled in correctly.\n    for (const variant of variants) {\n      const drmInfos = this.getVariantDrmInfos_(variant);\n      for (const info of drmInfos) {\n        shaka.media.DrmEngine.fillInDrmInfoDefaults_(\n            info,\n            shaka.util.MapUtils.asMap(this.config_.servers),\n            shaka.util.MapUtils.asMap(this.config_.advanced || {}));\n      }\n    }\n\n    /** @type {!Map.<string, MediaKeySystemConfiguration>} */\n    let configsByKeySystem;\n\n    // We should get the decodingInfo results for the variants after we filling\n    // in the drm infos, and before queryMediaKeys_().\n    await shaka.util.StreamUtils.getDecodingInfosForVariants(variants,\n        this.usePersistentLicenses_, this.srcEquals_);\n\n    const hasDrmInfo = hadDrmInfo || Object.keys(this.config_.servers).length;\n    // An unencrypted content is initialized.\n    if (!hasDrmInfo) {\n      this.initialized_ = true;\n      return Promise.resolve();\n    }\n\n    const p = this.queryMediaKeys_(configsByKeySystem, variants);\n\n    // TODO(vaage): Look into the assertion below. If we do not have any drm\n    // info, we create drm info so that content can play if it has drm info\n    // later.\n    // However it is okay if we fail to initialize? If we fail to initialize,\n    // it means we won't be able to play the later-encrypted content, which is\n    // not okay.\n\n    // If the content did not originally have any drm info, then it doesn't\n    // matter if we fail to initialize the drm engine, because we won't need it\n    // anyway.\n    return hadDrmInfo ? p : p.catch(() => {});\n  }\n\n  /**\n   * Attach MediaKeys to the video element and start processing events.\n   * @param {HTMLMediaElement} video\n   * @return {!Promise}\n   */\n  async attach(video) {\n    if (!this.mediaKeys_) {\n      // Unencrypted, or so we think.  We listen for encrypted events in order\n      // to warn when the stream is encrypted, even though the manifest does\n      // not know it.\n      // Don't complain about this twice, so just listenOnce().\n      // FIXME: This is ineffective when a prefixed event is translated by our\n      // polyfills, since those events are only caught and translated by a\n      // MediaKeys instance.  With clear content and no polyfilled MediaKeys\n      // instance attached, you'll never see the 'encrypted' event on those\n      // platforms (Safari).\n      this.eventManager_.listenOnce(video, 'encrypted', (event) => {\n        this.onError_(new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.ENCRYPTED_CONTENT_WITHOUT_DRM_INFO));\n      });\n      return;\n    }\n\n    this.video_ = video;\n\n    this.eventManager_.listenOnce(this.video_, 'play', () => this.onPlay_());\n    if ('webkitCurrentPlaybackTargetIsWireless' in this.video_) {\n      this.eventManager_.listen(this.video_,\n          'webkitcurrentplaybacktargetiswirelesschanged',\n          () => this.closeOpenSessions_());\n    }\n\n    let setMediaKeys = this.video_.setMediaKeys(this.mediaKeys_);\n    setMediaKeys = setMediaKeys.catch((exception) => {\n      goog.asserts.assert(exception instanceof Error, 'Wrong error type!');\n      return Promise.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_ATTACH_TO_VIDEO,\n          exception.message));\n    });\n\n    await setMediaKeys;\n    this.destroyer_.ensureNotDestroyed();\n\n    this.createOrLoad();\n    if (!this.currentDrmInfo_.initData.length &&\n        !this.offlineSessionIds_.length) {\n      // Explicit init data for any one stream or an offline session is\n      // sufficient to suppress 'encrypted' events for all streams.\n      const cb = (e) => this.newInitData(\n          e.initDataType, shaka.util.BufferUtils.toUint8(e.initData));\n      this.eventManager_.listen(this.video_, 'encrypted', cb);\n    }\n  }\n\n  /**\n   * Sets the server certificate based on the current DrmInfo.\n   *\n   * @return {!Promise}\n   */\n  async setServerCertificate() {\n    goog.asserts.assert(this.initialized_,\n        'Must call init() before setServerCertificate');\n\n    if (!this.mediaKeys_ || !this.currentDrmInfo_) {\n      return;\n    }\n\n    if (this.currentDrmInfo_.serverCertificateUri &&\n       (!this.currentDrmInfo_.serverCertificate ||\n       !this.currentDrmInfo_.serverCertificate.length)) {\n      const request = shaka.net.NetworkingEngine.makeRequest(\n          [this.currentDrmInfo_.serverCertificateUri],\n          this.config_.retryParameters);\n\n      try {\n        const operation = this.playerInterface_.netEngine.request(\n            shaka.net.NetworkingEngine.RequestType.SERVER_CERTIFICATE,\n            request);\n        const response = await operation.promise;\n\n        this.currentDrmInfo_.serverCertificate =\n          shaka.util.BufferUtils.toUint8(response.data);\n      } catch (error) {\n        // Request failed!\n        goog.asserts.assert(error instanceof shaka.util.Error,\n            'Wrong NetworkingEngine error type!');\n\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.SERVER_CERTIFICATE_REQUEST_FAILED,\n            error);\n      }\n\n      if (this.destroyer_.destroyed()) {\n        return;\n      }\n    }\n\n    if (!this.currentDrmInfo_.serverCertificate ||\n        !this.currentDrmInfo_.serverCertificate.length) {\n      return;\n    }\n\n    try {\n      const supported = await this.mediaKeys_.setServerCertificate(\n          this.currentDrmInfo_.serverCertificate);\n\n      if (!supported) {\n        shaka.log.warning('Server certificates are not supported by the ' +\n                          'key system.  The server certificate has been ' +\n                          'ignored.');\n      }\n    } catch (exception) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.INVALID_SERVER_CERTIFICATE,\n          exception.message);\n    }\n  }\n\n  /**\n   * Remove an offline session and delete it's data. This can only be called\n   * after a successful call to |init|. This will wait until the\n   * 'license-release' message is handled. The returned Promise will be rejected\n   * if there is an error releasing the license.\n   *\n   * @param {string} sessionId\n   * @return {!Promise}\n   */\n  async removeSession(sessionId) {\n    goog.asserts.assert(this.mediaKeys_,\n        'Must call init() before removeSession');\n\n    const session = await this.loadOfflineSession_(sessionId);\n\n    // This will be null on error, such as session not found.\n    if (!session) {\n      shaka.log.v2('Ignoring attempt to remove missing session', sessionId);\n      return;\n    }\n\n    // TODO: Consider adding a timeout to get the 'message' event.\n    // Note that the 'message' event will get raised after the remove()\n    // promise resolves.\n    const tasks = [];\n\n    const found = this.activeSessions_.get(session);\n    if (found) {\n      // This will force us to wait until the 'license-release' message has been\n      // handled.\n      found.updatePromise = new shaka.util.PublicPromise();\n      tasks.push(found.updatePromise);\n    }\n\n    shaka.log.v2('Attempting to remove session', sessionId);\n    tasks.push(session.remove());\n\n    await Promise.all(tasks);\n    this.activeSessions_.delete(session);\n  }\n\n  /**\n   * Creates the sessions for the init data and waits for them to become ready.\n   *\n   * @return {!Promise}\n   */\n  createOrLoad() {\n    // Create temp sessions.\n    const initDatas =\n        (this.currentDrmInfo_ ? this.currentDrmInfo_.initData : []) || [];\n    for (const initDataOverride of initDatas) {\n      this.newInitData(\n          initDataOverride.initDataType, initDataOverride.initData);\n    }\n\n    // Load each session.\n    for (const sessionId of this.offlineSessionIds_) {\n      this.loadOfflineSession_(sessionId);\n    }\n\n    // If we have no sessions, we need to resolve the promise right now or else\n    // it will never get resolved.\n    if (!initDatas.length && !this.offlineSessionIds_.length) {\n      this.allSessionsLoaded_.resolve();\n    }\n\n    return this.allSessionsLoaded_;\n  }\n\n  /**\n   * Called when new initialization data is encountered.  If this data hasn't\n   * been seen yet, this will create a new session for it.\n   *\n   * @param {string} initDataType\n   * @param {!Uint8Array} initData\n   */\n  newInitData(initDataType, initData) {\n    // Suppress duplicate init data.\n    // Note that some init data are extremely large and can't portably be used\n    // as keys in a dictionary.\n\n    const metadatas = this.activeSessions_.values();\n    for (const metadata of metadatas) {\n      // Tizen 2015 and 2016 models will send multiple webkitneedkey events\n      // with the same init data. If the duplicates are supressed, playback\n      // will stall without errors.\n      if (shaka.util.BufferUtils.equal(initData, metadata.initData) &&\n          !shaka.util.Platform.isTizen2()) {\n        shaka.log.debug('Ignoring duplicate init data.');\n        return;\n      }\n    }\n\n    this.createSession(initDataType, initData,\n        this.currentDrmInfo_.sessionType);\n  }\n\n  /** @return {boolean} */\n  initialized() {\n    return this.initialized_;\n  }\n\n  /**\n   * @param {?shaka.extern.DrmInfo} drmInfo\n   * @return {string} */\n  static keySystem(drmInfo) {\n    return drmInfo ? drmInfo.keySystem : '';\n  }\n\n  /**\n   * @param {?string} keySystem\n   * @return {boolean} */\n  static isPlayReadyKeySystem(keySystem) {\n    if (keySystem) {\n      return !!keySystem.match(/^com\\.(microsoft|chromecast)\\.playready/);\n    }\n\n    return false;\n  }\n\n  /**\n   * @param {?string} keySystem\n   * @return {boolean} */\n  static isFairPlayKeySystem(keySystem) {\n    if (keySystem) {\n      return !!keySystem.match(/^com\\.apple\\.fps/);\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if DrmEngine (as initialized) will likely be able to support the\n   * given content type.\n   *\n   * @param {string} contentType\n   * @return {boolean}\n   */\n  willSupport(contentType) {\n    // Edge 14 does not report correct capabilities.  It will only report the\n    // first MIME type even if the others are supported.  To work around this,\n    // we say that Edge supports everything.\n    //\n    // See https://github.com/shaka-project/shaka-player/issues/1495 for details.\n    if (shaka.util.Platform.isLegacyEdge()) {\n      return true;\n    }\n\n    contentType = contentType.toLowerCase();\n\n    if (shaka.util.Platform.isTizen() &&\n        contentType.includes('codecs=\"ac-3\"')) {\n      // Some Tizen devices seem to misreport AC-3 support.  This works around\n      // the issue, by falling back to EC-3, which seems to be supported on the\n      // same devices and be correctly reported in all cases we have observed.\n      // See https://github.com/shaka-project/shaka-player/issues/2989 for\n      // details.\n      const fallback = contentType.replace('ac-3', 'ec-3');\n      return this.supportedTypes_.has(contentType) ||\n             this.supportedTypes_.has(fallback);\n    }\n\n    return this.supportedTypes_.has(contentType);\n  }\n\n  /**\n   * Returns the ID of the sessions currently active.\n   *\n   * @return {!Array.<string>}\n   */\n  getSessionIds() {\n    const sessions = this.activeSessions_.keys();\n    const ids = shaka.util.Iterables.map(sessions, (s) => s.sessionId);\n\n    // TODO: Make |getSessionIds| return |Iterable| instead of |Array|.\n    return Array.from(ids);\n  }\n\n  /**\n   * Returns the next expiration time, or Infinity.\n   * @return {number}\n   */\n  getExpiration() {\n    // This will equal Infinity if there are no entries.\n    let min = Infinity;\n\n    const sessions = this.activeSessions_.keys();\n    for (const session of sessions) {\n      if (!isNaN(session.expiration)) {\n        min = Math.min(min, session.expiration);\n      }\n    }\n\n    return min;\n  }\n\n  /**\n   * Returns the time spent on license requests during this session, or NaN.\n   *\n   * @return {number}\n   */\n  getLicenseTime() {\n    if (this.licenseTimeSeconds_) {\n      return this.licenseTimeSeconds_;\n    }\n    return NaN;\n  }\n\n  /**\n   * Returns the DrmInfo that was used to initialize the current key system.\n   *\n   * @return {?shaka.extern.DrmInfo}\n   */\n  getDrmInfo() {\n    return this.currentDrmInfo_;\n  }\n\n  /**\n   * Return the media keys created from the current mediaKeySystemAccess.\n   * @return {MediaKeys}\n   */\n  getMediaKeys() {\n    return this.mediaKeys_;\n  }\n\n  /**\n   * Returns the current key statuses.\n   *\n   * @return {!Object.<string, string>}\n   */\n  getKeyStatuses() {\n    return shaka.util.MapUtils.asObject(this.announcedKeyStatusByKeyId_);\n  }\n\n  /**\n   * Returns the current media key sessions.\n   *\n   * @return {!Array.<MediaKeySession>}\n   */\n  getMediaKeySessions() {\n    return Array.from(this.activeSessions_.keys());\n  }\n\n\n  /**\n   * @param {shaka.extern.Stream} stream\n   * @param {string=} codecOverride\n   * @return {string}\n   * @private\n   */\n  static computeMimeType_(stream, codecOverride) {\n    const realMimeType = shaka.util.MimeUtils.getFullType(stream.mimeType,\n        codecOverride || stream.codecs);\n    if (shaka.media.Transmuxer.isSupported(realMimeType)) {\n      // This will be handled by the Transmuxer, so use the MIME type that the\n      // Transmuxer will produce.\n      return shaka.media.Transmuxer.convertTsCodecs(stream.type, realMimeType);\n    }\n    return realMimeType;\n  }\n\n  /**\n   * @param {!Map.<string, MediaKeySystemConfiguration>} configsByKeySystem\n   *   A dictionary of configs, indexed by key system, with an iteration order\n   *   (insertion order) that reflects the preference for the application.\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @return {!Promise} Resolved if/when a key system has been chosen.\n   * @private\n   */\n  async queryMediaKeys_(configsByKeySystem, variants) {\n    const drmInfosByKeySystem = new Map();\n\n    const mediaKeySystemAccess = variants.length ?\n        this.getKeySystemAccessFromVariants_(variants, drmInfosByKeySystem) :\n        await this.getKeySystemAccessByConfigs_(configsByKeySystem);\n\n    if (!mediaKeySystemAccess) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE);\n    }\n    this.destroyer_.ensureNotDestroyed();\n\n    try {\n      // Get the set of supported content types from the audio and video\n      // capabilities. Avoid duplicates so that it is easier to read what is\n      // supported.\n      this.supportedTypes_.clear();\n\n      // Store the capabilities of the key system.\n      const realConfig = mediaKeySystemAccess.getConfiguration();\n\n      shaka.log.v2(\n          'Got MediaKeySystemAccess with configuration',\n          realConfig);\n\n      const audioCaps = realConfig.audioCapabilities || [];\n      const videoCaps = realConfig.videoCapabilities || [];\n\n      for (const cap of audioCaps) {\n        this.supportedTypes_.add(cap.contentType.toLowerCase());\n      }\n\n      for (const cap of videoCaps) {\n        this.supportedTypes_.add(cap.contentType.toLowerCase());\n      }\n\n      goog.asserts.assert(this.supportedTypes_.size,\n          'We should get at least one supported MIME type');\n\n      if (variants.length) {\n        this.currentDrmInfo_ = this.createDrmInfoByInfos_(\n            mediaKeySystemAccess.keySystem,\n            drmInfosByKeySystem.get(mediaKeySystemAccess.keySystem));\n      } else {\n        this.currentDrmInfo_ = shaka.media.DrmEngine.createDrmInfoByConfigs_(\n            mediaKeySystemAccess.keySystem,\n            configsByKeySystem.get(mediaKeySystemAccess.keySystem));\n      }\n      if (!this.currentDrmInfo_.licenseServerUri) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.NO_LICENSE_SERVER_GIVEN,\n            this.currentDrmInfo_.keySystem);\n      }\n\n      const mediaKeys = await mediaKeySystemAccess.createMediaKeys();\n      this.destroyer_.ensureNotDestroyed();\n      shaka.log.info('Created MediaKeys object for key system',\n          this.currentDrmInfo_.keySystem);\n\n      this.mediaKeys_ = mediaKeys;\n      this.initialized_ = true;\n\n      await this.setServerCertificate();\n      this.destroyer_.ensureNotDestroyed();\n    } catch (exception) {\n      this.destroyer_.ensureNotDestroyed(exception);\n\n      // Don't rewrap a shaka.util.Error from earlier in the chain:\n      this.currentDrmInfo_ = null;\n      this.supportedTypes_.clear();\n      if (exception instanceof shaka.util.Error) {\n        throw exception;\n      }\n\n      // We failed to create MediaKeys.  This generally shouldn't happen.\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_CREATE_CDM,\n          exception.message);\n    }\n  }\n\n  /**\n   * Get the MediaKeySystemAccess from the decodingInfos of the variants.\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {!Map.<string, !Array.<shaka.extern.DrmInfo>>} drmInfosByKeySystem\n   *   A dictionary of drmInfos, indexed by key system.\n   * @return {MediaKeySystemAccess}\n   * @private\n   */\n  getKeySystemAccessFromVariants_(variants, drmInfosByKeySystem) {\n    for (const variant of variants) {\n      // Get all the key systems in the variant that shouldHaveLicenseServer.\n      const drmInfos = this.getVariantDrmInfos_(variant);\n      for (const info of drmInfos) {\n        if (!drmInfosByKeySystem.has(info.keySystem)) {\n          drmInfosByKeySystem.set(info.keySystem, []);\n        }\n        drmInfosByKeySystem.get(info.keySystem).push(info);\n      }\n    }\n\n    if (drmInfosByKeySystem.size == 1 && drmInfosByKeySystem.has('')) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.NO_RECOGNIZED_KEY_SYSTEMS);\n    }\n\n    // If we have configured preferredKeySystems, choose a preferred keySystem\n    // if available.\n    for (const preferredKeySystem of this.config_.preferredKeySystems) {\n      for (const variant of variants) {\n        const decodingInfo = variant.decodingInfos.find((decodingInfo) => {\n          return decodingInfo.supported &&\n              decodingInfo.keySystemAccess != null &&\n              decodingInfo.keySystemAccess.keySystem == preferredKeySystem;\n        });\n        if (decodingInfo) {\n          return decodingInfo.keySystemAccess;\n        }\n      }\n    }\n\n    // Try key systems with configured license servers first.  We only have to\n    // try key systems without configured license servers for diagnostic\n    // reasons, so that we can differentiate between \"none of these key\n    // systems are available\" and \"some are available, but you did not\n    // configure them properly.\"  The former takes precedence.\n    for (const shouldHaveLicenseServer of [true, false]) {\n      for (const variant of variants) {\n        for (const decodingInfo of variant.decodingInfos) {\n          if (!decodingInfo.supported || !decodingInfo.keySystemAccess) {\n            continue;\n          }\n          const drmInfos =\n              drmInfosByKeySystem.get(decodingInfo.keySystemAccess.keySystem);\n          for (const info of drmInfos) {\n            if (!!info.licenseServerUri == shouldHaveLicenseServer) {\n              return decodingInfo.keySystemAccess;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get the MediaKeySystemAccess by querying requestMediaKeySystemAccess.\n   * @param {!Map.<string, MediaKeySystemConfiguration>} configsByKeySystem\n   *   A dictionary of configs, indexed by key system, with an iteration order\n   *   (insertion order) that reflects the preference for the application.\n   * @return {!Promise.<MediaKeySystemAccess>} Resolved if/when a\n   *   mediaKeySystemAccess has been chosen.\n   * @private\n   */\n  async getKeySystemAccessByConfigs_(configsByKeySystem) {\n    /** @type {MediaKeySystemAccess} */\n    let mediaKeySystemAccess;\n\n    if (configsByKeySystem.size == 1 && configsByKeySystem.has('')) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.NO_RECOGNIZED_KEY_SYSTEMS);\n    }\n\n    // If there are no tracks of a type, these should be not present.\n    // Otherwise the query will fail.\n    for (const config of configsByKeySystem.values()) {\n      if (config.audioCapabilities.length == 0) {\n        delete config.audioCapabilities;\n      }\n      if (config.videoCapabilities.length == 0) {\n        delete config.videoCapabilities;\n      }\n    }\n\n    // If we have configured preferredKeySystems, choose the preferred one if\n    // available.\n    for (const keySystem of this.config_.preferredKeySystems) {\n      if (configsByKeySystem.has(keySystem)) {\n        const config = configsByKeySystem.get(keySystem);\n        try {\n          mediaKeySystemAccess =  // eslint-disable-next-line no-await-in-loop\n              await navigator.requestMediaKeySystemAccess(keySystem, [config]);\n          return mediaKeySystemAccess;\n        } catch (error) {\n          // Suppress errors.\n          shaka.log.v2(\n              'Requesting', keySystem, 'failed with config', config, error);\n        }\n        this.destroyer_.ensureNotDestroyed();\n      }\n    }\n\n    // Try key systems with configured license servers first.  We only have to\n    // try key systems without configured license servers for diagnostic\n    // reasons, so that we can differentiate between \"none of these key\n    // systems are available\" and \"some are available, but you did not\n    // configure them properly.\"  The former takes precedence.\n    // TODO: once MediaCap implementation is complete, this part can be\n    // simplified or removed.\n    for (const shouldHaveLicenseServer of [true, false]) {\n      for (const keySystem of configsByKeySystem.keys()) {\n        const config = configsByKeySystem.get(keySystem);\n        // TODO: refactor, don't stick drmInfos onto\n        // MediaKeySystemConfiguration\n        const hasLicenseServer = config['drmInfos'].some((info) => {\n          return !!info.licenseServerUri;\n        });\n        if (hasLicenseServer != shouldHaveLicenseServer) {\n          continue;\n        }\n\n        try {\n          mediaKeySystemAccess =  // eslint-disable-next-line no-await-in-loop\n              await navigator.requestMediaKeySystemAccess(keySystem, [config]);\n          return mediaKeySystemAccess;\n        } catch (error) {\n          // Suppress errors.\n          shaka.log.v2(\n              'Requesting', keySystem, 'failed with config', config, error);\n        }\n        this.destroyer_.ensureNotDestroyed();\n      }\n    }\n    return mediaKeySystemAccess;\n  }\n\n  /**\n   * Create a DrmInfo using configured clear keys.\n   * The server URI will be a data URI which decodes to a clearkey license.\n   * @return {?shaka.extern.DrmInfo} or null if clear keys are not configured.\n   * @private\n   * @see https://bit.ly/2K8gOnv for the spec on the clearkey license format.\n   */\n  configureClearKey_() {\n    const clearKeys = shaka.util.MapUtils.asMap(this.config_.clearKeys);\n    if (clearKeys.size == 0) {\n      return null;\n    }\n\n    const StringUtils = shaka.util.StringUtils;\n    const Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n    const keys = [];\n    const keyIds = [];\n\n    clearKeys.forEach((keyHex, keyIdHex) => {\n      const keyId = Uint8ArrayUtils.fromHex(keyIdHex);\n      const key = Uint8ArrayUtils.fromHex(keyHex);\n      const keyObj = {\n        kty: 'oct',\n        kid: Uint8ArrayUtils.toBase64(keyId, false),\n        k: Uint8ArrayUtils.toBase64(key, false),\n      };\n\n      keys.push(keyObj);\n      keyIds.push(keyObj.kid);\n    });\n\n    const jwkSet = {keys: keys};\n    const license = JSON.stringify(jwkSet);\n\n    // Use the keyids init data since is suggested by EME.\n    // Suggestion: https://bit.ly/2JYcNTu\n    // Format: https://www.w3.org/TR/eme-initdata-keyids/\n    const initDataStr = JSON.stringify({'kids': keyIds});\n    const initData =\n        shaka.util.BufferUtils.toUint8(StringUtils.toUTF8(initDataStr));\n    const initDatas = [{initData: initData, initDataType: 'keyids'}];\n\n    return {\n      keySystem: 'org.w3.clearkey',\n      licenseServerUri: 'data:application/json;base64,' + window.btoa(license),\n      distinctiveIdentifierRequired: false,\n      persistentStateRequired: false,\n      audioRobustness: '',\n      videoRobustness: '',\n      serverCertificate: null,\n      serverCertificateUri: '',\n      sessionType: '',\n      initData: initDatas,\n      keyIds: new Set(keyIds),\n    };\n  }\n\n  /**\n   * @param {string} sessionId\n   * @return {!Promise.<MediaKeySession>}\n   * @private\n   */\n  async loadOfflineSession_(sessionId) {\n    let session;\n\n    const sessionType = 'persistent-license';\n\n    try {\n      shaka.log.v1('Attempting to load an offline session', sessionId);\n      session = this.mediaKeys_.createSession(sessionType);\n    } catch (exception) {\n      const error = new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_CREATE_SESSION,\n          exception.message);\n      this.onError_(error);\n      return Promise.reject(error);\n    }\n\n    this.eventManager_.listen(session, 'message',\n        /** @type {shaka.util.EventManager.ListenerType} */(\n          (event) => this.onSessionMessage_(event)));\n    this.eventManager_.listen(session, 'keystatuseschange',\n        (event) => this.onKeyStatusesChange_(event));\n\n    const metadata = {\n      initData: null,\n      loaded: false,\n      oldExpiration: Infinity,\n      updatePromise: null,\n      type: sessionType,\n    };\n    this.activeSessions_.set(session, metadata);\n\n    try {\n      const present = await session.load(sessionId);\n      this.destroyer_.ensureNotDestroyed();\n      shaka.log.v2('Loaded offline session', sessionId, present);\n\n      if (!present) {\n        this.activeSessions_.delete(session);\n\n        this.onError_(new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.OFFLINE_SESSION_REMOVED));\n        return Promise.resolve();\n      }\n\n      // TODO: We should get a key status change event.  Remove once Chrome CDM\n      // is fixed.\n      metadata.loaded = true;\n      if (this.areAllSessionsLoaded_()) {\n        this.allSessionsLoaded_.resolve();\n      }\n\n      return session;\n    } catch (error) {\n      this.destroyer_.ensureNotDestroyed(error);\n\n      this.activeSessions_.delete(session);\n\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_CREATE_SESSION,\n          error.message));\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * @param {string} initDataType\n   * @param {!Uint8Array} initData\n   * @param {string} sessionType\n   */\n  createSession(initDataType, initData, sessionType) {\n    goog.asserts.assert(this.mediaKeys_,\n        'mediaKeys_ should be valid when creating temporary session.');\n\n    let session;\n\n    try {\n      shaka.log.info('Creating new', sessionType, 'session');\n\n      session = this.mediaKeys_.createSession(sessionType);\n    } catch (exception) {\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_CREATE_SESSION,\n          exception.message));\n      return;\n    }\n\n    this.eventManager_.listen(session, 'message',\n    /** @type {shaka.util.EventManager.ListenerType} */(\n          (event) => this.onSessionMessage_(event)));\n    this.eventManager_.listen(session, 'keystatuseschange',\n        (event) => this.onKeyStatusesChange_(event));\n\n    const metadata = {\n      initData: initData,\n      loaded: false,\n      oldExpiration: Infinity,\n      updatePromise: null,\n      type: sessionType,\n    };\n    this.activeSessions_.set(session, metadata);\n\n    try {\n      initData = this.config_.initDataTransform(\n          initData, initDataType, this.currentDrmInfo_);\n    } catch (error) {\n      let shakaError = error;\n      if (!(error instanceof shaka.util.Error)) {\n        shakaError = new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.INIT_DATA_TRANSFORM_ERROR,\n            error);\n      }\n      this.onError_(shakaError);\n      return;\n    }\n\n    if (this.config_.logLicenseExchange) {\n      const str = shaka.util.Uint8ArrayUtils.toBase64(initData);\n      shaka.log.info('EME init data: type=', initDataType, 'data=', str);\n    }\n\n    session.generateRequest(initDataType, initData).catch((error) => {\n      if (this.destroyer_.destroyed()) {\n        return;\n      }\n      goog.asserts.assert(error instanceof Error, 'Wrong error type!');\n\n      this.activeSessions_.delete(session);\n\n      // This may be supplied by some polyfills.\n      /** @type {MediaKeyError} */\n      const errorCode = error['errorCode'];\n\n      let extended;\n      if (errorCode && errorCode.systemCode) {\n        extended = errorCode.systemCode;\n        if (extended < 0) {\n          extended += Math.pow(2, 32);\n        }\n        extended = '0x' + extended.toString(16);\n      }\n\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_GENERATE_LICENSE_REQUEST,\n          error.message, error, extended));\n    });\n  }\n\n  /**\n   * @param {!Uint8Array} initData\n   * @param {string} initDataType\n   * @param {?shaka.extern.DrmInfo} drmInfo\n   * @return {!Uint8Array}\n   */\n  static defaultInitDataTransform(initData, initDataType, drmInfo) {\n    if (initDataType == 'skd') {\n      const cert = drmInfo.serverCertificate;\n      const contentId =\n          shaka.util.FairPlayUtils.defaultGetContentId(initData);\n      initData = shaka.util.FairPlayUtils.initDataTransform(\n          initData, contentId, cert);\n    }\n    return initData;\n  }\n\n  /**\n   * @param {!MediaKeyMessageEvent} event\n   * @private\n   */\n  onSessionMessage_(event) {\n    if (this.delayLicenseRequest_()) {\n      this.mediaKeyMessageEvents_.push(event);\n    } else {\n      this.sendLicenseRequest_(event);\n    }\n  }\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  delayLicenseRequest_() {\n    if (!this.video_) {\n      // If there's no video, don't delay the license request; i.e., in the case\n      // of offline storage.\n      return false;\n    }\n    return (this.config_.delayLicenseRequestUntilPlayed &&\n            this.video_.paused && !this.initialRequestsSent_);\n  }\n\n  /**\n   * Sends a license request.\n   * @param {!MediaKeyMessageEvent} event\n   * @private\n   */\n  async sendLicenseRequest_(event) {\n    /** @type {!MediaKeySession} */\n    const session = event.target;\n    shaka.log.v1(\n        'Sending license request for session', session.sessionId, 'of type',\n        event.messageType);\n    if (this.config_.logLicenseExchange) {\n      const str = shaka.util.Uint8ArrayUtils.toBase64(event.message);\n      shaka.log.info('EME license request', str);\n    }\n\n    const metadata = this.activeSessions_.get(session);\n\n    let url = this.currentDrmInfo_.licenseServerUri;\n    const advancedConfig =\n        this.config_.advanced[this.currentDrmInfo_.keySystem];\n\n    if (event.messageType == 'individualization-request' && advancedConfig &&\n        advancedConfig.individualizationServer) {\n      url = advancedConfig.individualizationServer;\n    }\n\n    const requestType = shaka.net.NetworkingEngine.RequestType.LICENSE;\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        [url], this.config_.retryParameters);\n    request.body = event.message;\n    request.method = 'POST';\n    request.licenseRequestType = event.messageType;\n    request.sessionId = session.sessionId;\n    // NOTE: allowCrossSiteCredentials can be set in a request filter.\n\n    if (shaka.media.DrmEngine.isPlayReadyKeySystem(\n        this.currentDrmInfo_.keySystem)) {\n      this.unpackPlayReadyRequest_(request);\n    }\n\n    const startTimeRequest = Date.now();\n\n    let response;\n    try {\n      const req = this.playerInterface_.netEngine.request(requestType, request);\n      response = await req.promise;\n    } catch (error) {\n      // Request failed!\n      goog.asserts.assert(error instanceof shaka.util.Error,\n          'Wrong NetworkingEngine error type!');\n      const shakaErr = new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.LICENSE_REQUEST_FAILED,\n          error);\n      this.onError_(shakaErr);\n      if (metadata && metadata.updatePromise) {\n        metadata.updatePromise.reject(shakaErr);\n      }\n      return;\n    }\n    if (this.destroyer_.destroyed()) {\n      return;\n    }\n\n    this.licenseTimeSeconds_ += (Date.now() - startTimeRequest) / 1000;\n\n    if (this.config_.logLicenseExchange) {\n      const str = shaka.util.Uint8ArrayUtils.toBase64(response.data);\n      shaka.log.info('EME license response', str);\n    }\n\n    // Request succeeded, now pass the response to the CDM.\n    try {\n      shaka.log.v1('Updating session', session.sessionId);\n      await session.update(response.data);\n    } catch (error) {\n      // Session update failed!\n      const shakaErr = new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.LICENSE_RESPONSE_REJECTED,\n          error.message);\n      this.onError_(shakaErr);\n      if (metadata && metadata.updatePromise) {\n        metadata.updatePromise.reject(shakaErr);\n      }\n      return;\n    }\n    if (this.destroyer_.destroyed()) {\n      return;\n    }\n\n    const updateEvent = new shaka.util.FakeEvent('drmsessionupdate');\n    this.playerInterface_.onEvent(updateEvent);\n\n    if (metadata) {\n      if (metadata.updatePromise) {\n        metadata.updatePromise.resolve();\n      }\n      // In case there are no key statuses, consider this session loaded\n      // after a reasonable timeout.  It should definitely not take 5\n      // seconds to process a license.\n      const timer = new shaka.util.Timer(() => {\n        metadata.loaded = true;\n        if (this.areAllSessionsLoaded_()) {\n          this.allSessionsLoaded_.resolve();\n        }\n      });\n\n      timer.tickAfter(\n          /* seconds= */ shaka.media.DrmEngine.SESSION_LOAD_TIMEOUT_);\n    }\n  }\n\n  /**\n   * Unpacks PlayReady license requests.  Modifies the request object.\n   * @param {shaka.extern.Request} request\n   * @private\n   */\n  unpackPlayReadyRequest_(request) {\n    // On Edge, the raw license message is UTF-16-encoded XML.  We need\n    // to unpack the Challenge element (base64-encoded string containing the\n    // actual license request) and any HttpHeader elements (sent as request\n    // headers).\n\n    // Example XML:\n\n    // <PlayReadyKeyMessage type=\"LicenseAcquisition\">\n    //   <LicenseAcquisition Version=\"1\">\n    //     <Challenge encoding=\"base64encoded\">{Base64Data}</Challenge>\n    //     <HttpHeaders>\n    //       <HttpHeader>\n    //         <name>Content-Type</name>\n    //         <value>text/xml; charset=utf-8</value>\n    //       </HttpHeader>\n    //       <HttpHeader>\n    //         <name>SOAPAction</name>\n    //         <value>http://schemas.microsoft.com/DRM/etc/etc</value>\n    //       </HttpHeader>\n    //     </HttpHeaders>\n    //   </LicenseAcquisition>\n    // </PlayReadyKeyMessage>\n\n    const xml = shaka.util.StringUtils.fromUTF16(\n        request.body, /* littleEndian= */ true, /* noThrow= */ true);\n    if (!xml.includes('PlayReadyKeyMessage')) {\n      // This does not appear to be a wrapped message as on Edge.  Some\n      // clients do not need this unwrapping, so we will assume this is one of\n      // them.  Note that \"xml\" at this point probably looks like random\n      // garbage, since we interpreted UTF-8 as UTF-16.\n      shaka.log.debug('PlayReady request is already unwrapped.');\n      request.headers['Content-Type'] = 'text/xml; charset=utf-8';\n      return;\n    }\n    shaka.log.debug('Unwrapping PlayReady request.');\n    const dom = shaka.util.XmlUtils.parseXmlString(xml, 'PlayReadyKeyMessage');\n    goog.asserts.assert(dom, 'Failed to parse PlayReady XML!');\n\n    // Set request headers.\n    const headers = dom.getElementsByTagName('HttpHeader');\n    for (const header of headers) {\n      const name = header.getElementsByTagName('name')[0];\n      const value = header.getElementsByTagName('value')[0];\n      goog.asserts.assert(name && value, 'Malformed PlayReady headers!');\n      request.headers[name.textContent] = value.textContent;\n    }\n\n    // Unpack the base64-encoded challenge.\n    const challenge = dom.getElementsByTagName('Challenge')[0];\n    goog.asserts.assert(challenge, 'Malformed PlayReady challenge!');\n    goog.asserts.assert(challenge.getAttribute('encoding') == 'base64encoded',\n        'Unexpected PlayReady challenge encoding!');\n    request.body = shaka.util.Uint8ArrayUtils.fromBase64(challenge.textContent);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   * @suppress {invalidCasts} to swap keyId and status\n   */\n  onKeyStatusesChange_(event) {\n    const session = /** @type {!MediaKeySession} */(event.target);\n    shaka.log.v2('Key status changed for session', session.sessionId);\n\n    const found = this.activeSessions_.get(session);\n    const keyStatusMap = session.keyStatuses;\n    let hasExpiredKeys = false;\n\n    keyStatusMap.forEach((status, keyId) => {\n      // The spec has changed a few times on the exact order of arguments here.\n      // As of 2016-06-30, Edge has the order reversed compared to the current\n      // EME spec.  Given the back and forth in the spec, it may not be the only\n      // one.  Try to detect this and compensate:\n      if (typeof keyId == 'string') {\n        const tmp = keyId;\n        keyId = /** @type {!ArrayBuffer} */(status);\n        status = /** @type {string} */(tmp);\n      }\n\n      // Microsoft's implementation in Edge seems to present key IDs as\n      // little-endian UUIDs, rather than big-endian or just plain array of\n      // bytes.\n      // standard: 6e 5a 1d 26 - 27 57 - 47 d7 - 80 46 ea a5 d1 d3 4b 5a\n      // on Edge:  26 1d 5a 6e - 57 27 - d7 47 - 80 46 ea a5 d1 d3 4b 5a\n      // Bug filed: https://bit.ly/2thuzXu\n\n      // NOTE that we skip this if byteLength != 16.  This is used for Edge\n      // which uses single-byte dummy key IDs.\n      // However, unlike Edge and Chromecast, Tizen doesn't have this problem.\n      if (shaka.media.DrmEngine.isPlayReadyKeySystem(\n          this.currentDrmInfo_.keySystem) &&\n          keyId.byteLength == 16 &&\n          (shaka.util.Platform.isEdge() || shaka.util.Platform.isPS4())) {\n        // Read out some fields in little-endian:\n        const dataView = shaka.util.BufferUtils.toDataView(keyId);\n        const part0 = dataView.getUint32(0, /* LE= */ true);\n        const part1 = dataView.getUint16(4, /* LE= */ true);\n        const part2 = dataView.getUint16(6, /* LE= */ true);\n        // Write it back in big-endian:\n        dataView.setUint32(0, part0, /* BE= */ false);\n        dataView.setUint16(4, part1, /* BE= */ false);\n        dataView.setUint16(6, part2, /* BE= */ false);\n      }\n\n      if (status != 'status-pending') {\n        found.loaded = true;\n      }\n\n      if (!found) {\n        // We can get a key status changed for a closed session after it has\n        // been removed from |activeSessions_|.  If it is closed, none of its\n        // keys should be usable.\n        goog.asserts.assert(\n            status != 'usable', 'Usable keys found in closed session');\n      }\n\n      if (status == 'expired') {\n        hasExpiredKeys = true;\n      }\n\n      const keyIdHex = shaka.util.Uint8ArrayUtils.toHex(keyId).slice(0, 32);\n\n      this.keyStatusByKeyId_.set(keyIdHex, status);\n    });\n\n    // If the session has expired, close it.\n    // Some CDMs do not have sub-second time resolution, so the key status may\n    // fire with hundreds of milliseconds left until the stated expiration time.\n    const msUntilExpiration = session.expiration - Date.now();\n    if (msUntilExpiration < 0 || (hasExpiredKeys && msUntilExpiration < 1000)) {\n      // If this is part of a remove(), we don't want to close the session until\n      // the update is complete.  Otherwise, we will orphan the session.\n      if (found && !found.updatePromise) {\n        shaka.log.debug('Session has expired', session.sessionId);\n        this.activeSessions_.delete(session);\n        session.close().catch(() => {});  // Silence uncaught rejection errors\n      }\n    }\n\n    if (!this.areAllSessionsLoaded_()) {\n      // Don't announce key statuses or resolve the \"all loaded\" promise until\n      // everything is loaded.\n      return;\n    }\n\n    this.allSessionsLoaded_.resolve();\n\n    // Batch up key status changes before checking them or notifying Player.\n    // This handles cases where the statuses of multiple sessions are set\n    // simultaneously by the browser before dispatching key status changes for\n    // each of them.  By batching these up, we only send one status change event\n    // and at most one EXPIRED error on expiration.\n    this.keyStatusTimer_.tickAfter(\n        /* seconds= */ shaka.media.DrmEngine.KEY_STATUS_BATCH_TIME);\n  }\n\n  /** @private */\n  processKeyStatusChanges_() {\n    const privateMap = this.keyStatusByKeyId_;\n    const publicMap = this.announcedKeyStatusByKeyId_;\n\n    // Copy the latest key statuses into the publicly-accessible map.\n    publicMap.clear();\n    privateMap.forEach((status, keyId) => publicMap.set(keyId, status));\n\n    // If all keys are expired, fire an error. |every| is always true for an\n    // empty array but we shouldn't fire an error for a lack of key status info.\n    const statuses = Array.from(publicMap.values());\n    const allExpired = statuses.length &&\n                       statuses.every((status) => status == 'expired');\n\n    if (allExpired) {\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.EXPIRED));\n    }\n\n    this.playerInterface_.onKeyStatus(shaka.util.MapUtils.asObject(publicMap));\n  }\n\n  /**\n   * Returns true if the browser has recent EME APIs.\n   *\n   * @return {boolean}\n   */\n  static isBrowserSupported() {\n    const basic =\n        !!window.MediaKeys &&\n        !!window.navigator &&\n        !!window.navigator.requestMediaKeySystemAccess &&\n        !!window.MediaKeySystemAccess &&\n        // eslint-disable-next-line no-restricted-syntax\n        !!window.MediaKeySystemAccess.prototype.getConfiguration;\n\n    return basic;\n  }\n\n  /**\n   * Returns a Promise to a map of EME support for well-known key systems.\n   *\n   * @return {!Promise.<!Object.<string, ?shaka.extern.DrmSupportType>>}\n   */\n  static async probeSupport() {\n    goog.asserts.assert(shaka.media.DrmEngine.isBrowserSupported(),\n        'Must have basic EME support');\n\n    const testKeySystems = [\n      'org.w3.clearkey',\n      'com.widevine.alpha',\n      'com.microsoft.playready',\n      'com.microsoft.playready.recommendation',\n      'com.apple.fps.3_0',\n      'com.apple.fps.2_0',\n      'com.apple.fps.1_0',\n      'com.apple.fps',\n      'com.adobe.primetime',\n    ];\n\n    const basicVideoCapabilities = [\n      {contentType: 'video/mp4; codecs=\"avc1.42E01E\"'},\n      {contentType: 'video/webm; codecs=\"vp8\"'},\n    ];\n\n    const basicConfig = {\n      initDataTypes: ['cenc'],\n      videoCapabilities: basicVideoCapabilities,\n    };\n    const offlineConfig = {\n      videoCapabilities: basicVideoCapabilities,\n      persistentState: 'required',\n      sessionTypes: ['persistent-license'],\n    };\n\n    // Try the offline config first, then fall back to the basic config.\n    const configs = [offlineConfig, basicConfig];\n\n    /** @type {!Map.<string, ?shaka.extern.DrmSupportType>} */\n    const support = new Map();\n\n    const testSystem = async (keySystem) => {\n      try {\n        const access = await navigator.requestMediaKeySystemAccess(\n            keySystem, configs);\n\n        // Edge doesn't return supported session types, but current versions\n        // do not support persistent-license.  If sessionTypes is missing,\n        // assume no support for persistent-license.\n        // TODO: Polyfill Edge to return known supported session types.\n        // Edge bug: https://bit.ly/2IeKzho\n        const sessionTypes = access.getConfiguration().sessionTypes;\n        let persistentState = sessionTypes ?\n            sessionTypes.includes('persistent-license') : false;\n\n        // Tizen 3.0 doesn't support persistent licenses, but reports that it\n        // does.  It doesn't fail until you call update() with a license\n        // response, which is way too late.\n        // This is a work-around for #894.\n        if (shaka.util.Platform.isTizen3()) {\n          persistentState = false;\n        }\n\n        support.set(keySystem, {persistentState: persistentState});\n        await access.createMediaKeys();\n      } catch (e) {\n        // Either the request failed or createMediaKeys failed.\n        // Either way, write null to the support object.\n        support.set(keySystem, null);\n      }\n    };\n\n    // Test each key system.\n    const tests = testKeySystems.map((keySystem) => testSystem(keySystem));\n    await Promise.all(tests);\n    return shaka.util.MapUtils.asObject(support);\n  }\n\n  /** @private */\n  onPlay_() {\n    for (const event of this.mediaKeyMessageEvents_) {\n      this.sendLicenseRequest_(event);\n    }\n\n    this.initialRequestsSent_ = true;\n    this.mediaKeyMessageEvents_ = [];\n  }\n\n  /**\n   * Close a drm session while accounting for a bug in Chrome. Sometimes the\n   * Promise returned by close() never resolves.\n   *\n   * See issue #2741 and http://crbug.com/1108158.\n   * @param {!MediaKeySession} session\n   * @return {!Promise}\n   * @private\n   */\n  async closeSession_(session) {\n    const DrmEngine = shaka.media.DrmEngine;\n\n    const timeout = new Promise((resolve, reject) => {\n      const timer = new shaka.util.Timer(reject);\n      timer.tickAfter(DrmEngine.CLOSE_TIMEOUT_);\n    });\n\n    try {\n      await Promise.race([\n        Promise.all([session.close(), session.closed]),\n        timeout,\n      ]);\n    } catch (e) {\n      shaka.log.warning('Timeout waiting for session close');\n    }\n  }\n\n  /** @private */\n  async closeOpenSessions_() {\n    // Close all open sessions.\n    const openSessions = Array.from(this.activeSessions_.entries());\n    this.activeSessions_.clear();\n\n    // Close all sessions before we remove media keys from the video element.\n    await Promise.all(openSessions.map(async ([session, metadata]) => {\n      try {\n        /**\n         * Special case when a persistent-license session has been initiated,\n         * without being registered in the offline sessions at start-up.\n         * We should remove the session to prevent it from being orphaned after\n         * the playback session ends\n         */\n        if (!this.initializedForStorage_ &&\n            !this.offlineSessionIds_.includes(session.sessionId) &&\n            metadata.type === 'persistent-license') {\n          shaka.log.v1('Removing session', session.sessionId);\n\n          await session.remove();\n        } else {\n          shaka.log.v1('Closing session', session.sessionId, metadata);\n\n          await this.closeSession_(session);\n        }\n      } catch (error) {\n        // Ignore errors when closing the sessions. Closing a session that\n        // generated no key requests will throw an error.\n\n        shaka.log.error('Failed to close or remove the session', error);\n      }\n    }));\n  }\n\n  /**\n   * Check if a variant is likely to be supported by DrmEngine. This will err on\n   * the side of being too accepting and may not reject a variant that it will\n   * later fail to play.\n   *\n   * @param {!shaka.extern.Variant} variant\n   * @return {boolean}\n   */\n  supportsVariant(variant) {\n    /** @type {?shaka.extern.Stream} */\n    const audio = variant.audio;\n    /** @type {?shaka.extern.Stream} */\n    const video = variant.video;\n\n    if (audio && audio.encrypted) {\n      const audioContentType = shaka.media.DrmEngine.computeMimeType_(audio);\n      if (!this.willSupport(audioContentType)) {\n        return false;\n      }\n    }\n\n    if (video && video.encrypted) {\n      const videoContentType = shaka.media.DrmEngine.computeMimeType_(video);\n      if (!this.willSupport(videoContentType)) {\n        return false;\n      }\n    }\n\n    const keySystem = shaka.media.DrmEngine.keySystem(this.currentDrmInfo_);\n    const drmInfos = this.getVariantDrmInfos_(variant);\n\n    return drmInfos.length == 0 ||\n        drmInfos.some((drmInfo) => drmInfo.keySystem == keySystem);\n  }\n\n  /**\n   * Checks if two DrmInfos can be decrypted using the same key system.\n   * Clear content is considered compatible with every key system.\n   *\n   * @param {!Array.<!shaka.extern.DrmInfo>} drms1\n   * @param {!Array.<!shaka.extern.DrmInfo>} drms2\n   * @return {boolean}\n   */\n  static areDrmCompatible(drms1, drms2) {\n    if (!drms1.length || !drms2.length) {\n      return true;\n    }\n\n    return shaka.media.DrmEngine.getCommonDrmInfos(\n        drms1, drms2).length > 0;\n  }\n\n  /**\n   * Returns an array of drm infos that are present in both input arrays.\n   * If one of the arrays is empty, returns the other one since clear\n   * content is considered compatible with every drm info.\n   *\n   * @param {!Array.<!shaka.extern.DrmInfo>} drms1\n   * @param {!Array.<!shaka.extern.DrmInfo>} drms2\n   * @return {!Array.<!shaka.extern.DrmInfo>}\n   */\n  static getCommonDrmInfos(drms1, drms2) {\n    if (!drms1.length) {\n      return drms2;\n    }\n    if (!drms2.length) {\n      return drms1;\n    }\n\n    const commonDrms = [];\n\n    for (const drm1 of drms1) {\n      for (const drm2 of drms2) {\n        // This method is only called to compare drmInfos of a video and an\n        // audio adaptations, so we shouldn't have to worry about checking\n        // robustness.\n        if (drm1.keySystem == drm2.keySystem) {\n          /** @type {Array<shaka.extern.InitDataOverride>} */\n          let initData = [];\n          initData = initData.concat(drm1.initData || []);\n          initData = initData.concat(drm2.initData || []);\n          initData = initData.filter((d, i) => {\n            return d.keyId === undefined || i === initData.findIndex((d2) => {\n              return d2.keyId === d.keyId;\n            });\n          });\n\n          const keyIds = drm1.keyIds && drm2.keyIds ?\n              new Set([...drm1.keyIds, ...drm2.keyIds]) :\n              drm1.keyIds || drm2.keyIds;\n          const mergedDrm = {\n            keySystem: drm1.keySystem,\n            licenseServerUri: drm1.licenseServerUri || drm2.licenseServerUri,\n            distinctiveIdentifierRequired: drm1.distinctiveIdentifierRequired ||\n                drm2.distinctiveIdentifierRequired,\n            persistentStateRequired: drm1.persistentStateRequired ||\n                drm2.persistentStateRequired,\n            videoRobustness: drm1.videoRobustness || drm2.videoRobustness,\n            audioRobustness: drm1.audioRobustness || drm2.audioRobustness,\n            serverCertificate: drm1.serverCertificate || drm2.serverCertificate,\n            serverCertificateUri: drm1.serverCertificateUri ||\n                drm2.serverCertificateUri,\n            initData,\n            keyIds,\n          };\n          commonDrms.push(mergedDrm);\n          break;\n        }\n      }\n    }\n\n    return commonDrms;\n  }\n\n  /**\n   * Concat the audio and video drmInfos in a variant.\n   * @param {shaka.extern.Variant} variant\n   * @return {!Array.<!shaka.extern.DrmInfo>}\n   * @private\n   */\n  getVariantDrmInfos_(variant) {\n    const videoDrmInfos = variant.video ? variant.video.drmInfos : [];\n    const audioDrmInfos = variant.audio ? variant.audio.drmInfos : [];\n    return videoDrmInfos.concat(audioDrmInfos);\n  }\n\n  /**\n   * Called in an interval timer to poll the expiration times of the sessions.\n   * We don't get an event from EME when the expiration updates, so we poll it\n   * so we can fire an event when it happens.\n   * @private\n   */\n  pollExpiration_() {\n    this.activeSessions_.forEach((metadata, session) => {\n      const oldTime = metadata.oldExpiration;\n      let newTime = session.expiration;\n      if (isNaN(newTime)) {\n        newTime = Infinity;\n      }\n\n      if (newTime != oldTime) {\n        this.playerInterface_.onExpirationUpdated(session.sessionId, newTime);\n        metadata.oldExpiration = newTime;\n      }\n    });\n  }\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  areAllSessionsLoaded_() {\n    const metadatas = this.activeSessions_.values();\n    return shaka.util.Iterables.every(metadatas, (data) => data.loaded);\n  }\n\n  /**\n   * Replace the drm info used in each variant in |variants| to reflect each\n   * key service in |keySystems|.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {!Map.<string, string>} keySystems\n   * @private\n   */\n  static replaceDrmInfo_(variants, keySystems) {\n    const drmInfos = [];\n\n    keySystems.forEach((uri, keySystem) => {\n      drmInfos.push({\n        keySystem: keySystem,\n        licenseServerUri: uri,\n        distinctiveIdentifierRequired: false,\n        persistentStateRequired: false,\n        audioRobustness: '',\n        videoRobustness: '',\n        serverCertificate: null,\n        serverCertificateUri: '',\n        initData: [],\n        keyIds: new Set(),\n      });\n    });\n\n    for (const variant of variants) {\n      if (variant.video) {\n        variant.video.drmInfos = drmInfos;\n      }\n      if (variant.audio) {\n        variant.audio.drmInfos = drmInfos;\n      }\n    }\n  }\n\n\n  /**\n   * Creates a DrmInfo object describing the settings used to initialize the\n   * engine.\n   *\n   * @param {string} keySystem\n   * @param {!Array.<shaka.extern.DrmInfo>} drmInfos\n   * @return {shaka.extern.DrmInfo}\n   *\n   * @private\n   */\n  createDrmInfoByInfos_(keySystem, drmInfos) {\n    /** @type {!Array.<string>} */\n    const licenseServers = [];\n\n    /** @type {!Array.<string>} */\n    const serverCertificateUris = [];\n\n    /** @type {!Array.<!Uint8Array>} */\n    const serverCerts = [];\n\n    /** @type {!Array.<!shaka.extern.InitDataOverride>} */\n    const initDatas = [];\n\n    /** @type {!Set.<string>} */\n    const keyIds = new Set();\n\n    shaka.media.DrmEngine.processDrmInfos_(\n        drmInfos, licenseServers, serverCerts,\n        serverCertificateUris, initDatas, keyIds);\n\n    if (serverCerts.length > 1) {\n      shaka.log.warning('Multiple unique server certificates found! ' +\n                        'Only the first will be used.');\n    }\n\n    if (licenseServers.length > 1) {\n      shaka.log.warning('Multiple unique license server URIs found! ' +\n                        'Only the first will be used.');\n    }\n\n    if (serverCertificateUris.length > 1) {\n      shaka.log.warning('Multiple unique server certificate URIs found! ' +\n                        'Only the first will be used.');\n    }\n\n    const defaultSessionType =\n        this.usePersistentLicenses_ ? 'persistent-license' : 'temporary';\n\n    /** @type {shaka.extern.DrmInfo} */\n    const res = {\n      keySystem,\n      licenseServerUri: licenseServers[0],\n      distinctiveIdentifierRequired: drmInfos[0].distinctiveIdentifierRequired,\n      persistentStateRequired: drmInfos[0].persistentStateRequired,\n      sessionType: drmInfos[0].sessionType || defaultSessionType,\n      audioRobustness: drmInfos[0].audioRobustness || '',\n      videoRobustness: drmInfos[0].videoRobustness || '',\n      serverCertificate: serverCerts[0],\n      serverCertificateUri: serverCertificateUris[0],\n      initData: initDatas,\n      keyIds,\n    };\n\n    for (const info of drmInfos) {\n      if (info.distinctiveIdentifierRequired) {\n        res.distinctiveIdentifierRequired = info.distinctiveIdentifierRequired;\n      }\n\n      if (info.persistentStateRequired) {\n        res.persistentStateRequired = info.persistentStateRequired;\n      }\n    }\n\n    return res;\n  }\n\n  /**\n   * Creates a DrmInfo object describing the settings used to initialize the\n   * engine.\n   *\n   * @param {string} keySystem\n   * @param {MediaKeySystemConfiguration} config\n   * @return {shaka.extern.DrmInfo}\n   *\n   * @private\n   */\n  static createDrmInfoByConfigs_(keySystem, config) {\n    /** @type {!Array.<string>} */\n    const licenseServers = [];\n\n    /** @type {!Array.<string>} */\n    const serverCertificateUris = [];\n\n    /** @type {!Array.<!Uint8Array>} */\n    const serverCerts = [];\n\n    /** @type {!Array.<!shaka.extern.InitDataOverride>} */\n    const initDatas = [];\n\n    /** @type {!Set.<string>} */\n    const keyIds = new Set();\n\n    // TODO: refactor, don't stick drmInfos onto MediaKeySystemConfiguration\n    shaka.media.DrmEngine.processDrmInfos_(\n        config['drmInfos'], licenseServers, serverCerts,\n        serverCertificateUris, initDatas, keyIds);\n\n    if (serverCerts.length > 1) {\n      shaka.log.warning('Multiple unique server certificates found! ' +\n                        'Only the first will be used.');\n    }\n\n    if (serverCertificateUris.length > 1) {\n      shaka.log.warning('Multiple unique server certificate URIs found! ' +\n                        'Only the first will be used.');\n    }\n\n    if (licenseServers.length > 1) {\n      shaka.log.warning('Multiple unique license server URIs found! ' +\n                        'Only the first will be used.');\n    }\n\n    // TODO: This only works when all DrmInfo have the same robustness.\n    const audioRobustness =\n        config.audioCapabilities ? config.audioCapabilities[0].robustness : '';\n    const videoRobustness =\n        config.videoCapabilities ? config.videoCapabilities[0].robustness : '';\n\n    const distinctiveIdentifier = config.distinctiveIdentifier;\n    return {\n      keySystem,\n      licenseServerUri: licenseServers[0],\n      distinctiveIdentifierRequired: (distinctiveIdentifier == 'required'),\n      persistentStateRequired: (config.persistentState == 'required'),\n      sessionType: config.sessionTypes[0] || 'temporary',\n      audioRobustness: audioRobustness || '',\n      videoRobustness: videoRobustness || '',\n      serverCertificate: serverCerts[0],\n      serverCertificateUri: serverCertificateUris[0],\n      initData: initDatas,\n      keyIds,\n    };\n  }\n\n  /**\n   * Extract license server, server cert, and init data from |drmInfos|, taking\n   * care to eliminate duplicates.\n   *\n   * @param {!Array.<shaka.extern.DrmInfo>} drmInfos\n   * @param {!Array.<string>} licenseServers\n   * @param {!Array.<!Uint8Array>} serverCerts\n   * @param {!Array.<string>} serverCertificateUris\n   * @param {!Array.<!shaka.extern.InitDataOverride>} initDatas\n   * @param {!Set.<string>} keyIds\n   * @private\n   */\n  static processDrmInfos_(\n      drmInfos, licenseServers, serverCerts,\n      serverCertificateUris, initDatas, keyIds) {\n    /** @type {function(shaka.extern.InitDataOverride,\n     *                  shaka.extern.InitDataOverride):boolean} */\n    const initDataOverrideEqual = (a, b) => {\n      if (a.keyId && a.keyId == b.keyId) {\n        // Two initDatas with the same keyId are considered to be the same,\n        // unless that \"same keyId\" is null.\n        return true;\n      }\n      return a.initDataType == b.initDataType &&\n         shaka.util.BufferUtils.equal(a.initData, b.initData);\n    };\n\n    for (const drmInfo of drmInfos) {\n      // Build an array of unique license servers.\n      if (!licenseServers.includes(drmInfo.licenseServerUri)) {\n        licenseServers.push(drmInfo.licenseServerUri);\n      }\n\n      // Build an array of unique license servers.\n      if (!serverCertificateUris.includes(drmInfo.serverCertificateUri)) {\n        serverCertificateUris.push(drmInfo.serverCertificateUri);\n      }\n\n      // Build an array of unique server certs.\n      if (drmInfo.serverCertificate) {\n        const found = serverCerts.some(\n            (cert) => shaka.util.BufferUtils.equal(\n                cert, drmInfo.serverCertificate));\n        if (!found) {\n          serverCerts.push(drmInfo.serverCertificate);\n        }\n      }\n\n      // Build an array of unique init datas.\n      if (drmInfo.initData) {\n        for (const initDataOverride of drmInfo.initData) {\n          const found = initDatas.some(\n              (initData) =>\n                initDataOverrideEqual(initData, initDataOverride));\n          if (!found) {\n            initDatas.push(initDataOverride);\n          }\n        }\n      }\n\n      if (drmInfo.keyIds) {\n        for (const keyId of drmInfo.keyIds) {\n          keyIds.add(keyId);\n        }\n      }\n    }\n  }\n\n  /**\n   * Use |servers| and |advancedConfigs| to fill in missing values in drmInfo\n   * that the parser left blank. Before working with any drmInfo, it should be\n   * passed through here as it is uncommon for drmInfo to be complete when\n   * fetched from a manifest because most manifest formats do not have the\n   * required information.\n   *\n   * @param {shaka.extern.DrmInfo} drmInfo\n   * @param {!Map.<string, string>} servers\n   * @param {!Map.<string, shaka.extern.AdvancedDrmConfiguration>}\n   *   advancedConfigs\n   * @private\n   */\n  static fillInDrmInfoDefaults_(drmInfo, servers, advancedConfigs) {\n    if (!drmInfo.keySystem) {\n      // This is a placeholder from the manifest parser for an unrecognized key\n      // system.  Skip this entry, to avoid logging nonsensical errors.\n      return;\n    }\n\n    // The order of preference for drmInfo:\n    // 1. Clear Key config, used for debugging, should override everything else.\n    //    (The application can still specify a clearkey license server.)\n    // 2. Application-configured servers, if any are present, should override\n    //    anything from the manifest.  Nuance: if key system A is in the\n    //    manifest and key system B is in the player config, only B will be\n    //    used, not A.\n    // 3. Manifest-provided license servers are only used if nothing else is\n    //    specified.\n    // This is important because it allows the application a clear way to\n    // indicate which DRM systems should be used on platforms with multiple DRM\n    // systems.\n    // The only way to get license servers from the manifest is not to specify\n    // any in your player config.\n\n    if (drmInfo.keySystem == 'org.w3.clearkey' && drmInfo.licenseServerUri) {\n      // Preference 1: Clear Key with pre-configured keys will have a data URI\n      // assigned as its license server.  Don't change anything.\n      return;\n    } else if (servers.size) {\n      // Preference 2: If anything is configured at the application level,\n      // override whatever was in the manifest.\n      const server = servers.get(drmInfo.keySystem) || '';\n\n      drmInfo.licenseServerUri = server;\n    } else {\n      // Preference 3: Keep whatever we had in drmInfo.licenseServerUri, which\n      // comes from the manifest.\n    }\n\n    if (!drmInfo.keyIds) {\n      drmInfo.keyIds = new Set();\n    }\n\n    const advancedConfig = advancedConfigs.get(drmInfo.keySystem);\n\n    if (advancedConfig) {\n      if (!drmInfo.distinctiveIdentifierRequired) {\n        drmInfo.distinctiveIdentifierRequired =\n            advancedConfig.distinctiveIdentifierRequired;\n      }\n\n      if (!drmInfo.persistentStateRequired) {\n        drmInfo.persistentStateRequired =\n            advancedConfig.persistentStateRequired;\n      }\n\n      if (!drmInfo.videoRobustness) {\n        drmInfo.videoRobustness = advancedConfig.videoRobustness;\n      }\n\n      if (!drmInfo.audioRobustness) {\n        drmInfo.audioRobustness = advancedConfig.audioRobustness;\n      }\n\n      if (!drmInfo.serverCertificate) {\n        drmInfo.serverCertificate = advancedConfig.serverCertificate;\n      }\n\n      if (advancedConfig.sessionType) {\n        drmInfo.sessionType = advancedConfig.sessionType;\n      }\n\n      if (!drmInfo.serverCertificateUri) {\n        drmInfo.serverCertificateUri = advancedConfig.serverCertificateUri;\n      }\n    }\n\n    // Chromecast has a variant of PlayReady that uses a different key\n    // system ID.  Since manifest parsers convert the standard PlayReady\n    // UUID to the standard PlayReady key system ID, here we will switch\n    // to the Chromecast version if we are running on that platform.\n    // Note that this must come after fillInDrmInfoDefaults_, since the\n    // player config uses the standard PlayReady ID for license server\n    // configuration.\n    if (window.cast && window.cast.__platform__) {\n      if (drmInfo.keySystem == 'com.microsoft.playready') {\n        drmInfo.keySystem = 'com.chromecast.playready';\n      }\n    }\n  }\n};\n\n\n/**\n * @typedef {{\n *   loaded: boolean,\n *   initData: Uint8Array,\n *   oldExpiration: number,\n *   type: string,\n *   updatePromise: shaka.util.PublicPromise\n * }}\n *\n * @description A record to track sessions and suppress duplicate init data.\n * @property {boolean} loaded\n *   True once the key status has been updated (to a non-pending state).  This\n *   does not mean the session is 'usable'.\n * @property {Uint8Array} initData\n *   The init data used to create the session.\n * @property {!MediaKeySession} session\n *   The session object.\n * @property {number} oldExpiration\n *   The expiration of the session on the last check.  This is used to fire\n *   an event when it changes.\n * @property {string} type\n *   The session type\n * @property {shaka.util.PublicPromise} updatePromise\n *   An optional Promise that will be resolved/rejected on the next update()\n *   call.  This is used to track the 'license-release' message when calling\n *   remove().\n */\nshaka.media.DrmEngine.SessionMetaData;\n\n\n/**\n * @typedef {{\n *   netEngine: !shaka.net.NetworkingEngine,\n *   onError: function(!shaka.util.Error),\n *   onKeyStatus: function(!Object.<string,string>),\n *   onExpirationUpdated: function(string,number),\n *   onEvent: function(!Event)\n * }}\n *\n * @property {shaka.net.NetworkingEngine} netEngine\n *   The NetworkingEngine instance to use.  The caller retains ownership.\n * @property {function(!shaka.util.Error)} onError\n *   Called when an error occurs.  If the error is recoverable (see\n *   {@link shaka.util.Error}) then the caller may invoke either\n *   StreamingEngine.switch*() or StreamingEngine.seeked() to attempt recovery.\n * @property {function(!Object.<string,string>)} onKeyStatus\n *   Called when key status changes.  The argument is a map of hex key IDs to\n *   statuses.\n * @property {function(string,number)} onExpirationUpdated\n *   Called when the session expiration value changes.\n * @property {function(!Event)} onEvent\n *   Called when an event occurs that should be sent to the app.\n */\nshaka.media.DrmEngine.PlayerInterface;\n\n/**\n * The amount of time, in seconds, we wait to consider a session closed.\n * This allows us to work around Chrome bug https://crbug.com/1108158.\n * @private {number}\n */\nshaka.media.DrmEngine.CLOSE_TIMEOUT_ = 1;\n\n\n/**\n * The amount of time, in seconds, we wait to consider session loaded even if no\n * key status information is available.  This allows us to support browsers/CDMs\n * without key statuses.\n * @private {number}\n */\nshaka.media.DrmEngine.SESSION_LOAD_TIMEOUT_ = 5;\n\n\n/**\n * The amount of time, in seconds, we wait to batch up rapid key status changes.\n * This allows us to avoid multiple expiration events in most cases.\n * @type {number}\n */\nshaka.media.DrmEngine.KEY_STATUS_BATCH_TIME = 0.5;\n\n\n/**\n * Contains the suggested \"default\" key ID used by EME polyfills that do not\n * have a per-key key status. See w3c/encrypted-media#32.\n * @type {!shaka.util.Lazy.<!ArrayBuffer>}\n */\nshaka.media.DrmEngine.DUMMY_KEY_ID = new shaka.util.Lazy(\n    () => shaka.util.BufferUtils.toArrayBuffer(new Uint8Array([0])));\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.ManifestParser');\n\ngoog.require('goog.Uri');\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Platform');\n\n\n// TODO: revisit this when Closure Compiler supports partially-exported classes.\n/**\n * @summary An interface to register manifest parsers.\n * @export\n */\nshaka.media.ManifestParser = class {\n  /**\n   * Registers a manifest parser by file extension.\n   *\n   * @param {string} extension The file extension of the manifest.\n   * @param {shaka.extern.ManifestParser.Factory} parserFactory The factory\n   *   used to create parser instances.\n   * @export\n   */\n  static registerParserByExtension(extension, parserFactory) {\n    shaka.media.ManifestParser.parsersByExtension[extension] = parserFactory;\n  }\n\n\n  /**\n   * Registers a manifest parser by MIME type.\n   *\n   * @param {string} mimeType The MIME type of the manifest.\n   * @param {shaka.extern.ManifestParser.Factory} parserFactory The factory\n   *   used to create parser instances.\n   * @export\n   */\n  static registerParserByMime(mimeType, parserFactory) {\n    shaka.media.ManifestParser.parsersByMime[mimeType] = parserFactory;\n  }\n\n  /**\n   * Unregisters a manifest parser by MIME type.\n   *\n   * @param {string} mimeType The MIME type of the manifest.\n   * @export\n   */\n  static unregisterParserByMime(mimeType) {\n    delete shaka.media.ManifestParser.parsersByMime[mimeType];\n  }\n\n\n  /**\n   * Returns a map of manifest support for well-known types.\n   *\n   * @return {!Object.<string, boolean>}\n   */\n  static probeSupport() {\n    const ManifestParser = shaka.media.ManifestParser;\n    const support = {};\n\n    // Make sure all registered parsers are shown, but only for MSE-enabled\n    // platforms where our parsers matter.\n    if (shaka.util.Platform.supportsMediaSource()) {\n      for (const type in ManifestParser.parsersByMime) {\n        support[type] = true;\n      }\n      for (const type in ManifestParser.parsersByExtension) {\n        support[type] = true;\n      }\n    }\n\n    // Make sure all well-known types are tested as well, just to show an\n    // explicit false for things people might be expecting.\n    const testMimeTypes = [\n      // DASH\n      'application/dash+xml',\n      // HLS\n      'application/x-mpegurl',\n      'application/vnd.apple.mpegurl',\n      // SmoothStreaming\n      'application/vnd.ms-sstr+xml',\n    ];\n    const testExtensions = {\n      // DASH\n      'mpd': 'application/dash+xml',\n      // HLS\n      'm3u8': 'application/x-mpegurl',\n      // SmoothStreaming\n      'ism': 'application/vnd.ms-sstr+xml',\n    };\n\n    for (const type of testMimeTypes) {\n      // Only query our parsers for MSE-enabled platforms.  Otherwise, query a\n      // temporary media element for native support for these types.\n      if (shaka.util.Platform.supportsMediaSource()) {\n        support[type] = !!ManifestParser.parsersByMime[type];\n      } else {\n        support[type] = shaka.util.Platform.supportsMediaType(type);\n      }\n    }\n\n    for (const extension in testExtensions) {\n      // Only query our parsers for MSE-enabled platforms.  Otherwise, query a\n      // temporary media element for native support for these MIME type for the\n      // extension.\n      if (shaka.util.Platform.supportsMediaSource()) {\n        support[extension] = !!ManifestParser.parsersByExtension[extension];\n      } else {\n        const type = testExtensions[extension];\n        support[extension] = shaka.util.Platform.supportsMediaType(type);\n      }\n    }\n\n    return support;\n  }\n\n\n  /**\n   * Get a factory that can create a manifest parser that should be able to\n   * parse the manifest at |uri|.\n   *\n   * @param {string} uri\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {shaka.extern.RetryParameters} retryParams\n   * @param {?string} mimeType\n   * @return {!Promise.<shaka.extern.ManifestParser.Factory>}\n   */\n  static async getFactory(uri, netEngine, retryParams, mimeType) {\n    const ManifestParser = shaka.media.ManifestParser;\n\n    // Try using the MIME type we were given.\n    if (mimeType) {\n      const factory = ManifestParser.parsersByMime[mimeType.toLowerCase()];\n      if (factory) {\n        return factory;\n      }\n\n      shaka.log.warning(\n          'Could not determine manifest type using MIME type ', mimeType);\n    }\n\n    const extension = ManifestParser.getExtension(uri);\n    if (extension) {\n      const factory = ManifestParser.parsersByExtension[extension];\n      if (factory) {\n        return factory;\n      }\n\n      shaka.log.warning(\n          'Could not determine manifest type for extension ', extension);\n    } else {\n      shaka.log.warning('Could not find extension for ', uri);\n    }\n\n    if (!mimeType) {\n      mimeType = await ManifestParser.getMimeType(uri, netEngine, retryParams);\n\n      if (mimeType) {\n        const factory = shaka.media.ManifestParser.parsersByMime[mimeType];\n        if (factory) {\n          return factory;\n        }\n\n        shaka.log.warning('Could not determine manifest type using MIME type',\n            mimeType);\n      }\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.UNABLE_TO_GUESS_MANIFEST_TYPE,\n        uri);\n  }\n\n\n  /**\n   * @param {string} uri\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {shaka.extern.RetryParameters} retryParams\n   * @return {!Promise.<string>}\n   */\n  static async getMimeType(uri, netEngine, retryParams) {\n    const type = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n\n    const request = shaka.net.NetworkingEngine.makeRequest([uri], retryParams);\n    request.method = 'HEAD';\n\n    const response = await netEngine.request(type, request).promise;\n\n    // https://bit.ly/2K9s9kf says this header should always be available,\n    // but just to be safe:\n    const mimeType = response.headers['content-type'];\n    return mimeType ? mimeType.toLowerCase().split(';').shift() : '';\n  }\n\n\n  /**\n   * @param {string} uri\n   * @return {string}\n   */\n  static getExtension(uri) {\n    const uriObj = new goog.Uri(uri);\n    const uriPieces = uriObj.getPath().split('/');\n    const uriFilename = uriPieces.pop();\n    const filenamePieces = uriFilename.split('.');\n\n    // Only one piece means there is no extension.\n    if (filenamePieces.length == 1) {\n      return '';\n    }\n\n    return filenamePieces.pop().toLowerCase();\n  }\n\n\n  /**\n   * Determines whether or not this URI and MIME type are supported by our own\n   * manifest parsers on this platform.  This takes into account whether or not\n   * MediaSource is available, as well as which parsers are registered to the\n   * system.\n   *\n   * @param {string} uri\n   * @param {string} mimeType\n   * @return {boolean}\n   */\n  static isSupported(uri, mimeType) {\n    // Without MediaSource, our own parsers are useless.\n    if (!shaka.util.Platform.supportsMediaSource()) {\n      return false;\n    }\n\n    if (mimeType in shaka.media.ManifestParser.parsersByMime) {\n      return true;\n    }\n\n    const extension = shaka.media.ManifestParser.getExtension(uri);\n    if (extension in shaka.media.ManifestParser.parsersByExtension) {\n      return true;\n    }\n\n    return false;\n  }\n};\n\n\n/**\n * Contains the parser factory functions indexed by MIME type.\n *\n * @type {!Object.<string, shaka.extern.ManifestParser.Factory>}\n */\nshaka.media.ManifestParser.parsersByMime = {};\n\n\n/**\n * Contains the parser factory functions indexed by file extension.\n *\n * @type {!Object.<string, shaka.extern.ManifestParser.Factory>}\n */\nshaka.media.ManifestParser.parsersByExtension = {};\n\n\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.DataViewReader');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n  * @summary DataViewReader abstracts a DataView object.\n  * @export\n  */\nshaka.util.DataViewReader = class {\n  /**\n   * @param {BufferSource} data\n   * @param {shaka.util.DataViewReader.Endianness} endianness The endianness.\n   */\n  constructor(data, endianness) {\n    /** @private {!DataView} */\n    this.dataView_ = shaka.util.BufferUtils.toDataView(data);\n\n    /** @private {boolean} */\n    this.littleEndian_ =\n        endianness == shaka.util.DataViewReader.Endianness.LITTLE_ENDIAN;\n\n    /** @private {number} */\n    this.position_ = 0;\n  }\n\n\n  /** @return {!DataView} The underlying DataView instance. */\n  getDataView() {\n    return this.dataView_;\n  }\n\n\n  /**\n   * @return {boolean} True if the reader has more data, false otherwise.\n   * @export\n   */\n  hasMoreData() {\n    return this.position_ < this.dataView_.byteLength;\n  }\n\n\n  /**\n   * Gets the current byte position.\n   * @return {number}\n   * @export\n   */\n  getPosition() {\n    return this.position_;\n  }\n\n\n  /**\n   * Gets the byte length of the DataView.\n   * @return {number}\n   * @export\n   */\n  getLength() {\n    return this.dataView_.byteLength;\n  }\n\n\n  /**\n   * Reads an unsigned 8 bit integer, and advances the reader.\n   * @return {number} The integer.\n   * @export\n   */\n  readUint8() {\n    try {\n      const value = this.dataView_.getUint8(this.position_);\n      this.position_ += 1;\n      return value;\n    } catch (exception) {\n      throw this.outOfBounds_();\n    }\n  }\n\n\n  /**\n   * Reads an unsigned 16 bit integer, and advances the reader.\n   * @return {number} The integer.\n   * @export\n   */\n  readUint16() {\n    try {\n      const value =\n          this.dataView_.getUint16(this.position_, this.littleEndian_);\n      this.position_ += 2;\n      return value;\n    } catch (exception) {\n      throw this.outOfBounds_();\n    }\n  }\n\n\n  /**\n   * Reads an unsigned 32 bit integer, and advances the reader.\n   * @return {number} The integer.\n   * @export\n   */\n  readUint32() {\n    try {\n      const value =\n          this.dataView_.getUint32(this.position_, this.littleEndian_);\n      this.position_ += 4;\n      return value;\n    } catch (exception) {\n      throw this.outOfBounds_();\n    }\n  }\n\n\n  /**\n   * Reads a signed 32 bit integer, and advances the reader.\n   * @return {number} The integer.\n   * @export\n   */\n  readInt32() {\n    try {\n      const value = this.dataView_.getInt32(this.position_, this.littleEndian_);\n      this.position_ += 4;\n      return value;\n    } catch (exception) {\n      throw this.outOfBounds_();\n    }\n  }\n\n\n  /**\n   * Reads an unsigned 64 bit integer, and advances the reader.\n   * @return {number} The integer.\n   * @export\n   */\n  readUint64() {\n    /** @type {number} */\n    let low;\n    /** @type {number} */\n    let high;\n\n    try {\n      if (this.littleEndian_) {\n        low = this.dataView_.getUint32(this.position_, true);\n        high = this.dataView_.getUint32(this.position_ + 4, true);\n      } else {\n        high = this.dataView_.getUint32(this.position_, false);\n        low = this.dataView_.getUint32(this.position_ + 4, false);\n      }\n    } catch (exception) {\n      throw this.outOfBounds_();\n    }\n\n    if (high > 0x1FFFFF) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.JS_INTEGER_OVERFLOW);\n    }\n\n    this.position_ += 8;\n\n    // NOTE: This is subtle, but in JavaScript you can't shift left by 32\n    // and get the full range of 53-bit values possible.\n    // You must multiply by 2^32.\n    return (high * Math.pow(2, 32)) + low;\n  }\n\n\n  /**\n   * Reads the specified number of raw bytes.\n   * @param {number} bytes The number of bytes to read.\n   * @return {!Uint8Array}\n   * @export\n   */\n  readBytes(bytes) {\n    goog.asserts.assert(bytes >= 0, 'Bad call to DataViewReader.readBytes');\n    if (this.position_ + bytes > this.dataView_.byteLength) {\n      throw this.outOfBounds_();\n    }\n\n    const value =\n        shaka.util.BufferUtils.toUint8(this.dataView_, this.position_, bytes);\n    this.position_ += bytes;\n    return value;\n  }\n\n\n  /**\n   * Skips the specified number of bytes.\n   * @param {number} bytes The number of bytes to skip.\n   * @export\n   */\n  skip(bytes) {\n    goog.asserts.assert(bytes >= 0, 'Bad call to DataViewReader.skip');\n    if (this.position_ + bytes > this.dataView_.byteLength) {\n      throw this.outOfBounds_();\n    }\n    this.position_ += bytes;\n  }\n\n\n  /**\n   * Rewinds the specified number of bytes.\n   * @param {number} bytes The number of bytes to rewind.\n   * @export\n   */\n  rewind(bytes) {\n    goog.asserts.assert(bytes >= 0, 'Bad call to DataViewReader.rewind');\n    if (this.position_ < bytes) {\n      throw this.outOfBounds_();\n    }\n    this.position_ -= bytes;\n  }\n\n\n  /**\n   * Seeks to a specified position.\n   * @param {number} position The desired byte position within the DataView.\n   * @export\n   */\n  seek(position) {\n    goog.asserts.assert(position >= 0, 'Bad call to DataViewReader.seek');\n    if (position < 0 || position > this.dataView_.byteLength) {\n      throw this.outOfBounds_();\n    }\n    this.position_ = position;\n  }\n\n\n  /**\n   * Keeps reading until it reaches a byte that equals to zero.  The text is\n   * assumed to be UTF-8.\n   * @return {string}\n   * @export\n   */\n  readTerminatedString() {\n    const start = this.position_;\n    while (this.hasMoreData()) {\n      const value = this.dataView_.getUint8(this.position_);\n      if (value == 0) {\n        break;\n      }\n      this.position_ += 1;\n    }\n\n    const ret = shaka.util.BufferUtils.toUint8(\n        this.dataView_, start, this.position_ - start);\n    // Skip string termination.\n    this.position_ += 1;\n    return shaka.util.StringUtils.fromUTF8(ret);\n  }\n\n\n  /**\n   * @return {!shaka.util.Error}\n   * @private\n   */\n  outOfBounds_() {\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.BUFFER_READ_OUT_OF_BOUNDS);\n  }\n};\n\n/**\n * Endianness.\n * @enum {number}\n * @export\n */\nshaka.util.DataViewReader.Endianness = {\n  'BIG_ENDIAN': 0,\n  'LITTLE_ENDIAN': 1,\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Mp4Parser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.DataViewReader');\n\n\n/**\n * @export\n */\nshaka.util.Mp4Parser = class {\n  /** */\n  constructor() {\n    /** @private {!Object.<number, shaka.util.Mp4Parser.BoxType_>} */\n    this.headers_ = [];\n\n    /** @private {!Object.<number, !shaka.util.Mp4Parser.CallbackType>} */\n    this.boxDefinitions_ = [];\n\n    /** @private {boolean} */\n    this.done_ = false;\n  }\n\n\n  /**\n   * Declare a box type as a Box.\n   *\n   * @param {string} type\n   * @param {!shaka.util.Mp4Parser.CallbackType} definition\n   * @return {!shaka.util.Mp4Parser}\n   * @export\n   */\n  box(type, definition) {\n    const typeCode = shaka.util.Mp4Parser.typeFromString_(type);\n    this.headers_[typeCode] = shaka.util.Mp4Parser.BoxType_.BASIC_BOX;\n    this.boxDefinitions_[typeCode] = definition;\n    return this;\n  }\n\n\n  /**\n   * Declare a box type as a Full Box.\n   *\n   * @param {string} type\n   * @param {!shaka.util.Mp4Parser.CallbackType} definition\n   * @return {!shaka.util.Mp4Parser}\n   * @export\n   */\n  fullBox(type, definition) {\n    const typeCode = shaka.util.Mp4Parser.typeFromString_(type);\n    this.headers_[typeCode] = shaka.util.Mp4Parser.BoxType_.FULL_BOX;\n    this.boxDefinitions_[typeCode] = definition;\n    return this;\n  }\n\n\n  /**\n   * Stop parsing.  Useful for extracting information from partial segments and\n   * avoiding an out-of-bounds error once you find what you are looking for.\n   *\n   * @export\n   */\n  stop() {\n    this.done_ = true;\n  }\n\n\n  /**\n   * Parse the given data using the added callbacks.\n   *\n   * @param {!BufferSource} data\n   * @param {boolean=} partialOkay If true, allow reading partial payloads\n   *   from some boxes. If the goal is a child box, we can sometimes find it\n   *   without enough data to find all child boxes.\n   * @param {boolean=} stopOnPartial If true, stop reading if an incomplete\n   *   box is detected.\n   * @export\n   */\n  parse(data, partialOkay, stopOnPartial) {\n    const reader = new shaka.util.DataViewReader(\n        data, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n    this.done_ = false;\n    while (reader.hasMoreData() && !this.done_) {\n      this.parseNext(0, reader, partialOkay, stopOnPartial);\n    }\n  }\n\n\n  /**\n   * Parse the next box on the current level.\n   *\n   * @param {number} absStart The absolute start position in the original\n   *   byte array.\n   * @param {!shaka.util.DataViewReader} reader\n   * @param {boolean=} partialOkay If true, allow reading partial payloads\n   *   from some boxes. If the goal is a child box, we can sometimes find it\n   *   without enough data to find all child boxes.\n   * @param {boolean=} stopOnPartial If true, stop reading if an incomplete\n   *   box is detected.\n   * @export\n   */\n  parseNext(absStart, reader, partialOkay, stopOnPartial) {\n    const start = reader.getPosition();\n\n    // size(4 bytes) + type(4 bytes) = 8 bytes\n    if (stopOnPartial && start + 8 > reader.getLength()) {\n      this.done_ = true;\n      return;\n    }\n\n    let size = reader.readUint32();\n    const type = reader.readUint32();\n    const name = shaka.util.Mp4Parser.typeToString(type);\n    let has64BitSize = false;\n    shaka.log.v2('Parsing MP4 box', name);\n\n    switch (size) {\n      case 0:\n        size = reader.getLength() - start;\n        break;\n      case 1:\n        if (stopOnPartial && reader.getPosition() + 8 > reader.getLength()) {\n          this.done_ = true;\n          return;\n        }\n        size = reader.readUint64();\n        has64BitSize = true;\n        break;\n    }\n\n    const boxDefinition = this.boxDefinitions_[type];\n\n    if (boxDefinition) {\n      let version = null;\n      let flags = null;\n\n      if (this.headers_[type] == shaka.util.Mp4Parser.BoxType_.FULL_BOX) {\n        if (stopOnPartial && reader.getPosition() + 4 > reader.getLength()) {\n          this.done_ = true;\n          return;\n        }\n        const versionAndFlags = reader.readUint32();\n        version = versionAndFlags >>> 24;\n        flags = versionAndFlags & 0xFFFFFF;\n      }\n\n      // Read the whole payload so that the current level can be safely read\n      // regardless of how the payload is parsed.\n      let end = start + size;\n      if (partialOkay && end > reader.getLength()) {\n        // For partial reads, truncate the payload if we must.\n        end = reader.getLength();\n      }\n\n      if (stopOnPartial && end > reader.getLength()) {\n        this.done_ = true;\n        return;\n      }\n      const payloadSize = end - reader.getPosition();\n      const payload =\n      (payloadSize > 0) ? reader.readBytes(payloadSize) : new Uint8Array(0);\n\n      const payloadReader = new shaka.util.DataViewReader(\n          payload, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n      /** @type {shaka.extern.ParsedBox} */\n      const box = {\n        parser: this,\n        partialOkay: partialOkay || false,\n        version,\n        flags,\n        reader: payloadReader,\n        size,\n        start: start + absStart,\n        has64BitSize,\n      };\n\n      boxDefinition(box);\n    } else {\n      // Move the read head to be at the end of the box.\n      // If the box is longer than the remaining parts of the file, e.g. the\n      // mp4 is improperly formatted, or this was a partial range request that\n      // ended in the middle of a box, just skip to the end.\n      const skipLength = Math.min(\n          start + size - reader.getPosition(),\n          reader.getLength() - reader.getPosition());\n      reader.skip(skipLength);\n    }\n  }\n\n\n  /**\n   * A callback that tells the Mp4 parser to treat the body of a box as a series\n   * of boxes. The number of boxes is limited by the size of the parent box.\n   *\n   * @param {!shaka.extern.ParsedBox} box\n   * @export\n   */\n  static children(box) {\n    // The \"reader\" starts at the payload, so we need to add the header to the\n    // start position.  The header size varies.\n    const headerSize = shaka.util.Mp4Parser.headerSize(box);\n    while (box.reader.hasMoreData() && !box.parser.done_) {\n      box.parser.parseNext(box.start + headerSize, box.reader, box.partialOkay);\n    }\n  }\n\n\n  /**\n   * A callback that tells the Mp4 parser to treat the body of a box as a sample\n   * description. A sample description box has a fixed number of children. The\n   * number of children is represented by a 4 byte unsigned integer. Each child\n   * is a box.\n   *\n   * @param {!shaka.extern.ParsedBox} box\n   * @export\n   */\n  static sampleDescription(box) {\n    // The \"reader\" starts at the payload, so we need to add the header to the\n    // start position.  The header size varies.\n    const headerSize = shaka.util.Mp4Parser.headerSize(box);\n    const count = box.reader.readUint32();\n    for (let i = 0; i < count; i++) {\n      box.parser.parseNext(box.start + headerSize, box.reader, box.partialOkay);\n      if (box.parser.done_) {\n        break;\n      }\n    }\n  }\n\n\n  /**\n   * Create a callback that tells the Mp4 parser to treat the body of a box as a\n   * binary blob and to parse the body's contents using the provided callback.\n   *\n   * @param {function(!Uint8Array)} callback\n   * @return {!shaka.util.Mp4Parser.CallbackType}\n   * @export\n   */\n  static allData(callback) {\n    return (box) => {\n      const all = box.reader.getLength() - box.reader.getPosition();\n      callback(box.reader.readBytes(all));\n    };\n  }\n\n\n  /**\n   * Convert an ascii string name to the integer type for a box.\n   *\n   * @param {string} name The name of the box. The name must be four\n   *                      characters long.\n   * @return {number}\n   * @private\n   */\n  static typeFromString_(name) {\n    goog.asserts.assert(\n        name.length == 4,\n        'Mp4 box names must be 4 characters long');\n\n    let code = 0;\n    for (const chr of name) {\n      code = (code << 8) | chr.charCodeAt(0);\n    }\n    return code;\n  }\n\n\n  /**\n   * Convert an integer type from a box into an ascii string name.\n   * Useful for debugging.\n   *\n   * @param {number} type The type of the box, a uint32.\n   * @return {string}\n   * @export\n   */\n  static typeToString(type) {\n    const name = String.fromCharCode(\n        (type >> 24) & 0xff,\n        (type >> 16) & 0xff,\n        (type >> 8) & 0xff,\n        type & 0xff);\n    return name;\n  }\n\n  /**\n   * Find the header size of the box.\n   * Useful for modifying boxes in place or finding the exact offset of a field.\n   *\n   * @param {shaka.extern.ParsedBox} box\n   * @return {number}\n   * @export\n   */\n  static headerSize(box) {\n    const basicHeaderSize = 8;\n    const _64BitFieldSize = box.has64BitSize ? 8 : 0;\n    const versionAndFlagsSize = box.flags != null ? 4 : 0;\n    return basicHeaderSize + _64BitFieldSize + versionAndFlagsSize;\n  }\n};\n\n\n/**\n * @typedef {function(!shaka.extern.ParsedBox)}\n * @exportInterface\n */\nshaka.util.Mp4Parser.CallbackType;\n\n\n/**\n * An enum used to track the type of box so that the correct values can be\n * read from the header.\n *\n * @enum {number}\n * @private\n */\nshaka.util.Mp4Parser.BoxType_ = {\n  BASIC_BOX: 0,\n  FULL_BOX: 1,\n};\n\n\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.ContentWorkarounds');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Lazy');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @summary\n * A collection of methods to work around content issues on various platforms.\n */\nshaka.media.ContentWorkarounds = class {\n  /**\n   * Transform the init segment into a new init segment buffer that indicates\n   * encryption.  If the init segment already indicates encryption, return the\n   * original init segment.\n   *\n   * Should only be called for MP4 init segments, and only on platforms that\n   * need this workaround.\n   *\n   * @param {!BufferSource} initSegmentBuffer\n   * @return {!Uint8Array}\n   * @see https://github.com/shaka-project/shaka-player/issues/2759\n   */\n  static fakeEncryption(initSegmentBuffer) {\n    const ContentWorkarounds = shaka.media.ContentWorkarounds;\n    let initSegment = shaka.util.BufferUtils.toUint8(initSegmentBuffer);\n    let isEncrypted = false;\n    /** @type {shaka.extern.ParsedBox} */\n    let stsdBox;\n    const ancestorBoxes = [];\n\n    const onSimpleAncestorBox = (box) => {\n      ancestorBoxes.push(box);\n      shaka.util.Mp4Parser.children(box);\n    };\n\n    const onEncryptionMetadataBox = (box) => {\n      isEncrypted = true;\n    };\n\n    // Multiplexed content could have multiple boxes that we need to modify.\n    // Add to this array in order of box offset.  This will be important later,\n    // when we process the boxes.\n    /** @type {!Array.<{box: shaka.extern.ParsedBox, newType: number}>} */\n    const boxesToModify = [];\n\n    new shaka.util.Mp4Parser()\n        .box('moov', onSimpleAncestorBox)\n        .box('trak', onSimpleAncestorBox)\n        .box('mdia', onSimpleAncestorBox)\n        .box('minf', onSimpleAncestorBox)\n        .box('stbl', onSimpleAncestorBox)\n        .fullBox('stsd', (box) => {\n          stsdBox = box;\n          ancestorBoxes.push(box);\n          shaka.util.Mp4Parser.sampleDescription(box);\n        })\n        .fullBox('encv', onEncryptionMetadataBox)\n        .fullBox('enca', onEncryptionMetadataBox)\n        .fullBox('hev1', (box) => {\n          boxesToModify.push({\n            box,\n            newType: ContentWorkarounds.BOX_TYPE_ENCV_,\n          });\n        })\n        .fullBox('hvc1', (box) => {\n          boxesToModify.push({\n            box,\n            newType: ContentWorkarounds.BOX_TYPE_ENCV_,\n          });\n        })\n        .fullBox('avc1', (box) => {\n          boxesToModify.push({\n            box,\n            newType: ContentWorkarounds.BOX_TYPE_ENCV_,\n          });\n        })\n        .fullBox('avc3', (box) => {\n          boxesToModify.push({\n            box,\n            newType: ContentWorkarounds.BOX_TYPE_ENCV_,\n          });\n        })\n        .fullBox('ac-3', (box) => {\n          boxesToModify.push({\n            box,\n            newType: ContentWorkarounds.BOX_TYPE_ENCA_,\n          });\n        })\n        .fullBox('ec-3', (box) => {\n          boxesToModify.push({\n            box,\n            newType: ContentWorkarounds.BOX_TYPE_ENCA_,\n          });\n        })\n        .fullBox('mp4a', (box) => {\n          boxesToModify.push({\n            box,\n            newType: ContentWorkarounds.BOX_TYPE_ENCA_,\n          });\n        }).parse(initSegment);\n\n    if (isEncrypted) {\n      shaka.log.debug('Init segment already indicates encryption.');\n      return initSegment;\n    }\n\n    if (boxesToModify.length == 0 || !stsdBox) {\n      shaka.log.error('Failed to find boxes needed to fake encryption!');\n      shaka.log.v2('Failed init segment (hex):',\n          shaka.util.Uint8ArrayUtils.toHex(initSegment));\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.CONTENT_TRANSFORMATION_FAILED);\n    }\n\n    // Modify boxes in order from largest offset to smallest, so that earlier\n    // boxes don't have their offsets changed before we process them.\n    boxesToModify.reverse();  // in place!\n    for (const workItem of boxesToModify) {\n      const insertedBoxType =\n          shaka.util.Mp4Parser.typeToString(workItem.newType);\n      shaka.log.debug(`Inserting \"${insertedBoxType}\" box into init segment.`);\n      initSegment = ContentWorkarounds.insertEncryptionMetadata_(\n          initSegment, stsdBox, workItem.box, ancestorBoxes, workItem.newType);\n    }\n\n    return initSegment;\n  }\n\n  /**\n   * Insert an encryption metadata box (\"encv\" or \"enca\" box) into the MP4 init\n   * segment, based on the source box (\"mp4a\", \"avc1\", etc).  Returns a new\n   * buffer containing the modified init segment.\n   *\n   * @param {!Uint8Array} initSegment\n   * @param {shaka.extern.ParsedBox} stsdBox\n   * @param {shaka.extern.ParsedBox} sourceBox\n   * @param {!Array.<shaka.extern.ParsedBox>} ancestorBoxes\n   * @param {number} metadataBoxType\n   * @return {!Uint8Array}\n   * @private\n   */\n  static insertEncryptionMetadata_(\n      initSegment, stsdBox, sourceBox, ancestorBoxes, metadataBoxType) {\n    const ContentWorkarounds = shaka.media.ContentWorkarounds;\n    const metadataBoxArray = ContentWorkarounds.createEncryptionMetadata_(\n        initSegment, sourceBox, metadataBoxType);\n\n    // Construct a new init segment array with room for the encryption metadata\n    // box we're adding.\n    const newInitSegment =\n        new Uint8Array(initSegment.byteLength + metadataBoxArray.byteLength);\n\n    // For Xbox One, we cut and insert at the start of the source box.  For\n    // other platforms, we cut and insert at the end of the source box.  It's\n    // not clear why this is necessary on Xbox One, but it seems to be evidence\n    // of another bug in the firmware implementation of MediaSource & EME.\n    const cutPoint = shaka.util.Platform.isXboxOne() ?\n        sourceBox.start :\n        sourceBox.start + sourceBox.size;\n\n    // The data before the cut point will be copied to the same location as\n    // before.  The data after that will be appended after the added metadata\n    // box.\n    const beforeData = initSegment.subarray(0, cutPoint);\n    const afterData = initSegment.subarray(cutPoint);\n\n    newInitSegment.set(beforeData);\n    newInitSegment.set(metadataBoxArray, cutPoint);\n    newInitSegment.set(afterData, cutPoint + metadataBoxArray.byteLength);\n\n    // The parents up the chain from the encryption metadata box need their\n    // sizes adjusted to account for the added box.  These offsets should not be\n    // changed, because they should all be within the first section we copy.\n    for (const box of ancestorBoxes) {\n      goog.asserts.assert(box.start < cutPoint,\n          'Ancestor MP4 box found in the wrong location!  ' +\n          'Modified init segment will not make sense!');\n      ContentWorkarounds.updateBoxSize_(\n          newInitSegment, box.start, box.size + metadataBoxArray.byteLength);\n    }\n\n    // Add one to the sample entries field of the \"stsd\" box.  This is a 4-byte\n    // field just past the box header.\n    const stsdBoxView = shaka.util.BufferUtils.toDataView(\n        newInitSegment, stsdBox.start);\n    const stsdBoxHeaderSize = shaka.util.Mp4Parser.headerSize(stsdBox);\n    const numEntries = stsdBoxView.getUint32(stsdBoxHeaderSize);\n    stsdBoxView.setUint32(stsdBoxHeaderSize, numEntries + 1);\n\n    return newInitSegment;\n  }\n\n  /**\n   * Create an encryption metadata box (\"encv\" or \"enca\" box), based on the\n   * source box (\"mp4a\", \"avc1\", etc).  Returns a new buffer containing the\n   * encryption metadata box.\n   *\n   * @param {!Uint8Array} initSegment\n   * @param {shaka.extern.ParsedBox} sourceBox\n   * @param {number} metadataBoxType\n   * @return {!Uint8Array}\n   * @private\n   */\n  static createEncryptionMetadata_(initSegment, sourceBox, metadataBoxType) {\n    const ContentWorkarounds = shaka.media.ContentWorkarounds;\n    const sinfBoxArray = ContentWorkarounds.CANNED_SINF_BOX_.value();\n\n    // Create a subarray which points to the source box data.\n    const sourceBoxArray = initSegment.subarray(\n        /* start= */ sourceBox.start,\n        /* end= */ sourceBox.start + sourceBox.size);\n\n    // Create a view on the source box array.\n    const sourceBoxView = shaka.util.BufferUtils.toDataView(sourceBoxArray);\n\n    // Create an array to hold the new encryption metadata box, which is based\n    // on the source box.\n    const metadataBoxArray = new Uint8Array(\n        sourceBox.size + sinfBoxArray.byteLength);\n\n    // Copy the source box into the new array.\n    metadataBoxArray.set(sourceBoxArray, /* targetOffset= */ 0);\n\n    // Change the box type.\n    const metadataBoxView = shaka.util.BufferUtils.toDataView(metadataBoxArray);\n    metadataBoxView.setUint32(\n        ContentWorkarounds.BOX_TYPE_OFFSET_, metadataBoxType);\n\n    // Append the \"sinf\" box to the encryption metadata box.\n    metadataBoxArray.set(sinfBoxArray, /* targetOffset= */ sourceBox.size);\n\n    // Update the \"sinf\" box's format field (in the child \"frma\" box) to reflect\n    // the format of the original source box.\n    const sourceBoxType = sourceBoxView.getUint32(\n        ContentWorkarounds.BOX_TYPE_OFFSET_);\n    metadataBoxView.setUint32(\n        sourceBox.size + ContentWorkarounds.CANNED_SINF_BOX_FORMAT_OFFSET_,\n        sourceBoxType);\n\n    // Now update the encryption metadata box size.\n    ContentWorkarounds.updateBoxSize_(\n        metadataBoxArray, /* boxStart= */ 0, metadataBoxArray.byteLength);\n\n    return metadataBoxArray;\n  }\n\n  /**\n   * Modify an MP4 box's size field in-place.\n   *\n   * @param {!Uint8Array} dataArray\n   * @param {number} boxStart The start position of the box in dataArray.\n   * @param {number} newBoxSize The new size of the box.\n   * @private\n   */\n  static updateBoxSize_(dataArray, boxStart, newBoxSize) {\n    const ContentWorkarounds = shaka.media.ContentWorkarounds;\n    const boxView = shaka.util.BufferUtils.toDataView(dataArray, boxStart);\n    const sizeField = boxView.getUint32(ContentWorkarounds.BOX_SIZE_OFFSET_);\n    if (sizeField == 0) { // Means \"the rest of the box\".\n      // No adjustment needed for this box.\n    } else if (sizeField == 1) { // Means \"use 64-bit size box\".\n      // Set the 64-bit int in two 32-bit parts.\n      // The high bits should definitely be 0 in practice, but we're being\n      // thorough here.\n      boxView.setUint32(ContentWorkarounds.BOX_SIZE_64_OFFSET_,\n          newBoxSize >> 32);\n      boxView.setUint32(ContentWorkarounds.BOX_SIZE_64_OFFSET_ + 4,\n          newBoxSize & 0xffffffff);\n    } else { // Normal 32-bit size field.\n      // Not checking the size of the value here, since a box larger than 4GB is\n      // unrealistic.\n      boxView.setUint32(ContentWorkarounds.BOX_SIZE_OFFSET_, newBoxSize);\n    }\n  }\n};\n\n/**\n * A canned \"sinf\" box for use when adding fake encryption metadata to init\n * segments.\n *\n * @const {!shaka.util.Lazy.<!Uint8Array>}\n * @private\n * @see https://github.com/shaka-project/shaka-player/issues/2759\n */\nshaka.media.ContentWorkarounds.CANNED_SINF_BOX_ =\n    new shaka.util.Lazy(() => new Uint8Array([\n      // sinf box\n      // Size: 0x50 = 80\n      0x00, 0x00, 0x00, 0x50,\n\n      // Type: sinf\n      0x73, 0x69, 0x6e, 0x66,\n\n      // Children of sinf...\n\n      // frma box\n      // Size: 0x0c = 12\n      0x00, 0x00, 0x00, 0x0c,\n\n      // Type: frma (child of sinf)\n      0x66, 0x72, 0x6d, 0x61,\n\n      // Format: filled in later based on the source box (\"avc1\", \"mp4a\", etc)\n      0x00, 0x00, 0x00, 0x00,\n      // end of frma box\n\n      // schm box\n      // Size: 0x14 = 20\n      0x00, 0x00, 0x00, 0x14,\n\n      // Type: schm (child of sinf)\n      0x73, 0x63, 0x68, 0x6d,\n\n      // Version: 0, Flags: 0\n      0x00, 0x00, 0x00, 0x00,\n\n      // Scheme: cenc\n      0x63, 0x65, 0x6e, 0x63,\n\n      // Scheme version: 1.0\n      0x00, 0x01, 0x00, 0x00,\n      // end of schm box\n\n      // schi box\n      // Size: 0x28 = 40\n      0x00, 0x00, 0x00, 0x28,\n\n      // Type: schi (child of sinf)\n      0x73, 0x63, 0x68, 0x69,\n\n      // Children of schi...\n\n      // tenc box\n      // Size: 0x20 = 32\n      0x00, 0x00, 0x00, 0x20,\n\n      // Type: tenc (child of schi)\n      0x74, 0x65, 0x6e, 0x63,\n\n      // Version: 0, Flags: 0\n      0x00, 0x00, 0x00, 0x00,\n\n      // Reserved fields\n      0x00, 0x00,\n\n      // Default protected: true\n      0x01,\n\n      // Default per-sample IV size: 8\n      0x08,\n\n      // Default key ID: all zeros (dummy)\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // end of tenc box\n\n      // end of schi box\n\n      // end of sinf box\n    ]));\n\n/**\n * The location of the format field in the \"frma\" box inside the canned \"sinf\"\n * box above.\n *\n * @const {number}\n * @private\n */\nshaka.media.ContentWorkarounds.CANNED_SINF_BOX_FORMAT_OFFSET_ = 0x10;\n\n/**\n * Offset to a box's size field.\n *\n * @const {number}\n * @private\n */\nshaka.media.ContentWorkarounds.BOX_SIZE_OFFSET_ = 0;\n\n/**\n * Offset to a box's type field.\n *\n * @const {number}\n * @private\n */\nshaka.media.ContentWorkarounds.BOX_TYPE_OFFSET_ = 4;\n\n/**\n * Offset to a box's 64-bit size field, if it has one.\n *\n * @const {number}\n * @private\n */\nshaka.media.ContentWorkarounds.BOX_SIZE_64_OFFSET_ = 8;\n\n/**\n * Box type for \"encv\".\n *\n * @const {number}\n * @private\n */\nshaka.media.ContentWorkarounds.BOX_TYPE_ENCV_ = 0x656e6376;\n\n/**\n * Box type for \"enca\".\n *\n * @const {number}\n * @private\n */\nshaka.media.ContentWorkarounds.BOX_TYPE_ENCA_ = 0x656e6361;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.CeaUtils');\ngoog.provide('shaka.cea.CeaUtils.StyledChar');\n\ngoog.require('shaka.cea.ICaptionDecoder');\ngoog.require('shaka.text.Cue');\n\n\nshaka.cea.CeaUtils = class {\n  /**\n   * Emits a closed caption based on the state of the buffer.\n   * @param {!shaka.text.Cue} topLevelCue\n   * @param {string} stream\n   * @param {!Array<!Array<?shaka.cea.CeaUtils.StyledChar>>} memory\n   * @param {number} startTime Start time of the cue.\n   * @param {number} endTime End time of the cue.\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   */\n  static getParsedCaption(topLevelCue, stream, memory, startTime, endTime) {\n    if (startTime >= endTime) {\n      return null;\n    }\n\n    // Find the first and last row that contains characters.\n    let firstNonEmptyRow = -1;\n    let lastNonEmptyRow = -1;\n\n    for (let i = 0; i < memory.length; i++) {\n      if (memory[i].some((e) => e != null && e.getChar().trim() != '')) {\n        firstNonEmptyRow = i;\n        break;\n      }\n    }\n\n    for (let i = memory.length - 1; i >= 0; i--) {\n      if (memory[i].some((e) => e != null && e.getChar().trim() != '')) {\n        lastNonEmptyRow = i;\n        break;\n      }\n    }\n\n    // Exit early if no non-empty row was found.\n    if (firstNonEmptyRow === -1 || lastNonEmptyRow === -1) {\n      return null;\n    }\n\n    // Keeps track of the current styles for a cue being emitted.\n    let currentUnderline = false;\n    let currentItalics = false;\n    let currentTextColor = shaka.cea.CeaUtils.DEFAULT_TXT_COLOR;\n    let currentBackgroundColor = shaka.cea.CeaUtils.DEFAULT_BG_COLOR;\n\n    // Create first cue that will be nested in top level cue. Default styles.\n    let currentCue = shaka.cea.CeaUtils.createStyledCue(\n        startTime, endTime, currentUnderline, currentItalics,\n        currentTextColor, currentBackgroundColor);\n\n    // Logic: Reduce rows into a single top level cue containing nested cues.\n    // Each nested cue corresponds either a style change or a line break.\n\n    for (let i = firstNonEmptyRow; i <= lastNonEmptyRow; i++) {\n      // Find the first and last non-empty characters in this row. We do this so\n      // no styles creep in before/after the first and last non-empty chars.\n      const row = memory[i];\n      let firstNonEmptyCol = -1;\n      let lastNonEmptyCol = -1;\n\n      for (let j = 0; j < row.length; j++) {\n        if (row[j] != null && row[j].getChar().trim() !== '') {\n          firstNonEmptyCol = j;\n          break;\n        }\n      }\n\n      for (let j = row.length - 1; j >= 0; j--) {\n        if (row[j] != null && row[j].getChar().trim() !== '') {\n          lastNonEmptyCol = j;\n          break;\n        }\n      }\n\n      // If no non-empty char. was found in this row, it must be a linebreak.\n      if (firstNonEmptyCol === -1 || lastNonEmptyCol === -1) {\n        const linebreakCue = shaka.cea.CeaUtils\n            .createLineBreakCue(startTime, endTime);\n        topLevelCue.nestedCues.push(linebreakCue);\n        continue;\n      }\n\n      for (let j = firstNonEmptyCol; j <= lastNonEmptyCol; j++) {\n        const styledChar = row[j];\n\n        // A null between non-empty cells in a row is handled as a space.\n        if (!styledChar) {\n          currentCue.payload += ' ';\n          continue;\n        }\n        const underline = styledChar.isUnderlined();\n        const italics = styledChar.isItalicized();\n        const textColor = styledChar.getTextColor();\n        const backgroundColor = styledChar.getBackgroundColor();\n\n        // If any style properties have changed, we need to open a new cue.\n        if (underline != currentUnderline || italics != currentItalics ||\n            textColor != currentTextColor ||\n            backgroundColor != currentBackgroundColor) {\n          // Push the currently built cue and start a new cue, with new styles.\n          if (currentCue.payload) {\n            topLevelCue.nestedCues.push(currentCue);\n          }\n          currentCue = shaka.cea.CeaUtils.createStyledCue(\n              startTime, endTime, underline,\n              italics, textColor, backgroundColor);\n\n          currentUnderline = underline;\n          currentItalics = italics;\n          currentTextColor = textColor;\n          currentBackgroundColor = backgroundColor;\n        }\n\n        currentCue.payload += styledChar.getChar();\n      }\n      if (currentCue.payload) {\n        topLevelCue.nestedCues.push(currentCue);\n      }\n\n      // Add a linebreak since the row just ended.\n      if (i !== lastNonEmptyRow) {\n        const linebreakCue = shaka.cea.CeaUtils\n            .createLineBreakCue(startTime, endTime);\n        topLevelCue.nestedCues.push(linebreakCue);\n      }\n\n      // Create a new cue.\n      currentCue = shaka.cea.CeaUtils.createStyledCue(\n          startTime, endTime, currentUnderline, currentItalics,\n          currentTextColor, currentBackgroundColor);\n    }\n\n    if (topLevelCue.nestedCues.length) {\n      return {\n        cue: topLevelCue,\n        stream,\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {number} startTime\n   * @param {number} endTime\n   * @param {boolean} underline\n   * @param {boolean} italics\n   * @param {string} txtColor\n   * @param {string} bgColor\n   * @return {!shaka.text.Cue}\n   */\n  static createStyledCue(startTime, endTime, underline,\n      italics, txtColor, bgColor) {\n    const cue = new shaka.text.Cue(startTime, endTime, /* payload= */ '');\n    if (underline) {\n      cue.textDecoration.push(shaka.text.Cue.textDecoration.UNDERLINE);\n    }\n    if (italics) {\n      cue.fontStyle = shaka.text.Cue.fontStyle.ITALIC;\n    }\n    cue.color = txtColor;\n    cue.backgroundColor = bgColor;\n    return cue;\n  }\n\n  /**\n   * @param {number} startTime\n   * @param {number} endTime\n   * @return {!shaka.text.Cue}\n   */\n  static createLineBreakCue(startTime, endTime) {\n    const linebreakCue = new shaka.text.Cue(\n        startTime, endTime, /* payload= */ '');\n    linebreakCue.lineBreak = true;\n    return linebreakCue;\n  }\n};\n\nshaka.cea.CeaUtils.StyledChar = class {\n  /**\n   * @param {string} character\n   * @param {boolean} underline\n   * @param {boolean} italics\n   * @param {string} backgroundColor\n   * @param {string} textColor\n   */\n  constructor(character, underline, italics, backgroundColor, textColor) {\n    /**\n     * @private {string}\n     */\n    this.character_ = character;\n\n    /**\n     * @private {boolean}\n     */\n    this.underline_ = underline;\n\n    /**\n     * @private {boolean}\n     */\n    this.italics_ = italics;\n\n    /**\n     * @private {string}\n     */\n    this.backgroundColor_ = backgroundColor;\n\n    /**\n     * @private {string}\n     */\n    this.textColor_ = textColor;\n  }\n\n  /**\n   * @return {string}\n   */\n  getChar() {\n    return this.character_;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isUnderlined() {\n    return this.underline_;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isItalicized() {\n    return this.italics_;\n  }\n\n  /**\n   * @return {string}\n   */\n  getBackgroundColor() {\n    return this.backgroundColor_;\n  }\n\n  /**\n   * @return {string}\n   */\n  getTextColor() {\n    return this.textColor_;\n  }\n};\n\n/**\n * Default background color for text.\n * @const {string}\n */\nshaka.cea.CeaUtils.DEFAULT_BG_COLOR = 'black';\n\n/**\n * Default text color.\n * @const {string}\n */\nshaka.cea.CeaUtils.DEFAULT_TXT_COLOR = 'white';\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.Cea608Memory');\n\ngoog.require('shaka.cea.CeaUtils');\ngoog.require('shaka.text.Cue');\ngoog.requireType('shaka.cea.ICaptionDecoder');\n\n\n/**\n * CEA-608 captions memory/buffer.\n */\nshaka.cea.Cea608Memory = class {\n  /**\n   * @param {number} fieldNum Field number.\n   * @param {number} channelNum Channel number.\n   */\n  constructor(fieldNum, channelNum) {\n    /**\n     * Buffer for storing decoded characters.\n     * @private @const {!Array<!Array<!shaka.cea.CeaUtils.StyledChar>>}\n     */\n    this.rows_ = [];\n\n    /**\n     * Current row.\n     * @private {number}\n     */\n    this.row_ = 1;\n\n    /**\n     * Number of rows in the scroll window. Used for rollup mode.\n     * @private {number}\n     */\n    this.scrollRows_ = 0;\n\n    /**\n     * Field number.\n     * @private {number}\n     */\n    this.fieldNum_ = fieldNum;\n\n    /**\n     * Channel number.\n     * @private {number}\n     */\n    this.channelNum_ = channelNum;\n\n    /**\n     * @private {boolean}\n     */\n    this.underline_ = false;\n\n    /**\n     * @private {boolean}\n     */\n    this.italics_ = false;\n\n    /**\n     * @private {string}\n     */\n    this.textColor_ = shaka.cea.CeaUtils.DEFAULT_TXT_COLOR;\n\n    /**\n     * @private {string}\n     */\n    this.backgroundColor_ = shaka.cea.CeaUtils.DEFAULT_BG_COLOR;\n\n    this.reset();\n  }\n\n  /**\n   * Emits a closed caption based on the state of the buffer.\n   * @param {number} startTime Start time of the cue.\n   * @param {number} endTime End time of the cue.\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   */\n  forceEmit(startTime, endTime) {\n    const stream = `CC${(this.fieldNum_<< 1) | this.channelNum_ +1}`;\n    const topLevelCue = new shaka.text.Cue(\n        startTime, endTime, /* payload= */ '');\n    return shaka.cea.CeaUtils.getParsedCaption(\n        topLevelCue, stream, this.rows_, startTime, endTime);\n  }\n\n  /**\n   * Resets the memory buffer.\n   */\n  reset() {\n    this.resetAllRows();\n    this.row_ = 1;\n  }\n\n  /**\n   * @return {number}\n   */\n  getRow() {\n    return this.row_;\n  }\n\n  /**\n   * @param {number} row\n   */\n  setRow(row) {\n    this.row_ = row;\n  }\n\n  /**\n   * @return {number}\n   */\n  getScrollSize() {\n    return this.scrollRows_;\n  }\n\n  /**\n   * @param {number} scrollRows\n   */\n  setScrollSize(scrollRows) {\n    this.scrollRows_ = scrollRows;\n  }\n\n  /**\n   * Adds a character to the buffer.\n   * @param {!shaka.cea.Cea608Memory.CharSet} set Character set.\n   * @param {number} b CC byte to add.\n   */\n  addChar(set, b) {\n    // Valid chars are in the range [0x20, 0x7f]\n    if (b < 0x20 || b > 0x7f) {\n      return;\n    }\n\n    let char = '';\n    switch (set) {\n      case shaka.cea.Cea608Memory.CharSet.BASIC_NORTH_AMERICAN:\n        if (shaka.cea.Cea608Memory.CharSet.BasicNorthAmericanChars.has(b)) {\n          char =\n                shaka.cea.Cea608Memory.CharSet.BasicNorthAmericanChars.get(b);\n        } else {\n          // Regular ASCII\n          char = String.fromCharCode(b);\n        }\n        break;\n      case shaka.cea.Cea608Memory.CharSet.SPECIAL_NORTH_AMERICAN:\n        char =\n              shaka.cea.Cea608Memory.CharSet.SpecialNorthAmericanChars.get(b);\n        break;\n      case shaka.cea.Cea608Memory.CharSet.SPANISH_FRENCH:\n        // Extended charset does a BS over preceding char, 6.4.2 EIA-608-B.\n        this.eraseChar();\n        char =\n              shaka.cea.Cea608Memory.CharSet.ExtendedSpanishFrench.get(b);\n        break;\n      case shaka.cea.Cea608Memory.CharSet.PORTUGUESE_GERMAN:\n        this.eraseChar();\n        char =\n              shaka.cea.Cea608Memory.CharSet.ExtendedPortugueseGerman.get(b);\n        break;\n    }\n\n    if (char) {\n      const styledChar = new shaka.cea.CeaUtils.StyledChar(\n          char, this.underline_, this.italics_,\n          this.backgroundColor_, this.textColor_);\n      this.rows_[this.row_].push(styledChar);\n    }\n  }\n\n  /**\n   * Erases a character from the buffer.\n   */\n  eraseChar() {\n    this.rows_[this.row_].pop();\n  }\n\n  /**\n   * Moves rows of characters.\n   * @param {number} dst Destination row index.\n   * @param {number} src Source row index.\n   * @param {number} count Count of rows to move.\n   */\n  moveRows(dst, src, count) {\n    if (src < 0 || dst < 0) {\n      return;\n    }\n\n    if (dst >= src) {\n      for (let i = count-1; i >= 0; i--) {\n        this.rows_[dst + i] = this.rows_[src + i].map((e) => e);\n      }\n    } else {\n      for (let i = 0; i < count; i++) {\n        this.rows_[dst + i] = this.rows_[src + i].map((e) => e);\n      }\n    }\n  }\n\n  /**\n   * Resets rows of characters.\n   * @param {number} idx Starting index.\n   * @param {number} count Count of rows to reset.\n   */\n  resetRows(idx, count) {\n    for (let i = 0; i <= count; i++) {\n      this.rows_[idx + i] = [];\n    }\n  }\n\n  /**\n   * Resets the entire memory buffer.\n   */\n  resetAllRows() {\n    this.resetRows(0, shaka.cea.Cea608Memory.CC_ROWS);\n  }\n\n  /**\n   * Erases entire memory buffer.\n   * Doesn't change scroll state or number of rows.\n   */\n  eraseBuffer() {\n    this.row_ = (this.scrollRows_ > 0) ? this.scrollRows_ : 0;\n    this.resetAllRows();\n  }\n\n  /**\n   * @param {boolean} underline\n   */\n  setUnderline(underline) {\n    this.underline_ = underline;\n  }\n\n  /**\n   * @param {boolean} italics\n   */\n  setItalics(italics) {\n    this.italics_ = italics;\n  }\n\n  /**\n   * @param {string} color\n   */\n  setTextColor(color) {\n    this.textColor_ = color;\n  }\n\n  /**\n   * @param {string} color\n   */\n  setBackgroundColor(color) {\n    this.backgroundColor_ = color;\n  }\n};\n\n/**\n * Maximum number of rows in the buffer.\n * @const {number}\n */\nshaka.cea.Cea608Memory.CC_ROWS = 15;\n\n/**\n * Characters sets.\n * @const @enum {number}\n */\nshaka.cea.Cea608Memory.CharSet = {\n  BASIC_NORTH_AMERICAN: 0,\n  SPECIAL_NORTH_AMERICAN: 1,\n  SPANISH_FRENCH: 2,\n  PORTUGUESE_GERMAN: 3,\n};\n\n/**\n * Basic North American char set deviates from ASCII with these exceptions.\n * @private @const {!Map<number, string>}\n */\nshaka.cea.Cea608Memory.CharSet.BasicNorthAmericanChars = new Map([\n  [0x27, '’'], [0x2a, 'á'], [0x5c, 'é'], [0x5c, 'é'], [0x5e, 'í'], [0x5f, 'ó'],\n  [0x60, 'ú'], [0x7b, 'ç'], [0x7c, '÷'], [0x7d, 'Ñ'], [0x7e, 'ñ'], [0x7f, '█'],\n]);\n\n/**\n * Special North American char set.\n * Note: Transparent Space is currently implemented as a regular space.\n * @private @const {!Map<number, string>}\n */\nshaka.cea.Cea608Memory.CharSet.SpecialNorthAmericanChars = new Map([\n  [0x30, '®'], [0x31, '°'], [0x32, '½'], [0x33, '¿'], [0x34, '™'], [0x35, '¢'],\n  [0x36, '£'], [0x37, '♪'], [0x38, 'à'], [0x39, '⠀'], [0x3a, 'è'], [0x3b, 'â'],\n  [0x3c, 'ê'], [0x3d, 'î'], [0x3e, 'ô'], [0x3f, 'û'],\n]);\n\n/**\n * Extended Spanish/Misc/French char set.\n * @private @const {!Map<number, string>}\n */\nshaka.cea.Cea608Memory.CharSet.ExtendedSpanishFrench = new Map([\n  [0x20, 'Á'], [0x21, 'É'], [0x22, 'Ó'], [0x23, 'Ú'], [0x24, 'Ü'], [0x25, 'ü'],\n  [0x26, '‘'], [0x27, '¡'], [0x28, '*'], [0x29, '\\''], [0x2a, '─'], [0x2b, '©'],\n  [0x2c, '℠'], [0x2d, '·'], [0x2e, '“'], [0x2f, '”'], [0x30, 'À'], [0x31, 'Â'],\n  [0x32, 'Ç'], [0x33, 'È'], [0x34, 'Ê'], [0x35, 'Ë'], [0x36, 'ë'], [0x37, 'Î'],\n  [0x38, 'Ï'], [0x39, 'ï'], [0x3a, 'Ô'], [0x3b, 'Ù'], [0x3c, 'ù'], [0x3d, 'Û'],\n  [0x3e, '«'], [0x3f, '»'],\n]);\n\n/**\n * Extended Portuguese/German/Danish char set.\n * @private @const {!Map<number, string>}\n */\nshaka.cea.Cea608Memory.CharSet.ExtendedPortugueseGerman = new Map([\n  [0x20, 'Ã'], [0x21, 'ã'], [0x22, 'Í'], [0x23, 'Ì'], [0x24, 'ì'], [0x25, 'Ò'],\n  [0x26, 'ò'], [0x27, 'Õ'], [0x28, 'õ'], [0x29, '{'], [0x2a, '}'], [0x2b, '\\\\'],\n  [0x2c, '^'], [0x2d, '_'], [0x2e, '|'], [0x2f, '~'], [0x30, 'Ä'], [0x31, 'ä'],\n  [0x32, 'Ö'], [0x33, 'ö'], [0x34, 'ß'], [0x35, '¥'], [0x36, '¤'], [0x37, '│'],\n  [0x38, 'Å'], [0x39, 'å'], [0x3a, 'Ø'], [0x3b, 'ø'], [0x3c, '┌'], [0x3d, '┐'],\n  [0x3e, '└'], [0x3f, '┘'],\n]);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.Cea608DataChannel');\n\ngoog.require('shaka.cea.Cea608Memory');\ngoog.require('shaka.cea.CeaUtils');\ngoog.require('shaka.log');\ngoog.requireType('shaka.cea.ICaptionDecoder');\n\n\n/**\n * 608 closed captions channel.\n */\nshaka.cea.Cea608DataChannel = class {\n  /**\n   * @param {number} fieldNum Field number.\n   * @param {number} channelNum Channel number.\n   */\n  constructor(fieldNum, channelNum) {\n    /**\n     * Current Caption Type.\n     * @public {!shaka.cea.Cea608DataChannel.CaptionType}\n     */\n    this.type_ = shaka.cea.Cea608DataChannel.CaptionType.NONE;\n\n    /**\n     * Text buffer for CEA-608 \"text mode\". Although, we don't emit text mode.\n     * So, this buffer serves as a no-op placeholder, just in case we receive\n     * captions that toggle text mode.\n     * @private @const {!shaka.cea.Cea608Memory}\n     */\n    this.text_ =\n        new shaka.cea.Cea608Memory(fieldNum, channelNum);\n\n    /**\n     * Displayed memory.\n     * @private {!shaka.cea.Cea608Memory}\n     */\n    this.displayedMemory_ =\n        new shaka.cea.Cea608Memory(fieldNum, channelNum);\n\n    /**\n     * Non-displayed memory.\n     * @private {!shaka.cea.Cea608Memory}\n     */\n    this.nonDisplayedMemory_ =\n        new shaka.cea.Cea608Memory(fieldNum, channelNum);\n\n    /**\n     * Points to current buffer.\n     * @private {!shaka.cea.Cea608Memory}\n     */\n    this.curbuf_ = this.displayedMemory_;\n\n    /**\n     * End time of the previous caption, serves as start time of next caption.\n     * @private {number}\n     */\n    this.prevEndTime_ = 0;\n\n    /**\n     * Last control pair, 16 bits representing byte 1 and byte 2\n     * @private {?number}\n     */\n    this.lastcp_ = null;\n  }\n\n  /**\n   * Resets channel state.\n   */\n  reset() {\n    this.type_ = shaka.cea.Cea608DataChannel.CaptionType.PAINTON;\n    this.curbuf_ = this.displayedMemory_;\n    this.lastcp_ = null;\n    this.displayedMemory_.reset();\n    this.nonDisplayedMemory_.reset();\n    this.text_.reset();\n  }\n\n  /**\n   * Gets the row index from a Preamble Address Code byte pair.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @return {number} Row index.\n   * @private\n   */\n  pacToRow_(b1, b2) {\n    const ccrowtab = [\n      11, 11,  // 0x00 or 0x01\n      1, 2,    // 0x02 -> 0x03\n      3, 4,    // 0x04 -> 0x05\n      12, 13,  // 0x06 -> 0x07\n      14, 15,  // 0x08 -> 0x09\n      5, 6,    // 0x0A -> 0x0B\n      7, 8,    // 0x0C -> 0x0D\n      9, 10,   // 0x0E -> 0x0F\n    ];\n    return ccrowtab[((b1 & 0x07) << 1) | ((b2 >> 5) & 0x01)];\n  }\n\n  /**\n   * PAC - Preamble Address Code.\n   * b1 is of the form |P|0|0|1|C|0|ROW|\n   * b2 is of the form |P|1|N|ATTRIBUTE|U|\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @private\n   */\n  controlPac_(b1, b2) {\n    const row = this.pacToRow_(b1, b2);\n\n    // Get attribute bits (4 bits)\n    const attr = (b2 & 0x1E) >> 1;\n\n    // Set up the defaults.\n    let textColor = shaka.cea.CeaUtils.DEFAULT_TXT_COLOR;\n    let italics = false;\n\n\n    // Attributes < 7 are colors, = 7 is white w/ italics, and >7 are indents\n    if (attr < 7) {\n      textColor = shaka.cea.Cea608DataChannel.TEXT_COLORS[attr];\n    } else if (attr === 7) {\n      italics = true; // color stays white\n    }\n\n    // PACs toggle underline on the last bit of b2.\n    const underline = (b2 & 0x01) === 0x01;\n\n    if (this.type_ === shaka.cea.Cea608DataChannel.CaptionType.TEXT) {\n      // Don't execute the PAC if in text mode.\n      return;\n    }\n\n    // Execute the PAC.\n    const buf = this.curbuf_;\n\n    // Move entire scroll window to a new base in rollup mode.\n    if (this.type_ === shaka.cea.Cea608DataChannel.CaptionType.ROLLUP &&\n        row !== buf.getRow()) {\n      const oldTopRow = 1 + buf.getRow() - buf.getScrollSize();\n      const newTopRow = 1 + row - buf.getScrollSize();\n\n      // Shift up the scroll window.\n      buf.moveRows(newTopRow, oldTopRow, buf.getScrollSize());\n\n      // Clear everything outside of the new scroll window.\n      buf.resetRows(0, newTopRow - 1);\n      buf.resetRows(row + 1,\n          shaka.cea.Cea608Memory.CC_ROWS - row);\n    }\n    buf.setRow(row);\n\n    this.curbuf_.setUnderline(underline);\n    this.curbuf_.setItalics(italics);\n    this.curbuf_.setTextColor(textColor);\n\n    // Clear the background color, since new row (PAC) should reset ALL styles.\n    this.curbuf_.setBackgroundColor(shaka.cea.CeaUtils.DEFAULT_BG_COLOR);\n  }\n\n  /**\n   * Mid-Row control code handler.\n   * @param {number} b2 Byte #2.\n   * @private\n   */\n  controlMidrow_(b2) {\n    // Clear all pre-existing midrow style attributes.\n    this.curbuf_.setUnderline(false);\n    this.curbuf_.setItalics(false);\n    this.curbuf_.setTextColor(shaka.cea.CeaUtils.DEFAULT_TXT_COLOR);\n\n    // Mid-row attrs use a space.\n    this.curbuf_.addChar(\n        shaka.cea.Cea608Memory.CharSet.BASIC_NORTH_AMERICAN, ' '.charCodeAt(0));\n\n    let textColor = shaka.cea.CeaUtils.DEFAULT_TXT_COLOR;\n    let italics = false;\n\n    // Midrow codes set underline on last (LSB) bit.\n    const underline = (b2 & 0x01) === 0x01;\n\n    // b2 has the form |P|0|1|0|STYLE|U|\n    textColor = shaka.cea.Cea608DataChannel.TEXT_COLORS[(b2 & 0xe) >> 1];\n    if (textColor === 'white_italics') {\n      textColor = 'white';\n      italics = true;\n    }\n\n    this.curbuf_.setUnderline(underline);\n    this.curbuf_.setItalics(italics);\n    this.curbuf_.setTextColor(textColor);\n  }\n\n  /**\n   * Background attribute control code handler.\n   * @param {number} b1 Byte #1\n   * @param {number} b2 Byte #2.\n   * @private\n   */\n  controlBackgroundAttribute_(b1, b2) {\n    let backgroundColor = shaka.cea.CeaUtils.DEFAULT_BG_COLOR;\n    if ((b1 & 0x07) === 0x0) {\n      // If background provided, last 3 bits of b1 are |0|0|0|. Color is in b2.\n      backgroundColor = shaka.cea.Cea608DataChannel.BG_COLORS[(b2 & 0xe) >> 1];\n    }\n    this.curbuf_.setBackgroundColor(backgroundColor);\n  }\n\n  /**\n   * The Cea608DataChannel control methods implement all CC control operations.\n   * @param {!shaka.cea.Cea608DataChannel.Cea608Packet} ccPacket\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  controlMiscellaneous_(ccPacket) {\n    const MiscCmd = shaka.cea.Cea608DataChannel.MiscCmd_;\n    const b2 = ccPacket.ccData2;\n    const pts = ccPacket.pts;\n    let parsedClosedCaption = null;\n\n    switch (b2) {\n      case MiscCmd.RCL:\n        this.controlRcl_();\n        break;\n      case MiscCmd.BS:\n        this.controlBs_();\n        break;\n        // unused (alarm off and alarm on)\n      case MiscCmd.AOD:\n      case MiscCmd.AON:\n        break;\n      case MiscCmd.DER:\n        // Delete to End of Row. Not implemented since position not supported.\n        break;\n      case MiscCmd.RU2:\n        parsedClosedCaption = this.controlRu_(2, pts);\n        break;\n      case MiscCmd.RU3:\n        parsedClosedCaption = this.controlRu_(3, pts);\n        break;\n      case MiscCmd.RU4:\n        parsedClosedCaption = this.controlRu_(4, pts);\n        break;\n      case MiscCmd.FON:\n        this.controlFon_();\n        break;\n      case MiscCmd.RDC:\n        this.controlRdc_(pts);\n        break;\n      case MiscCmd.TR:\n        this.controlTr_();\n        break;\n      case MiscCmd.RTD:\n        this.controlRtd_();\n        break;\n      case MiscCmd.EDM:\n        parsedClosedCaption = this.controlEdm_(pts);\n        break;\n      case MiscCmd.CR:\n        parsedClosedCaption = this.controlCr_(pts);\n        break;\n      case MiscCmd.ENM:\n        this.controlEnm_();\n        break;\n      case MiscCmd.EOC:\n        parsedClosedCaption = this.controlEoc_(pts);\n        break;\n    }\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Handles CR - Carriage Return (Start new row).\n   * CR only affects scroll windows (Rollup and Text modes).\n   * Any currently buffered line needs to be emitted, along\n   * with a window scroll action.\n   * @param {number} pts in seconds.\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  controlCr_(pts) {\n    const buf = this.curbuf_;\n    // Only rollup and text mode is affected, but we don't emit text mode.\n    if (this.type_ !== shaka.cea.Cea608DataChannel.CaptionType.ROLLUP) {\n      return null;\n    }\n    // Force out the scroll window since the top row will cleared.\n    const parsedClosedCaption = buf.forceEmit(this.prevEndTime_, pts);\n\n    // Calculate the top of the scroll window.\n    const toprow = (buf.getRow() - buf.getScrollSize()) + 1;\n\n    // Shift up the window one row higher.\n    buf.moveRows(toprow - 1, toprow, buf.getScrollSize());\n\n    // Clear out anything that's outside of our current scroll window.\n    buf.resetRows(0, toprow - 1);\n    buf.resetRows(buf.getRow(), shaka.cea.Cea608Memory.CC_ROWS - buf.getRow());\n\n    // Update the end time so the next caption emits starting at this time.\n    this.prevEndTime_ = pts;\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Handles RU2, RU3, RU4 - Roll-Up, N rows.\n   * If in TEXT, POPON or PAINTON, any displayed captions are erased.\n   *    This means must force emit entire display buffer.\n   * @param {number} scrollSize New scroll window size.\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  controlRu_(scrollSize, pts) {\n    this.curbuf_ = this.displayedMemory_;  // Point to displayed memory\n    const buf = this.curbuf_;\n    let parsedClosedCaption = null;\n\n    // For any type except rollup and text mode, it should be emitted,\n    // and memories cleared.\n    if (this.type_ !== shaka.cea.Cea608DataChannel.CaptionType.ROLLUP &&\n        this.type_ !== shaka.cea.Cea608DataChannel.CaptionType.TEXT) {\n      parsedClosedCaption = buf.forceEmit(this.prevEndTime_, pts);\n\n      // Clear both memories.\n      this.displayedMemory_.eraseBuffer();\n      this.nonDisplayedMemory_.eraseBuffer();\n\n      // Rollup base row defaults to the last row (15).\n      buf.setRow(shaka.cea.Cea608Memory.CC_ROWS);\n    }\n    this.type_ = shaka.cea.Cea608DataChannel.CaptionType.ROLLUP;\n\n    // Set the new rollup window size.\n    buf.setScrollSize(scrollSize);\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Handles flash on.\n   * @private\n   */\n  controlFon_() {\n    this.curbuf_.addChar(\n        shaka.cea.Cea608Memory.CharSet.BASIC_NORTH_AMERICAN,\n        ' '.charCodeAt(0));\n  }\n\n\n  /**\n   * Handles EDM - Erase Displayed Mem\n   * Mode check:\n   * EDM affects all captioning modes (but not Text mode);\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  controlEdm_(pts) {\n    const buf = this.displayedMemory_;\n    let parsedClosedCaption = null;\n    if (this.type_ !== shaka.cea.Cea608DataChannel.CaptionType.TEXT) {\n      // Clearing displayed memory means we now know how long\n      // its contents were displayed, so force it out.\n      parsedClosedCaption = buf.forceEmit(this.prevEndTime_, pts);\n    }\n    buf.resetAllRows();\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Handles RDC - Resume Direct Captions. Initiates Paint-On captioning mode.\n   * RDC does not affect current display, so nothing needs to be forced out yet.\n   * @param {number} pts in seconds\n   * @private\n   */\n  controlRdc_(pts) {\n    this.type_ = shaka.cea.Cea608DataChannel.CaptionType.PAINTON;\n    // Point to displayed memory.\n    this.curbuf_ = this.displayedMemory_;\n\n    // No scroll window now.\n    this.curbuf_.setScrollSize(0);\n\n    // The next paint-on caption needs this time as the start time.\n    this.prevEndTime_ = pts;\n  }\n\n\n  /**\n   * Handles ENM - Erase Nondisplayed Mem\n   * @private\n   */\n  controlEnm_() {\n    this.nonDisplayedMemory_.resetAllRows();\n  }\n\n  /**\n   * Handles EOC - End Of Caption (flip mem)\n   * This forces Pop-On mode, and swaps the displayed and nondisplayed memories.\n   * @private\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   */\n  controlEoc_(pts) {\n    let parsedClosedCaption = null;\n    if (this.type_ !== shaka.cea.Cea608DataChannel.CaptionType.TEXT) {\n      parsedClosedCaption =\n        this.displayedMemory_.forceEmit(this.prevEndTime_, pts);\n    }\n    // Swap memories\n    const buf = this.nonDisplayedMemory_;\n    this.nonDisplayedMemory_ = this.displayedMemory_;  // Swap buffers\n    this.displayedMemory_ = buf;\n\n    // Enter Pop-On mode.\n    this.controlRcl_();\n\n    // The caption ended, and so the previous end time should be updated.\n    this.prevEndTime_ = pts;\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Handles RCL - Resume Caption Loading\n   * Initiates Pop-On style captioning. No need to force anything out upon\n   * entering Pop-On mode because it does not affect the current display.\n   * @private\n   */\n  controlRcl_() {\n    this.type_ = shaka.cea.Cea608DataChannel.CaptionType.POPON;\n    this.curbuf_ = this.nonDisplayedMemory_;\n    // No scroll window now\n    this.curbuf_.setScrollSize(0);\n  }\n\n\n  /**\n   * Handles BS - BackSpace.\n   * @private\n   */\n  controlBs_() {\n    this.curbuf_.eraseChar();\n  }\n\n  /**\n   * Handles TR - Text Restart.\n   * Clears text buffer and resumes Text Mode.\n   * @private\n   */\n  controlTr_() {\n    this.text_.reset();\n    this.controlRtd_();  // Put into text mode.\n  }\n\n  /**\n   * Handles RTD - Resume Text Display.\n   * Resumes text mode. No need to force anything out, because Text Mode doesn't\n   * affect current display. Also, this decoder does not emit Text Mode anyway.\n   * @private\n   */\n  controlRtd_() {\n    shaka.log.warnOnce('Cea608DataChannel',\n        'CEA-608 text mode entered, but is unsupported');\n    this.curbuf_ = this.text_;\n    this.type_ = shaka.cea.Cea608DataChannel.CaptionType.TEXT;\n  }\n\n  /**\n   * Handles a Basic North American byte pair.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   */\n  handleBasicNorthAmericanChar(b1, b2) {\n    this.curbuf_.addChar(\n        shaka.cea.Cea608Memory.CharSet.BASIC_NORTH_AMERICAN, b1);\n    this.curbuf_.addChar(\n        shaka.cea.Cea608Memory.CharSet.BASIC_NORTH_AMERICAN, b2);\n  }\n\n  /**\n   * Handles an Extended Western European byte pair.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @private\n   */\n  handleExtendedWesternEuropeanChar_(b1, b2) {\n    // Get the char set from the LSB, which is the char set toggle bit.\n    const charSet = b1 & 0x01 ?\n          shaka.cea.Cea608Memory.CharSet.PORTUGUESE_GERMAN:\n          shaka.cea.Cea608Memory.CharSet.SPANISH_FRENCH;\n\n    this.curbuf_.addChar(charSet, b2);\n  }\n\n  /**\n   * Decodes control code.\n   * Three types of control codes:\n   * Preamble Address Codes, Mid-Row Codes, and Miscellaneous Control Codes.\n   * @param {!shaka.cea.Cea608DataChannel.Cea608Packet} ccPacket\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   */\n  handleControlCode(ccPacket) {\n    const b1 = ccPacket.ccData1;\n    const b2 = ccPacket.ccData2;\n\n    // FCC wants control codes transmitted twice, and that will often be\n    // seen in broadcast captures. If the very next frame has a duplicate\n    // control code, that duplicate is ignored. Note that this only applies\n    // to the very next frame, and only for one match.\n    if (this.lastcp_ === ((b1 << 8) | b2)) {\n      this.lastcp_ = null;\n      return null;\n    }\n\n    // Remember valid control code for checking in next frame!\n    this.lastcp_ = (b1 << 8) | b2;\n\n    if (this.isPAC_(b1, b2)) {\n      this.controlPac_(b1, b2);\n    } else if (this.isMidrowStyleChange_(b1, b2)) {\n      this.controlMidrow_(b2);\n    } else if (this.isBackgroundAttribute_(b1, b2)) {\n      this.controlBackgroundAttribute_(b1, b2);\n    } else if (this.isSpecialNorthAmericanChar_(b1, b2)) {\n      this.curbuf_.addChar(\n          shaka.cea.Cea608Memory.CharSet.SPECIAL_NORTH_AMERICAN, b2);\n    } else if (this.isExtendedWesternEuropeanChar_(b1, b2)) {\n      this.handleExtendedWesternEuropeanChar_(b1, b2);\n    } else if (this.isMiscellaneous_(b1, b2)) {\n      return this.controlMiscellaneous_(ccPacket);\n    }\n    return null;\n  }\n\n  /**\n   * Checks if this is a Miscellaneous control code.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @return {boolean}\n   * @private\n   */\n  isMiscellaneous_(b1, b2) {\n    // For Miscellaneous Control Codes, the bytes take the following form:\n    // b1 -> |0|0|0|1|C|1|0|F|\n    // b2 -> |0|0|1|0|X|X|X|X|\n    return ((b1 & 0xf6) === 0x14) && ((b2 & 0xf0) === 0x20);\n  }\n\n  /**\n   * Checks if this is a PAC control code.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @return {boolean}\n   * @private\n   */\n  isPAC_(b1, b2) {\n    // For Preamble Address Codes, the bytes take the following form:\n    // b1 -> |0|0|0|1|X|X|X|X|\n    // b2 -> |0|1|X|X|X|X|X|X|\n    return ((b1 & 0xf0) === 0x10) && ((b2 & 0xc0) === 0x40);\n  }\n\n  /**\n   * Checks if this is a Midrow style change control code.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @return {boolean}\n   * @private\n   */\n  isMidrowStyleChange_(b1, b2) {\n    // For Midrow Control Codes, the bytes take the following form:\n    // b1 -> |0|0|0|1|C|0|0|1|\n    // b2 -> |0|0|1|0|X|X|X|X|\n    return ((b1 & 0xf7) === 0x11) && ((b2 & 0xf0) === 0x20);\n  }\n\n  /**\n   * Checks if this is a background attribute control code.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @return {boolean}\n   * @private\n   */\n  isBackgroundAttribute_(b1, b2) {\n    // For Background Attribute Codes, the bytes take the following form:\n    // Bg provided: b1 -> |0|0|0|1|C|0|0|0| b2 -> |0|0|1|0|COLOR|T|\n    // No Bg:       b1 -> |0|0|0|1|C|1|1|1| b2 -> |0|0|1|0|1|1|0|1|\n    return (((b1 & 0xf7) === 0x10) && ((b2 & 0xf0) === 0x20)) ||\n             (((b1 & 0xf7) === 0x17) && ((b2 & 0xff) === 0x2D));\n  }\n\n  /**\n   * Checks if the character is in the Special North American char. set.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @return {boolean}\n   * @private\n   */\n  isSpecialNorthAmericanChar_(b1, b2) {\n    // The bytes take the following form:\n    // b1 -> |0|0|0|1|C|0|0|1|\n    // b2 -> |0|0|1|1|  CHAR |\n    return ((b1 & 0xf7) === 0x11) && ((b2 & 0xf0) === 0x30);\n  }\n\n  /**\n   * Checks if the character is in the Extended Western European char. set.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @return {boolean}\n   * @private\n   */\n  isExtendedWesternEuropeanChar_(b1, b2) {\n    // The bytes take the following form:\n    // b1 -> |0|0|0|1|C|0|1|S|\n    // b2 -> |0|0|1|CHARACTER|\n    return ((b1 & 0xf6) === 0x12) && ((b2 & 0xe0) === 0x20);\n  }\n\n  /**\n   * Checks if the data contains a control code.\n   * @param {number} b1 Byte 1.\n   * @return {boolean}\n   */\n  static isControlCode(b1) {\n    // For control codes, the first byte takes the following form:\n    // b1 -> |P|0|0|1|X|X|X|X|\n    return (b1 & 0x70) === 0x10;\n  }\n};\n\n/**\n * Command codes.\n * @enum {number}\n * @private\n */\nshaka.cea.Cea608DataChannel.MiscCmd_ = {\n  // \"RCL - Resume Caption Loading\"\n  RCL: 0x20,\n\n  // \"BS  - BackSpace\"\n  BS: 0x21,\n\n  // \"AOD - Unused (alarm off)\"\n  AOD: 0x22,\n\n  // \"AON - Unused (alarm on)\"\n  AON: 0x23,\n\n  // \"DER - Delete to End of Row\"\n  DER: 0x24,\n\n  // \"RU2 - Roll-Up, 2 rows\"\n  RU2: 0x25,\n\n  // \"RU3 - Roll-Up, 3 rows\"\n  RU3: 0x26,\n\n  // \"RU4 - Roll-Up, 4 rows\"\n  RU4: 0x27,\n\n  // \"FON - Flash On\"\n  FON: 0x28,\n\n  // \"RDC - Resume Direct Captions\"\n  RDC: 0x29,\n\n  // \"TR - Text Restart\"\n  TR: 0x2a,\n\n  // \"RTD - Resume Text Display\"\n  RTD: 0x2b,\n\n  // \"EDM - Erase Displayed Mem\"\n  EDM: 0x2c,\n\n  // \"CR  - Carriage return\"\n  CR: 0x2d,\n\n  // \"ENM - Erase Nondisplayed Mem\"\n  ENM: 0x2e,\n\n  // \"EOC - End Of Caption (flip mem)\"\n  EOC: 0x2f,\n};\n\n/**\n * Caption type.\n * @private @const @enum {number}\n */\nshaka.cea.Cea608DataChannel.CaptionType = {\n  NONE: 0,\n  POPON: 1,\n  PAINTON: 2,\n  ROLLUP: 3,\n  TEXT: 4,\n};\n\n/**\n * @const {!Array<string>}\n */\nshaka.cea.Cea608DataChannel.BG_COLORS = [\n  'black',\n  'green',\n  'blue',\n  'cyan',\n  'red',\n  'yellow',\n  'magenta',\n  'black',\n];\n\n/**\n * @const {!Array<string>}\n */\nshaka.cea.Cea608DataChannel.TEXT_COLORS = [\n  'white',\n  'green',\n  'blue',\n  'cyan',\n  'red',\n  'yellow',\n  'magenta',\n  'white_italics',\n];\n\n/**\n * Style associated with a cue.\n * @typedef {{\n *   textColor: ?string,\n *   backgroundColor: ?string,\n *   italics: ?boolean,\n *   underline: ?boolean\n * }}\n */\nshaka.cea.Cea608DataChannel.Style;\n\n/**\n * CEA closed captions packet.\n * @typedef {{\n  *   pts: number,\n  *   type: number,\n  *   ccData1: number,\n  *   ccData2: number,\n  *   order: number\n  * }}\n  *\n  * @property {number} pts\n  *   Presentation timestamp (in second) at which this packet was received.\n  * @property {number} type\n  *   Type of the packet. Either 0 or 1, representing the CEA-608 field.\n  * @property {number} ccData1 CEA-608 byte 1.\n  * @property {number} ccData2 CEA-608 byte 2.\n  * @property {number} order\n  *   A number indicating the order this packet was received in a sequence\n  *   of packets. Used to break ties in a stable sorting algorithm\n  */\nshaka.cea.Cea608DataChannel.Cea608Packet;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.Cea708Window');\n\ngoog.require('shaka.cea.CeaUtils');\ngoog.require('shaka.cea.CeaUtils.StyledChar');\ngoog.require('shaka.cea.ICaptionDecoder');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.util.Functional');\n\n\n/**\n * CEA-708 Window. Each CEA-708 service owns 8 of these.\n */\nshaka.cea.Cea708Window = class {\n  /**\n   * @param {number} windowNum\n   */\n  constructor(windowNum) {\n    /**\n     * A number from 0 - 7 indicating the window number in the\n     * service that owns this window.\n     * @private {number}\n     */\n    this.windowNum_ = windowNum;\n\n    /**\n     * Indicates whether this window is visible.\n     * @private {boolean}\n     */\n    this.visible_ = false;\n\n    /**\n     * Indicates whether the horizontal and vertical anchors coordinates specify\n     * a percentage of the screen, or physical coordinates on the screen.\n     * @private {boolean}\n     */\n    this.relativeToggle_ = false;\n\n    /**\n     * Horizontal anchor. Loosely corresponds to a WebVTT viewport X anchor.\n     * @private {number}\n     */\n    this.horizontalAnchor_ = 0;\n\n    /**\n     * Vertical anchor. Loosely corresponds to a WebVTT viewport Y anchor.\n     * @private {number}\n     */\n    this.verticalAnchor_ = 0;\n\n    /**\n     * If valid, ranges from 0 to 8, specifying one of 9 locations on window:\n     * 0________1________2\n     * |        |        |\n     * 3________4________5\n     * |        |        |\n     * 6________7________8\n     * Diagram is valid as per CEA-708-E section 8.4.4.\n     * Each of these locations corresponds to a WebVTT region's \"region anchor\".\n     * @private {number}\n     */\n    this.anchorId_ = 0;\n\n    /**\n     * Indicates the number of rows in this window's buffer/memory.\n     * @private {number}\n     */\n    this.rowCount_ = 0;\n\n    /**\n     * Indicates the number of columns in this window's buffer/memory.\n     * @private {number}\n     */\n    this.colCount_ = 0;\n\n    /**\n     * Center by default.\n     * @private {!shaka.cea.Cea708Window.TextJustification}\n     */\n    this.justification_ = shaka.cea.Cea708Window.TextJustification.CENTER;\n\n    /**\n     * An array of rows of styled characters, representing the\n     * current text and styling of text in this window.\n     * @private {!Array<!Array<?shaka.cea.CeaUtils.StyledChar>>}\n     */\n    this.memory_ = [];\n\n    /**\n     * @private {number}\n     */\n    this.startTime_ = 0;\n\n    /**\n     * Row that the current pen is pointing at.\n     * @private {number}\n     */\n    this.row_ = 0;\n\n    /**\n     * Column that the current pen is pointing at.\n     * @private {number}\n     */\n    this.col_ = 0;\n\n    /**\n     * Indicates whether the current pen position is italicized.\n     * @private {boolean}\n     */\n    this.italics_ = false;\n\n    /**\n     * Indicates whether the current pen position is underlined.\n     * @private {boolean}\n     */\n    this.underline_ = false;\n\n    /**\n     * Indicates the text color at the current pen position.\n     * @private {string}\n     */\n    this.textColor_ = shaka.cea.CeaUtils.DEFAULT_TXT_COLOR;\n\n    /**\n     * Indicates the background color at the current pen position.\n     * @private {string}\n     */\n    this.backgroundColor_ = shaka.cea.CeaUtils.DEFAULT_BG_COLOR;\n\n    this.resetMemory();\n\n    // TODO Support window positioning by mapping them to Regions.\n    // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-708\n    shaka.util.Functional.ignored(this.verticalAnchor_, this.relativeToggle_,\n        this.horizontalAnchor_, this.anchorId_, this.windowNum_);\n  }\n\n  /**\n   * @param {boolean} visible\n   * @param {number} verticalAnchor\n   * @param {number} horizontalAnchor\n   * @param {number} anchorId\n   * @param {boolean} relativeToggle\n   * @param {number} rowCount\n   * @param {number} colCount\n   */\n  defineWindow(visible, verticalAnchor, horizontalAnchor, anchorId,\n      relativeToggle, rowCount, colCount) {\n    this.visible_ = visible;\n    this.verticalAnchor_ = verticalAnchor;\n    this.horizontalAnchor_ = horizontalAnchor;\n    this.anchorId_ = anchorId;\n    this.relativeToggle_ = relativeToggle;\n    this.rowCount_ = rowCount;\n    this.colCount_ = colCount;\n  }\n\n  /**\n   * Resets the memory buffer.\n   */\n  resetMemory() {\n    this.memory_ = [];\n    for (let i = 0; i < shaka.cea.Cea708Window.MAX_ROWS; i++) {\n      this.memory_.push(this.createNewRow_());\n    }\n  }\n\n  /**\n   * Allocates and returns a new row.\n   * @return {!Array<?shaka.cea.CeaUtils.StyledChar>}\n   * @private\n   */\n  createNewRow_() {\n    const row = [];\n    for (let j = 0; j < shaka.cea.Cea708Window.MAX_COLS; j++) {\n      row.push(null);\n    }\n    return row;\n  }\n\n  /**\n   * Sets the unicode value for a char at the current pen location.\n   * @param {string} char\n   */\n  setCharacter(char) {\n    // Check if the pen is out of bounds.\n    if (!this.isPenInBounds_()) {\n      return;\n    }\n\n    const cea708Char = new shaka.cea.CeaUtils.StyledChar(\n        char, this.underline_, this.italics_,\n        this.backgroundColor_, this.textColor_);\n    this.memory_[this.row_][this.col_] = cea708Char;\n\n    // Increment column\n    this.col_ ++;\n  }\n\n  /**\n   * Erases a character from the buffer and moves the pen back.\n   */\n  backspace() {\n    if (!this.isPenInBounds_()) {\n      return;\n    }\n\n    // Check if a backspace can be done.\n    if (this.col_ <= 0 && this.row_ <= 0) {\n      return;\n    }\n\n    if (this.col_ <= 0) {\n      // Move pen back a row.\n      this.col_ = this.colCount_ - 1;\n      this.row_--;\n    } else {\n      // Move pen back a column.\n      this.col_--;\n    }\n\n    // Erase the character occupied at that position.\n    this.memory_[this.row_][this.col_] = null;\n  }\n\n  /**\n   * @private\n   */\n  isPenInBounds_() {\n    const inRowBounds = this.row_ < this.rowCount_ && this.row_ >= 0;\n    const inColBounds = this.col_ < this.colCount_ && this.col_ >= 0;\n    return inRowBounds && inColBounds;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isVisible() {\n    return this.visible_;\n  }\n\n  /**\n   * Moves up <count> rows in the buffer.\n   * @param {number} count\n   * @private\n   */\n  moveUpRows_(count) {\n    let dst = 0; // Row each row should be moved to.\n\n    // Move existing rows up by <count>.\n    for (let i = count; i < shaka.cea.Cea708Window.MAX_ROWS; i++, dst++) {\n      this.memory_[dst] = this.memory_[i];\n    }\n\n    // Create <count> new rows at the bottom.\n    for (let i = 0; i < count; i++, dst++) {\n      this.memory_[dst] = this.createNewRow_();\n    }\n  }\n\n  /**\n   * Handles CR. Increments row - if last row, \"roll up\" all rows by one.\n   */\n  carriageReturn() {\n    if (this.row_ + 1 >= this.rowCount_) {\n      this.moveUpRows_(1);\n      this.col_ = 0;\n      return;\n    }\n\n    this.row_++;\n    this.col_ = 0;\n  }\n\n  /**\n   * Handles HCR. Moves the pen to the beginning of the cur. row and clears it.\n   */\n  horizontalCarriageReturn() {\n    this.memory_[this.row_] = this.createNewRow_();\n    this.col_ = 0;\n  }\n\n  /**\n   * @param {number} endTime\n   * @param {number} serviceNumber Number of the service emitting this caption.\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   */\n  forceEmit(endTime, serviceNumber) {\n    const stream = `svc${serviceNumber}`;\n    const TextJustification = shaka.cea.Cea708Window.TextJustification;\n    const topLevelCue = new shaka.text.Cue(\n        this.startTime_, endTime, /* payload= */ '');\n\n    if (this.justification_ === TextJustification.LEFT) {\n      // LEFT justified.\n      topLevelCue.textAlign = shaka.text.Cue.textAlign.LEFT;\n    } else if (this.justification_ === TextJustification.RIGHT) {\n      // RIGHT justified.\n      topLevelCue.textAlign = shaka.text.Cue.textAlign.RIGHT;\n    } else {\n      // CENTER justified. Both FULL and CENTER are handled as CENTER justified.\n      topLevelCue.textAlign = shaka.text.Cue.textAlign.CENTER;\n    }\n\n    const caption = shaka.cea.CeaUtils.getParsedCaption(\n        topLevelCue, stream, this.memory_, this.startTime_, endTime);\n    if (caption) {\n      // If a caption is being emitted, then the next caption's start time\n      // should be no less than this caption's end time.\n      this.setStartTime(endTime);\n    }\n    return caption;\n  }\n\n  /**\n   * @param {number} row\n   * @param {number} col\n   */\n  setPenLocation(row, col) {\n    this.row_ = row;\n    this.col_ = col;\n  }\n\n  /**\n   * @param {string} backgroundColor\n   */\n  setPenBackgroundColor(backgroundColor) {\n    this.backgroundColor_ = backgroundColor;\n  }\n\n  /**\n   * @param {string} textColor\n   */\n  setPenTextColor(textColor) {\n    this.textColor_ = textColor;\n  }\n\n  /**\n   * @param {boolean} underline\n   */\n  setPenUnderline(underline) {\n    this.underline_ = underline;\n  }\n\n  /**\n   * @param {boolean} italics\n   */\n  setPenItalics(italics) {\n    this.italics_ = italics;\n  }\n\n  /** Reset the pen to 0,0 with default styling. */\n  resetPen() {\n    this.row_ = 0;\n    this.col_ = 0;\n    this.underline_ = false;\n    this.italics_ = false;\n    this.textColor_ = shaka.cea.CeaUtils.DEFAULT_TXT_COLOR;\n    this.backgroundColor_ = shaka.cea.CeaUtils.DEFAULT_BG_COLOR;\n  }\n\n  /**\n   * @param {!shaka.cea.Cea708Window.TextJustification} justification\n   */\n  setJustification(justification) {\n    this.justification_ = justification;\n  }\n\n  /**\n   * Sets the window to visible.\n   */\n  display() {\n    this.visible_ = true;\n  }\n\n  /**\n   * Sets the window to invisible.\n   */\n  hide() {\n    this.visible_ = false;\n  }\n\n  /**\n   * Toggles the visibility of the window.\n   */\n  toggle() {\n    this.visible_ = !this.visible_;\n  }\n\n  /**\n   * Sets the start time for the cue to be emitted.\n   * @param {number} pts\n   */\n  setStartTime(pts) {\n    this.startTime_ = pts;\n  }\n};\n\n/**\n * Caption type.\n * @const @enum {number}\n */\nshaka.cea.Cea708Window.TextJustification = {\n  LEFT: 0,\n  RIGHT: 1,\n  CENTER: 2,\n  FULL: 3,\n};\n\n/**\n * Can be indexed 0-31 for 4:3 format, and 0-41 for 16:9 formats.\n * Thus the absolute maximum is 42 columns for the 16:9 format.\n * @private @const {number}\n */\nshaka.cea.Cea708Window.MAX_COLS = 42;\n\n/**\n * Maximum of 16 rows that can be indexed from 0 to 15.\n * @private @const {number}\n */\nshaka.cea.Cea708Window.MAX_ROWS = 16;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.DtvccPacketBuilder');\ngoog.provide('shaka.cea.DtvccPacket');\ngoog.require('shaka.util.Error');\ngoog.requireType('shaka.cea.Cea708Service');\n\n\n/**\n * CEA-708 DTVCC Packet Builder.\n * Builds packets based on Figure 5 CCP State Table in 5.2 of CEA-708-E.\n * Initially, there is no packet. When a DTVCC_PACKET_START payload is received,\n * a packet begins construction. The packet is considered \"built\" once all bytes\n * indicated in the header are read, and ignored if a new packet starts building\n * before the current packet is finished being built.\n */\nshaka.cea.DtvccPacketBuilder = class {\n  /** */\n  constructor() {\n    /**\n     * An array containing built DTVCC packets that are ready to be processed.\n     * @private {!Array<!shaka.cea.DtvccPacket>}\n     */\n    this.builtPackets_ = [];\n\n    /**\n     * Stores the packet data for the current packet being processed, if any.\n     * @private {?Array<!shaka.cea.Cea708Service.Cea708Byte>}\n     */\n    this.currentPacketBeingBuilt_ = null;\n\n    /**\n     * Keeps track of the number of bytes left to add in the current packet.\n     * @private {number}\n     */\n    this.bytesLeftToAddInCurrentPacket_ = 0;\n  }\n\n  /**\n   * @param {!shaka.cea.Cea708Service.Cea708Byte} cea708Byte\n   */\n  addByte(cea708Byte) {\n    if (cea708Byte.type === shaka.cea.DtvccPacketBuilder.DTVCC_PACKET_START) {\n      // If there was a packet being built that finished, it would have\n      // already been added to the built packets when it finished. So if\n      // there's an open packet at this point, it must be unfinished. As\n      // per the spec, we don't deal with unfinished packets. So we ignore them.\n\n      // A new packet should be opened.\n      const packetSize = cea708Byte.value & 0x3f;\n\n      // As per spec, number of packet data bytes to follow is packetSize*2-1.\n      this.bytesLeftToAddInCurrentPacket_ = packetSize * 2 - 1;\n      this.currentPacketBeingBuilt_ = [];\n      return;\n    }\n\n    if (!this.currentPacketBeingBuilt_) {\n      // There is no packet open. Then an incoming byte should not\n      // have come in at all. Ignore it.\n      return;\n    }\n\n    if (this.bytesLeftToAddInCurrentPacket_ > 0) {\n      this.currentPacketBeingBuilt_.push(cea708Byte);\n      this.bytesLeftToAddInCurrentPacket_--;\n    }\n\n    if (this.bytesLeftToAddInCurrentPacket_ === 0) {\n      // Current packet is complete and ready for processing.\n      const packet = new shaka.cea.DtvccPacket(this.currentPacketBeingBuilt_);\n      this.builtPackets_.push(packet);\n      this.currentPacketBeingBuilt_ = null;\n      this.bytesLeftToAddInCurrentPacket_ = 0;\n    }\n  }\n\n  /**\n   * @return {!Array<!shaka.cea.DtvccPacket>}\n   */\n  getBuiltPackets() {\n    return this.builtPackets_;\n  }\n\n  /** Clear built packets. */\n  clearBuiltPackets() {\n    this.builtPackets_ = [];\n  }\n\n  /** Clear built packets and packets in progress. */\n  clear() {\n    this.builtPackets_ = [];\n    this.currentPacketBeingBuilt_ = [];\n    this.bytesLeftToAddInCurrentPacket_ = 0;\n  }\n};\n\n\nshaka.cea.DtvccPacket = class {\n  /**\n   * @param {!Array<!shaka.cea.Cea708Service.Cea708Byte>} packetData\n   */\n  constructor(packetData) {\n    /**\n     * Keeps track of the position to read the next byte from in the packet.\n     * @private {number}\n     */\n    this.pos_ = 0;\n\n    /**\n     * Bytes that represent the data in the DTVCC packet.\n     * @private {!Array<!shaka.cea.Cea708Service.Cea708Byte>}\n     */\n    this.packetData_ = packetData;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  hasMoreData() {\n    return this.pos_ < this.packetData_.length;\n  }\n\n  /**\n   * @return {number}\n   */\n  getPosition() {\n    return this.pos_;\n  }\n\n  /**\n   * Reads a byte from the packet. TODO CONSIDER RENAMING THIS TO BLOCK\n   * @return {!shaka.cea.Cea708Service.Cea708Byte}\n   * @throws {!shaka.util.Error}\n   */\n  readByte() {\n    if (!this.hasMoreData()) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.BUFFER_READ_OUT_OF_BOUNDS);\n    }\n    return this.packetData_[this.pos_++];\n  }\n\n  /**\n   * Skips the provided number of blocks in the buffer.\n   * @param {number} numBlocks\n   * @throws {!shaka.util.Error}\n   */\n  skip(numBlocks) {\n    if (this.pos_ + numBlocks > this.packetData_.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.BUFFER_READ_OUT_OF_BOUNDS);\n    }\n    this.pos_ += numBlocks;\n  }\n};\n\n/**\n * @const {number}\n */\nshaka.cea.DtvccPacketBuilder.DTVCC_PACKET_DATA = 2;\n\n/**\n * @const {number}\n */\nshaka.cea.DtvccPacketBuilder.DTVCC_PACKET_START = 3;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.Cea708Service');\n\ngoog.require('shaka.cea.Cea708Window');\ngoog.require('shaka.cea.DtvccPacket');\ngoog.require('shaka.cea.ICaptionDecoder');\n\n\n/**\n * CEA-708 closed captions service as defined by CEA-708-E. A decoder can own up\n * to 63 services. Each service owns eight windows.\n */\nshaka.cea.Cea708Service = class {\n  /**\n   * @param {number} serviceNumber\n   */\n  constructor(serviceNumber) {\n    /**\n     * Number for this specific service (1 - 63).\n     * @private {number}\n     */\n    this.serviceNumber_ = serviceNumber;\n\n    /**\n     * Eight Cea708 Windows, as defined by the spec.\n     * @private {!Array<?shaka.cea.Cea708Window>}\n     */\n    this.windows_ = [\n      null, null, null, null, null, null, null, null,\n    ];\n\n    /**\n     * The current window for which window command operate on.\n     * @private {?shaka.cea.Cea708Window}\n     */\n    this.currentWindow_ = null;\n  }\n\n  /**\n   * Processes a CEA-708 control code.\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @throws {!shaka.util.Error}\n   */\n  handleCea708ControlCode(dtvccPacket) {\n    const blockData = dtvccPacket.readByte();\n    let controlCode = blockData.value;\n    const pts = blockData.pts;\n\n    // Read extended control code if needed.\n    if (controlCode === shaka.cea.Cea708Service.EXT_CEA708_CTRL_CODE_BYTE1) {\n      const extendedControlCodeBlock = dtvccPacket.readByte();\n      controlCode = (controlCode << 16) | extendedControlCodeBlock.value;\n    }\n\n    // Control codes are in 1 of 4 logical groups:\n    // CL (C0, C2), CR (C1, C3), GL (G0, G2), GR (G1, G2).\n    if (controlCode >= 0x00 && controlCode <= 0x1f) {\n      return this.handleC0_(controlCode, pts);\n    } else if (controlCode >= 0x80 && controlCode <= 0x9f) {\n      return this.handleC1_(dtvccPacket, controlCode, pts);\n    } else if (controlCode >= 0x1000 && controlCode <= 0x101f) {\n      this.handleC2_(dtvccPacket, controlCode & 0xff);\n    } else if (controlCode >= 0x1080 && controlCode <= 0x109f) {\n      this.handleC3_(dtvccPacket, controlCode & 0xff);\n    } else if (controlCode >= 0x20 && controlCode <= 0x7f) {\n      this.handleG0_(controlCode);\n    } else if (controlCode >= 0xa0 && controlCode <= 0xff) {\n      this.handleG1_(controlCode);\n    } else if (controlCode >= 0x1020 && controlCode <= 0x107f) {\n      this.handleG2_(controlCode & 0xff);\n    } else if (controlCode >= 0x10a0 && controlCode <= 0x10ff) {\n      this.handleG3_(controlCode & 0xff);\n    }\n\n    return null;\n  }\n\n  /**\n   * Handles G0 group data.\n   * @param {number} controlCode\n   * @private\n   */\n  handleG0_(controlCode) {\n    if (!this.currentWindow_) {\n      return;\n    }\n    // G0 contains ASCII from 0x20 to 0x7f, with the exception that 0x7f\n    // is replaced by a musical note.\n    if (controlCode === 0x7f) {\n      this.currentWindow_.setCharacter('♪');\n      return;\n    }\n    this.currentWindow_.setCharacter(String.fromCharCode(controlCode));\n  }\n\n  /**\n   * Handles G1 group data.\n   * @param {number} controlCode\n   * @private\n   */\n  handleG1_(controlCode) {\n    if (!this.currentWindow_) {\n      return;\n    }\n    // G1 is the Latin-1 Character Set from 0xa0 to 0xff.\n    this.currentWindow_.setCharacter(String.fromCharCode(controlCode));\n  }\n\n  /**\n   * Handles G2 group data.\n   * @param {number} controlCode\n   * @private\n   */\n  handleG2_(controlCode) {\n    if (!this.currentWindow_) {\n      return;\n    }\n    if (!shaka.cea.Cea708Service.G2Charset.has(controlCode)) {\n      // If the character is unsupported, the spec says to put an underline.\n      this.currentWindow_.setCharacter('_');\n      return;\n    }\n\n    const char = shaka.cea.Cea708Service.G2Charset.get(controlCode);\n    this.currentWindow_.setCharacter(char);\n  }\n\n  /**\n   * Handles G3 group data.\n   * @param {number} controlCode\n   * @private\n   */\n  handleG3_(controlCode) {\n    if (!this.currentWindow_) {\n      return;\n    }\n\n    // As of CEA-708-E, the G3 group only contains 1 character. It's a\n    // [CC] character which has no unicode value on 0xa0.\n    if (controlCode != 0xa0) {\n      // Similar to G2, the spec decrees an underline if char is unsupported.\n      this.currentWindow_.setCharacter('_');\n      return;\n    }\n\n    this.currentWindow_.setCharacter('[CC]');\n  }\n\n  /**\n   * Handles C0 group data.\n   * @param {number} controlCode\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  handleC0_(controlCode, pts) {\n    // All these commands pertain to the current window, so ensure it exists.\n    if (!this.currentWindow_) {\n      return null;\n    }\n\n    const window = this.currentWindow_;\n    let parsedClosedCaption = null;\n\n    // Note: This decoder ignores the \"ETX\" (end of text) control code. Since\n    // this is JavaScript, a '\\0' is not needed to terminate a string.\n    switch (controlCode) {\n      case shaka.cea.Cea708Service.ASCII_BACKSPACE:\n        window.backspace();\n        break;\n      case shaka.cea.Cea708Service.ASCII_CARRIAGE_RETURN:\n        // Force out the buffer, since the top row could be lost.\n        if (window.isVisible()) {\n          parsedClosedCaption = window.forceEmit(pts, this.serviceNumber_);\n        }\n        window.carriageReturn();\n        break;\n      case shaka.cea.Cea708Service.ASCII_HOR_CARRIAGE_RETURN:\n        // Force out the buffer, a row will be erased.\n        if (window.isVisible()) {\n          parsedClosedCaption = window.forceEmit(pts, this.serviceNumber_);\n        }\n        window.horizontalCarriageReturn();\n        break;\n      case shaka.cea.Cea708Service.ASCII_FORM_FEED:\n        // Clear window and move pen to (0,0).\n        // Force emit if the window is visible.\n        if (window.isVisible()) {\n          parsedClosedCaption = window.forceEmit(pts, this.serviceNumber_);\n        }\n        window.resetMemory();\n        window.setPenLocation(0, 0);\n        break;\n    }\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Processes C1 group data.\n   * These are caption commands.\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @param {number} captionCommand\n   * @param {number} pts in seconds\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @throws {!shaka.util.Error} a possible out-of-range buffer read.\n   * @private\n   */\n  handleC1_(dtvccPacket, captionCommand, pts) {\n    // Note: This decoder ignores delay and delayCancel control codes in the C1.\n    // group. These control codes delay processing of data for a set amount of\n    // time, however this decoder processes that data immediately.\n\n    if (captionCommand >= 0x80 && captionCommand <= 0x87) {\n      const windowNum = captionCommand & 0x07;\n      this.setCurrentWindow_(windowNum);\n    } else if (captionCommand === 0x88) {\n      const bitmap = dtvccPacket.readByte().value;\n      return this.clearWindows_(bitmap, pts);\n    } else if (captionCommand === 0x89) {\n      const bitmap = dtvccPacket.readByte().value;\n      this.displayWindows_(bitmap, pts);\n    } else if (captionCommand === 0x8a) {\n      const bitmap = dtvccPacket.readByte().value;\n      return this.hideWindows_(bitmap, pts);\n    } else if (captionCommand === 0x8b) {\n      const bitmap = dtvccPacket.readByte().value;\n      return this.toggleWindows_(bitmap, pts);\n    } else if (captionCommand === 0x8c) {\n      const bitmap = dtvccPacket.readByte().value;\n      return this.deleteWindows_(bitmap, pts);\n    } else if (captionCommand === 0x8f) {\n      return this.reset_(pts);\n    } else if (captionCommand === 0x90) {\n      this.setPenAttributes_(dtvccPacket);\n    } else if (captionCommand === 0x91) {\n      this.setPenColor_(dtvccPacket);\n    } else if (captionCommand === 0x92) {\n      this.setPenLocation_(dtvccPacket);\n    } else if (captionCommand === 0x97) {\n      this.setWindowAttributes_(dtvccPacket);\n    } else if (captionCommand >= 0x98 && captionCommand <= 0x9f) {\n      const windowNum = (captionCommand & 0x0f) - 8;\n      this.defineWindow_(dtvccPacket, windowNum, pts);\n    }\n    return null;\n  }\n\n  /**\n   * Handles C2 group data.\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @param {number} controlCode\n   * @private\n   */\n  handleC2_(dtvccPacket, controlCode) {\n    // As of the CEA-708-E spec there are no commands on the C2 table, but if\n    // seen, then the appropriate number of bytes must be skipped as per spec.\n    if (controlCode >= 0x08 && controlCode <= 0x0f) {\n      dtvccPacket.skip(1);\n    } else if (controlCode >= 0x10 && controlCode <= 0x17) {\n      dtvccPacket.skip(2);\n    } else if (controlCode >= 0x18 && controlCode <= 0x1f) {\n      dtvccPacket.skip(3);\n    }\n  }\n\n  /**\n   * Handles C3 group data.\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @param {number} controlCode\n   * @private\n   */\n  handleC3_(dtvccPacket, controlCode) {\n    // As of the CEA-708-E spec there are no commands on the C3 table, but if\n    // seen, then the appropriate number of bytes must be skipped as per spec.\n    if (controlCode >= 0x80 && controlCode <= 0x87) {\n      dtvccPacket.skip(4);\n    } else if (controlCode >= 0x88 && controlCode <= 0x8f) {\n      dtvccPacket.skip(5);\n    }\n  }\n\n  /**\n   * @param {number} windowNum\n   * @private\n   */\n  setCurrentWindow_(windowNum) {\n    // If the window isn't created, ignore the command.\n    if (!this.windows_[windowNum]) {\n      return;\n    }\n    this.currentWindow_ = this.windows_[windowNum];\n  }\n\n  /**\n   * Yields each non-null window specified in the 8-bit bitmap.\n   * @param {number} bitmap 8 bits corresponding to each of the 8 windows.\n   * @return {!Array.<number>}\n   * @private\n   */\n  getSpecifiedWindowIds_(bitmap) {\n    const ids = [];\n    for (let i = 0; i < 8; i++) {\n      const windowSpecified = (bitmap & 0x01) === 0x01;\n      if (windowSpecified && this.windows_[i]) {\n        ids.push(i);\n      }\n      bitmap >>= 1;\n    }\n    return ids;\n  }\n\n  /**\n   * @param {number} windowsBitmap\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  clearWindows_(windowsBitmap, pts) {\n    let parsedClosedCaption = null;\n\n    // Clears windows from the 8 bit bitmap.\n    for (const windowId of this.getSpecifiedWindowIds_(windowsBitmap)) {\n      // If window visible and being cleared, emit buffer and reset start time!\n      const window = this.windows_[windowId];\n      if (window.isVisible()) {\n        parsedClosedCaption = window.forceEmit(pts, this.serviceNumber_);\n      }\n      window.resetMemory();\n    }\n    return parsedClosedCaption;\n  }\n\n  /**\n   * @param {number} windowsBitmap\n   * @param {number} pts\n   * @private\n   */\n  displayWindows_(windowsBitmap, pts) {\n    // Displays windows from the 8 bit bitmap.\n    for (const windowId of this.getSpecifiedWindowIds_(windowsBitmap)) {\n      const window = this.windows_[windowId];\n      if (!window.isVisible()) {\n        // We are turning on the visibility, set the start time.\n        window.setStartTime(pts);\n      }\n      window.display();\n    }\n  }\n\n  /**\n   * @param {number} windowsBitmap\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  hideWindows_(windowsBitmap, pts) {\n    let parsedClosedCaption = null;\n\n    // Hides windows from the 8 bit bitmap.\n    for (const windowId of this.getSpecifiedWindowIds_(windowsBitmap)) {\n      const window = this.windows_[windowId];\n      if (window.isVisible()) {\n        // We are turning off the visibility, emit!\n        parsedClosedCaption = window.forceEmit(pts, this.serviceNumber_);\n      }\n      window.hide();\n    }\n    return parsedClosedCaption;\n  }\n\n  /**\n   * @param {number} windowsBitmap\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  toggleWindows_(windowsBitmap, pts) {\n    let parsedClosedCaption = null;\n\n    // Toggles windows from the 8 bit bitmap.\n    for (const windowId of this.getSpecifiedWindowIds_(windowsBitmap)) {\n      const window = this.windows_[windowId];\n      if (window.isVisible()) {\n        // We are turning off the visibility, emit!\n        parsedClosedCaption = window.forceEmit(pts, this.serviceNumber_);\n      } else {\n        // We are turning on visibility, set the start time.\n        window.setStartTime(pts);\n      }\n\n      window.toggle();\n    }\n    return parsedClosedCaption;\n  }\n\n  /**\n   * @param {number} windowsBitmap\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  deleteWindows_(windowsBitmap, pts) {\n    let parsedClosedCaption = null;\n    // Deletes windows from the 8 bit bitmap.\n    for (const windowId of this.getSpecifiedWindowIds_(windowsBitmap)) {\n      const window = this.windows_[windowId];\n      if (window.isVisible()) {\n        // We are turning off the visibility, emit!\n        parsedClosedCaption = window.forceEmit(pts, this.serviceNumber_);\n      }\n      // Delete the window from the list of windows\n      this.windows_[windowId] = null;\n    }\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Emits anything currently present in any of the windows, and then\n   * deletes all windows, cancels all delays, reinitializes the service.\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  reset_(pts) {\n    const allWindowsBitmap = 0xff; // All windows should be deleted.\n    const caption = this.deleteWindows_(allWindowsBitmap, pts);\n    this.clear();\n    return caption;\n  }\n\n  /**\n   * Clears the state of the service completely.\n   */\n  clear() {\n    this.currentWindow_ = null;\n    this.windows_ = [null, null, null, null, null, null, null, null];\n  }\n\n  /**\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @throws {!shaka.util.Error}\n   * @private\n   */\n  setPenAttributes_(dtvccPacket) {\n    // Two bytes follow. For the purpose of this decoder, we are only concerned\n    // with byte 2, which is of the form |I|U|EDTYP|FNTAG|.\n\n    // I (1 bit): Italics toggle.\n    // U (1 bit): Underline toggle.\n    // EDTYP (3 bits): Edge type (unused in this decoder).\n    // FNTAG (3 bits): Font tag (unused in this decoder).\n    // More info at https://en.wikipedia.org/wiki/CEA-708#SetPenAttributes_(0x90_+_2_bytes)\n\n    dtvccPacket.skip(1); // Skip first byte\n    const attrByte2 = dtvccPacket.readByte().value;\n\n    if (!this.currentWindow_) {\n      return;\n    }\n\n    const italics = (attrByte2 & 0x80) > 0;\n    const underline = (attrByte2 & 0x40) > 0;\n\n    this.currentWindow_.setPenItalics(italics);\n    this.currentWindow_.setPenUnderline(underline);\n  }\n\n  /**\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @throws {!shaka.util.Error}\n   * @private\n   */\n  setPenColor_(dtvccPacket) {\n    // Read foreground and background properties.\n    const foregroundByte = dtvccPacket.readByte().value;\n    const backgroundByte = dtvccPacket.readByte().value;\n    dtvccPacket.skip(1); // Edge color not supported, skip it.\n\n    if (!this.currentWindow_) {\n      return;\n    }\n\n    // Byte semantics are described at the following link:\n    // https://en.wikipedia.org/wiki/CEA-708#SetPenColor_(0x91_+_3_bytes)\n\n    // Foreground color properties: |FOP|F_R|F_G|F_B|.\n    const foregroundBlue = foregroundByte & 0x03;\n    const foregroundGreen = (foregroundByte & 0x0c) >> 2;\n    const foregroundRed = (foregroundByte & 0x30) >> 4;\n\n    // Background color properties: |BOP|B_R|B_G|B_B|.\n    const backgroundBlue = backgroundByte & 0x03;\n    const backgroundGreen = (backgroundByte & 0x0c) >> 2;\n    const backgroundRed = (backgroundByte & 0x30) >> 4;\n\n    const foregroundColor = this.rgbColorToHex_(\n        foregroundRed, foregroundGreen, foregroundBlue);\n\n    const backgroundColor = this.rgbColorToHex_(\n        backgroundRed, backgroundGreen, backgroundBlue);\n\n    this.currentWindow_.setPenTextColor(foregroundColor);\n    this.currentWindow_.setPenBackgroundColor(backgroundColor);\n  }\n\n  /**\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @throws {!shaka.util.Error}\n   * @private\n   */\n  setPenLocation_(dtvccPacket) {\n    // Following 2 bytes take the following form:\n    // b1 = |0|0|0|0|ROW| and b2 = |0|0|COLUMN|\n    const locationByte1 = dtvccPacket.readByte().value;\n    const locationByte2 = dtvccPacket.readByte().value;\n\n    if (!this.currentWindow_) {\n      return;\n    }\n\n    const row = locationByte1 & 0x0f;\n    const col = locationByte2 & 0x3f;\n    this.currentWindow_.setPenLocation(row, col);\n  }\n\n  /**\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @throws {!shaka.util.Error}\n   * @private\n   */\n  setWindowAttributes_(dtvccPacket) {\n    // 4 bytes follow, with the following form:\n    // Byte 1 contains fill-color information. Unused in this decoder.\n    // Byte 2 contains border color information. Unused in this decoder.\n    // Byte 3 contains justification information. In this decoder, we only use\n    // the last 2 bits, which specifies text justification on the screen.\n    // Byte 4 is special effects. Unused in this decoder.\n    // More info at https://en.wikipedia.org/wiki/CEA-708#SetWindowAttributes_(0x97_+_4_bytes)\n    dtvccPacket.skip(1); // Fill color not supported, skip.\n    dtvccPacket.skip(1); // Border colors not supported, skip.\n    const b3 = dtvccPacket.readByte().value;\n    dtvccPacket.skip(1); // Effects not supported, skip.\n\n    if (!this.currentWindow_) {\n      return;\n    }\n\n    // Word wrap is outdated as of CEA-708-E, so we ignore those bits.\n    // Extract the text justification and set it on the window.\n    const justification =\n      /** @type {!shaka.cea.Cea708Window.TextJustification} */ (b3 & 0x03);\n    this.currentWindow_.setJustification(justification);\n  }\n\n  /**\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @param {number} windowNum\n   * @param {number} pts\n   * @throws {!shaka.util.Error}\n   * @private\n   */\n  defineWindow_(dtvccPacket, windowNum, pts) {\n    // Create the window if it doesn't exist.\n    const windowAlreadyExists = this.windows_[windowNum] !== null;\n    if (!windowAlreadyExists) {\n      const window = new shaka.cea.Cea708Window(windowNum);\n      window.setStartTime(pts);\n      this.windows_[windowNum] = window;\n    }\n\n    // 6 Bytes follow, with the following form:\n    // b1 = |0|0|V|R|C|PRIOR| , b2 = |P|VERT_ANCHOR| , b3 = |HOR_ANCHOR|\n    // b4 = |ANC_ID|ROW_CNT| , b5 = |0|0|COL_COUNT| , b6 = |0|0|WNSTY|PNSTY|\n    // Semantics of these bytes at https://en.wikipedia.org/wiki/CEA-708#DefineWindow07_(0x98-0x9F,_+_6_bytes)\n    const b1 = dtvccPacket.readByte().value;\n    const b2 = dtvccPacket.readByte().value;\n    const b3 = dtvccPacket.readByte().value;\n    const b4 = dtvccPacket.readByte().value;\n    const b5 = dtvccPacket.readByte().value;\n    const b6 = dtvccPacket.readByte().value;\n\n    // As per 8.4.7 of CEA-708-E, row locks and column locks are to be ignored.\n    // So this decoder will ignore these values.\n\n    const visible = (b1 & 0x20) > 0;\n    const verticalAnchor = b2 & 0x7f;\n    const relativeToggle = (b2 & 0x80) > 0;\n    const horAnchor = b3;\n    const rowCount = (b4 & 0x0f) + 1; // Spec says to add 1.\n    const anchorId = (b4 & 0xf0) >> 4;\n    const colCount = (b5 & 0x3f) + 1; // Spec says to add 1.\n\n    // If pen style = 0 AND window previously existed, keep its pen style.\n    // Otherwise, change the pen style (For now, just reset to the default pen).\n    // TODO add support for predefined pen styles and fonts.\n    const penStyle = b6 & 0x07;\n    if (!windowAlreadyExists || penStyle !== 0) {\n      this.windows_[windowNum].resetPen();\n    }\n\n    this.windows_[windowNum].defineWindow(visible, verticalAnchor,\n        horAnchor, anchorId, relativeToggle, rowCount, colCount);\n\n    // Set the current window to the newly defined window.\n    this.currentWindow_ = this.windows_[windowNum];\n  }\n\n  /**\n   * Maps 64 possible CEA-708 colors to 8 CSS colors.\n   * @param {number} red value from 0-3\n   * @param {number} green value from 0-3\n   * @param {number} blue value from 0-3\n   * @return {string}\n   * @private\n   */\n  rgbColorToHex_(red, green, blue) {\n    // Rather than supporting 64 colors, this decoder supports 8 colors and\n    // gets the closest color, as per 9.19 of CEA-708-E. This is because some\n    // colors on television such as white, are often sent with lower intensity\n    // and often appear dull/greyish on the browser, making them hard to read.\n\n    // As per CEA-708-E 9.19, these mappings will map 64 colors to 8 colors.\n    const colorMapping = {0: 0, 1: 0, 2: 1, 3: 1};\n    red = colorMapping[red];\n    green = colorMapping[green];\n    blue = colorMapping[blue];\n\n    const colorCode = (red << 2) | (green << 1) | blue;\n    return shaka.cea.Cea708Service.Colors[colorCode];\n  }\n};\n\n/**\n * @private @const {number}\n */\nshaka.cea.Cea708Service.ASCII_BACKSPACE = 0x08;\n\n/**\n * @private @const {number}\n */\nshaka.cea.Cea708Service.ASCII_FORM_FEED = 0x0c;\n\n/**\n * @private @const {number}\n */\nshaka.cea.Cea708Service.ASCII_CARRIAGE_RETURN = 0x0d;\n\n/**\n * @private @const {number}\n */\nshaka.cea.Cea708Service.ASCII_HOR_CARRIAGE_RETURN = 0x0e;\n\n/**\n * For extended control codes in block_data on CEA-708, byte 1 is 0x10.\n * @private @const {number}\n */\nshaka.cea.Cea708Service.EXT_CEA708_CTRL_CODE_BYTE1 = 0x10;\n\n/**\n * Holds characters mapping for bytes that are G2 control codes.\n * @private @const {!Map<number, string>}\n */\nshaka.cea.Cea708Service.G2Charset = new Map([\n  [0x20, ' '], [0x21, '\\xa0'], [0x25, '…'], [0x2a, 'Š'], [0x2c, 'Œ'],\n  [0x30, '█'], [0x31, '‘'], [0x32, '’'], [0x33, '“'], [0x34, '”'],\n  [0x35, '•'], [0x39, '™'], [0x3a, 'š'], [0x3c, 'œ'], [0x3d, '℠'],\n  [0x3f, 'Ÿ'], [0x76, '⅛'], [0x77, '⅜'], [0x78, '⅝'], [0x79, '⅞'],\n  [0x7a, '│'], [0x7b, '┐'], [0x7c, '└'], [0x7d, '─'], [0x7e, '┘'], [0x7f, '┌'],\n]);\n\n/**\n * An array of 8 colors that 64 colors can be quantized to. Order here matters.\n * @private @const {!Array<string>}\n */\nshaka.cea.Cea708Service.Colors = [\n  'black', 'blue', 'green', 'cyan',\n  'red', 'magenta', 'yellow', 'white',\n];\n\n/**\n * CEA-708 closed captions byte.\n * @typedef {{\n *   pts: number,\n *   type: number,\n *   value: number,\n *   order: number\n * }}\n *\n * @property {number} pts\n *   Presentation timestamp (in second) at which this packet was received.\n * @property {number} type\n *   Type of the byte. Either 2 or 3, DTVCC Packet Data or a DTVCC Packet Start.\n * @property {number} value The byte containing data relevant to the packet.\n * @property {number} order\n *   A number indicating the order this packet was received in a sequence\n *   of packets. Used to break ties in a stable sorting algorithm\n */\nshaka.cea.Cea708Service.Cea708Byte;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.CeaDecoder');\n\ngoog.require('shaka.cea.Cea608DataChannel');\ngoog.require('shaka.cea.Cea708Service');\ngoog.require('shaka.cea.DtvccPacketBuilder');\ngoog.require('shaka.cea.ICaptionDecoder');\ngoog.require('shaka.log');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.requireType('shaka.cea.DtvccPacket');\n\n\n/**\n * CEA-X08 captions decoder. Currently only CEA-608 supported.\n * @implements {shaka.cea.ICaptionDecoder}\n */\nshaka.cea.CeaDecoder = class {\n  /** */\n  constructor() {\n    /**\n     * An array of CEA-608 closed caption data extracted for decoding.\n     * @private {!Array<!shaka.cea.Cea608DataChannel.Cea608Packet>}\n     */\n    this.cea608DataArray_ = [];\n\n    /**\n     * An array of CEA-708 closed caption data extracted for decoding.\n     * @private {!Array<!shaka.cea.Cea708Service.Cea708Byte>}\n     */\n    this.cea708DataArray_ = [];\n\n    /**\n     * A DTVCC Packet builder for CEA-708 data.\n     * @private {!shaka.cea.DtvccPacketBuilder}\n     */\n    this.dtvccPacketBuilder_ = new shaka.cea.DtvccPacketBuilder();\n\n    /**\n     * Number of consecutive bad frames decoded on CEA-608.\n     * @private {number}\n     */\n    this.badFrames_ = 0;\n\n    /**\n     * A map containing the stream for each mode.\n     * @private {!Map<string, !shaka.cea.Cea608DataChannel>}\n     */\n    this.cea608ModeToStream_ = new Map([\n      ['CC1', new shaka.cea.Cea608DataChannel(0, 0)], // F1 + C1 -> CC1\n      ['CC2', new shaka.cea.Cea608DataChannel(0, 1)], // F1 + C2 -> CC2\n      ['CC3', new shaka.cea.Cea608DataChannel(1, 0)], // F2 + C1 -> CC3\n      ['CC4', new shaka.cea.Cea608DataChannel(1, 1)], // F2 + C2 -> CC4\n    ]);\n\n    /**\n     * The current channel that is active on CEA-608 field 1.\n     * @private {number}\n     */\n    this.currentField1Channel_ = 0;\n\n    /**\n     * The current channel that is active on CEA-608 field 2.\n     * @private {number}\n     */\n    this.currentField2Channel_ = 0;\n\n    /**\n     * Map of service number to CEA-708 services, initially empty. Since there\n     * can be up to 63 services, they are created dynamically only when needed.\n     * @private {!Map<number, shaka.cea.Cea708Service>}\n     */\n    this.serviceNumberToService_ = new Map();\n\n    this.reset();\n  }\n\n  /**\n   * Clears the decoder.\n   * @override\n   */\n  clear() {\n    this.badFrames_ = 0;\n    this.cea608DataArray_ = [];\n    this.cea708DataArray_ = [];\n    this.dtvccPacketBuilder_.clear();\n    this.reset();\n\n    // Clear all the CEA-708 services.\n    for (const service of this.serviceNumberToService_.values()) {\n      service.clear();\n    }\n  }\n\n  /**\n   * Resets the decoder.\n   */\n  reset() {\n    this.currentField1Channel_ = 0;\n    this.currentField2Channel_ = 0;\n    for (const stream of this.cea608ModeToStream_.values()) {\n      stream.reset();\n    }\n  }\n\n  /**\n   * Extracts closed caption bytes from CEA-X08 packets from the stream based on\n   * ANSI/SCTE 128 and A/53, Part 4.\n   * @override\n   */\n  extract(userDataSeiMessage, pts) {\n    const reader = new shaka.util.DataViewReader(\n        userDataSeiMessage, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n    if (reader.readUint8() !== shaka.cea.CeaDecoder.USA_COUNTRY_CODE) {\n      return;\n    }\n    if (reader.readUint16() !== shaka.cea.CeaDecoder.ATSC_PROVIDER_CODE) {\n      return;\n    }\n    if (reader.readUint32() !== shaka.cea.CeaDecoder.ATSC1_USER_IDENTIFIER) {\n      return;\n    }\n\n    // user_data_type_code: 0x03 - cc_data()\n    if (reader.readUint8() !== 0x03) {\n      return;\n    }\n\n    // 1 bit reserved\n    // 1 bit process_cc_data_flag\n    // 1 bit zero_bit\n    // 5 bits cc_count\n    const captionData = reader.readUint8();\n    // If process_cc_data_flag is not set, do not process this data.\n    if ((captionData & 0x40) === 0) {\n      return;\n    }\n\n    const count = captionData & 0x1f;\n\n    // 8 bits reserved\n    reader.skip(1);\n\n    for (let i = 0; i < count; i++) {\n      const cc = reader.readUint8();\n      // When ccValid is 0, the next two bytes should be discarded.\n      const ccValid = (cc & 0x04) >> 2;\n      const ccData1 = reader.readUint8();\n      const ccData2 = reader.readUint8();\n\n      if (ccValid) {\n        const ccType = cc & 0x03;\n        // Send the packet to the appropriate data array (CEA-608 or CEA-708).\n        if (ccType === shaka.cea.CeaDecoder.NTSC_CC_FIELD_1 ||\n            ccType === shaka.cea.CeaDecoder.NTSC_CC_FIELD_2) {\n          // CEA-608 NTSC (Line 21) Data.\n          this.cea608DataArray_.push({\n            pts,\n            type: ccType,\n            ccData1,\n            ccData2,\n            order: this.cea608DataArray_.length,\n          });\n        } else {\n          // CEA-708 DTVCC Data.\n          this.cea708DataArray_.push({\n            pts,\n            type: ccType,\n            value: ccData1,\n            order: this.cea708DataArray_.length,\n          });\n\n          // The second byte should always be labelled as DTVCC packet data.\n          // Even if this pair was a DTVCC packet start, only the first byte\n          // contains header info, and the second byte is just packet data.\n          this.cea708DataArray_.push({\n            pts,\n            type: shaka.cea.DtvccPacketBuilder.DTVCC_PACKET_DATA,\n            value: ccData2,\n            order: this.cea708DataArray_.length,\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Decodes extracted closed caption data.\n   * @override\n   */\n  decode() {\n    /** @type {!Array.<!shaka.cea.ICaptionDecoder.ClosedCaption>} */\n    const parsedClosedCaptions = [];\n\n    // In some versions of Chrome, and other browsers, the default sorting\n    // algorithm isn't stable. This comparator sorts on presentation\n    // timestamp, and breaks ties on receive order (position in array).\n    const stableComparator =\n      (p1, p2) => (p1.pts - p2.pts) || (p1.order - p2.order);\n\n    this.cea608DataArray_.sort(stableComparator);\n    this.cea708DataArray_.sort(stableComparator);\n\n    // CEA-608 packets are just byte pairs. Decode all of them.\n    for (const cea608Packet of this.cea608DataArray_) {\n      const parsedClosedCaption = this.decodeCea608_(cea608Packet);\n      if (parsedClosedCaption) {\n        parsedClosedCaptions.push(parsedClosedCaption);\n      }\n    }\n\n    // CEA-708 packets are DTVCC packets composed of many byte pairs. Add all\n    // byte pairs to the packet builder, and process + clear any ready packets.\n    for (const cea708Byte of this.cea708DataArray_) {\n      this.dtvccPacketBuilder_.addByte(cea708Byte);\n    }\n    const dtvccPackets = this.dtvccPacketBuilder_.getBuiltPackets();\n    for (const dtvccPacket of dtvccPackets) {\n      const closedCaptions = this.decodeCea708_(dtvccPacket);\n      parsedClosedCaptions.push(...closedCaptions);\n    }\n\n    // Clear all processed data.\n    this.dtvccPacketBuilder_.clearBuiltPackets();\n    this.cea608DataArray_ = [];\n    this.cea708DataArray_ = [];\n\n    return parsedClosedCaptions;\n  }\n\n  /**\n   * Decodes a CEA-608 closed caption packet based on ANSI/CEA-608.\n   * @param {shaka.cea.Cea608DataChannel.Cea608Packet} ccPacket\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  decodeCea608_(ccPacket) {\n    const fieldNum = ccPacket.type;\n\n    // If this packet is a control code, then it also sets the channel.\n    // For control codes, cc_data_1 has the form |P|0|0|1|C|X|X|X|.\n    // \"C\" is the channel bit. It indicates whether to set C2 active.\n    if (shaka.cea.Cea608DataChannel.isControlCode(ccPacket.ccData1)) {\n      const channelNum = (ccPacket.ccData1 >> 3) & 0x01; // Get channel bit.\n\n      // Change the stream based on the field, and the new channel\n      if (fieldNum === 0) {\n        this.currentField1Channel_ = channelNum;\n      } else {\n        this.currentField2Channel_ = channelNum;\n      }\n    }\n\n    // Get the correct stream for this caption packet (CC1, ..., CC4)\n    const selectedChannel = fieldNum ?\n        this.currentField2Channel_ : this.currentField1Channel_;\n    const selectedMode = `CC${(fieldNum << 1) | selectedChannel + 1}`;\n    const selectedStream = this.cea608ModeToStream_.get(selectedMode);\n\n    // Check for bad frames (bad pairs). This can be two 0xff, two 0x00, or any\n    // byte of even parity. ccData1 and ccData2 should be uint8 of odd parity.\n    if ((ccPacket.ccData1 === 0xff && ccPacket.ccData2 === 0xff) ||\n        (!ccPacket.ccData1 && !ccPacket.ccData2) ||\n        !this.isOddParity_(ccPacket.ccData1) ||\n        !this.isOddParity_(ccPacket.ccData2)) {\n      // Per CEA-608-B C.21, reset the memory after 45 consecutive bad frames.\n      if (++this.badFrames_ >= 45) {\n        this.reset();\n      }\n      return null;\n    }\n    this.badFrames_ = 0;\n\n    // Remove the MSB (parity bit).\n    ccPacket.ccData1 &= 0x7f;\n    ccPacket.ccData2 &= 0x7f;\n\n    // Check for empty captions and skip them.\n    if (!ccPacket.ccData1 && !ccPacket.ccData2) {\n      return null;\n    }\n\n    // Process the clean CC data pair.\n    let parsedClosedCaption = null;\n    if (shaka.cea.Cea608DataChannel.isControlCode(ccPacket.ccData1)) {\n      parsedClosedCaption = selectedStream.handleControlCode(ccPacket);\n    } else {\n      // Handle as a Basic North American Character.\n      selectedStream.handleBasicNorthAmericanChar(\n          ccPacket.ccData1, ccPacket.ccData2);\n    }\n\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Decodes a CEA-708 DTVCC packet based on ANSI/CTA-708-E.\n   * @param {shaka.cea.DtvccPacket} dtvccPacket\n   * @return {!Array<!shaka.cea.ICaptionDecoder.ClosedCaption>}\n   * @private\n   */\n  decodeCea708_(dtvccPacket) {\n    const parsedClosedCaptions = [];\n    try {\n      while (dtvccPacket.hasMoreData()) {\n        // Process a service block.\n        const serviceBlockHeader = dtvccPacket.readByte().value;\n\n        // First 3 bits are service number, next 5 are block size,\n        // representing the number of bytes coming in this block\n        // (discluding a possible extended service block header byte)\n        let serviceNumber = (serviceBlockHeader & 0xe0) >> 5;\n        const blockSize = serviceBlockHeader & 0x1f;\n\n        if (serviceNumber === /* 0b111 */ 0x07 && blockSize != 0) {\n          // 2 bits null padding, 6 bits extended service number\n          const extendedServiceBlockHeader = dtvccPacket.readByte().value;\n          serviceNumber = extendedServiceBlockHeader & 0x3f;\n        }\n\n        // As per CEA-708-E, service number 0 is invalid, and should be ignored.\n        if (serviceNumber != 0) {\n          // If the service doesn't already exist, create it.\n          if (!this.serviceNumberToService_.has(serviceNumber)) {\n            const service = new shaka.cea.Cea708Service(serviceNumber);\n            this.serviceNumberToService_.set(serviceNumber, service);\n          }\n          const service = this.serviceNumberToService_.get(serviceNumber);\n\n          // Process all control codes.\n          const startPos = dtvccPacket.getPosition();\n\n          // Execute this loop `blockSize` times, to decode the control codes.\n          while (dtvccPacket.getPosition() - startPos < blockSize) {\n            const closedCaption = service.handleCea708ControlCode(dtvccPacket);\n            if (closedCaption) {\n              parsedClosedCaptions.push(closedCaption);\n            }\n          }  // position < end of block\n        }  // serviceNumber != 0\n      }  // hasMoreData\n    } catch (error) {\n      if (error instanceof shaka.util.Error &&\n      error.code === shaka.util.Error.Code.BUFFER_READ_OUT_OF_BOUNDS) {\n        shaka.log.warnOnce('CEA708_INVALID_DATA',\n            'Buffer read out of bounds / invalid CEA-708 Data.');\n      } else {\n        // This is an unexpected error, and should be rethrown.\n        throw error;\n      }\n    }\n    return parsedClosedCaptions;\n  }\n\n  /**\n   * Checks if a byte has odd parity (Odd number of 1s in binary).\n   * @param {number} byte\n   * @return {boolean} True if the byte has odd parity.\n   * @private\n   */\n  isOddParity_(byte) {\n    let parity = 0;\n    while (byte) {\n      parity ^= (byte & 1); // toggle parity if low bit is 1\n      byte >>= 1; // shift away the low bit\n    }\n    return parity === 1;\n  }\n};\n\n/**\n * itu_t_35_provider_code for ATSC user_data\n * @private @const {number}\n */\nshaka.cea.CeaDecoder.ATSC_PROVIDER_CODE = 0x0031;\n\n/**\n * When provider is ATSC user data, the ATSC_user_identifier code\n * for ATSC1_data is \"GA94\" (0x47413934)\n * @private @const {number}\n */\nshaka.cea.CeaDecoder.ATSC1_USER_IDENTIFIER = 0x47413934;\n\n/**\n * @private @const {number}\n */\nshaka.cea.CeaDecoder.NTSC_CC_FIELD_1 = 0;\n\n/**\n * @private @const {number}\n */\nshaka.cea.CeaDecoder.NTSC_CC_FIELD_2 = 1;\n\n/**\n * 0xB5 is USA's code (Rec. ITU-T T.35)\n * @private @const {number}\n */\nshaka.cea.CeaDecoder.USA_COUNTRY_CODE = 0xb5;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Mp4BoxParsers');\n\ngoog.require('shaka.util.DataViewReader');\n\nshaka.util.Mp4BoxParsers = class {\n  /**\n   * Parses a TFHD Box.\n   * @param {!shaka.util.DataViewReader} reader\n   * @param {number} flags\n   * @return {!shaka.util.ParsedTFHDBox}\n   */\n  static parseTFHD(reader, flags) {\n    let defaultSampleDuration = null;\n    let defaultSampleSize = null;\n\n    const trackId = reader.readUint32(); // Read \"track_ID\"\n\n    // Skip \"base_data_offset\" if present.\n    if (flags & 0x000001) {\n      reader.skip(8);\n    }\n\n    // Skip \"sample_description_index\" if present.\n    if (flags & 0x000002) {\n      reader.skip(4);\n    }\n\n    // Read \"default_sample_duration\" if present.\n    if (flags & 0x000008) {\n      defaultSampleDuration = reader.readUint32();\n    }\n\n    // Read \"default_sample_size\" if present.\n    if (flags & 0x000010) {\n      defaultSampleSize = reader.readUint32();\n    }\n\n    return {\n      trackId,\n      defaultSampleDuration,\n      defaultSampleSize,\n    };\n  }\n\n  /**\n   * Parses a TFDT Box.\n   * @param {!shaka.util.DataViewReader} reader\n   * @param {number} version\n   * @return {!shaka.util.ParsedTFDTBox}\n   */\n  static parseTFDT(reader, version) {\n    const baseMediaDecodeTime = version == 1 ?\n        reader.readUint64() : reader.readUint32();\n\n    return {\n      baseMediaDecodeTime,\n    };\n  }\n\n  /**\n   * Parses a MDHD Box.\n   * @param {!shaka.util.DataViewReader} reader\n   * @param {number} version\n   * @return {!shaka.util.ParsedMDHDBox}\n   */\n  static parseMDHD(reader, version) {\n    if (version == 1) {\n      reader.skip(8); // Skip \"creation_time\"\n      reader.skip(8); // Skip \"modification_time\"\n    } else {\n      reader.skip(4); // Skip \"creation_time\"\n      reader.skip(4); // Skip \"modification_time\"\n    }\n\n    const timescale = reader.readUint32();\n\n    return {\n      timescale,\n    };\n  }\n\n  /**\n   * Parses a TREX Box.\n   * @param {!shaka.util.DataViewReader} reader\n   * @return {!shaka.util.ParsedTREXBox}\n   */\n  static parseTREX(reader) {\n    reader.skip(4); // Skip \"track_ID\"\n    reader.skip(4); // Skip \"default_sample_description_index\"\n    const defaultSampleDuration = reader.readUint32();\n    const defaultSampleSize = reader.readUint32();\n\n    return {\n      defaultSampleDuration,\n      defaultSampleSize,\n    };\n  }\n\n  /**\n   * Parses a TRUN Box.\n   * @param {!shaka.util.DataViewReader} reader\n   * @param {number} version\n   * @param {number} flags\n   * @return {!shaka.util.ParsedTRUNBox}\n   */\n  static parseTRUN(reader, version, flags) {\n    const sampleCount = reader.readUint32();\n    const sampleData = [];\n\n    // Skip \"data_offset\" if present.\n    if (flags & 0x000001) {\n      reader.skip(4);\n    }\n\n    // Skip \"first_sample_flags\" if present.\n    if (flags & 0x000004) {\n      reader.skip(4);\n    }\n\n    for (let i = 0; i < sampleCount; i++) {\n      /** @type {shaka.util.ParsedTRUNSample} */\n      const sample = {\n        sampleDuration: null,\n        sampleSize: null,\n        sampleCompositionTimeOffset: null,\n      };\n\n      // Read \"sample duration\" if present.\n      if (flags & 0x000100) {\n        sample.sampleDuration = reader.readUint32();\n      }\n\n      // Read \"sample_size\" if present.\n      if (flags & 0x000200) {\n        sample.sampleSize = reader.readUint32();\n      }\n\n      // Skip \"sample_flags\" if present.\n      if (flags & 0x000400) {\n        reader.skip(4);\n      }\n\n      // Read \"sample_time_offset\" if present.\n      if (flags & 0x000800) {\n        sample.sampleCompositionTimeOffset = version == 0 ?\n              reader.readUint32() :\n              reader.readInt32();\n      }\n\n      sampleData.push(sample);\n    }\n\n    return {\n      sampleCount,\n      sampleData,\n    };\n  }\n\n  /**\n   * Parses a TKHD Box.\n   * @param {!shaka.util.DataViewReader} reader\n   * @param {number} version\n   * @return {!shaka.util.ParsedTKHDBox}\n   */\n  static parseTKHD(reader, version) {\n    let trackId = 0;\n    if (version == 1) {\n      reader.skip(8); // Skip \"creation_time\"\n      reader.skip(8); // Skip \"modification_time\"\n      trackId = reader.readUint32();\n    } else {\n      reader.skip(4); // Skip \"creation_time\"\n      reader.skip(4); // Skip \"modification_time\"\n      trackId = reader.readUint32();\n    }\n\n    return {\n      trackId,\n    };\n  }\n};\n\n\n/**\n * @typedef {{\n *    trackId: number,\n *    defaultSampleDuration: ?number,\n *    defaultSampleSize: ?number\n * }}\n *\n * @property {number} trackId\n *   As per the spec: an integer that uniquely identifies this\n *   track over the entire life‐time of this presentation\n * @property {?number} defaultSampleDuration\n *   If specified via flags, this overrides the default sample\n *   duration in the Track Extends Box for this fragment\n * @property {?number} defaultSampleSize\n *   If specified via flags, this overrides the default sample\n *   size in the Track Extends Box for this fragment\n *\n * @exportDoc\n */\nshaka.util.ParsedTFHDBox;\n\n/**\n * @typedef {{\n *    baseMediaDecodeTime: number\n * }}\n *\n * @property {number} baseMediaDecodeTime\n *   As per the spec: the absolute decode time, measured on the media\n *   timeline, of the first sample in decode order in the track fragment\n *\n * @exportDoc\n */\nshaka.util.ParsedTFDTBox;\n\n/**\n * @typedef {{\n *    timescale: number\n * }}\n *\n * @property {number} timescale\n *   As per the spec: an integer that specifies the time‐scale for this media;\n *   this is the number of time units that pass in one second\n *\n * @exportDoc\n */\nshaka.util.ParsedMDHDBox;\n\n/**\n * @typedef {{\n *    defaultSampleDuration: number,\n *    defaultSampleSize: number\n * }}\n *\n * @property {number} defaultSampleDuration\n *   The default sample duration to be used in track fragments\n * @property {number} defaultSampleSize\n *   The default sample size to be used in track fragments\n *\n * @exportDoc\n */\nshaka.util.ParsedTREXBox;\n\n/**\n * @typedef {{\n *    sampleCount: number,\n *    sampleData: !Array.<shaka.util.ParsedTRUNSample>\n * }}\n *\n * @property {number} sampleCount\n *   As per the spec: the number of samples being added in this run;\n * @property {!Array.<shaka.util.ParsedTRUNSample>} sampleData\n *   An array of size <sampleCount> containing data for each sample\n *\n * @exportDoc\n */\nshaka.util.ParsedTRUNBox;\n\n/**\n * @typedef {{\n *    sampleDuration: ?number,\n *    sampleSize: ?number,\n *    sampleCompositionTimeOffset: ?number\n *  }}\n *\n * @property {?number} sampleDuration\n *   The length of the sample in timescale units.\n * @property {?number} sampleSize\n *   The size of the sample in bytes.\n * @property {?number} sampleCompositionTimeOffset\n *   The time since the start of the sample in timescale units. Time\n *   offset is based of the start of the sample. If this value is\n *   missing, the accumulated durations preceeding this time sample will\n *   be used to create the start time.\n *\n * @exportDoc\n */\nshaka.util.ParsedTRUNSample;\n\n/**\n * @typedef {{\n *    trackId: number\n *  }}\n *\n * @property {number} trackId\n *   Unique ID indicative of this track\n *\n * @exportDoc\n */\nshaka.util.ParsedTKHDBox;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.Mp4CeaParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.cea.ICeaParser');\ngoog.require('shaka.cea.SeiProcessor');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Mp4BoxParsers');\n\n/**\n * MPEG4 stream parser used for extracting 708 closed captions data.\n * @implements {shaka.cea.ICeaParser}\n */\nshaka.cea.Mp4CeaParser = class {\n  /** */\n  constructor() {\n    /**\n     * SEI data processor.\n     * @private\n     * @const {!shaka.cea.SeiProcessor}\n     */\n    this.seiProcessor_ = new shaka.cea.SeiProcessor();\n\n    /**\n     * Map of track id to corresponding timescale.\n     * @private {!Map<number, number>}\n     */\n    this.trackIdToTimescale_ = new Map();\n\n    /**\n     * Default sample duration, as specified by the TREX box.\n     * @private {number}\n     */\n    this.defaultSampleDuration_ = 0;\n\n    /**\n     * Default sample size, as specified by the TREX box.\n     * @private {number}\n     */\n    this.defaultSampleSize_ = 0;\n  }\n\n  /**\n   * Parses the init segment. Gets Default Sample Duration and Size from the\n   * TREX box, and constructs a map of Track IDs to timescales. Each TRAK box\n   * contains a track header (TKHD) containing track ID, and a media header box\n   * (MDHD) containing the timescale for the track\n   * @override\n   */\n  init(initSegment) {\n    const Mp4Parser = shaka.util.Mp4Parser;\n    const trackIds = [];\n    const timescales = [];\n\n    new Mp4Parser()\n        .box('moov', Mp4Parser.children)\n        .box('mvex', Mp4Parser.children)\n        .fullBox('trex', (box) => {\n          const parsedTREXBox = shaka.util.Mp4BoxParsers.parseTREX(\n              box.reader);\n\n          this.defaultSampleDuration_ = parsedTREXBox.defaultSampleDuration;\n          this.defaultSampleSize_ = parsedTREXBox.defaultSampleSize;\n        })\n        .box('trak', Mp4Parser.children)\n        .fullBox('tkhd', (box) => {\n          goog.asserts.assert(\n              box.version != null,\n              'TKHD is a full box and should have a valid version.');\n          const parsedTKHDBox = shaka.util.Mp4BoxParsers.parseTKHD(\n              box.reader, box.version);\n          trackIds.push(parsedTKHDBox.trackId);\n        })\n        .box('mdia', Mp4Parser.children)\n        .fullBox('mdhd', (box) => {\n          goog.asserts.assert(\n              box.version != null,\n              'MDHD is a full box and should have a valid version.');\n          const parsedMDHDBox = shaka.util.Mp4BoxParsers.parseMDHD(\n              box.reader, box.version);\n          timescales.push(parsedMDHDBox.timescale);\n        })\n        .parse(initSegment, /* partialOkay= */ true);\n\n    // At least one track should exist, and each track should have a\n    // corresponding Id in TKHD box, and timescale in its MDHD box\n    if (!trackIds.length|| !timescales.length ||\n      trackIds.length != timescales.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_CEA);\n    }\n\n    // Populate the map from track Id to timescale\n    trackIds.forEach((trackId, idx) => {\n      this.trackIdToTimescale_.set(trackId, timescales[idx]);\n    });\n  }\n\n  /**\n   * Parses each video segment. In fragmented MP4s, MOOF and MDAT come in\n   * pairs. The following logic gets the necessary info from MOOFs to parse\n   * MDATs (base media decode time, sample sizes/offsets/durations, etc),\n   * and then parses the MDAT boxes for CEA-708 packets using this information.\n   * CEA-708 packets are returned in the callback.\n   * @override\n   */\n  parse(mediaSegment) {\n    const Mp4Parser = shaka.util.Mp4Parser;\n\n    /** @type {!Array<!shaka.cea.ICeaParser.CaptionPacket>} **/\n    const captionPackets = [];\n\n    // Fields that are found in MOOF boxes\n    let defaultSampleDuration = this.defaultSampleDuration_;\n    let defaultSampleSize = this.defaultSampleSize_;\n    let sampleData = [];\n    let baseMediaDecodeTime = null;\n    let timescale = shaka.cea.ICeaParser.DEFAULT_TIMESCALE_VALUE;\n\n    new Mp4Parser()\n        .box('moof', Mp4Parser.children)\n        .box('traf', Mp4Parser.children)\n        .fullBox('trun', (box) => {\n          goog.asserts.assert(\n              box.version != null && box.flags!=null,\n              'TRUN is a full box and should have a valid version & flags.');\n\n          const parsedTRUN = shaka.util.Mp4BoxParsers.parseTRUN(\n              box.reader, box.version, box.flags);\n\n          sampleData = parsedTRUN.sampleData;\n        })\n\n        .fullBox('tfhd', (box) => {\n          goog.asserts.assert(\n              box.flags != null,\n              'TFHD is a full box and should have valid flags.');\n\n          const parsedTFHD = shaka.util.Mp4BoxParsers.parseTFHD(\n              box.reader, box.flags);\n\n          // If specified, defaultSampleDuration and defaultSampleSize\n          // override the ones specified in the TREX box\n          defaultSampleDuration = parsedTFHD.defaultSampleDuration ||\n              this.defaultSampleDuration_;\n\n          defaultSampleSize = parsedTFHD.defaultSampleSize ||\n              this.defaultSampleSize_;\n\n          const trackId = parsedTFHD.trackId;\n\n          // Get the timescale from the track Id\n          if (this.trackIdToTimescale_.has(trackId)) {\n            timescale = this.trackIdToTimescale_.get(trackId);\n          }\n        })\n\n        .fullBox('tfdt', (box) => {\n          goog.asserts.assert(\n              box.version != null,\n              'TFDT is a full box and should have a valid version.');\n\n          const parsedTFDT = shaka.util.Mp4BoxParsers.parseTFDT(\n              box.reader, box.version);\n\n          baseMediaDecodeTime = parsedTFDT.baseMediaDecodeTime;\n        })\n        .box('mdat', (box) => {\n          if (baseMediaDecodeTime === null) {\n            // This field should have been populated by\n            // the Base Media Decode time in the TFDT box\n            throw new shaka.util.Error(\n                shaka.util.Error.Severity.CRITICAL,\n                shaka.util.Error.Category.TEXT,\n                shaka.util.Error.Code.INVALID_MP4_CEA);\n          }\n          this.parseMdat_(box.reader, baseMediaDecodeTime, timescale,\n              defaultSampleDuration, defaultSampleSize, sampleData,\n              captionPackets);\n        })\n        .parse(mediaSegment, /* partialOkay= */ false);\n\n    return captionPackets;\n  }\n\n  /**\n   * Parse MDAT box.\n   * @param {!shaka.util.DataViewReader} reader\n   * @param {number} time\n   * @param {number} timescale\n   * @param {number} defaultSampleDuration\n   * @param {number} defaultSampleSize\n   * @param {!Array<shaka.util.ParsedTRUNSample>} sampleData\n   * @param {!Array<!shaka.cea.ICeaParser.CaptionPacket>} captionPackets\n   * @private\n   */\n  parseMdat_(reader, time, timescale, defaultSampleDuration,\n      defaultSampleSize, sampleData, captionPackets) {\n    let sampleIndex = 0;\n\n    // The fields in each ParsedTRUNSample contained in the sampleData\n    // array are nullable. In the case of sample data and sample duration,\n    // we use the defaults provided by the TREX/TFHD boxes. For sample\n    // composition time offset, we default to 0.\n    let sampleSize = defaultSampleSize;\n\n    if (sampleData.length) {\n      sampleSize = sampleData[0].sampleSize || defaultSampleSize;\n    }\n\n    while (reader.hasMoreData()) {\n      const naluSize = reader.readUint32();\n      const naluType = reader.readUint8() & 0x1F;\n      if (naluType == shaka.cea.ICeaParser.NALU_TYPE_SEI) {\n        let timeOffset = 0;\n\n        if (sampleData.length > sampleIndex) {\n          timeOffset = sampleData[sampleIndex].sampleCompositionTimeOffset || 0;\n        }\n\n        const pts = (time + timeOffset)/timescale;\n        for (const packet of this.seiProcessor_\n            .process(reader.readBytes(naluSize - 1))) {\n          captionPackets.push({\n            packet,\n            pts,\n          });\n        }\n      } else {\n        try {\n          reader.skip(naluSize - 1);\n        } catch (e) {\n          // It is necessary to ignore this error because it can break the start\n          // of playback even if the user does not want to see the subtitles.\n          break;\n        }\n      }\n      sampleSize -= (naluSize + 4);\n      if (sampleSize == 0) {\n        if (sampleData.length > sampleIndex) {\n          time += sampleData[sampleIndex].sampleDuration ||\n              defaultSampleDuration;\n        } else {\n          time += defaultSampleDuration;\n        }\n\n        sampleIndex++;\n\n        if (sampleData.length > sampleIndex) {\n          sampleSize = sampleData[sampleIndex].sampleSize || defaultSampleSize;\n        } else {\n          sampleSize = defaultSampleSize;\n        }\n      }\n    }\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.ICeaParser');\n\n/**\n * Interface for parsing inband closed caption data from MP4 streams.\n * @interface\n */\nshaka.cea.ICeaParser = class {\n  /**\n   * Initializes the parser with init segment data.\n   * @param {!BufferSource} initSegment init segment to parse.\n   */\n  init(initSegment) {}\n\n  /**\n   * Parses the stream and extracts closed captions packets.\n   * @param {!BufferSource} mediaSegment media segment to parse.\n   * @return {!Array<!shaka.cea.ICeaParser.CaptionPacket>}\n   */\n  parse(mediaSegment) {}\n};\n\n/**\n * NALU type for Supplemental Enhancement Information (SEI).\n * @const {number}\n */\nshaka.cea.ICeaParser.NALU_TYPE_SEI = 0x06;\n\n/**\n * Default timescale value for a track.\n */\nshaka.cea.ICeaParser.DEFAULT_TIMESCALE_VALUE = 90000;\n\n/**\n * @typedef {{\n *   packet: !Uint8Array,\n *   pts: number\n * }}\n *\n * @description Parsed Caption Packet.\n * @property {!Uint8Array} packet\n * Caption packet. More specifically, it contains a \"User data\n * registered by Recommendation ITU-T T.35 SEI message\", from section D.1.6\n * and section D.2.6 of Rec. ITU-T H.264 (06/2019).\n * @property {number} pts\n * The presentation timestamp (pts) at which the ITU-T T.35 data shows up.\n * in seconds.\n * @exportDoc\n */\nshaka.cea.ICeaParser.CaptionPacket;\n\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.SeiProcessor');\n\n\n/**\n * H.264 SEI NALU Parser used for extracting 708 closed caption packets.\n */\nshaka.cea.SeiProcessor = class {\n  /**\n   * Processes supplemental enhancement information data.\n   * @param {!Uint8Array} naluData NALU from which SEI data is to be processed.\n   * @return {!Array.<!Uint8Array>}\n   */\n  process(naluData) {\n    const seiPayloads = [];\n    const naluClone = this.removeEmu(naluData);\n\n    // The following is an implementation of section 7.3.2.3.1\n    // in Rec. ITU-T H.264 (06/2019), the H.264 spec.\n    let offset = 0;\n\n    while (offset < naluClone.length) {\n      let payloadType = 0; // SEI payload type as defined by H.264 spec\n      while (naluClone[offset] == 0xFF) {\n        payloadType += 255;\n        offset++;\n      }\n      payloadType += naluClone[offset++];\n\n      let payloadSize = 0; // SEI payload size as defined by H.264 spec\n      while (naluClone[offset] == 0xFF) {\n        payloadSize += 255;\n        offset++;\n      }\n      payloadSize += naluClone[offset++];\n\n      // Payload type 4 is user_data_registered_itu_t_t35, as per the H.264\n      // spec. This payload type contains caption data.\n      if (payloadType == 0x04) {\n        seiPayloads.push(naluClone.subarray(offset, offset + payloadSize));\n      }\n      offset += payloadSize;\n    }\n\n    return seiPayloads;\n  }\n\n\n  /**\n   * Removes H.264 emulation prevention bytes from the byte array.\n   *\n   * Note: Remove bytes by shifting will cause Chromium (VDA) to complain\n   * about conformance. Recreating a new array solves it.\n   *\n   * @param {!Uint8Array} naluData NALU from which EMUs should be removed.\n   * @return {!Uint8Array} The NALU with the emulation prevention byte removed.\n   */\n  removeEmu(naluData) {\n    let naluClone = naluData;\n    let zeroCount = 0;\n    let src = 0;\n    while (src < naluClone.length) {\n      if (zeroCount == 2 && naluClone[src] == 0x03) {\n        // 0x00, 0x00, 0x03 pattern detected\n        zeroCount = 0;\n\n        // Splice the array and recreate a new one, instead of shifting bytes\n        const newArr = [...naluClone];\n        newArr.splice(src, 1);\n        naluClone = new Uint8Array(newArr);\n      } else {\n        if (naluClone[src] == 0x00) {\n          zeroCount++;\n        } else {\n          zeroCount = 0;\n        }\n      }\n      src++;\n    }\n    return naluClone;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.ClosedCaptionParser');\ngoog.provide('shaka.media.IClosedCaptionParser');\n\ngoog.require('shaka.cea.CeaDecoder');\ngoog.require('shaka.cea.Mp4CeaParser');\ngoog.require('shaka.util.BufferUtils');\ngoog.requireType('shaka.cea.ICaptionDecoder');\ngoog.requireType('shaka.cea.ICeaParser');\n\n\n/**\n * The IClosedCaptionParser defines the interface to provide all operations for\n * parsing the closed captions embedded in Dash videos streams.\n * TODO: Remove this interface and move method definitions\n * directly to ClosedCaptonParser.\n * @interface\n */\nshaka.media.IClosedCaptionParser = class {\n  /**\n   * Initialize the caption parser. This should be called only once.\n   * @param {BufferSource} initSegment\n   */\n  init(initSegment) {}\n\n  /**\n   * Parses embedded CEA closed captions and interacts with the underlying\n   * CaptionStream, and calls the callback function when there are closed\n   * captions.\n   *\n   * @param {BufferSource} mediaFragment\n   * @return {!Array<!shaka.cea.ICaptionDecoder.ClosedCaption>}\n   * An array of parsed closed captions.\n   */\n  parseFrom(mediaFragment) {}\n\n  /**\n   * Resets the CaptionStream.\n   */\n  reset() {}\n};\n\n/**\n * Closed Caption Parser provides all operations for parsing the closed captions\n * embedded in Dash videos streams.\n *\n * @implements {shaka.media.IClosedCaptionParser}\n * @final\n */\nshaka.media.ClosedCaptionParser = class {\n  /** */\n  constructor() {\n    /**\n     * MP4 Parser to extract closed caption packets from H.264 video.\n     * @private {!shaka.cea.ICeaParser}\n     */\n    this.ceaParser_ = new shaka.cea.Mp4CeaParser();\n\n    /**\n     * Decoder for decoding CEA-X08 data from closed caption packets.\n     * @private {!shaka.cea.ICaptionDecoder}\n     */\n    this.ceaDecoder_ = new shaka.cea.CeaDecoder();\n  }\n\n  /**\n   * @override\n   */\n  init(initSegment) {\n    this.ceaParser_.init(initSegment);\n  }\n\n  /**\n   * @override\n   */\n  parseFrom(mediaFragment) {\n    // Parse the fragment.\n    const captionPackets = this.ceaParser_.parse(mediaFragment);\n\n    // Extract the caption packets for decoding.\n    for (const captionPacket of captionPackets) {\n      const uint8ArrayData =\n          shaka.util.BufferUtils.toUint8(captionPacket.packet);\n      if (uint8ArrayData.length > 0) {\n        this.ceaDecoder_.extract(uint8ArrayData, captionPacket.pts);\n      }\n    }\n\n    // Decode and return the parsed captions.\n    return this.ceaDecoder_.decode();\n  }\n\n  /**\n   * @override\n   */\n  reset() {\n    this.ceaDecoder_.clear();\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.TimeRangesUtils');\n\n\n/**\n * @summary A set of utility functions for dealing with TimeRanges objects.\n */\nshaka.media.TimeRangesUtils = class {\n  /**\n   * Gets the first timestamp in the buffer.\n   *\n   * @param {TimeRanges} b\n   * @return {?number} The first buffered timestamp, in seconds, if |buffered|\n   *   is non-empty; otherwise, return null.\n   */\n  static bufferStart(b) {\n    if (!b) {\n      return null;\n    }\n    // Workaround Safari bug: https://bit.ly/2trx6O8\n    if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n      return null;\n    }\n    // Workaround Edge bug: https://bit.ly/2JYLPeB\n    if (b.length == 1 && b.start(0) < 0) {\n      return 0;\n    }\n    return b.length ? b.start(0) : null;\n  }\n\n\n  /**\n   * Gets the last timestamp in the buffer.\n   *\n   * @param {TimeRanges} b\n   * @return {?number} The last buffered timestamp, in seconds, if |buffered|\n   *   is non-empty; otherwise, return null.\n   */\n  static bufferEnd(b) {\n    if (!b) {\n      return null;\n    }\n    // Workaround Safari bug: https://bit.ly/2trx6O8\n    if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n      return null;\n    }\n    return b.length ? b.end(b.length - 1) : null;\n  }\n\n\n  /**\n   * Determines if the given time is inside a buffered range.  This includes\n   * gaps, meaning that if the playhead is in a gap, it is considered buffered.\n   * If there is a small gap between the playhead and buffer start, consider it\n   * as buffered.\n   *\n   * @param {TimeRanges} b\n   * @param {number} time Playhead time\n   * @param {number=} smallGapLimit Set in configuration\n   * @return {boolean}\n   */\n  static isBuffered(b, time, smallGapLimit = 0) {\n    if (!b || !b.length) {\n      return false;\n    }\n    // Workaround Safari bug: https://bit.ly/2trx6O8\n    if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n      return false;\n    }\n\n    if (time > b.end(b.length - 1)) {\n      return false;\n    }\n    // Push the time forward by the gap limit so that it is more likely to be in\n    // the range.\n    return (time + smallGapLimit >= b.start(0));\n  }\n\n\n  /**\n   * Computes how far ahead of the given timestamp is buffered.  To provide\n   * smooth playback while jumping gaps, we don't include the gaps when\n   * calculating this.\n   * This only includes the amount of content that is buffered.\n   *\n   * @param {TimeRanges} b\n   * @param {number} time\n   * @return {number} The number of seconds buffered, in seconds, ahead of the\n   *   given time.\n   */\n  static bufferedAheadOf(b, time) {\n    if (!b || !b.length) {\n      return 0;\n    }\n    // Workaround Safari bug: https://bit.ly/2trx6O8\n    if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n      return 0;\n    }\n\n    // We calculate the buffered amount by ONLY accounting for the content\n    // buffered (i.e. we ignore the times of the gaps).  We also buffer through\n    // all gaps.\n    // Therefore, we start at the end and add up all buffers until |time|.\n    let result = 0;\n    for (const {start, end} of shaka.media.TimeRangesUtils.getBufferedInfo(b)) {\n      if (end > time) {\n        result += end - Math.max(start, time);\n      }\n    }\n\n    return result;\n  }\n\n\n  /**\n   * Determines if the given time is inside a gap between buffered ranges.  If\n   * it is, this returns the index of the buffer that is *ahead* of the gap.\n   *\n   * @param {TimeRanges} b\n   * @param {number} time\n   * @param {number} threshold\n   * @return {?number} The index of the buffer after the gap, or null if not in\n   *   a gap.\n   */\n  static getGapIndex(b, time, threshold) {\n    const TimeRangesUtils = shaka.media.TimeRangesUtils;\n\n    if (!b || !b.length) {\n      return null;\n    }\n    // Workaround Safari bug: https://bit.ly/2trx6O8\n    if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n      return null;\n    }\n\n    const idx = TimeRangesUtils.getBufferedInfo(b).findIndex((item, i, arr) => {\n      return item.start > time &&\n          (i == 0 || arr[i - 1].end - time <= threshold);\n    });\n    return idx >= 0 ? idx : null;\n  }\n\n\n  /**\n   * @param {TimeRanges} b\n   * @return {!Array.<shaka.extern.BufferedRange>}\n   */\n  static getBufferedInfo(b) {\n    if (!b) {\n      return [];\n    }\n    const ret = [];\n    for (let i = 0; i < b.length; i++) {\n      ret.push({start: b.start(i), end: b.end(i)});\n    }\n    return ret;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.MediaSourceEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.ContentWorkarounds');\ngoog.require('shaka.media.IClosedCaptionParser');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.media.Transmuxer');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * @summary\n * MediaSourceEngine wraps all operations on MediaSource and SourceBuffers.\n * All asynchronous operations return a Promise, and all operations are\n * internally synchronized and serialized as needed.  Operations that can\n * be done in parallel will be done in parallel.\n *\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.MediaSourceEngine = class {\n  /**\n   * @param {HTMLMediaElement} video The video element, whose source is tied to\n   *   MediaSource during the lifetime of the MediaSourceEngine.\n   * @param {!shaka.media.IClosedCaptionParser} closedCaptionParser\n   *    The closed caption parser that should be used to parser closed captions\n   *    from the video stream. MediaSourceEngine takes ownership of the parser.\n   *    When MediaSourceEngine is destroyed, it will destroy the parser.\n   * @param {!shaka.extern.TextDisplayer} textDisplayer\n   *    The text displayer that will be used with the text engine.\n   *    MediaSourceEngine takes ownership of the displayer. When\n   *    MediaSourceEngine is destroyed, it will destroy the displayer.\n   * @param {!function(!Array.<shaka.extern.ID3Metadata>, number, ?number)=}\n   *    onMetadata\n   */\n  constructor(video, closedCaptionParser, textDisplayer, onMetadata) {\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {shaka.extern.TextDisplayer} */\n    this.textDisplayer_ = textDisplayer;\n\n    /** @private {!Object.<shaka.util.ManifestParserUtils.ContentType,\n                           SourceBuffer>} */\n    this.sourceBuffers_ = {};\n\n    /** @private {!Object.<shaka.util.ManifestParserUtils.ContentType,\n                           string>} */\n    this.sourceBufferTypes_ = {};\n\n\n    /** @private {!Object.<shaka.util.ManifestParserUtils.ContentType,\n                           boolean>} */\n    this.expectedEncryption_ = {};\n\n    /** @private {shaka.text.TextEngine} */\n    this.textEngine_ = null;\n\n    const onMetadataNoOp = (metadata, timestampOffset, segmentEnd) => {};\n\n    /** @private {!function(!Array.<shaka.extern.ID3Metadata>,\n                    number, ?number)} */\n    this.onMetadata_ = onMetadata || onMetadataNoOp;\n\n    /**\n     * @private {!Object.<string,\n     *                    !Array.<shaka.media.MediaSourceEngine.Operation>>}\n     */\n    this.queues_ = {};\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {!Object.<string, !shaka.media.Transmuxer>} */\n    this.transmuxers_ = {};\n\n    /** @private {shaka.media.IClosedCaptionParser} */\n    this.captionParser_ = closedCaptionParser;\n\n    /** @private {!shaka.util.PublicPromise} */\n    this.mediaSourceOpen_ = new shaka.util.PublicPromise();\n\n    /** @private {MediaSource} */\n    this.mediaSource_ = this.createMediaSource(this.mediaSourceOpen_);\n\n    /** @type {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(() => this.doDestroy_());\n\n    /** @private {string} */\n    this.url_ = '';\n  }\n\n  /**\n   * Create a MediaSource object, attach it to the video element, and return it.\n   * Resolves the given promise when the MediaSource is ready.\n   *\n   * Replaced by unit tests.\n   *\n   * @param {!shaka.util.PublicPromise} p\n   * @return {!MediaSource}\n   */\n  createMediaSource(p) {\n    const mediaSource = new MediaSource();\n\n    // Set up MediaSource on the video element.\n    this.eventManager_.listenOnce(\n        mediaSource, 'sourceopen', () => this.onSourceOpen_(p));\n\n    // Store the object URL for releasing it later.\n    this.url_ = shaka.media.MediaSourceEngine.createObjectURL(mediaSource);\n\n    this.video_.src = this.url_;\n\n    return mediaSource;\n  }\n\n  /**\n   * @param {!shaka.util.PublicPromise} p\n   * @private\n   */\n  onSourceOpen_(p) {\n    // Release the object URL that was previously created, to prevent memory\n    // leak.\n    // createObjectURL creates a strong reference to the MediaSource object\n    // inside the browser.  Setting the src of the video then creates another\n    // reference within the video element.  revokeObjectURL will remove the\n    // strong reference to the MediaSource object, and allow it to be\n    // garbage-collected later.\n    URL.revokeObjectURL(this.url_);\n    p.resolve();\n  }\n\n  /**\n   * Checks if a certain type is supported.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {boolean}\n   */\n  static isStreamSupported(stream) {\n    const fullMimeType = shaka.util.MimeUtils.getFullType(\n        stream.mimeType, stream.codecs);\n    const extendedMimeType = shaka.util.MimeUtils.getExtendedType(stream);\n    return shaka.text.TextEngine.isTypeSupported(fullMimeType) ||\n        MediaSource.isTypeSupported(extendedMimeType) ||\n        shaka.media.Transmuxer.isSupported(fullMimeType, stream.type);\n  }\n\n  /**\n   * Returns a map of MediaSource support for well-known types.\n   *\n   * @return {!Object.<string, boolean>}\n   */\n  static probeSupport() {\n    const testMimeTypes = [\n      // MP4 types\n      'video/mp4; codecs=\"avc1.42E01E\"',\n      'video/mp4; codecs=\"avc3.42E01E\"',\n      'video/mp4; codecs=\"hev1.1.6.L93.90\"',\n      'video/mp4; codecs=\"hvc1.1.6.L93.90\"',\n      'video/mp4; codecs=\"hev1.2.4.L153.B0\"; eotf=\"smpte2084\"',  // HDR HEVC\n      'video/mp4; codecs=\"hvc1.2.4.L153.B0\"; eotf=\"smpte2084\"',  // HDR HEVC\n      'video/mp4; codecs=\"vp9\"',\n      'video/mp4; codecs=\"vp09.00.10.08\"',\n      'video/mp4; codecs=\"av01.0.01M.08\"',\n      'audio/mp4; codecs=\"mp4a.40.2\"',\n      'audio/mp4; codecs=\"ac-3\"',\n      'audio/mp4; codecs=\"ec-3\"',\n      'audio/mp4; codecs=\"opus\"',\n      'audio/mp4; codecs=\"flac\"',\n      'audio/mp4; codecs=\"dtsc\"', // DTS Digital Surround\n      'audio/mp4; codecs=\"dtse\"', // DTS Express\n      'audio/mp4; codecs=\"dtsx\"', // DTS:X\n      // WebM types\n      'video/webm; codecs=\"vp8\"',\n      'video/webm; codecs=\"vp9\"',\n      'video/webm; codecs=\"vp09.00.10.08\"',\n      'audio/webm; codecs=\"vorbis\"',\n      'audio/webm; codecs=\"opus\"',\n      // MPEG2 TS types (video/ is also used for audio: https://bit.ly/TsMse)\n      'video/mp2t; codecs=\"avc1.42E01E\"',\n      'video/mp2t; codecs=\"avc3.42E01E\"',\n      'video/mp2t; codecs=\"hvc1.1.6.L93.90\"',\n      'video/mp2t; codecs=\"mp4a.40.2\"',\n      'video/mp2t; codecs=\"ac-3\"',\n      'video/mp2t; codecs=\"ec-3\"',\n      // WebVTT types\n      'text/vtt',\n      'application/mp4; codecs=\"wvtt\"',\n      // TTML types\n      'application/ttml+xml',\n      'application/mp4; codecs=\"stpp\"',\n    ];\n\n    const support = {};\n    for (const type of testMimeTypes) {\n      if (shaka.util.Platform.supportsMediaSource()) {\n        // Our TextEngine is only effective for MSE platforms at the moment.\n        if (shaka.text.TextEngine.isTypeSupported(type)) {\n          support[type] = true;\n        } else {\n          support[type] = MediaSource.isTypeSupported(type) ||\n                          shaka.media.Transmuxer.isSupported(type);\n        }\n      } else {\n        support[type] = shaka.util.Platform.supportsMediaType(type);\n      }\n\n      const basicType = type.split(';')[0];\n      support[basicType] = support[basicType] || support[type];\n    }\n\n    return support;\n  }\n\n  /** @override */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /** @private */\n  async doDestroy_() {\n    const Functional = shaka.util.Functional;\n\n    const cleanup = [];\n\n    for (const contentType in this.queues_) {\n      // Make a local copy of the queue and the first item.\n      const q = this.queues_[contentType];\n      const inProgress = q[0];\n\n      // Drop everything else out of the original queue.\n      this.queues_[contentType] = q.slice(0, 1);\n\n      // We will wait for this item to complete/fail.\n      if (inProgress) {\n        cleanup.push(inProgress.p.catch(Functional.noop));\n      }\n\n      // The rest will be rejected silently if possible.\n      for (const item of q.slice(1)) {\n        item.p.reject(shaka.util.Destroyer.destroyedError());\n      }\n    }\n\n    if (this.textEngine_) {\n      cleanup.push(this.textEngine_.destroy());\n    }\n    if (this.textDisplayer_) {\n      cleanup.push(this.textDisplayer_.destroy());\n    }\n\n    for (const contentType in this.transmuxers_) {\n      cleanup.push(this.transmuxers_[contentType].destroy());\n    }\n\n\n    await Promise.all(cleanup);\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    if (this.video_) {\n      // \"unload\" the video element.\n      this.video_.removeAttribute('src');\n      this.video_.load();\n      this.video_ = null;\n    }\n\n    this.mediaSource_ = null;\n    this.textEngine_ = null;\n    this.textDisplayer_ = null;\n    this.sourceBuffers_ = {};\n    this.transmuxers_ = {};\n    this.captionParser_ = null;\n    if (goog.DEBUG) {\n      for (const contentType in this.queues_) {\n        goog.asserts.assert(\n            this.queues_[contentType].length == 0,\n            contentType + ' queue should be empty after destroy!');\n      }\n    }\n    this.queues_ = {};\n  }\n\n  /**\n   * @return {!Promise} Resolved when MediaSource is open and attached to the\n   *   media element.  This process is actually initiated by the constructor.\n   */\n  open() {\n    return this.mediaSourceOpen_;\n  }\n\n  /**\n   * Initialize MediaSourceEngine.\n   *\n   * Note that it is not valid to call this multiple times, except to add or\n   * reinitialize text streams.\n   *\n   * @param {!Map.<shaka.util.ManifestParserUtils.ContentType,\n   *               shaka.extern.Stream>} streamsByType\n   *   A map of content types to streams.  All streams must be supported\n   *   according to MediaSourceEngine.isStreamSupported.\n   * @param {boolean} forceTransmuxTS\n   *   If true, this will transmux TS content even if it is natively supported.\n   *\n   * @return {!Promise}\n   */\n  async init(streamsByType, forceTransmuxTS) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    await this.mediaSourceOpen_;\n\n    for (const contentType of streamsByType.keys()) {\n      const stream = streamsByType.get(contentType);\n      goog.asserts.assert(\n          shaka.media.MediaSourceEngine.isStreamSupported(stream),\n          'Type negotiation should happen before MediaSourceEngine.init!');\n\n      let mimeType = shaka.util.MimeUtils.getFullType(\n          stream.mimeType, stream.codecs);\n      if (contentType == ContentType.TEXT) {\n        this.reinitText(mimeType);\n      } else {\n        if ((forceTransmuxTS || !MediaSource.isTypeSupported(mimeType)) &&\n            shaka.media.Transmuxer.isSupported(mimeType, contentType)) {\n          this.transmuxers_[contentType] = new shaka.media.Transmuxer();\n          mimeType =\n              shaka.media.Transmuxer.convertTsCodecs(contentType, mimeType);\n        }\n        const sourceBuffer = this.mediaSource_.addSourceBuffer(mimeType);\n        this.eventManager_.listen(\n            sourceBuffer, 'error',\n            () => this.onError_(contentType));\n        this.eventManager_.listen(\n            sourceBuffer, 'updateend',\n            () => this.onUpdateEnd_(contentType));\n        this.sourceBuffers_[contentType] = sourceBuffer;\n        this.sourceBufferTypes_[contentType] = mimeType;\n        this.queues_[contentType] = [];\n        this.expectedEncryption_[contentType] = !!stream.drmInfos.length;\n      }\n    }\n  }\n\n  /**\n   * Reinitialize the TextEngine for a new text type.\n   * @param {string} mimeType\n   */\n  reinitText(mimeType) {\n    if (!this.textEngine_) {\n      this.textEngine_ = new shaka.text.TextEngine(this.textDisplayer_);\n    }\n    this.textEngine_.initParser(mimeType);\n  }\n\n  /**\n   * @return {boolean} True if the MediaSource is in an \"ended\" state, or if the\n   *   object has been destroyed.\n   */\n  ended() {\n    return this.mediaSource_ ? this.mediaSource_.readyState == 'ended' : true;\n  }\n\n  /**\n   * Gets the first timestamp in buffer for the given content type.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {?number} The timestamp in seconds, or null if nothing is buffered.\n   */\n  bufferStart(contentType) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      return this.textEngine_.bufferStart();\n    }\n    return shaka.media.TimeRangesUtils.bufferStart(\n        this.getBuffered_(contentType));\n  }\n\n  /**\n   * Gets the last timestamp in buffer for the given content type.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {?number} The timestamp in seconds, or null if nothing is buffered.\n   */\n  bufferEnd(contentType) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      return this.textEngine_.bufferEnd();\n    }\n    return shaka.media.TimeRangesUtils.bufferEnd(\n        this.getBuffered_(contentType));\n  }\n\n  /**\n   * Determines if the given time is inside the buffered range of the given\n   * content type.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} time Playhead time\n   * @param {number=} smallGapLimit\n   * @return {boolean}\n   */\n  isBuffered(contentType, time, smallGapLimit) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      return this.textEngine_.isBuffered(time);\n    } else {\n      const buffered = this.getBuffered_(contentType);\n      return shaka.media.TimeRangesUtils.isBuffered(\n          buffered, time, smallGapLimit);\n    }\n  }\n\n  /**\n   * Computes how far ahead of the given timestamp is buffered for the given\n   * content type.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} time\n   * @return {number} The amount of time buffered ahead in seconds.\n   */\n  bufferedAheadOf(contentType, time) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      return this.textEngine_.bufferedAheadOf(time);\n    } else {\n      const buffered = this.getBuffered_(contentType);\n      return shaka.media.TimeRangesUtils.bufferedAheadOf(buffered, time);\n    }\n  }\n\n  /**\n   * Returns info about what is currently buffered.\n   * @return {shaka.extern.BufferedInfo}\n   */\n  getBufferedInfo() {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const TimeRangeUtils = shaka.media.TimeRangesUtils;\n\n    const info = {\n      total: TimeRangeUtils.getBufferedInfo(this.video_.buffered),\n      audio: TimeRangeUtils.getBufferedInfo(\n          this.getBuffered_(ContentType.AUDIO)),\n      video: TimeRangeUtils.getBufferedInfo(\n          this.getBuffered_(ContentType.VIDEO)),\n      text: [],\n    };\n\n    if (this.textEngine_) {\n      const start = this.textEngine_.bufferStart();\n      const end = this.textEngine_.bufferEnd();\n\n      if (start != null && end != null) {\n        info.text.push({start: start, end: end});\n      }\n    }\n    return info;\n  }\n\n  /**\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {TimeRanges} The buffered ranges for the given content type, or\n   *   null if the buffered ranges could not be obtained.\n   * @private\n   */\n  getBuffered_(contentType) {\n    try {\n      return this.sourceBuffers_[contentType].buffered;\n    } catch (exception) {\n      if (contentType in this.sourceBuffers_) {\n        // Note: previous MediaSource errors may cause access to |buffered| to\n        // throw.\n        shaka.log.error('failed to get buffered range for ' + contentType,\n            exception);\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Enqueue an operation to append data to the SourceBuffer.\n   * Start and end times are needed for TextEngine, but not for MediaSource.\n   * Start and end times may be null for initialization segments; if present\n   * they are relative to the presentation timeline.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {!BufferSource} data\n   * @param {?number} startTime relative to the start of the presentation\n   * @param {?number} endTime relative to the start of the presentation\n   * @param {?boolean} hasClosedCaptions True if the buffer contains CEA closed\n   * captions\n   * @return {!Promise}\n   */\n  async appendBuffer(contentType, data, startTime, endTime, hasClosedCaptions) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    if (contentType == ContentType.TEXT) {\n      await this.textEngine_.appendBuffer(data, startTime, endTime);\n    } else if (this.transmuxers_[contentType]) {\n      const transmuxedData =\n          await this.transmuxers_[contentType].transmux(data);\n      // For HLS CEA-608/708 CLOSED-CAPTIONS, text data is embedded in\n      // the video stream, so textEngine may not have been initialized.\n      if (!this.textEngine_) {\n        this.reinitText(shaka.util.MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE);\n      }\n\n      if (transmuxedData.metadata) {\n        const timestampOffset =\n            this.sourceBuffers_[contentType].timestampOffset;\n        this.onMetadata_(transmuxedData.metadata, timestampOffset, endTime);\n      }\n      // This doesn't work for native TS support (ex. Edge/Chromecast),\n      // since no transmuxing is needed for native TS.\n      if (transmuxedData.captions && transmuxedData.captions.length) {\n        const videoOffset =\n        this.sourceBuffers_[ContentType.VIDEO].timestampOffset;\n        const closedCaptions = this.textEngine_\n            .convertMuxjsCaptionsToShakaCaptions(transmuxedData.captions);\n        this.textEngine_.storeAndAppendClosedCaptions(\n            closedCaptions, startTime, endTime, videoOffset);\n      }\n\n      let transmuxedSegment = transmuxedData.data;\n      transmuxedSegment = this.workAroundBrokenPlatforms_(\n          transmuxedSegment, startTime, contentType);\n\n      await this.enqueueOperation_(\n          contentType, () => this.append_(contentType, transmuxedSegment));\n    } else if (hasClosedCaptions) {\n      if (!this.textEngine_) {\n        this.reinitText(shaka.util.MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE);\n      }\n      // If it is the init segment for closed captions, initialize the closed\n      // caption parser.\n      if (startTime == null && endTime == null) {\n        this.captionParser_.init(data);\n      } else {\n        const closedCaptions = this.captionParser_.parseFrom(data);\n        if (closedCaptions.length) {\n          const videoOffset =\n            this.sourceBuffers_[ContentType.VIDEO].timestampOffset;\n          this.textEngine_.storeAndAppendClosedCaptions(\n              closedCaptions, startTime, endTime, videoOffset);\n        }\n      }\n\n      data = this.workAroundBrokenPlatforms_(data, startTime, contentType);\n\n      await this.enqueueOperation_(\n          contentType,\n          () => this.append_(contentType, data));\n    } else {\n      data = this.workAroundBrokenPlatforms_(data, startTime, contentType);\n\n      await this.enqueueOperation_(\n          contentType,\n          () => this.append_(contentType, data));\n    }\n  }\n\n  /**\n   * Set the selected closed captions Id and language.\n   *\n   * @param {string} id\n   */\n  setSelectedClosedCaptionId(id) {\n    const VIDEO = shaka.util.ManifestParserUtils.ContentType.VIDEO;\n    const videoBufferEndTime = this.bufferEnd(VIDEO) || 0;\n    this.textEngine_.setSelectedClosedCaptionId(id, videoBufferEndTime);\n  }\n\n  /** Disable embedded closed captions. */\n  clearSelectedClosedCaptionId() {\n    if (this.textEngine_) {\n      this.textEngine_.setSelectedClosedCaptionId('', 0);\n    }\n  }\n\n  /**\n   * Enqueue an operation to remove data from the SourceBuffer.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} startTime relative to the start of the presentation\n   * @param {number} endTime relative to the start of the presentation\n   * @return {!Promise}\n   */\n  async remove(contentType, startTime, endTime) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      await this.textEngine_.remove(startTime, endTime);\n    } else {\n      await this.enqueueOperation_(\n          contentType,\n          () => this.remove_(contentType, startTime, endTime));\n    }\n  }\n\n  /**\n   * Enqueue an operation to clear the SourceBuffer.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {!Promise}\n   */\n  async clear(contentType) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      if (!this.textEngine_) {\n        return;\n      }\n      await this.textEngine_.remove(0, Infinity);\n    } else {\n      // Note that not all platforms allow clearing to Infinity.\n      await this.enqueueOperation_(\n          contentType,\n          () => this.remove_(contentType, 0, this.mediaSource_.duration));\n    }\n  }\n\n  /**\n   * Fully reset the state of the caption parser owned by MediaSourceEngine.\n   */\n  resetCaptionParser() {\n    this.captionParser_.reset();\n  }\n\n  /**\n   * Enqueue an operation to flush the SourceBuffer.\n   * This is a workaround for what we believe is a Chromecast bug.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {!Promise}\n   */\n  async flush(contentType) {\n    // Flush the pipeline.  Necessary on Chromecast, even though we have removed\n    // everything.\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      // Nothing to flush for text.\n      return;\n    }\n    await this.enqueueOperation_(\n        contentType,\n        () => this.flush_(contentType));\n  }\n\n  /**\n   * Sets the timestamp offset and append window end for the given content type.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} timestampOffset The timestamp offset.  Segments which start\n   *   at time t will be inserted at time t + timestampOffset instead.  This\n   *   value does not affect segments which have already been inserted.\n   * @param {number} appendWindowStart The timestamp to set the append window\n   *   start to.  For future appends, frames/samples with timestamps less than\n   *   this value will be dropped.\n   * @param {number} appendWindowEnd The timestamp to set the append window end\n   *   to.  For future appends, frames/samples with timestamps greater than this\n   *   value will be dropped.\n   * @return {!Promise}\n   */\n  async setStreamProperties(\n      contentType, timestampOffset, appendWindowStart, appendWindowEnd) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      this.textEngine_.setTimestampOffset(timestampOffset);\n      this.textEngine_.setAppendWindow(appendWindowStart, appendWindowEnd);\n      return;\n    }\n\n    await Promise.all([\n      // Queue an abort() to help MSE splice together overlapping segments.\n      // We set appendWindowEnd when we change periods in DASH content, and the\n      // period transition may result in overlap.\n      //\n      // An abort() also helps with MPEG2-TS.  When we append a TS segment, we\n      // always enter a PARSING_MEDIA_SEGMENT state and we can't change the\n      // timestamp offset.  By calling abort(), we reset the state so we can\n      // set it.\n      this.enqueueOperation_(\n          contentType,\n          () => this.abort_(contentType)),\n      this.enqueueOperation_(\n          contentType,\n          () => this.setTimestampOffset_(contentType, timestampOffset)),\n      this.enqueueOperation_(\n          contentType,\n          () => this.setAppendWindow_(\n              contentType, appendWindowStart, appendWindowEnd)),\n    ]);\n  }\n\n  /**\n   * @param {string=} reason Valid reasons are 'network' and 'decode'.\n   * @return {!Promise}\n   * @see http://w3c.github.io/media-source/#idl-def-EndOfStreamError\n   */\n  async endOfStream(reason) {\n    await this.enqueueBlockingOperation_(() => {\n      // If endOfStream() has already been called on the media source,\n      // don't call it again. Also do not call if readyState is\n      // 'closed' (not attached to video element) since it is not a\n      // valid operation.\n      if (this.ended() || this.mediaSource_.readyState === 'closed') {\n        return;\n      }\n      // Tizen won't let us pass undefined, but it will let us omit the\n      // argument.\n      if (reason) {\n        this.mediaSource_.endOfStream(reason);\n      } else {\n        this.mediaSource_.endOfStream();\n      }\n    });\n  }\n\n  /**\n   * We only support increasing duration at this time.  Decreasing duration\n   * causes the MSE removal algorithm to run, which results in an 'updateend'\n   * event.  Supporting this scenario would be complicated, and is not currently\n   * needed.\n   *\n   * @param {number} duration\n   * @return {!Promise}\n   */\n  async setDuration(duration) {\n    goog.asserts.assert(\n        isNaN(this.mediaSource_.duration) ||\n            this.mediaSource_.duration <= duration,\n        'duration cannot decrease: ' + this.mediaSource_.duration + ' -> ' +\n            duration);\n    await this.enqueueBlockingOperation_(() => {\n      this.mediaSource_.duration = duration;\n    });\n  }\n\n  /**\n   * Get the current MediaSource duration.\n   *\n   * @return {number}\n   */\n  getDuration() {\n    return this.mediaSource_.duration;\n  }\n\n  /**\n   * Append data to the SourceBuffer.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {BufferSource} data\n   * @private\n   */\n  append_(contentType, data) {\n    // This will trigger an 'updateend' event.\n    this.sourceBuffers_[contentType].appendBuffer(data);\n  }\n\n  /**\n   * Remove data from the SourceBuffer.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} startTime relative to the start of the presentation\n   * @param {number} endTime relative to the start of the presentation\n   * @private\n   */\n  remove_(contentType, startTime, endTime) {\n    if (endTime <= startTime) {\n      // Ignore removal of inverted or empty ranges.\n      // Fake 'updateend' event to resolve the operation.\n      this.onUpdateEnd_(contentType);\n      return;\n    }\n\n    // This will trigger an 'updateend' event.\n    this.sourceBuffers_[contentType].remove(startTime, endTime);\n  }\n\n  /**\n   * Call abort() on the SourceBuffer.\n   * This resets MSE's last_decode_timestamp on all track buffers, which should\n   * trigger the splicing logic for overlapping segments.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  abort_(contentType) {\n    // Save the append window, which is reset on abort().\n    const appendWindowStart =\n        this.sourceBuffers_[contentType].appendWindowStart;\n    const appendWindowEnd = this.sourceBuffers_[contentType].appendWindowEnd;\n\n    // This will not trigger an 'updateend' event, since nothing is happening.\n    // This is only to reset MSE internals, not to abort an actual operation.\n    this.sourceBuffers_[contentType].abort();\n\n    // Restore the append window.\n    this.sourceBuffers_[contentType].appendWindowStart = appendWindowStart;\n    this.sourceBuffers_[contentType].appendWindowEnd = appendWindowEnd;\n\n    // Fake an 'updateend' event to resolve the operation.\n    this.onUpdateEnd_(contentType);\n  }\n\n  /**\n   * Nudge the playhead to force the media pipeline to be flushed.\n   * This seems to be necessary on Chromecast to get new content to replace old\n   * content.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  flush_(contentType) {\n    // Never use flush_ if there's data.  It causes a hiccup in playback.\n    goog.asserts.assert(\n        this.video_.buffered.length == 0, 'MediaSourceEngine.flush_ should ' +\n        'only be used after clearing all data!');\n\n    // Seeking forces the pipeline to be flushed.\n    this.video_.currentTime -= 0.001;\n\n    // Fake an 'updateend' event to resolve the operation.\n    this.onUpdateEnd_(contentType);\n  }\n\n  /**\n   * Set the SourceBuffer's timestamp offset.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} timestampOffset\n   * @private\n   */\n  setTimestampOffset_(contentType, timestampOffset) {\n    // Work around for\n    // https://github.com/shaka-project/shaka-player/issues/1281:\n    // TODO(https://bit.ly/2ttKiBU): follow up when this is fixed in Edge\n    if (timestampOffset < 0) {\n      // Try to prevent rounding errors in Edge from removing the first\n      // keyframe.\n      timestampOffset += 0.001;\n    }\n\n    this.sourceBuffers_[contentType].timestampOffset = timestampOffset;\n\n    // Fake an 'updateend' event to resolve the operation.\n    this.onUpdateEnd_(contentType);\n  }\n\n  /**\n   * Set the SourceBuffer's append window end.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @private\n   */\n  setAppendWindow_(contentType, appendWindowStart, appendWindowEnd) {\n    // You can't set start > end, so first set start to 0, then set the new\n    // end, then set the new start.  That way, there are no intermediate\n    // states which are invalid.\n    this.sourceBuffers_[contentType].appendWindowStart = 0;\n    this.sourceBuffers_[contentType].appendWindowEnd = appendWindowEnd;\n    this.sourceBuffers_[contentType].appendWindowStart = appendWindowStart;\n\n    // Fake an 'updateend' event to resolve the operation.\n    this.onUpdateEnd_(contentType);\n  }\n\n  /**\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  onError_(contentType) {\n    const operation = this.queues_[contentType][0];\n    goog.asserts.assert(operation, 'Spurious error event!');\n    goog.asserts.assert(!this.sourceBuffers_[contentType].updating,\n        'SourceBuffer should not be updating on error!');\n    const code = this.video_.error ? this.video_.error.code : 0;\n    operation.p.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_FAILED,\n        code));\n    // Do not pop from queue.  An 'updateend' event will fire next, and to\n    // avoid synchronizing these two event handlers, we will allow that one to\n    // pop from the queue as normal.  Note that because the operation has\n    // already been rejected, the call to resolve() in the 'updateend' handler\n    // will have no effect.\n  }\n\n  /**\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  onUpdateEnd_(contentType) {\n    const operation = this.queues_[contentType][0];\n    goog.asserts.assert(operation, 'Spurious updateend event!');\n    if (!operation) {\n      return;\n    }\n    goog.asserts.assert(!this.sourceBuffers_[contentType].updating,\n        'SourceBuffer should not be updating on updateend!');\n    operation.p.resolve();\n    this.popFromQueue_(contentType);\n  }\n\n  /**\n   * Enqueue an operation and start it if appropriate.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {function()} start\n   * @return {!Promise}\n   * @private\n   */\n  enqueueOperation_(contentType, start) {\n    this.destroyer_.ensureNotDestroyed();\n\n    const operation = {\n      start: start,\n      p: new shaka.util.PublicPromise(),\n    };\n    this.queues_[contentType].push(operation);\n\n    if (this.queues_[contentType].length == 1) {\n      this.startOperation_(contentType);\n    }\n    return operation.p;\n  }\n\n  /**\n   * Enqueue an operation which must block all other operations on all\n   * SourceBuffers.\n   *\n   * @param {function()} run\n   * @return {!Promise}\n   * @private\n   */\n  async enqueueBlockingOperation_(run) {\n    this.destroyer_.ensureNotDestroyed();\n\n    /** @type {!Array.<!shaka.util.PublicPromise>} */\n    const allWaiters = [];\n\n    // Enqueue a 'wait' operation onto each queue.\n    // This operation signals its readiness when it starts.\n    // When all wait operations are ready, the real operation takes place.\n    for (const contentType in this.sourceBuffers_) {\n      const ready = new shaka.util.PublicPromise();\n      const operation = {\n        start: () => ready.resolve(),\n        p: ready,\n      };\n\n      this.queues_[contentType].push(operation);\n      allWaiters.push(ready);\n\n      if (this.queues_[contentType].length == 1) {\n        operation.start();\n      }\n    }\n\n    // Return a Promise to the real operation, which waits to begin until\n    // there are no other in-progress operations on any SourceBuffers.\n    try {\n      await Promise.all(allWaiters);\n    } catch (error) {\n      // One of the waiters failed, which means we've been destroyed.\n      goog.asserts.assert(\n          this.destroyer_.destroyed(), 'Should be destroyed by now');\n      // We haven't popped from the queue.  Canceled waiters have been removed\n      // by destroy.  What's left now should just be resolved waiters.  In\n      // uncompiled mode, we will maintain good hygiene and make sure the\n      // assert at the end of destroy passes.  In compiled mode, the queues\n      // are wiped in destroy.\n      if (goog.DEBUG) {\n        for (const contentType in this.sourceBuffers_) {\n          if (this.queues_[contentType].length) {\n            goog.asserts.assert(\n                this.queues_[contentType].length == 1,\n                'Should be at most one item in queue!');\n            goog.asserts.assert(\n                allWaiters.includes(this.queues_[contentType][0].p),\n                'The item in queue should be one of our waiters!');\n            this.queues_[contentType].shift();\n          }\n        }\n      }\n      throw error;\n    }\n\n    if (goog.DEBUG) {\n      // If we did it correctly, nothing is updating.\n      for (const contentType in this.sourceBuffers_) {\n        goog.asserts.assert(\n            this.sourceBuffers_[contentType].updating == false,\n            'SourceBuffers should not be updating after a blocking op!');\n      }\n    }\n\n    // Run the real operation, which is synchronous.\n    try {\n      run();\n    } catch (exception) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW,\n          exception);\n    } finally {\n      // Unblock the queues.\n      for (const contentType in this.sourceBuffers_) {\n        this.popFromQueue_(contentType);\n      }\n    }\n  }\n\n  /**\n   * Pop from the front of the queue and start a new operation.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  popFromQueue_(contentType) {\n    // Remove the in-progress operation, which is now complete.\n    this.queues_[contentType].shift();\n    this.startOperation_(contentType);\n  }\n\n  /**\n   * Starts the next operation in the queue.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  startOperation_(contentType) {\n    // Retrieve the next operation, if any, from the queue and start it.\n    const next = this.queues_[contentType][0];\n    if (next) {\n      try {\n        next.start();\n      } catch (exception) {\n        if (exception.name == 'QuotaExceededError') {\n          next.p.reject(new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.MEDIA,\n              shaka.util.Error.Code.QUOTA_EXCEEDED_ERROR,\n              contentType));\n        } else {\n          next.p.reject(new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.MEDIA,\n              shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW,\n              exception));\n        }\n        this.popFromQueue_(contentType);\n      }\n    }\n  }\n\n  /**\n   * @return {!shaka.extern.TextDisplayer}\n   */\n  getTextDisplayer() {\n    goog.asserts.assert(\n        this.textDisplayer_,\n        'TextDisplayer should only be null when this is destroyed');\n\n    return this.textDisplayer_;\n  }\n\n  /**\n   * @param {!shaka.extern.TextDisplayer} textDisplayer\n   */\n  setTextDisplayer(textDisplayer) {\n    const oldTextDisplayer = this.textDisplayer_;\n    this.textDisplayer_ = textDisplayer;\n    if (oldTextDisplayer) {\n      textDisplayer.setTextVisibility(oldTextDisplayer.isTextVisible());\n      oldTextDisplayer.destroy();\n    }\n    if (this.textEngine_) {\n      this.textEngine_.setDisplayer(textDisplayer);\n    }\n  }\n\n  /**\n   * Apply platform-specific transformations to this segment to work around\n   * issues in the platform.\n   *\n   * @param {!BufferSource} segment\n   * @param {?number} startTime\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {!BufferSource}\n   * @private\n   */\n  workAroundBrokenPlatforms_(segment, startTime, contentType) {\n    const isInitSegment = startTime == null;\n    const encryptionExpected = this.expectedEncryption_[contentType];\n\n    // If:\n    //   1. this is an init segment,\n    //   2. and encryption is expected,\n    //   3. and the platform requires encryption in all init segments,\n    //   4. and the content is MP4 (mimeType == \"video/mp4\" or \"audio/mp4\"),\n    // then insert fake encryption metadata for init segments that lack it.\n    // The MP4 requirement is because we can currently only do this\n    // transformation on MP4 containers.\n    // See: https://github.com/shaka-project/shaka-player/issues/2759\n    if (isInitSegment &&\n        encryptionExpected &&\n        shaka.util.Platform.requiresEncryptionInfoInAllInitSegments() &&\n        shaka.util.MimeUtils.getContainerType(\n            this.sourceBufferTypes_[contentType]) == 'mp4') {\n      shaka.log.debug('Forcing fake encryption information in init segment.');\n      segment = shaka.media.ContentWorkarounds.fakeEncryption(segment);\n    }\n\n    return segment;\n  }\n};\n\n\n/**\n * Internal reference to window.URL.createObjectURL function to avoid\n * compatibility issues with other libraries and frameworks such as React\n * Native. For use in unit tests only, not meant for external use.\n *\n * @type {function(?):string}\n */\nshaka.media.MediaSourceEngine.createObjectURL = window.URL.createObjectURL;\n\n\n/**\n * @typedef {{\n *   start: function(),\n *   p: !shaka.util.PublicPromise\n * }}\n *\n * @summary An operation in queue.\n * @property {function()} start\n *   The function which starts the operation.\n * @property {!shaka.util.PublicPromise} p\n *   The PublicPromise which is associated with this operation.\n */\nshaka.media.MediaSourceEngine.Operation;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.PresentationTimeline');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.SegmentReference');\n\n\n/**\n * PresentationTimeline.\n * @export\n */\nshaka.media.PresentationTimeline = class {\n  /**\n   * @param {?number} presentationStartTime The wall-clock time, in seconds,\n   *   when the presentation started or will start. Only required for live.\n   * @param {number} presentationDelay The delay to give the presentation, in\n   *   seconds.  Only required for live.\n   * @param {boolean=} autoCorrectDrift Whether to account for drift when\n   *   determining the availability window.\n   *\n   * @see {shaka.extern.Manifest}\n   * @see {@tutorial architecture}\n   */\n  constructor(presentationStartTime, presentationDelay,\n      autoCorrectDrift = true) {\n    /** @private {?number} */\n    this.presentationStartTime_ = presentationStartTime;\n\n    /** @private {number} */\n    this.presentationDelay_ = presentationDelay;\n\n    /** @private {number} */\n    this.duration_ = Infinity;\n\n    /** @private {number} */\n    this.segmentAvailabilityDuration_ = Infinity;\n\n    /**\n     * The maximum segment duration (in seconds).  Can be based on explicitly-\n     * known segments or on signalling in the manifest.\n     *\n     * @private {number}\n     */\n    this.maxSegmentDuration_ = 1;\n\n    /**\n     * The minimum segment start time (in seconds, in the presentation timeline)\n     * for segments we explicitly know about.\n     *\n     * This is null if we have no explicit descriptions of segments, such as in\n     * DASH when using SegmentTemplate w/ duration.\n     *\n     * @private {?number}\n     */\n    this.minSegmentStartTime_ = null;\n\n    /**\n     * The maximum segment end time (in seconds, in the presentation timeline)\n     * for segments we explicitly know about.\n     *\n     * This is null if we have no explicit descriptions of segments, such as in\n     * DASH when using SegmentTemplate w/ duration.  When this is non-null, the\n     * presentation start time is calculated from the segment end times.\n     *\n     * @private {?number}\n     */\n    this.maxSegmentEndTime_ = null;\n\n    /** @private {number} */\n    this.clockOffset_ = 0;\n\n    /** @private {boolean} */\n    this.static_ = true;\n\n    /** @private {number} */\n    this.userSeekStart_ = 0;\n\n    /** @private {boolean} */\n    this.autoCorrectDrift_ = autoCorrectDrift;\n\n    /**\n     * For low latency Dash, availabilityTimeOffset indicates a segment is\n     * available for download earlier than its availability start time.\n     * This field is the minimum availabilityTimeOffset value among the\n     * segments. We reduce the distance from live edge by this value.\n     *\n     * @private {number}\n     */\n    this.availabilityTimeOffset_ = 0;\n\n    /** @private {boolean} */\n    this.startTimeLocked_ = false;\n  }\n\n\n  /**\n   * @return {number} The presentation's duration in seconds.\n   *   Infinity indicates that the presentation continues indefinitely.\n   * @export\n   */\n  getDuration() {\n    return this.duration_;\n  }\n\n\n  /**\n   * @return {number} The presentation's max segment duration in seconds.\n   * @export\n   */\n  getMaxSegmentDuration() {\n    return this.maxSegmentDuration_;\n  }\n\n\n  /**\n   * Sets the presentation's duration.\n   *\n   * @param {number} duration The presentation's duration in seconds.\n   *   Infinity indicates that the presentation continues indefinitely.\n   * @export\n   */\n  setDuration(duration) {\n    goog.asserts.assert(duration > 0, 'duration must be > 0');\n    this.duration_ = duration;\n  }\n\n\n  /**\n   * @return {?number} The presentation's start time in seconds.\n   * @export\n   */\n  getPresentationStartTime() {\n    return this.presentationStartTime_;\n  }\n\n\n  /**\n   * Sets the clock offset, which is the difference between the client's clock\n   * and the server's clock, in milliseconds (i.e., serverTime = Date.now() +\n   * clockOffset).\n   *\n   * @param {number} offset The clock offset, in ms.\n   * @export\n   */\n  setClockOffset(offset) {\n    this.clockOffset_ = offset;\n  }\n\n\n  /**\n   * Sets the presentation's static flag.\n   *\n   * @param {boolean} isStatic If true, the presentation is static, meaning all\n   *   segments are available at once.\n   * @export\n   */\n  setStatic(isStatic) {\n    // NOTE: the argument name is not \"static\" because that's a keyword in ES6\n    this.static_ = isStatic;\n  }\n\n\n  /**\n   * Sets the presentation's segment availability duration. The segment\n   * availability duration should only be set for live.\n   *\n   * @param {number} segmentAvailabilityDuration The presentation's new segment\n   *   availability duration in seconds.\n   * @export\n   */\n  setSegmentAvailabilityDuration(segmentAvailabilityDuration) {\n    goog.asserts.assert(segmentAvailabilityDuration >= 0,\n        'segmentAvailabilityDuration must be >= 0');\n    this.segmentAvailabilityDuration_ = segmentAvailabilityDuration;\n  }\n\n\n  /**\n   * Sets the presentation delay in seconds.\n   *\n   * @param {number} delay\n   * @export\n   */\n  setDelay(delay) {\n    // NOTE: This is no longer used internally, but is exported.\n    // So we cannot remove it without deprecating it and waiting one release\n    // cycle, or else we risk breaking custom manifest parsers.\n    goog.asserts.assert(delay >= 0, 'delay must be >= 0');\n    this.presentationDelay_ = delay;\n  }\n\n\n  /**\n   * Gets the presentation delay in seconds.\n   * @return {number}\n   * @export\n   */\n  getDelay() {\n    return this.presentationDelay_;\n  }\n\n\n  /**\n   * Gives PresentationTimeline a Stream's segments so it can size and position\n   * the segment availability window, and account for missing segment\n   * information.  This function should be called once for each Stream (no more,\n   * no less).\n   *\n   * @param {!Array.<!shaka.media.SegmentReference>} references\n   * @export\n   */\n  notifySegments(references) {\n    if (references.length == 0) {\n      return;\n    }\n\n    const firstReferenceStartTime = references[0].startTime;\n    const lastReferenceEndTime = references[references.length - 1].endTime;\n\n    this.notifyMinSegmentStartTime(firstReferenceStartTime);\n\n    this.maxSegmentDuration_ = references.reduce(\n        (max, r) => { return Math.max(max, r.endTime - r.startTime); },\n        this.maxSegmentDuration_);\n\n    this.maxSegmentEndTime_ =\n        Math.max(this.maxSegmentEndTime_, lastReferenceEndTime);\n\n    if (this.presentationStartTime_ != null && this.autoCorrectDrift_ &&\n        !this.startTimeLocked_) {\n      // Since we have explicit segment end times, calculate a presentation\n      // start based on them.  This start time accounts for drift.\n      // Date.now() is in milliseconds, from which we compute \"now\" in seconds.\n      const now = (Date.now() + this.clockOffset_) / 1000.0;\n      this.presentationStartTime_ =\n          now - this.maxSegmentEndTime_ - this.maxSegmentDuration_;\n    }\n\n    shaka.log.v1('notifySegments:',\n        'maxSegmentDuration=' + this.maxSegmentDuration_);\n  }\n\n\n  /**\n   * Lock the presentation timeline's start time.  After this is called, no\n   * further adjustments to presentationStartTime_ will be permitted.\n   *\n   * This should be called after all Periods have been parsed, and all calls to\n   * notifySegments() from the initial manifest parse have been made.\n   *\n   * Without this, we can get assertion failures in SegmentIndex for certain\n   * DAI content.  If DAI adds ad segments to the manifest faster than\n   * real-time, adjustments to presentationStartTime_ can cause availability\n   * windows to jump around on updates.\n   *\n   * @export\n   */\n  lockStartTime() {\n    this.startTimeLocked_ = true;\n  }\n\n\n  /**\n   * Gives PresentationTimeline a Stream's minimum segment start time.\n   *\n   * @param {number} startTime\n   * @export\n   */\n  notifyMinSegmentStartTime(\n      startTime) {\n    if (this.minSegmentStartTime_ == null) {\n      // No data yet, and Math.min(null, startTime) is always 0.  So just store\n      // startTime.\n      this.minSegmentStartTime_ = startTime;\n    } else {\n      this.minSegmentStartTime_ =\n          Math.min(this.minSegmentStartTime_, startTime);\n    }\n  }\n\n\n  /**\n   * Gives PresentationTimeline a Stream's maximum segment duration so it can\n   * size and position the segment availability window.  This function should be\n   * called once for each Stream (no more, no less), but does not have to be\n   * called if notifySegments() is called instead for a particular stream.\n   *\n   * @param {number} maxSegmentDuration The maximum segment duration for a\n   *   particular stream.\n   * @export\n   */\n  notifyMaxSegmentDuration(maxSegmentDuration) {\n    this.maxSegmentDuration_ = Math.max(\n        this.maxSegmentDuration_, maxSegmentDuration);\n\n    shaka.log.v1('notifyNewSegmentDuration:',\n        'maxSegmentDuration=' + this.maxSegmentDuration_);\n  }\n\n\n  /**\n   * Offsets the segment times by the given amount.\n   *\n   * @param {number} offset The number of seconds to offset by.  A positive\n   *   number adjusts the segment times forward.\n   * @export\n   */\n  offset(offset) {\n    if (this.minSegmentStartTime_ != null) {\n      this.minSegmentStartTime_ += offset;\n    }\n    if (this.maxSegmentEndTime_ != null) {\n      this.maxSegmentEndTime_ += offset;\n    }\n  }\n\n\n  /**\n   * @return {boolean} True if the presentation is live; otherwise, return\n   *   false.\n   * @export\n   */\n  isLive() {\n    return this.duration_ == Infinity &&\n           !this.static_;\n  }\n\n\n  /**\n   * @return {boolean} True if the presentation is in progress (meaning not\n   *   live, but also not completely available); otherwise, return false.\n   * @export\n   */\n  isInProgress() {\n    return this.duration_ != Infinity &&\n           !this.static_;\n  }\n\n\n  /**\n   * Gets the presentation's current segment availability start time.  Segments\n   * ending at or before this time should be assumed to be unavailable.\n   *\n   * @return {number} The current segment availability start time, in seconds,\n   *   relative to the start of the presentation.\n   * @export\n   */\n  getSegmentAvailabilityStart() {\n    goog.asserts.assert(this.segmentAvailabilityDuration_ >= 0,\n        'The availability duration should be positive');\n\n    const end = this.getSegmentAvailabilityEnd();\n    const start = end - this.segmentAvailabilityDuration_;\n    return Math.max(this.userSeekStart_, start);\n  }\n\n\n  /**\n   * Sets the start time of the user-defined seek range.  This is only used for\n   * VOD content.\n   *\n   * @param {number} time\n   * @export\n   */\n  setUserSeekStart(time) {\n    this.userSeekStart_ = time;\n  }\n\n\n  /**\n   * Gets the presentation's current segment availability end time.  Segments\n   * starting after this time should be assumed to be unavailable.\n   *\n   * @return {number} The current segment availability end time, in seconds,\n   *   relative to the start of the presentation.  For VOD, the availability\n   *   end time is the content's duration.  If the Player's playRangeEnd\n   *   configuration is used, this can override the duration.\n   * @export\n   */\n  getSegmentAvailabilityEnd() {\n    if (!this.isLive() && !this.isInProgress()) {\n      // It's a static manifest (can also be a dynamic->static conversion)\n      if (this.maxSegmentEndTime_) {\n        // If we know segment times, use the min of that and duration.\n        // Note that the playRangeEnd configuration changes this.duration_.\n        // See https://github.com/shaka-project/shaka-player/issues/4026\n        return Math.min(this.maxSegmentEndTime_, this.duration_);\n      } else {\n        // If we don't have segment times, use duration.\n        return this.duration_;\n      }\n    }\n    // Can be either live or \"in-progress recording\" (live with known duration)\n    return Math.min(this.getLiveEdge_() + this.availabilityTimeOffset_,\n        this.duration_);\n  }\n\n\n  /**\n   * Gets the seek range start time, offset by the given amount.  This is used\n   * to ensure that we don't \"fall\" back out of the seek window while we are\n   * buffering.\n   *\n   * @param {number} offset The offset to add to the start time for live\n   *   streams.\n   * @return {number} The current seek start time, in seconds, relative to the\n   *   start of the presentation.\n   * @export\n   */\n  getSafeSeekRangeStart(offset) {\n    // The earliest known segment time, ignoring segment availability duration.\n    const earliestSegmentTime =\n        Math.max(this.minSegmentStartTime_, this.userSeekStart_);\n\n    // For VOD, the offset and end time are ignored, and we just return the\n    // earliest segment time.  All segments are \"safe\" in VOD.  However, we\n    // should round up to the nearest millisecond to avoid issues like\n    // https://github.com/shaka-project/shaka-player/issues/2831, in which we\n    // tried to seek repeatedly to catch up to the seek range, and never\n    // actually \"arrived\" within it.  The video's currentTime is not as\n    // accurate as the JS number representing the earliest segment time for\n    // some content.\n    if (this.segmentAvailabilityDuration_ == Infinity) {\n      return Math.ceil(earliestSegmentTime * 1e3) / 1e3;\n    }\n\n    // AKA the live edge for live streams.\n    const availabilityEnd = this.getSegmentAvailabilityEnd();\n\n    // The ideal availability start, not considering known segments.\n    const availabilityStart =\n        availabilityEnd - this.segmentAvailabilityDuration_;\n\n    // Add the offset to the availability start to ensure that we don't fall\n    // outside the availability window while we buffer; we don't need to add the\n    // offset to earliestSegmentTime since that won't change over time.\n    // Also see: https://github.com/shaka-project/shaka-player/issues/692\n    const desiredStart =\n        Math.min(availabilityStart + offset, this.getSeekRangeEnd());\n    return Math.max(earliestSegmentTime, desiredStart);\n  }\n\n\n  /**\n   * Gets the seek range start time.\n   *\n   * @return {number}\n   * @export\n   */\n  getSeekRangeStart() {\n    return this.getSafeSeekRangeStart(/* offset= */ 0);\n  }\n\n\n  /**\n   * Gets the seek range end.\n   *\n   * @return {number}\n   * @export\n   */\n  getSeekRangeEnd() {\n    const useDelay = this.isLive() || this.isInProgress();\n    const delay = useDelay ? this.presentationDelay_ : 0;\n    return Math.max(0, this.getSegmentAvailabilityEnd() - delay);\n  }\n\n\n  /**\n   * True if the presentation start time is being used to calculate the live\n   * edge.\n   * Using the presentation start time means that the stream may be subject to\n   * encoder drift.  At runtime, we will avoid using the presentation start time\n   * whenever possible.\n   *\n   * @return {boolean}\n   * @export\n   */\n  usingPresentationStartTime() {\n    // If it's VOD, IPR, or an HLS \"event\", we are not using the presentation\n    // start time.\n    if (this.presentationStartTime_ == null) {\n      return false;\n    }\n\n    // If we have explicit segment times, we're not using the presentation\n    // start time.\n    if (this.maxSegmentEndTime_ != null && this.autoCorrectDrift_) {\n      return false;\n    }\n\n    return true;\n  }\n\n\n  /**\n   * @return {number} The current presentation time in seconds.\n   * @private\n   */\n  getLiveEdge_() {\n    goog.asserts.assert(this.presentationStartTime_ != null,\n        'Cannot compute timeline live edge without start time');\n    // Date.now() is in milliseconds, from which we compute \"now\" in seconds.\n    const now = (Date.now() + this.clockOffset_) / 1000.0;\n    return Math.max(\n        0, now - this.maxSegmentDuration_ - this.presentationStartTime_);\n  }\n\n  /**\n   * Sets the presentation's segment availability time offset. This should be\n   * only set for Low Latency Dash.\n   * The segments are available earlier for download than the availability start\n   * time, so we can move closer to the live edge.\n   *\n   * @param {number} offset\n   * @export\n   */\n  setAvailabilityTimeOffset(offset) {\n    this.availabilityTimeOffset_ = offset;\n  }\n\n  /**\n   * Debug only: assert that the timeline parameters make sense for the type\n   * of presentation (VOD, IPR, live).\n   */\n  assertIsValid() {\n    if (goog.DEBUG) {\n      if (this.isLive()) {\n        // Implied by isLive(): infinite and dynamic.\n        // Live streams should have a start time.\n        goog.asserts.assert(this.presentationStartTime_ != null,\n            'Detected as live stream, but does not match our model of live!');\n      } else if (this.isInProgress()) {\n        // Implied by isInProgress(): finite and dynamic.\n        // IPR streams should have a start time, and segments should not expire.\n        goog.asserts.assert(this.presentationStartTime_ != null &&\n                            this.segmentAvailabilityDuration_ == Infinity,\n        'Detected as IPR stream, but does not match our model of IPR!');\n      } else {  // VOD\n        // VOD segments should not expire and the presentation should be finite\n        // and static.\n        goog.asserts.assert(this.segmentAvailabilityDuration_ == Infinity &&\n                            this.duration_ != Infinity &&\n                            this.static_,\n        'Detected as VOD stream, but does not match our model of VOD!');\n      }\n    }\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.StallDetector');\ngoog.provide('shaka.media.StallDetector.Implementation');\ngoog.provide('shaka.media.StallDetector.MediaElementImplementation');\n\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.util.IReleasable');\n\n/**\n * Some platforms/browsers can get stuck in the middle of a buffered range (e.g.\n * when seeking in a background tab). Detect when we get stuck so that the\n * player can respond.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.StallDetector = class {\n  /**\n   * @param {shaka.media.StallDetector.Implementation} implementation\n   * @param {number} stallThresholdSeconds\n   */\n  constructor(implementation, stallThresholdSeconds) {\n    /** @private {shaka.media.StallDetector.Implementation} */\n    this.implementation_ = implementation;\n\n    /** @private {boolean} */\n    this.wasMakingProgress_ = implementation.shouldBeMakingProgress();\n    /** @private {number} */\n    this.value_ = implementation.getPresentationSeconds();\n    /** @private {number} */\n    this.lastUpdateSeconds_ = implementation.getWallSeconds();\n    /** @private {boolean} */\n    this.didJump_ = false;\n\n    /**\n     * The amount of time in seconds that we must have the same value of\n     * |value_| before we declare it as a stall.\n     *\n     * @private {number}\n     */\n    this.stallThresholdSeconds_ = stallThresholdSeconds;\n\n    /** @private {function(number, number)} */\n    this.onStall_ = () => {};\n  }\n\n  /** @override */\n  release() {\n    // Drop external references to make things easier on the GC.\n    this.implementation_ = null;\n    this.onStall_ = () => {};\n  }\n\n  /**\n   * Set the callback that should be called when a stall is detected. Calling\n   * this will override any previous calls to |onStall|.\n   *\n   * @param {function(number, number)} doThis\n   */\n  onStall(doThis) {\n    this.onStall_ = doThis;\n  }\n\n  /**\n   * Have the detector update itself and fire the \"on stall\" callback if a stall\n   * was detected.\n   *\n   * @return {boolean} True if action was taken.\n   */\n  poll() {\n    const impl = this.implementation_;\n\n    const shouldBeMakingProgress = impl.shouldBeMakingProgress();\n    const value = impl.getPresentationSeconds();\n    const wallTimeSeconds = impl.getWallSeconds();\n\n    const acceptUpdate = this.value_ != value ||\n                         this.wasMakingProgress_ != shouldBeMakingProgress;\n\n    if (acceptUpdate) {\n      this.lastUpdateSeconds_ = wallTimeSeconds;\n      this.value_ = value;\n      this.wasMakingProgress_ = shouldBeMakingProgress;\n      this.didJump_ = false;\n    }\n\n    const stallSeconds = wallTimeSeconds - this.lastUpdateSeconds_;\n\n    const triggerCallback = stallSeconds >= this.stallThresholdSeconds_ &&\n                            shouldBeMakingProgress && !this.didJump_;\n\n    if (triggerCallback) {\n      this.onStall_(this.value_, stallSeconds);\n      this.didJump_ = true;\n      // If the onStall_ method updated the current time, update our stored\n      // value so we don't think that was an update.\n      this.value_ = impl.getPresentationSeconds();\n    }\n\n    return triggerCallback;\n  }\n};\n\n/**\n * @interface\n */\nshaka.media.StallDetector.Implementation = class {\n  /**\n   * Check if the presentation time should be changing. This will return |true|\n   * when we expect the presentation time to change.\n   *\n   * @return {boolean}\n   */\n  shouldBeMakingProgress() {}\n\n  /**\n   * Get the presentation time in seconds.\n   *\n   * @return {number}\n   */\n  getPresentationSeconds() {}\n\n  /**\n   * Get the time wall time in seconds.\n   *\n   * @return {number}\n   */\n  getWallSeconds() {}\n};\n\n\n/**\n * Some platforms/browsers can get stuck in the middle of a buffered range (e.g.\n * when seeking in a background tab). Force a seek to help get it going again.\n *\n * @implements {shaka.media.StallDetector.Implementation}\n * @final\n */\nshaka.media.StallDetector.MediaElementImplementation = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   */\n  constructor(mediaElement) {\n    /** @private {!HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n  }\n\n  /** @override */\n  shouldBeMakingProgress() {\n    // If we are not trying to play, the lack of change could be misidentified\n    // as a stall.\n    if (this.mediaElement_.paused) {\n      return false;\n    }\n    if (this.mediaElement_.playbackRate == 0) {\n      return false;\n    }\n\n    // If we have don't have enough content, we are not stalled, we are\n    // buffering.\n    if (this.mediaElement_.buffered.length == 0) {\n      return false;\n    }\n\n    return shaka.media.StallDetector.MediaElementImplementation.hasContentFor_(\n        this.mediaElement_.buffered,\n        /* timeInSeconds= */ this.mediaElement_.currentTime);\n  }\n\n  /** @override */\n  getPresentationSeconds() {\n    return this.mediaElement_.currentTime;\n  }\n\n  /** @override */\n  getWallSeconds() {\n    return Date.now() / 1000;\n  }\n\n  /**\n   * Check if we have buffered enough content to play at |timeInSeconds|. Ignore\n   * the end of the buffered range since it may not play any more on all\n   * platforms.\n   *\n   * @param {!TimeRanges} buffered\n   * @param {number} timeInSeconds\n   * @return {boolean}\n   * @private\n   */\n  static hasContentFor_(buffered, timeInSeconds) {\n    const TimeRangesUtils = shaka.media.TimeRangesUtils;\n    for (const {start, end} of TimeRangesUtils.getBufferedInfo(buffered)) {\n      // Can be as much as 100ms before the range\n      if (timeInSeconds < start - 0.1) {\n        continue;\n      }\n      // Must be at least 500ms inside the range\n      if (timeInSeconds > end - 0.5) {\n        continue;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.GapJumpingController');\n\ngoog.require('shaka.log');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.StallDetector');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * GapJumpingController handles jumping gaps that appear within the content.\n * This will only jump gaps between two buffered ranges, so we should not have\n * to worry about the availability window.\n *\n * @implements {shaka.util.IReleasable}\n */\nshaka.media.GapJumpingController = class {\n  /**\n   * @param {!HTMLMediaElement} video\n   * @param {!shaka.media.PresentationTimeline} timeline\n   * @param {shaka.extern.StreamingConfiguration} config\n   * @param {shaka.media.StallDetector} stallDetector\n   *   The stall detector is used to keep the playhead moving while in a\n   *   playable region. The gap jumping controller takes ownership over the\n   *   stall detector.\n   *   If no stall detection logic is desired, |null| may be provided.\n   * @param {function(!Event)} onEvent Called when an event is raised to be sent\n   *   to the application.\n   */\n  constructor(video, timeline, config, stallDetector, onEvent) {\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {?shaka.media.PresentationTimeline} */\n    this.timeline_ = timeline;\n\n    /** @private {?shaka.extern.StreamingConfiguration} */\n    this.config_ = config;\n\n    /** @private {?function(!Event)} */\n    this.onEvent_ = onEvent;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {boolean} */\n    this.seekingEventReceived_ = false;\n\n    /** @private {number} */\n    this.prevReadyState_ = video.readyState;\n\n    /** @private {boolean} */\n    this.didFireLargeGap_ = false;\n\n    /**\n     * The stall detector tries to keep the playhead moving forward. It is\n     * managed by the gap-jumping controller to avoid conflicts. On some\n     * platforms, the stall detector is not wanted, so it may be null.\n     *\n     * @private {shaka.media.StallDetector}\n     */\n    this.stallDetector_ = stallDetector;\n\n    /** @private {boolean} */\n    this.hadSegmentAppended_ = false;\n\n    this.eventManager_.listen(video, 'waiting', () => this.onPollGapJump_());\n\n    /**\n     * We can't trust |readyState| or 'waiting' events on all platforms. To make\n     * up for this, we poll the current time. If we think we are in a gap, jump\n     * out of it.\n     *\n     * See: https://bit.ly/2McuXxm and https://bit.ly/2K5xmJO\n     *\n     * @private {?shaka.util.Timer}\n     */\n    this.gapJumpTimer_ = new shaka.util.Timer(() => {\n      this.onPollGapJump_();\n    }).tickEvery(/* seconds= */ 0.25);\n  }\n\n\n  /** @override */\n  release() {\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    if (this.gapJumpTimer_ != null) {\n      this.gapJumpTimer_.stop();\n      this.gapJumpTimer_ = null;\n    }\n\n    if (this.stallDetector_) {\n      this.stallDetector_.release();\n      this.stallDetector_ = null;\n    }\n\n    this.onEvent_ = null;\n    this.timeline_ = null;\n    this.video_ = null;\n  }\n\n\n  /**\n   * Called when a segment is appended by StreamingEngine, but not when a clear\n   * is pending. This means StreamingEngine will continue buffering forward from\n   * what is buffered.  So we know about any gaps before the start.\n   */\n  onSegmentAppended() {\n    this.hadSegmentAppended_ = true;\n    this.onPollGapJump_();\n  }\n\n\n  /** Called when a seek has started. */\n  onSeeking() {\n    this.seekingEventReceived_ = true;\n    this.hadSegmentAppended_ = false;\n    this.didFireLargeGap_ = false;\n  }\n\n\n  /**\n   * Called on a recurring timer to check for gaps in the media.  This is also\n   * called in a 'waiting' event.\n   *\n   * @private\n   */\n  onPollGapJump_() {\n    // Don't gap jump before the video is ready to play.\n    if (this.video_.readyState == 0) {\n      return;\n    }\n    // Do not gap jump if seeking has begun, but the seeking event has not\n    // yet fired for this particular seek.\n    if (this.video_.seeking) {\n      if (!this.seekingEventReceived_) {\n        return;\n      }\n    } else {\n      this.seekingEventReceived_ = false;\n    }\n    // Don't gap jump while paused, so that you don't constantly jump ahead\n    // while paused on a livestream.  We make an exception for time 0, since we\n    // may be _required_ to seek on startup before play can begin, but only if\n    // autoplay is enabled.\n    if (this.video_.paused && (this.video_.currentTime != 0 ||\n      (!this.video_.autoplay && this.video_.currentTime == 0))) {\n      return;\n    }\n\n\n    // When the ready state changes, we have moved on, so we should fire the\n    // large gap event if we see one.\n    if (this.video_.readyState != this.prevReadyState_) {\n      this.didFireLargeGap_ = false;\n      this.prevReadyState_ = this.video_.readyState;\n    }\n\n    if (this.stallDetector_ && this.stallDetector_.poll()) {\n      // Some action was taken by StallDetector, so don't do anything yet.\n      return;\n    }\n\n\n    const smallGapLimit = this.config_.smallGapLimit;\n    const currentTime = this.video_.currentTime;\n    const buffered = this.video_.buffered;\n    const gapDetectionThreshold = this.config_.gapDetectionThreshold;\n\n    const gapIndex = shaka.media.TimeRangesUtils.getGapIndex(\n        buffered, currentTime, gapDetectionThreshold);\n\n    // The current time is unbuffered or is too far from a gap.\n    if (gapIndex == null) {\n      return;\n    }\n\n    // If we are before the first buffered range, this could be an unbuffered\n    // seek.  So wait until a segment is appended so we are sure it is a gap.\n    if (gapIndex == 0 && !this.hadSegmentAppended_) {\n      return;\n    }\n\n    // StreamingEngine can buffer past the seek end, but still don't allow\n    // seeking past it.\n    const jumpTo = buffered.start(gapIndex);\n    const seekEnd = this.timeline_.getSeekRangeEnd();\n    if (jumpTo >= seekEnd) {\n      return;\n    }\n\n    const jumpSize = jumpTo - currentTime;\n    const isGapSmall = jumpSize <= smallGapLimit;\n    let jumpLargeGap = false;\n\n    // If we jump to exactly the gap start, we may detect a small gap due to\n    // rounding errors or browser bugs.  We can ignore these extremely small\n    // gaps since the browser should play through them for us.\n    if (jumpSize < shaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE) {\n      return;\n    }\n\n    if (!isGapSmall && !this.didFireLargeGap_) {\n      this.didFireLargeGap_ = true;\n\n      // Event firing is synchronous.\n      const data = new Map()\n          .set('currentTime', currentTime)\n          .set('gapSize', jumpSize);\n      const event = new shaka.util.FakeEvent('largegap', data);\n      event.cancelable = true;\n      this.onEvent_(event);\n\n      if (this.config_.jumpLargeGaps && !event.defaultPrevented) {\n        jumpLargeGap = true;\n      } else {\n        shaka.log.info('Ignoring large gap at', currentTime, 'size', jumpSize);\n      }\n    }\n\n    if (isGapSmall || jumpLargeGap) {\n      if (gapIndex == 0) {\n        shaka.log.info(\n            'Jumping forward', jumpSize,\n            'seconds because of gap before start time of', jumpTo);\n      } else {\n        shaka.log.info(\n            'Jumping forward', jumpSize, 'seconds because of gap starting at',\n            buffered.end(gapIndex - 1), 'and ending at', jumpTo);\n      }\n\n      this.video_.currentTime = jumpTo;\n    }\n  }\n};\n\n\n/**\n * The limit, in seconds, for the gap size that we will assume the browser will\n * handle for us.\n * @const\n */\nshaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE = 0.001;\n\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.MediaReadyState');\n\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.Lazy');\n\n\nshaka.util.MediaReadyState = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {number} readyState\n   * @param {shaka.util.EventManager} eventManager\n   * @param {function()} callback\n   */\n  static waitForReadyState(mediaElement, readyState, eventManager, callback) {\n    if (readyState == HTMLMediaElement.HAVE_NOTHING ||\n      mediaElement.readyState >= readyState) {\n      callback();\n    } else {\n      const MediaReadyState = shaka.util.MediaReadyState;\n      const eventName =\n          MediaReadyState.READY_STATES_TO_EVENT_NAMES_.value().get(readyState);\n      eventManager.listenOnce(mediaElement, eventName, callback);\n    }\n  }\n};\n\n/**\n * @const {!shaka.util.Lazy.<!Map.<number, string>>}\n * @private\n */\nshaka.util.MediaReadyState.READY_STATES_TO_EVENT_NAMES_ =\n    new shaka.util.Lazy(() => new Map([\n      [HTMLMediaElement.HAVE_METADATA, 'loadedmetadata'],\n      [HTMLMediaElement.HAVE_CURRENT_DATA, 'loadeddata'],\n      [HTMLMediaElement.HAVE_FUTURE_DATA, 'canplay'],\n      [HTMLMediaElement.HAVE_ENOUGH_DATA, 'canplaythrough'],\n    ]));\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.VideoWrapper');\ngoog.provide('shaka.media.VideoWrapper.PlayheadMover');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.MediaReadyState');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * Creates a new VideoWrapper that manages setting current time and playback\n * rate.  This handles seeks before content is loaded and ensuring the video\n * time is set properly.  This doesn't handle repositioning within the\n * presentation window.\n *\n * @implements {shaka.util.IReleasable}\n */\nshaka.media.VideoWrapper = class {\n  /**\n   * @param {!HTMLMediaElement} video\n   * @param {function()} onSeek Called when the video seeks.\n   * @param {number} startTime The time to start at.\n   */\n  constructor(video, onSeek, startTime) {\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {function()} */\n    this.onSeek_ = onSeek;\n\n    /** @private {number} */\n    this.startTime_ = startTime;\n\n    /** @private {boolean} */\n    this.started_ = false;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {shaka.media.VideoWrapper.PlayheadMover} */\n    this.mover_ = new shaka.media.VideoWrapper.PlayheadMover(\n        /* mediaElement= */ video,\n        /* maxAttempts= */ 10);\n\n    // Before we can set the start time, we must check if the video element is\n    // ready. If the video element is not ready, we cannot set the time. To work\n    // around this, we will wait for the \"loadedmetadata\" event which tells us\n    // that the media element is now ready.\n    shaka.util.MediaReadyState.waitForReadyState(this.video_,\n        HTMLMediaElement.HAVE_METADATA,\n        this.eventManager_,\n        () => {\n          this.setStartTime_(this.startTime_);\n        });\n  }\n\n\n  /** @override */\n  release() {\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    if (this.mover_ != null) {\n      this.mover_.release();\n      this.mover_ = null;\n    }\n\n    this.onSeek_ = () => {};\n    this.video_ = null;\n  }\n\n\n  /**\n   * Gets the video's current (logical) position.\n   *\n   * @return {number}\n   */\n  getTime() {\n    return this.started_ ? this.video_.currentTime : this.startTime_;\n  }\n\n\n  /**\n   * Sets the current time of the video.\n   *\n   * @param {number} time\n   */\n  setTime(time) {\n    if (this.video_.readyState > 0) {\n      this.mover_.moveTo(time);\n    } else {\n      shaka.util.MediaReadyState.waitForReadyState(this.video_,\n          HTMLMediaElement.HAVE_METADATA,\n          this.eventManager_,\n          () => {\n            this.setStartTime_(this.startTime_);\n          });\n    }\n  }\n\n\n  /**\n   * Set the start time for the content. The given start time will be ignored if\n   * the content does not start at 0.\n   *\n   * @param {number} startTime\n   * @private\n   */\n  setStartTime_(startTime) {\n    // If we start close enough to our intended start time, then we won't do\n    // anything special.\n    if (Math.abs(this.video_.currentTime - startTime) < 0.001) {\n      this.startListeningToSeeks_();\n      return;\n    }\n\n    // We will need to delay adding our normal seeking listener until we have\n    // seen the first seek event. We will force the first seek event later in\n    // this method.\n    this.eventManager_.listenOnce(this.video_, 'seeking', () => {\n      this.startListeningToSeeks_();\n    });\n\n    // If the currentTime != 0, it indicates that the user has seeked after\n    // calling |Player.load|, meaning that |currentTime| is more meaningful than\n    // |startTime|.\n    //\n    // Seeking to the current time is a work around for Issue 1298 and 4888.\n    // If we don't do this, the video may get stuck and not play.\n    //\n    // TODO: Need further investigation why it happens. Before and after\n    // setting the current time, video.readyState is 1, video.paused is true,\n    // and video.buffered's TimeRanges length is 0.\n    // See: https://github.com/shaka-project/shaka-player/issues/1298\n    this.mover_.moveTo(\n        (!this.video_.currentTime || this.video_.currentTime == 0) ?\n        startTime :\n        this.video_.currentTime);\n  }\n\n\n  /**\n   * Add the listener for seek-events. This will call the externally-provided\n   * |onSeek| callback whenever the media element seeks.\n   *\n   * @private\n   */\n  startListeningToSeeks_() {\n    goog.asserts.assert(\n        this.video_.readyState > 0,\n        'The media element should be ready before we listen for seeking.');\n\n    // Now that any startup seeking is complete, we can trust the video element\n    // for currentTime.\n    this.started_ = true;\n\n    this.eventManager_.listen(this.video_, 'seeking', () => this.onSeek_());\n  }\n};\n\n/**\n * A class used to move the playhead away from its current time.  Sometimes,\n * Edge ignores re-seeks. After changing the current time, check every 100ms,\n * retrying if the change was not accepted.\n *\n * Delay stats over 100 runs of a re-seeking integration test:\n *   Edge   -   0ms -   2%\n *   Edge   - 100ms -  40%\n *   Edge   - 200ms -  32%\n *   Edge   - 300ms -  24%\n *   Edge   - 400ms -   2%\n *   Chrome -   0ms - 100%\n *\n * TODO: File a bug on Edge about this.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.VideoWrapper.PlayheadMover = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   *    The media element that the mover can manipulate.\n   *\n   * @param {number} maxAttempts\n   *    To prevent us from infinitely trying to change the current time, the\n   *    mover accepts a max attempts value. At most, the mover will check if the\n   *    video moved |maxAttempts| times. If this is zero of negative, no\n   *    attempts will be made.\n   */\n  constructor(mediaElement, maxAttempts) {\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n\n    /** @private {number} */\n    this.maxAttempts_ = maxAttempts;\n\n    /** @private {number} */\n    this.remainingAttempts_ = 0;\n\n    /** @private {number} */\n    this.originTime_ = 0;\n\n    /** @private {number} */\n    this.targetTime_ = 0;\n\n    /** @private {shaka.util.Timer} */\n    this.timer_ = new shaka.util.Timer(() => this.onTick_());\n  }\n\n  /** @override */\n  release() {\n    if (this.timer_) {\n      this.timer_.stop();\n      this.timer_ = null;\n    }\n\n    this.mediaElement_ = null;\n  }\n\n  /**\n   * Try forcing the media element to move to |timeInSeconds|. If a previous\n   * call to |moveTo| is still in progress, this will override it.\n   *\n   * @param {number} timeInSeconds\n   */\n  moveTo(timeInSeconds) {\n    this.originTime_ = this.mediaElement_.currentTime;\n    this.targetTime_ = timeInSeconds;\n\n    this.remainingAttempts_ = this.maxAttempts_;\n\n    // Set the time and then start the timer. The timer will check if the set\n    // was successful, and retry if not.\n    this.mediaElement_.currentTime = timeInSeconds;\n    this.timer_.tickEvery(/* seconds= */ 0.1);\n  }\n\n  /**\n   * @private\n   */\n  onTick_() {\n    // Sigh... We ran out of retries...\n    if (this.remainingAttempts_ <= 0) {\n      shaka.log.warning([\n        'Failed to move playhead from', this.originTime_,\n        'to', this.targetTime_,\n      ].join(' '));\n\n      this.timer_.stop();\n      return;\n    }\n\n    // Yay! We were successful.\n    if (this.mediaElement_.currentTime != this.originTime_) {\n      this.timer_.stop();\n      return;\n    }\n\n    // Sigh... Try again...\n    this.mediaElement_.currentTime = this.targetTime_;\n    this.remainingAttempts_--;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.MediaSourcePlayhead');\ngoog.provide('shaka.media.Playhead');\ngoog.provide('shaka.media.SrcEqualsPlayhead');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.GapJumpingController');\ngoog.require('shaka.media.StallDetector');\ngoog.require('shaka.media.StallDetector.MediaElementImplementation');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.media.VideoWrapper');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.MediaReadyState');\ngoog.require('shaka.util.Timer');\ngoog.requireType('shaka.media.PresentationTimeline');\n\n\n/**\n * Creates a Playhead, which manages the video's current time.\n *\n * The Playhead provides mechanisms for setting the presentation's start time,\n * restricting seeking to valid time ranges, and stopping playback for startup\n * and re-buffering.\n *\n * @extends {shaka.util.IReleasable}\n * @interface\n */\nshaka.media.Playhead = class {\n  /**\n   * Called when the Player is ready to begin playback. Anything that depends\n   * on setStartTime() should be done here, not in the constructor.\n   *\n   * @see https://github.com/shaka-project/shaka-player/issues/4244\n   */\n  ready() {}\n\n  /**\n   * Set the start time. If the content has already started playback, this will\n   * be ignored.\n   *\n   * @param {number} startTime\n   */\n  setStartTime(startTime) {}\n\n  /**\n   * Get the current playhead position. The position will be restricted to valid\n   * time ranges.\n   *\n   * @return {number}\n   */\n  getTime() {}\n\n  /**\n   * Notify the playhead that the buffered ranges have changed.\n   */\n  notifyOfBufferingChange() {}\n};\n\n\n/**\n * A playhead implementation that only relies on the media element.\n *\n * @implements {shaka.media.Playhead}\n * @final\n */\nshaka.media.SrcEqualsPlayhead = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   */\n  constructor(mediaElement) {\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n    /** @private {boolean} */\n    this.started_ = false;\n    /** @private {?number} */\n    this.startTime_ = null;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n  }\n\n  /** @override */\n  ready() {\n    goog.asserts.assert(\n        this.mediaElement_ != null,\n        'Playhead should not be released before calling ready()',\n    );\n\n    // We listen for the loaded-data-event so that we know when we can\n    // interact with |currentTime|.\n    const onLoaded = () => {\n      if (this.startTime_ == null || this.startTime_ == 0) {\n        this.started_ = true;\n      } else {\n        // Startup is complete only when the video element acknowledges the\n        // seek.\n        this.eventManager_.listenOnce(this.mediaElement_, 'seeking', () => {\n          this.started_ = true;\n        });\n\n        const currentTime = this.mediaElement_.currentTime;\n        // Using the currentTime allows using a negative number in Live HLS\n        const newTime = Math.max(0, currentTime + this.startTime_);\n        this.mediaElement_.currentTime = newTime;\n      }\n    };\n\n    shaka.util.MediaReadyState.waitForReadyState(this.mediaElement_,\n        HTMLMediaElement.HAVE_CURRENT_DATA,\n        this.eventManager_, () => {\n          onLoaded();\n        });\n  }\n\n  /** @override */\n  release() {\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    this.mediaElement_ = null;\n  }\n\n  /** @override */\n  setStartTime(startTime) {\n    // If we have already started playback, ignore updates to the start time.\n    // This is just to make things consistent.\n    this.startTime_ = this.started_ ? this.startTime_ : startTime;\n  }\n\n  /** @override */\n  getTime() {\n    // If we have not started playback yet, return the start time. However once\n    // we start playback we assume that we can always return the current time.\n    const time = this.started_ ?\n                 this.mediaElement_.currentTime :\n                 this.startTime_;\n\n    // In the case that we have not started playback, but the start time was\n    // never set, we don't know what the start time should be. To ensure we\n    // always return a number, we will default back to 0.\n    return time || 0;\n  }\n\n  /** @override */\n  notifyOfBufferingChange() {}\n};\n\n\n/**\n * A playhead implementation that relies on the media element and a manifest.\n * When provided with a manifest, we can provide more accurate control than\n * the SrcEqualsPlayhead.\n *\n * TODO: Clean up and simplify Playhead.  There are too many layers of, methods\n *       for, and conditions on timestamp adjustment.\n *\n * @implements {shaka.media.Playhead}\n * @final\n */\nshaka.media.MediaSourcePlayhead = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.extern.StreamingConfiguration} config\n   * @param {?number} startTime\n   *     The playhead's initial position in seconds. If null, defaults to the\n   *     start of the presentation for VOD and the live-edge for live.\n   * @param {function()} onSeek\n   *     Called when the user agent seeks to a time within the presentation\n   *     timeline.\n   * @param {function(!Event)} onEvent\n   *     Called when an event is raised to be sent to the application.\n   */\n  constructor(mediaElement, manifest, config, startTime, onSeek, onEvent) {\n    /**\n     * The seek range must be at least this number of seconds long. If it is\n     * smaller than this, change it to be this big so we don't repeatedly seek\n     * to keep within a zero-width window.\n     *\n     * This is 3s long, to account for the weaker hardware on platforms like\n     * Chromecast.\n     *\n     * @private {number}\n     */\n    this.minSeekRange_ = 3.0;\n\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n\n    /** @private {shaka.media.PresentationTimeline} */\n    this.timeline_ = manifest.presentationTimeline;\n\n    /** @private {number} */\n    this.minBufferTime_ = manifest.minBufferTime || 0;\n\n    /** @private {?shaka.extern.StreamingConfiguration} */\n    this.config_ = config;\n\n    /** @private {function()} */\n    this.onSeek_ = onSeek;\n\n    /** @private {?number} */\n    this.lastCorrectiveSeek_ = null;\n\n    /** @private {shaka.media.GapJumpingController} */\n    this.gapController_ = new shaka.media.GapJumpingController(\n        mediaElement,\n        manifest.presentationTimeline,\n        config,\n        this.createStallDetector_(mediaElement, config),\n        onEvent);\n\n    /** @private {shaka.media.VideoWrapper} */\n    this.videoWrapper_ = new shaka.media.VideoWrapper(\n        mediaElement,\n        () => this.onSeeking_(),\n        this.getStartTime_(startTime));\n\n    /** @type {shaka.util.Timer} */\n    this.checkWindowTimer_ = new shaka.util.Timer(() => {\n      this.onPollWindow_();\n    });\n  }\n\n  /** @override */\n  ready() {\n    this.checkWindowTimer_.tickEvery(/* seconds= */ 0.25);\n  }\n\n  /** @override */\n  release() {\n    if (this.videoWrapper_) {\n      this.videoWrapper_.release();\n      this.videoWrapper_ = null;\n    }\n\n    if (this.gapController_) {\n      this.gapController_.release();\n      this.gapController_= null;\n    }\n\n    if (this.checkWindowTimer_) {\n      this.checkWindowTimer_.stop();\n      this.checkWindowTimer_ = null;\n    }\n\n    this.config_ = null;\n    this.timeline_ = null;\n    this.videoWrapper_ = null;\n    this.mediaElement_ = null;\n\n    this.onSeek_ = () => {};\n  }\n\n  /** @override */\n  setStartTime(startTime) {\n    this.videoWrapper_.setTime(startTime);\n  }\n\n  /** @override */\n  getTime() {\n    const time = this.videoWrapper_.getTime();\n\n    // Although we restrict the video's currentTime elsewhere, clamp it here to\n    // ensure timing issues don't cause us to return a time outside the segment\n    // availability window.  E.g., the user agent seeks and calls this function\n    // before we receive the 'seeking' event.\n    //\n    // We don't buffer when the livestream video is paused and the playhead time\n    // is out of the seek range; thus, we do not clamp the current time when the\n    // video is paused.\n    // https://github.com/shaka-project/shaka-player/issues/1121\n    if (this.mediaElement_.readyState > 0 && !this.mediaElement_.paused) {\n      return this.clampTime_(time);\n    }\n\n    return time;\n  }\n\n  /**\n   * Gets the playhead's initial position in seconds.\n   *\n   * @param {?number} startTime\n   * @return {number}\n   * @private\n   */\n  getStartTime_(startTime) {\n    if (startTime == null) {\n      if (this.timeline_.getDuration() < Infinity) {\n        // If the presentation is VOD, or if the presentation is live but has\n        // finished broadcasting, then start from the beginning.\n        startTime = this.timeline_.getSeekRangeStart();\n      } else {\n        // Otherwise, start near the live-edge.\n        startTime = this.timeline_.getSeekRangeEnd();\n      }\n    } else if (startTime < 0) {\n      // For live streams, if the startTime is negative, start from a certain\n      // offset time from the live edge.  If the offset from the live edge is\n      // not available, start from the current available segment start point\n      // instead, handled by clampTime_().\n      startTime = this.timeline_.getSeekRangeEnd() + startTime;\n    }\n\n    return this.clampSeekToDuration_(this.clampTime_(startTime));\n  }\n\n  /** @override */\n  notifyOfBufferingChange() {\n    this.gapController_.onSegmentAppended();\n  }\n\n  /**\n   * Called on a recurring timer to keep the playhead from falling outside the\n   * availability window.\n   *\n   * @private\n   */\n  onPollWindow_() {\n    // Don't catch up to the seek range when we are paused or empty.\n    // The definition of \"seeking\" says that we are seeking until the buffered\n    // data intersects with the playhead.  If we fall outside of the seek range,\n    // it doesn't matter if we are in a \"seeking\" state.  We can and should go\n    // ahead and catch up while seeking.\n    if (this.mediaElement_.readyState == 0 || this.mediaElement_.paused) {\n      return;\n    }\n\n    const currentTime = this.videoWrapper_.getTime();\n    let seekStart = this.timeline_.getSeekRangeStart();\n    const seekEnd = this.timeline_.getSeekRangeEnd();\n\n    if (seekEnd - seekStart < this.minSeekRange_) {\n      seekStart = seekEnd - this.minSeekRange_;\n    }\n\n    if (currentTime < seekStart) {\n      // The seek range has moved past the playhead.  Move ahead to catch up.\n      const targetTime = this.reposition_(currentTime);\n      shaka.log.info('Jumping forward ' + (targetTime - currentTime) +\n                     ' seconds to catch up with the seek range.');\n      this.mediaElement_.currentTime = targetTime;\n    }\n  }\n\n  /**\n   * Handles when a seek happens on the video.\n   *\n   * @private\n   */\n  onSeeking_() {\n    this.gapController_.onSeeking();\n    const currentTime = this.videoWrapper_.getTime();\n    const targetTime = this.reposition_(currentTime);\n\n    const gapLimit = shaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE;\n    if (Math.abs(targetTime - currentTime) > gapLimit) {\n      // You can only seek like this every so often. This is to prevent an\n      // infinite loop on systems where changing currentTime takes a significant\n      // amount of time (e.g. Chromecast).\n      const time = Date.now() / 1000;\n      if (!this.lastCorrectiveSeek_ || this.lastCorrectiveSeek_ < time - 1) {\n        this.lastCorrectiveSeek_ = time;\n        this.videoWrapper_.setTime(targetTime);\n        return;\n      }\n    }\n\n    shaka.log.v1('Seek to ' + currentTime);\n    this.onSeek_();\n  }\n\n  /**\n   * Clamp seek times and playback start times so that we never seek to the\n   * presentation duration.  Seeking to or starting at duration does not work\n   * consistently across browsers.\n   *\n   * @see https://github.com/shaka-project/shaka-player/issues/979\n   * @param {number} time\n   * @return {number} The adjusted seek time.\n   * @private\n   */\n  clampSeekToDuration_(time) {\n    const duration = this.timeline_.getDuration();\n    if (time >= duration) {\n      goog.asserts.assert(this.config_.durationBackoff >= 0,\n          'Duration backoff must be non-negative!');\n      return duration - this.config_.durationBackoff;\n    }\n    return time;\n  }\n\n  /**\n   * Computes a new playhead position that's within the presentation timeline.\n   *\n   * @param {number} currentTime\n   * @return {number} The time to reposition the playhead to.\n   * @private\n   */\n  reposition_(currentTime) {\n    goog.asserts.assert(\n        this.config_,\n        'Cannot reposition playhead when it has beeen destroyed');\n\n    /** @type {function(number)} */\n    const isBuffered = (playheadTime) => shaka.media.TimeRangesUtils.isBuffered(\n        this.mediaElement_.buffered, playheadTime);\n\n    const rebufferingGoal = Math.max(\n        this.minBufferTime_,\n        this.config_.rebufferingGoal);\n\n    const safeSeekOffset = this.config_.safeSeekOffset;\n\n    let start = this.timeline_.getSeekRangeStart();\n    const end = this.timeline_.getSeekRangeEnd();\n    const duration = this.timeline_.getDuration();\n\n    if (end - start < this.minSeekRange_) {\n      start = end - this.minSeekRange_;\n    }\n\n    // With live content, the beginning of the availability window is moving\n    // forward.  This means we cannot seek to it since we will \"fall\" outside\n    // the window while we buffer.  So we define a \"safe\" region that is far\n    // enough away.  For VOD, |safe == start|.\n    const safe = this.timeline_.getSafeSeekRangeStart(rebufferingGoal);\n\n    // These are the times to seek to rather than the exact destinations.  When\n    // we seek, we will get another event (after a slight delay) and these steps\n    // will run again.  So if we seeked directly to |start|, |start| would move\n    // on the next call and we would loop forever.\n    const seekStart = this.timeline_.getSafeSeekRangeStart(safeSeekOffset);\n    const seekSafe = this.timeline_.getSafeSeekRangeStart(\n        rebufferingGoal + safeSeekOffset);\n\n    if (currentTime >= duration) {\n      shaka.log.v1('Playhead past duration.');\n      return this.clampSeekToDuration_(currentTime);\n    }\n\n    if (currentTime > end) {\n      shaka.log.v1('Playhead past end.');\n      return end;\n    }\n\n    if (currentTime < start) {\n      if (isBuffered(seekStart)) {\n        shaka.log.v1('Playhead before start & start is buffered');\n        return seekStart;\n      } else {\n        shaka.log.v1('Playhead before start & start is unbuffered');\n        return seekSafe;\n      }\n    }\n\n    if (currentTime >= safe || isBuffered(currentTime)) {\n      shaka.log.v1('Playhead in safe region or in buffered region.');\n      return currentTime;\n    } else {\n      shaka.log.v1('Playhead outside safe region & in unbuffered region.');\n      return seekSafe;\n    }\n  }\n\n  /**\n   * Clamps the given time to the seek range.\n   *\n   * @param {number} time The time in seconds.\n   * @return {number} The clamped time in seconds.\n   * @private\n   */\n  clampTime_(time) {\n    const start = this.timeline_.getSeekRangeStart();\n    if (time < start) {\n      return start;\n    }\n\n    const end = this.timeline_.getSeekRangeEnd();\n    if (time > end) {\n      return end;\n    }\n\n    return time;\n  }\n\n  /**\n   * Create and configure a stall detector using the player's streaming\n   * configuration settings. If the player is configured to have no stall\n   * detector, this will return |null|.\n   *\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {shaka.extern.StreamingConfiguration} config\n   * @return {shaka.media.StallDetector}\n   * @private\n   */\n  createStallDetector_(mediaElement, config) {\n    if (!config.stallEnabled) {\n      return null;\n    }\n\n    // Cache the values from the config so that changes to the config won't\n    // change the initialized behaviour.\n    const threshold = config.stallThreshold;\n    const skip = config.stallSkip;\n\n    // When we see a stall, we will try to \"jump-start\" playback by moving the\n    // playhead forward.\n    const detector = new shaka.media.StallDetector(\n        new shaka.media.StallDetector.MediaElementImplementation(mediaElement),\n        threshold);\n\n    detector.onStall((at, duration) => {\n      shaka.log.debug(`Stall detected at ${at} for ${duration} seconds.`);\n\n      if (skip) {\n        shaka.log.debug(`Seeking forward ${skip} seconds to break stall.`);\n        mediaElement.currentTime += skip;\n      } else {\n        shaka.log.debug('Pausing and unpausing to break stall.');\n        mediaElement.pause();\n        mediaElement.play();\n      }\n    });\n\n    return detector;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.MetaSegmentIndex');\ngoog.provide('shaka.media.SegmentIndex');\ngoog.provide('shaka.media.SegmentIterator');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * SegmentIndex.\n *\n * @implements {shaka.util.IReleasable}\n * @implements {Iterable.<!shaka.media.SegmentReference>}\n * @export\n */\nshaka.media.SegmentIndex = class {\n  /**\n   * @param {!Array.<!shaka.media.SegmentReference>} references The list of\n   *   SegmentReferences, which must be sorted first by their start times\n   *   (ascending) and second by their end times (ascending).\n   */\n  constructor(references) {\n    if (goog.DEBUG) {\n      shaka.media.SegmentIndex.assertCorrectReferences_(references);\n    }\n\n    /** @protected {!Array.<!shaka.media.SegmentReference>} */\n    this.references = references;\n\n    /** @private {shaka.util.Timer} */\n    this.timer_ = null;\n\n    /**\n     * The number of references that have been removed from the front of the\n     * array.  Used to create stable positions in the find/get APIs.\n     *\n     * @protected {number}\n     */\n    this.numEvicted = 0;\n\n    /** @private {boolean} */\n    this.immutable_ = false;\n  }\n\n\n  /**\n   * SegmentIndex used to be an IDestroyable.  Now it is an IReleasable.\n   * This method is provided for backward compatibility.\n   *\n   * @deprecated\n   * @return {!Promise}\n   * @export\n   */\n  destroy() {\n    shaka.Deprecate.deprecateFeature(4,\n        'shaka.media.SegmentIndex',\n        'Please use release() instead of destroy().');\n    this.release();\n    return Promise.resolve();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  release() {\n    if (this.immutable_) {\n      return;\n    }\n\n    this.references = [];\n\n    if (this.timer_) {\n      this.timer_.stop();\n    }\n    this.timer_ = null;\n  }\n\n\n  /**\n   * Marks the index as immutable.  Segments cannot be added or removed after\n   * this point.  This doesn't affect the references themselves.  This also\n   * makes the destroy/release methods do nothing.\n   *\n   * This is mainly for testing.\n   *\n   * @export\n   */\n  markImmutable() {\n    this.immutable_ = true;\n  }\n\n\n  /**\n   * Finds the position of the segment for the given time, in seconds, relative\n   * to the start of the presentation.  Returns the position of the segment\n   * with the largest end time if more than one segment is known for the given\n   * time.\n   *\n   * @param {number} time\n   * @return {?number} The position of the segment, or null if the position of\n   *   the segment could not be determined.\n   * @export\n   */\n  find(time) {\n    // For live streams, searching from the end is faster.  For VOD, it balances\n    // out either way.  In both cases, references.length is small enough that\n    // the difference isn't huge.\n    const lastReferenceIndex = this.references.length - 1;\n    for (let i = lastReferenceIndex; i >= 0; --i) {\n      const r = this.references[i];\n      const start = r.startTime;\n      // A rounding error can cause /time/ to equal e.endTime or fall in between\n      // the references by a fraction of a second. To account for this, we use\n      // the start of the next segment as /end/, unless this is the last\n      // reference, in which case we use its end time as /end/.\n      const end = i < lastReferenceIndex ?\n        this.references[i + 1].startTime : r.endTime;\n      // Note that a segment ends immediately before the end time.\n      if ((time >= start) && (time < end)) {\n        return i + this.numEvicted;\n      }\n    }\n    if (this.references.length && time < this.references[0].startTime) {\n      return this.numEvicted;\n    }\n\n    return null;\n  }\n\n\n  /**\n   * Gets the SegmentReference for the segment at the given position.\n   *\n   * @param {number} position The position of the segment as returned by find().\n   * @return {shaka.media.SegmentReference} The SegmentReference, or null if\n   *   no such SegmentReference exists.\n   * @export\n   */\n  get(position) {\n    if (this.references.length == 0) {\n      return null;\n    }\n\n    const index = position - this.numEvicted;\n    if (index < 0 || index >= this.references.length) {\n      return null;\n    }\n\n    return this.references[index];\n  }\n\n\n  /**\n   * Offset all segment references by a fixed amount.\n   *\n   * @param {number} offset The amount to add to each segment's start and end\n   *   times.\n   * @export\n   */\n  offset(offset) {\n    if (!this.immutable_) {\n      for (const ref of this.references) {\n        ref.startTime += offset;\n        ref.endTime += offset;\n        ref.timestampOffset += offset;\n      }\n    }\n  }\n\n\n  /**\n   * Merges the given SegmentReferences.  Supports extending the original\n   * references only.  Will replace old references with equivalent new ones, and\n   * keep any unique old ones.\n   *\n   * Used, for example, by the DASH and HLS parser, where manifests may not list\n   * all available references, so we must keep available references in memory to\n   * fill the availability window.\n   *\n   * @param {!Array.<!shaka.media.SegmentReference>} references The list of\n   *   SegmentReferences, which must be sorted first by their start times\n   *   (ascending) and second by their end times (ascending).\n   * @deprecated Not used directly by our own parsers, so will become private in\n   *   v4.  Use mergeAndEvict() instead.\n   * @export\n   */\n  merge(references) {\n    if (goog.DEBUG) {\n      shaka.media.SegmentIndex.assertCorrectReferences_(references);\n    }\n    if (this.immutable_) {\n      return;\n    }\n\n    if (!references.length) {\n      return;\n    }\n\n    // Partial segments are used for live edge, and should be removed when they\n    // get older. Remove the old SegmentReferences after the first new\n    // reference's start time.\n    this.references = this.references.filter((r) => {\n      return r.startTime < references[0].startTime;\n    });\n\n    this.references.push(...references);\n\n    if (goog.DEBUG) {\n      shaka.media.SegmentIndex.assertCorrectReferences_(this.references);\n    }\n  }\n\n  /**\n   * Merges the given SegmentReferences and evicts the ones that end before the\n   * given time.  Supports extending the original references only.\n   * Will not replace old references or interleave new ones.\n   * Used, for example, by the DASH and HLS parser, where manifests may not list\n   * all available references, so we must keep available references in memory to\n   * fill the availability window.\n   *\n   * @param {!Array.<!shaka.media.SegmentReference>} references The list of\n   *   SegmentReferences, which must be sorted first by their start times\n   *   (ascending) and second by their end times (ascending).\n   * @param {number} windowStart The start of the availability window to filter\n   *   out the references that are no longer available.\n   * @export\n   */\n  mergeAndEvict(references, windowStart) {\n    // Filter out the references that are no longer available to avoid\n    // repeatedly evicting them and messing up eviction count.\n    references = references.filter((r) => {\n      return r.endTime > windowStart &&\n          (this.references.length == 0 ||\n           r.endTime > this.references[0].startTime);\n    });\n\n    const oldFirstRef = this.references[0];\n    this.merge(references);\n    const newFirstRef = this.references[0];\n\n    if (oldFirstRef) {\n      // We don't compare the actual ref, since the object could legitimately be\n      // replaced with an equivalent.  Even the URIs could change due to\n      // load-balancing actions taken by the server.  However, if the time\n      // changes, its not an equivalent reference.\n      goog.asserts.assert(oldFirstRef.startTime == newFirstRef.startTime,\n          'SegmentIndex.merge should not change the first reference time!');\n    }\n\n    this.evict(windowStart);\n  }\n\n  /**\n   * Removes all SegmentReferences that end before the given time.\n   *\n   * @param {number} time The time in seconds.\n   * @export\n   */\n  evict(time) {\n    if (this.immutable_) {\n      return;\n    }\n\n    const oldSize = this.references.length;\n\n    this.references = this.references.filter((ref) => ref.endTime > time);\n\n    const newSize = this.references.length;\n    const diff = oldSize - newSize;\n    // Tracking the number of evicted refs will keep their \"positions\" stable\n    // for the caller.\n    this.numEvicted += diff;\n  }\n\n\n  /**\n   * Drops references that start after windowEnd, or end before windowStart,\n   * and contracts the last reference so that it ends at windowEnd.\n   *\n   * Do not call on the last period of a live presentation (unknown duration).\n   * It is okay to call on the other periods of a live presentation, where the\n   * duration is known and another period has been added.\n   *\n   * @param {number} windowStart\n   * @param {?number} windowEnd\n   * @param {boolean=} isNew Whether this is a new SegmentIndex and we shouldn't\n   *   update the number of evicted elements.\n   * @export\n   */\n  fit(windowStart, windowEnd, isNew = false) {\n    goog.asserts.assert(windowEnd != null,\n        'Content duration must be known for static content!');\n    goog.asserts.assert(windowEnd != Infinity,\n        'Content duration must be finite for static content!');\n    if (this.immutable_) {\n      return;\n    }\n\n    // Trim out references we will never use.\n    while (this.references.length) {\n      const lastReference = this.references[this.references.length - 1];\n      if (lastReference.startTime >= windowEnd) {\n        this.references.pop();\n      } else {\n        break;\n      }\n    }\n\n    while (this.references.length) {\n      const firstReference = this.references[0];\n      if (firstReference.endTime <= windowStart) {\n        this.references.shift();\n        if (!isNew) {\n          this.numEvicted++;\n        }\n      } else {\n        break;\n      }\n    }\n\n    if (this.references.length == 0) {\n      return;\n    }\n\n    // Adjust the last SegmentReference.\n    const lastReference = this.references[this.references.length - 1];\n    this.references[this.references.length - 1] =\n        new shaka.media.SegmentReference(\n            lastReference.startTime,\n            /* endTime= */ windowEnd,\n            lastReference.getUrisInner,\n            lastReference.startByte,\n            lastReference.endByte,\n            lastReference.initSegmentReference,\n            lastReference.timestampOffset,\n            lastReference.appendWindowStart,\n            lastReference.appendWindowEnd,\n            lastReference.partialReferences,\n            lastReference.tilesLayout,\n            lastReference.tileDuration);\n  }\n\n\n  /**\n   * Updates the references every so often.  Stops when the references list\n   * returned by the callback is null.\n   *\n   * @param {number} interval The interval in seconds.\n   * @param {function():Array.<shaka.media.SegmentReference>} updateCallback\n   * @export\n   */\n  updateEvery(interval, updateCallback) {\n    goog.asserts.assert(!this.timer_, 'SegmentIndex timer already started!');\n    if (this.immutable_) {\n      return;\n    }\n    if (this.timer_) {\n      this.timer_.stop();\n    }\n\n    this.timer_ = new shaka.util.Timer(() => {\n      const references = updateCallback();\n      if (references) {\n        this.references.push(...references);\n      } else {\n        this.timer_.stop();\n        this.timer_ = null;\n      }\n    });\n    this.timer_.tickEvery(interval);\n  }\n\n\n  /** @return {!shaka.media.SegmentIterator} */\n  [Symbol.iterator]() {\n    const iter = this.getIteratorForTime(0);\n    goog.asserts.assert(iter != null, 'Iterator for 0 should never be null!');\n    return iter;\n  }\n\n  /**\n   * Returns a new iterator that initially points to the segment that contains\n   * the given time.  Like the normal iterator, next() must be called first to\n   * get to the first element. Returns null if we do not find a segment at the\n   * requested time.\n   *\n   * @param {number} time\n   * @return {?shaka.media.SegmentIterator}\n   * @export\n   */\n  getIteratorForTime(time) {\n    let index = this.find(time);\n    if (index == null) {\n      return null;\n    } else {\n      index--;\n    }\n    // +1 so we can get the element we'll eventually point to so we can see if\n    // we need to use a partial segment index.\n    const ref = this.get(index + 1);\n\n    let partialSegmentIndex = -1;\n    if (ref && ref.hasPartialSegments()) {\n      // Look for a partial SegmentReference.\n      for (let i = ref.partialReferences.length - 1; i >= 0; --i) {\n        const r = ref.partialReferences[i];\n        // Note that a segment ends immediately before the end time.\n        if ((time >= r.startTime) && (time < r.endTime)) {\n          // Call to next() should move the partial segment, not the full\n          // segment.\n          index++;\n          partialSegmentIndex = i - 1;\n          break;\n        }\n      }\n    }\n    return new shaka.media.SegmentIterator(this, index, partialSegmentIndex);\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isEmpty() {\n    return this.references.length == 0;\n  }\n\n  /**\n   * Create a SegmentIndex for a single segment of the given start time and\n   * duration at the given URIs.\n   *\n   * @param {number} startTime\n   * @param {number} duration\n   * @param {!Array.<string>} uris\n   * @return {!shaka.media.SegmentIndex}\n   * @export\n   */\n  static forSingleSegment(startTime, duration, uris) {\n    const reference = new shaka.media.SegmentReference(\n        /* startTime= */ startTime,\n        /* endTime= */ startTime + duration,\n        /* getUris= */ () => uris,\n        /* startByte= */ 0,\n        /* endByte= */ null,\n        /* initSegmentReference= */ null,\n        /* presentationTimeOffset= */ startTime,\n        /* appendWindowStart= */ startTime,\n        /* appendWindowEnd= */ startTime + duration);\n    return new shaka.media.SegmentIndex([reference]);\n  }\n};\n\n\nif (goog.DEBUG) {\n  /**\n   * Asserts that the given SegmentReferences are sorted.\n   *\n   * @param {!Array.<shaka.media.SegmentReference>} references\n   * @private\n   */\n  shaka.media.SegmentIndex.assertCorrectReferences_ = (references) => {\n    goog.asserts.assert(references.every((r2, i) => {\n      if (i == 0) {\n        return true;\n      }\n      const r1 = references[i - 1];\n      if (r1.startTime < r2.startTime) {\n        return true;\n      } else if (r1.startTime > r2.startTime) {\n        return false;\n      } else {\n        if (r1.endTime <= r2.endTime) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    }), 'SegmentReferences are incorrect');\n  };\n}\n\n\n/**\n * An iterator over a SegmentIndex's references.\n *\n * @implements {Iterator.<shaka.media.SegmentReference>}\n * @export\n */\nshaka.media.SegmentIterator = class {\n  /**\n   * @param {shaka.media.SegmentIndex} segmentIndex\n   * @param {number} index\n   * @param {number} partialSegmentIndex\n   */\n  constructor(segmentIndex, index, partialSegmentIndex) {\n    /** @private {shaka.media.SegmentIndex} */\n    this.segmentIndex_ = segmentIndex;\n\n    /** @private {number} */\n    this.currentPosition_ = index;\n\n    /** @private {number} */\n    this.currentPartialPosition_ = partialSegmentIndex;\n  }\n\n  /**\n   * Move the iterator to a given timestamp in the underlying SegmentIndex.\n   *\n   * @param {number} time\n   * @return {shaka.media.SegmentReference}\n   * @deprecated Use SegmentIndex.getIteratorForTime instead\n   * @export\n   */\n  seek(time) {\n    shaka.Deprecate.deprecateFeature(\n        4, 'shaka.media.SegmentIterator',\n        'Please use SegmentIndex.getIteratorForTime instead of seek().');\n\n    const iter = this.segmentIndex_.getIteratorForTime(time);\n    if (iter) {\n      this.currentPosition_ = iter.currentPosition_;\n      this.currentPartialPosition_ = iter.currentPartialPosition_;\n    } else {\n      this.currentPosition_ = Number.MAX_VALUE;\n      this.currentPartialPosition_ = 0;\n    }\n    return this.next().value;\n  }\n\n  /**\n   * @return {shaka.media.SegmentReference}\n   * @export\n   */\n  current() {\n    let ref = this.segmentIndex_.get(this.currentPosition_);\n\n    // When we advance past the end of partial references in next(), then add\n    // new references in merge(), the pointers may not make sense any more.\n    // This adjusts the invalid pointer values to point to the next newly added\n    // segment or partial segment.\n    if (ref && ref.hasPartialSegments() && ref.getUris().length &&\n        this.currentPartialPosition_ >= ref.partialReferences.length) {\n      this.currentPosition_++;\n      this.currentPartialPosition_ = 0;\n      ref = this.segmentIndex_.get(this.currentPosition_);\n    }\n\n    // If the regular segment contains partial segments, get the current\n    // partial SegmentReference.\n    if (ref && ref.hasPartialSegments()) {\n      const partial = ref.partialReferences[this.currentPartialPosition_];\n      return partial;\n    }\n    return ref;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  next() {\n    const ref = this.segmentIndex_.get(this.currentPosition_);\n\n    if (ref && ref.hasPartialSegments()) {\n      // If the regular segment contains partial segments, move to the next\n      // partial SegmentReference.\n      this.currentPartialPosition_++;\n      // If the current regular segment has been published completely (has a\n      // valid Uri), and we've reached the end of its partial segments list,\n      // move to the next regular segment.\n      // If the Partial Segments list is still on the fly, do not move to\n      // the next regular segment.\n      if (ref.getUris().length &&\n          this.currentPartialPosition_ == ref.partialReferences.length) {\n        this.currentPosition_++;\n        this.currentPartialPosition_ = 0;\n      }\n    } else {\n      // If the regular segment doesn't contain partial segments, move to the\n      // next regular segment.\n      this.currentPosition_++;\n      this.currentPartialPosition_ = 0;\n    }\n\n    const res = this.current();\n\n    return {\n      'value': res,\n      'done': !res,\n    };\n  }\n};\n\n\n/**\n * A meta-SegmentIndex composed of multiple other SegmentIndexes.\n * Used in constructing multi-Period Streams for DASH.\n *\n * @extends shaka.media.SegmentIndex\n * @implements {shaka.util.IReleasable}\n * @implements {Iterable.<!shaka.media.SegmentReference>}\n * @export\n */\nshaka.media.MetaSegmentIndex = class extends shaka.media.SegmentIndex {\n  /** */\n  constructor() {\n    super([]);\n\n    /** @private {!Array.<!shaka.media.SegmentIndex>} */\n    this.indexes_ = [];\n  }\n\n  /**\n   * Append a SegmentIndex to this MetaSegmentIndex.  This effectively stitches\n   * the underlying Stream onto the end of the multi-Period Stream represented\n   * by this MetaSegmentIndex.\n   *\n   * @param {!shaka.media.SegmentIndex} segmentIndex\n   */\n  appendSegmentIndex(segmentIndex) {\n    goog.asserts.assert(\n        this.indexes_.length == 0 || segmentIndex.numEvicted == 0,\n        'Should not append a new segment index with already-evicted segments');\n    this.indexes_.push(segmentIndex);\n  }\n\n  /**\n   * Create a clone of this MetaSegmentIndex containing all the same indexes.\n   *\n   * @return {!shaka.media.MetaSegmentIndex}\n   */\n  clone() {\n    const clone = new shaka.media.MetaSegmentIndex();\n    // Be careful to clone the Array.  We don't want to share the reference with\n    // our clone and affect each other accidentally.\n    clone.indexes_ = this.indexes_.slice();\n    return clone;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  release() {\n    for (const index of this.indexes_) {\n      index.release();\n    }\n\n    this.indexes_ = [];\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  find(time) {\n    let numPassedInEarlierIndexes = 0;\n\n    for (const index of this.indexes_) {\n      const position = index.find(time);\n\n      if (position != null) {\n        return position + numPassedInEarlierIndexes;\n      }\n\n      numPassedInEarlierIndexes += index.numEvicted + index.references.length;\n    }\n\n    return null;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  get(position) {\n    let numPassedInEarlierIndexes = 0;\n    let sawSegments = false;\n\n    for (const index of this.indexes_) {\n      goog.asserts.assert(\n          !sawSegments || index.numEvicted == 0,\n          'Should not see evicted segments after available segments');\n      const reference = index.get(position - numPassedInEarlierIndexes);\n\n      if (reference) {\n        return reference;\n      }\n\n      numPassedInEarlierIndexes += index.numEvicted + index.references.length;\n      sawSegments = sawSegments || index.references.length != 0;\n    }\n\n    return null;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  offset(offset) {\n    // offset() is only used by HLS, and MetaSegmentIndex is only used for DASH.\n    goog.asserts.assert(\n        false, 'offset() should not be used in MetaSegmentIndex!');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  merge(references) {\n    // merge() is only used internally by the DASH and HLS parser on\n    // SegmentIndexes, but never on MetaSegmentIndex.\n    goog.asserts.assert(\n        false, 'merge() should not be used in MetaSegmentIndex!');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  evict(time) {\n    // evict() is only used internally by the DASH and HLS parser on\n    // SegmentIndexes, but never on MetaSegmentIndex.\n    goog.asserts.assert(\n        false, 'evict() should not be used in MetaSegmentIndex!');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  mergeAndEvict(references, windowStart) {\n    // mergeAndEvict() is only used internally by the DASH and HLS parser on\n    // SegmentIndexes, but never on MetaSegmentIndex.\n    goog.asserts.assert(\n        false, 'mergeAndEvict() should not be used in MetaSegmentIndex!');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  fit(windowStart, windowEnd) {\n    // fit() is only used internally by manifest parsers on SegmentIndexes, but\n    // never on MetaSegmentIndex.\n    goog.asserts.assert(false, 'fit() should not be used in MetaSegmentIndex!');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  updateEvery(interval, updateCallback) {\n    // updateEvery() is only used internally by the DASH parser on\n    // SegmentIndexes, but never on MetaSegmentIndex.\n    goog.asserts.assert(\n        false, 'updateEvery() should not be used in MetaSegmentIndex!');\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.PlayRateController');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n/**\n * The play rate controller controls the playback rate on the media element.\n * This provides some missing functionality (e.g. negative playback rate). If\n * the playback rate on the media element can change outside of the controller,\n * the playback controller will need to be updated to stay in-sync.\n *\n * TODO: Try not to manage buffering above the browser with playbackRate=0.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.PlayRateController = class {\n  /**\n   * @param {shaka.media.PlayRateController.Harness} harness\n   */\n  constructor(harness) {\n    /** @private {?shaka.media.PlayRateController.Harness} */\n    this.harness_ = harness;\n\n    /** @private {boolean} */\n    this.isBuffering_ = false;\n\n    /** @private {number} */\n    this.rate_ = this.harness_.getRate();\n\n    /** @private {number} */\n    this.pollRate_ = 0.25;\n\n    /** @private {shaka.util.Timer} */\n    this.timer_ = new shaka.util.Timer(() => {\n      this.harness_.movePlayhead(this.rate_ * this.pollRate_);\n    });\n  }\n\n  /** @override */\n  release() {\n    if (this.timer_) {\n      this.timer_.stop();\n      this.timer_ = null;\n    }\n\n    this.harness_ = null;\n  }\n\n  /**\n   * Sets the buffering flag, which controls the effective playback rate.\n   *\n   * @param {boolean} isBuffering If true, forces playback rate to 0 internally.\n   */\n  setBuffering(isBuffering) {\n    this.isBuffering_ = isBuffering;\n    this.apply_();\n  }\n\n  /**\n   * Set the playback rate. This rate will only be used as provided when the\n   * player is not buffering. You should never set the rate to 0.\n   *\n   * @param {number} rate\n   */\n  set(rate) {\n    goog.asserts.assert(rate != 0, 'Should never set rate of 0 explicitly!');\n    this.rate_ = rate;\n    this.apply_();\n  }\n\n  /**\n   * Get the real rate of the playback. This means that if we are using trick\n   * play, this will report the trick play rate. If playback is occurring as\n   * normal, this will report 1.\n   *\n   * @return {number}\n   */\n  getRealRate() {\n    return this.rate_;\n  }\n\n  /**\n   * Get the default play rate of the playback.\n   *\n   * @return {number}\n   */\n  getDefaultRate() {\n    return this.harness_.getDefaultRate();\n  }\n\n  /**\n   * Reapply the effects of |this.rate_| and |this.active_| to the media\n   * element. This will only update the rate via the harness if the desired rate\n   * has changed.\n   *\n   * @private\n   */\n  apply_() {\n    // Always stop the timer. We may not start it again.\n    this.timer_.stop();\n\n    /** @type {number} */\n    const rate = this.calculateCurrentRate_();\n\n    shaka.log.v1('Changing effective playback rate to', rate);\n\n    if (rate >= 0) {\n      try {\n        this.applyRate_(rate);\n        return;\n      } catch (e) {\n        // Fall through to the next clause.\n        //\n        // Fast forward is accomplished through setting video.playbackRate.\n        // If the play rate value is not supported by the browser (too big),\n        // the browsers will throw.\n        // Use this as a cue to fall back to fast forward through repeated\n        // seeking, which is what we do for rewind as well.\n      }\n    }\n\n    // When moving backwards or forwards in large steps,\n    // set the playback rate to 0 so that we can manually\n    // seek backwards with out fighting the playhead.\n    this.timer_.tickEvery(this.pollRate_);\n    this.applyRate_(0);\n  }\n\n  /**\n   * Calculate the rate that the controller wants the media element to have\n   * based on the current state of the controller.\n   *\n   * @return {number}\n   * @private\n   */\n  calculateCurrentRate_() {\n    return this.isBuffering_ ? 0 : this.rate_;\n  }\n\n  /**\n   * If the new rate is different than the media element's playback rate, this\n   * will change the playback rate. If the rate does not need to change, it will\n   * not be set. This will avoid unnecessary ratechange events.\n   *\n   * @param {number} newRate\n   * @return {boolean}\n   * @private\n   */\n  applyRate_(newRate) {\n    const oldRate = this.harness_.getRate();\n\n    if (oldRate != newRate) {\n      this.harness_.setRate(newRate);\n    }\n\n    return oldRate != newRate;\n  }\n};\n\n\n/**\n * @typedef {{\n *   getRate: function():number,\n *   getDefaultRate: function():number,\n *   setRate: function(number),\n *   movePlayhead: function(number)\n * }}\n *\n * @description\n *   A layer of abstraction between the controller and what it is controlling.\n *   In tests this will be implemented with spies. In production this will be\n *   implemented using a media element.\n *\n * @property {function():number} getRate\n *   Get the current playback rate being seen by the user.\n *\n * @property {function():number} getDefaultRate\n *   Get the default playback rate that the user should see.\n *\n * @property {function(number)} setRate\n *   Set the playback rate that the user should see.\n *\n * @property {function(number)} movePlayhead\n *   Move the playhead N seconds. If N is positive, the playhead will move\n *   forward abs(N) seconds. If N is negative, the playhead will move backwards\n *   abs(N) seconds.\n */\nshaka.media.PlayRateController.Harness;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.IPlayheadObserver');\ngoog.provide('shaka.media.PlayheadObserverManager');\n\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * A playhead observer is a system that watches for meaningful changes in state\n * that are dependent on playhead information. The observer is responsible for\n * managing its own listeners.\n *\n * @extends {shaka.util.IReleasable}\n * @interface\n */\nshaka.media.IPlayheadObserver = class {\n  /**\n   * Check again (using an update playhead summary) if an event should be fired.\n   * If an event should be fired, fire it.\n   *\n   * @param {number} positionInSeconds\n   * @param {boolean} wasSeeking\n   */\n  poll(positionInSeconds, wasSeeking) {}\n};\n\n\n/**\n * The playhead observer manager is responsible for owning playhead observer\n * instances and polling them when needed. Destroying the manager will destroy\n * all observers managed by the manager.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.PlayheadObserverManager = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   */\n  constructor(mediaElement) {\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n\n    /**\n     * The set of all observers that this manager is responsible for updating.\n     * We are using a set to ensure that we don't double update an observer if\n     * it is accidentally added twice.\n     *\n     * @private {!Set.<shaka.media.IPlayheadObserver>}\n     */\n    this.observers_ = new Set();\n\n    /**\n     * To fire events semi-accurately, poll the observers 4 times a second. This\n     * should be frequent enough to trigger an event close enough to its actual\n     * occurrence without the user noticing a delay.\n     *\n     * @private {shaka.util.Timer}\n     */\n    this.pollingLoop_ = new shaka.util.Timer(() => {\n      this.pollAllObservers_(/* seeking= */ false);\n    }).tickEvery(/* seconds= */ 0.25);\n  }\n\n  /** @override */\n  release() {\n    // We need to stop the loop or else we may try to use a released resource.\n    this.pollingLoop_.stop();\n\n    for (const observer of this.observers_) {\n      observer.release();\n    }\n\n    this.observers_.clear();\n  }\n\n  /**\n   * Have the playhead observer manager manage a new observer. This will ensure\n   * that observers are only tracked once within the manager. After this call,\n   * the manager will be responsible for the life cycle of |observer|.\n   *\n   * @param {!shaka.media.IPlayheadObserver} observer\n   */\n  manage(observer) {\n    this.observers_.add(observer);\n  }\n\n  /**\n   * Notify all the observers that we just seeked.\n   */\n  notifyOfSeek() {\n    this.pollAllObservers_(/* seeking= */ true);\n  }\n\n  /**\n   * @param {boolean} seeking\n   * @private\n   */\n  pollAllObservers_(seeking) {\n    for (const observer of this.observers_) {\n      observer.poll(\n          this.mediaElement_.currentTime,\n          seeking);\n    }\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.QualityObserver');\n\ngoog.require('shaka.media.IPlayheadObserver');\ngoog.require('shaka.log');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\n\n/**\n * Monitors the quality of content being appended to the source buffers and\n * fires 'qualitychange' events when the media quality at the playhead changes.\n *\n * @implements {shaka.media.IPlayheadObserver}\n * @final\n */\nshaka.media.QualityObserver = class extends shaka.util.FakeEventTarget {\n  /**\n   * Creates a new QualityObserver.\n   *\n   * @param {!function():!shaka.extern.BufferedInfo} getBufferedInfo\n   *   Buffered info is needed to purge QualityChanges that are no\n   *   longer relevant.\n   */\n  constructor(getBufferedInfo) {\n    super();\n\n    /**\n     * @private {!Map.<string,!shaka.media.QualityObserver.ContentTypeState>}\n     */\n    this.contentTypeStates_ = new Map();\n\n    /** @private function():!shaka.extern.BufferedInfo */\n    this.getBufferedInfo_ = getBufferedInfo;\n  }\n\n  /** @override */\n  release() {\n    this.contentTypeStates_.clear();\n    super.release();\n  }\n\n  /**\n   * Get the ContenTypeState for a contentType, creating a new\n   * one if necessary.\n   *\n   * @param {!string} contentType\n   *  The contend type e.g. \"video\" or \"audio\".\n   * @return {!shaka.media.QualityObserver.ContentTypeState}\n   * @private\n   */\n  getContentTypeState_(contentType) {\n    let contentTypeState = this.contentTypeStates_.get(contentType);\n    if (!contentTypeState) {\n      contentTypeState = {\n        qualityChangePositions: [],\n        currentQuality: null,\n        contentType: contentType,\n      };\n      this.contentTypeStates_.set(contentType, contentTypeState);\n    }\n    return contentTypeState;\n  }\n\n  /**\n   * Adds a QualityChangePosition for the contentType identified by\n   * the mediaQuality.contentType.\n   *\n   * @param {!shaka.extern.MediaQualityInfo} mediaQuality\n   * @param {!number} position\n   *  Position in seconds of the quality change.\n   */\n  addMediaQualityChange(mediaQuality, position) {\n    const contentTypeState =\n      this.getContentTypeState_(mediaQuality.contentType);\n\n    // Remove unneeded QualityChangePosition(s) before adding the new one\n    this.purgeQualityChangePositions_(contentTypeState);\n\n    const newChangePosition = {\n      mediaQuality: mediaQuality,\n      position: position,\n    };\n\n    const changePositions = contentTypeState.qualityChangePositions;\n    const insertBeforeIndex = changePositions.findIndex(\n        (qualityChange) => (qualityChange.position >= position));\n\n    if (insertBeforeIndex >= 0) {\n      const duplicatePositions =\n        (changePositions[insertBeforeIndex].position == position) ? 1 : 0;\n      changePositions.splice(\n          insertBeforeIndex, duplicatePositions, newChangePosition);\n    } else {\n      changePositions.push(newChangePosition);\n    }\n  }\n\n  /**\n   * Determines the media quality at a specific position in the source buffer.\n   *\n   * @param {!number} position\n   *  Position in seconds\n   * @param {!shaka.media.QualityObserver.ContentTypeState} contentTypeState\n   * @return {?shaka.extern.MediaQualityInfo}\n   * @private\n   */\n  static getMediaQualityAtPosition_(position, contentTypeState) {\n    // The qualityChangePositions must be ordered by position ascending\n    // Find the last QualityChangePosition prior to the position\n    const changePositions = contentTypeState.qualityChangePositions;\n    for (let i = changePositions.length - 1; i >= 0; i--) {\n      const qualityChange = changePositions[i];\n      if (qualityChange.position <= position) {\n        return qualityChange.mediaQuality;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Determines if two MediaQualityInfo objects are the same or not.\n   *\n   * @param {?shaka.extern.MediaQualityInfo} mq1\n   * @param {?shaka.extern.MediaQualityInfo} mq2\n   * @return {boolean}\n   * @private\n   */\n  static mediaQualitiesAreTheSame_(mq1, mq2) {\n    if (mq1 === mq2) {\n      return true;\n    }\n    if (!mq1 || !mq2) {\n      return false;\n    }\n    return (mq1.bandwidth == mq2.bandwidth) &&\n      (mq1.audioSamplingRate == mq2.audioSamplingRate) &&\n      (mq1.codecs == mq2.codecs) &&\n      (mq1.contentType == mq2.contentType) &&\n      (mq1.frameRate == mq2.frameRate) &&\n      (mq1.height == mq2.height) &&\n      (mq1.mimeType == mq2.mimeType) &&\n      (mq1.channelsCount == mq2.channelsCount) &&\n      (mq1.pixelAspectRatio == mq2.pixelAspectRatio) &&\n      (mq1.width == mq2.width);\n  }\n\n  /** @override */\n  poll(positionInSeconds, wasSeeking) {\n    for (const contentTypeState of this.contentTypeStates_.values()) {\n      const qualityAtPosition =\n        shaka.media.QualityObserver.getMediaQualityAtPosition_(\n            positionInSeconds, contentTypeState);\n      if (qualityAtPosition &&\n          !shaka.media.QualityObserver.mediaQualitiesAreTheSame_(\n              contentTypeState.currentQuality, qualityAtPosition)) {\n        if (this.positionIsBuffered_(\n            positionInSeconds, qualityAtPosition.contentType)) {\n          contentTypeState.currentQuality = qualityAtPosition;\n\n          shaka.log.debug('Media quality changed at position ' +\n            positionInSeconds + ' ' + JSON.stringify(qualityAtPosition));\n\n          const event = new shaka.util.FakeEvent('qualitychange', new Map([\n            ['quality', qualityAtPosition],\n            ['position', positionInSeconds],\n          ]));\n          this.dispatchEvent(event);\n        }\n      }\n    }\n  }\n\n  /**\n   * Determine if a position is buffered for a given content type.\n   *\n   * @param {!number} position\n   * @param {!string} contentType\n   * @private\n   */\n  positionIsBuffered_(position, contentType) {\n    const bufferedInfo = this.getBufferedInfo_();\n    const bufferedRanges = bufferedInfo[contentType];\n    if (bufferedRanges && bufferedRanges.length > 0) {\n      const bufferStart = bufferedRanges[0].start;\n      const bufferEnd = bufferedRanges[bufferedRanges.length - 1].end;\n      if (position >= bufferStart && position < bufferEnd) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Removes the QualityChangePosition(s) that are not relevant to the buffered\n   * content of the specified contentType. Note that this function is\n   * invoked just before adding the quality change info associated with\n   * the next media segment to be appended.\n   *\n   * @param {!shaka.media.QualityObserver.ContentTypeState} contentTypeState\n   * @private\n   */\n  purgeQualityChangePositions_(contentTypeState) {\n    const bufferedInfo = this.getBufferedInfo_();\n    const bufferedRanges = bufferedInfo[contentTypeState.contentType];\n\n    if (bufferedRanges && bufferedRanges.length > 0) {\n      const bufferStart = bufferedRanges[0].start;\n      const bufferEnd = bufferedRanges[bufferedRanges.length - 1].end;\n      const oldChangePositions = contentTypeState.qualityChangePositions;\n      contentTypeState.qualityChangePositions =\n        oldChangePositions.filter(\n            (qualityChange, index) => {\n              // Remove all but last quality change before bufferStart.\n              if ((qualityChange.position <= bufferStart) &&\n                (index + 1 < oldChangePositions.length) &&\n                (oldChangePositions[index + 1].position <= bufferStart)) {\n                return false;\n              }\n              // Remove all quality changes after bufferEnd.\n              if (qualityChange.position >= bufferEnd) {\n                return false;\n              }\n              return true;\n            });\n    } else {\n      // Nothing is buffered; so remove all quality changes.\n      contentTypeState.qualityChangePositions = [];\n    }\n  }\n};\n\n/**\n  * @typedef {{\n  *   mediaQuality: !shaka.extern.MediaQualityInfo,\n  *   position: !number\n  * }}\n  *\n  * @description\n  * Identifies the position of a media quality change in the\n  * source buffer.\n  *\n  * @property {shaka.extern.MediaQualityInfo} !mediaQuality\n  *   The new media quality for content after position in the source buffer.\n  * @property {number} !position\n  *   A position in seconds in the source buffer\n  */\nshaka.media.QualityObserver.QualityChangePosition;\n\n/**\n  * @typedef {{\n  *  qualityChangePositions:\n  *   !Array.<shaka.media.QualityObserver.QualityChangePosition>,\n  *  currentQuality: ?shaka.extern.MediaQualityInfo,\n  *  contentType: !string\n  * }}\n  *\n  * @description\n  * Contains media quality information for a specific content type\n  * e.g video or audio.\n  *\n  * @property {!Array.<shaka.media.QualityObserver.QualityChangePosition>}\n  * qualityChangePositions\n  *   Quality changes ordered by position ascending.\n  * @property {?shaka.media.MediaQualityInfo} currentMediaQuality\n  *   The media quality at the playhead position.\n  * @property {string} contentType\n  *   The contentType e.g. 'video' or 'audio'\n  */\nshaka.media.QualityObserver.ContentTypeState;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.RegionTimeline');\n\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * The region timeline is a set of unique timeline region info entries. When\n * a new entry is added, the 'regionadd' event will be fired.  When an entry is\n * deleted, the 'regionremove' event will be fired.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.RegionTimeline = class extends shaka.util.FakeEventTarget {\n  /**\n   * @param {!function():{start: number, end: number}} getSeekRange\n   */\n  constructor(getSeekRange) {\n    super();\n\n    /** @private {!Set.<shaka.extern.TimelineRegionInfo>} */\n    this.regions_ = new Set();\n\n    /** @private {!function():{start: number, end: number}} */\n    this.getSeekRange_ = getSeekRange;\n\n    /**\n     * Make sure all of the regions we're tracking are within the\n     * seek range or further in the future. We don't want to store\n     * regions that fall before the start of the seek range.\n     *\n     * @private {shaka.util.Timer}\n     */\n    this.filterTimer_ = new shaka.util.Timer(() => {\n      this.filterBySeekRange_();\n    }).tickEvery(\n        /* seconds= */ shaka.media.RegionTimeline.REGION_FILTER_INTERVAL);\n  }\n\n  /** @override */\n  release() {\n    this.regions_.clear();\n    this.filterTimer_.stop();\n    super.release();\n  }\n\n  /**\n   * @param {shaka.extern.TimelineRegionInfo} region\n   */\n  addRegion(region) {\n    const similarRegion = this.findSimilarRegion_(region);\n\n    // Make sure we don't add duplicate regions. We keep track of this here\n    // instead of making the parser track it.\n    if (similarRegion == null) {\n      this.regions_.add(region);\n      const event = new shaka.util.FakeEvent('regionadd', new Map([\n        ['region', region],\n      ]));\n      this.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @private\n   */\n  filterBySeekRange_() {\n    const seekRange = this.getSeekRange_();\n    for (const region of this.regions_) {\n      // Only consider the seek range start here.\n      // Future regions might become relevant eventually,\n      // but regions that are in the past and can't ever be\n      // seeked to will never come up again, and there's no\n      // reson to store or process them.\n      if (region.endTime < seekRange.start) {\n        this.regions_.delete(region);\n        const event = new shaka.util.FakeEvent('regionremove', new Map([\n          ['region', region],\n        ]));\n        this.dispatchEvent(event);\n      }\n    }\n  }\n\n  /**\n   * Find a region in the timeline that has the same scheme id uri, event id,\n   * start time and end time. If these four parameters match, we assume it\n   * to be the same region. If no similar region can be found, |null| will be\n   * returned.\n   *\n   * @param {shaka.extern.TimelineRegionInfo} region\n   * @return {?shaka.extern.TimelineRegionInfo}\n   * @private\n   */\n  findSimilarRegion_(region) {\n    for (const existing of this.regions_) {\n      // The same scheme ID and time range means that it is similar-enough to\n      // be the same region.\n      const isSimilar = existing.schemeIdUri == region.schemeIdUri &&\n                        existing.id == region.id &&\n                        existing.startTime == region.startTime &&\n                        existing.endTime == region.endTime;\n\n      if (isSimilar) {\n        return existing;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get an iterable for all the regions in the timeline. This will allow\n   * others to see what regions are in the timeline while not being able to\n   * change the collection.\n   *\n   * @return {!Iterable.<shaka.extern.TimelineRegionInfo>}\n   */\n  regions() {\n    return this.regions_;\n  }\n};\n\n/** @const {number} */\nshaka.media.RegionTimeline.REGION_FILTER_INTERVAL = 2; // in seconds\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.RegionObserver');\n\ngoog.require('shaka.media.IPlayheadObserver');\ngoog.require('shaka.media.RegionTimeline');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\n\n\n/**\n * The region observer watches a region timeline and playhead, and fires events\n * ('enter', 'exit', 'skip') as the playhead moves.\n *\n * @implements {shaka.media.IPlayheadObserver}\n * @final\n */\nshaka.media.RegionObserver = class extends shaka.util.FakeEventTarget {\n  /**\n   * Create a region observer for the given timeline. The observer does not\n   * own the timeline, only uses it. This means that the observer should NOT\n   * destroy the timeline.\n   *\n   * @param {!shaka.media.RegionTimeline} timeline\n   */\n  constructor(timeline) {\n    super();\n\n    /** @private {shaka.media.RegionTimeline} */\n    this.timeline_ = timeline;\n\n    /**\n     * A mapping between a region and where we previously were relative to it.\n     * When the value here differs from what we calculate, it means we moved and\n     * should fire an event.\n     *\n     * @private {!Map.<shaka.extern.TimelineRegionInfo,\n     *                 shaka.media.RegionObserver.RelativePosition_>}\n     */\n    this.oldPosition_ = new Map();\n\n    // To make the rules easier to read, alias all the relative positions.\n    const RelativePosition = shaka.media.RegionObserver.RelativePosition_;\n    const BEFORE_THE_REGION = RelativePosition.BEFORE_THE_REGION;\n    const IN_THE_REGION = RelativePosition.IN_THE_REGION;\n    const AFTER_THE_REGION = RelativePosition.AFTER_THE_REGION;\n\n    /**\n     * A read-only collection of rules for what to do when we change position\n     * relative to a region.\n     *\n     * @private {!Iterable.<shaka.media.RegionObserver.Rule_>}\n     */\n    this.rules_ = [\n      {\n        weWere: null,\n        weAre: IN_THE_REGION,\n        invoke: (region, seeking) => this.onEvent_('enter', region, seeking),\n      },\n      {\n        weWere: BEFORE_THE_REGION,\n        weAre: IN_THE_REGION,\n        invoke: (region, seeking) => this.onEvent_('enter', region, seeking),\n      },\n      {\n        weWere: AFTER_THE_REGION,\n        weAre: IN_THE_REGION,\n        invoke: (region, seeking) => this.onEvent_('enter', region, seeking),\n      },\n      {\n        weWere: IN_THE_REGION,\n        weAre: BEFORE_THE_REGION,\n        invoke: (region, seeking) => this.onEvent_('exit', region, seeking),\n      },\n      {\n        weWere: IN_THE_REGION,\n        weAre: AFTER_THE_REGION,\n        invoke: (region, seeking) => this.onEvent_('exit', region, seeking),\n      },\n      {\n        weWere: BEFORE_THE_REGION,\n        weAre: AFTER_THE_REGION,\n        invoke: (region, seeking) => this.onEvent_('skip', region, seeking),\n      },\n      {\n        weWere: AFTER_THE_REGION,\n        weAre: BEFORE_THE_REGION,\n        invoke: (region, seeking) => this.onEvent_('skip', region, seeking),\n      },\n    ];\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    this.eventManager_.listen(this.timeline_, 'regionremove', (event) => {\n      /** @type {shaka.extern.TimelineRegionInfo} */\n      const region = event['region'];\n      this.oldPosition_.delete(region);\n    });\n  }\n\n  /** @override */\n  release() {\n    this.timeline_ = null;\n\n    // Clear our maps so that we are not holding onto any more information than\n    // needed.\n    this.oldPosition_.clear();\n\n    this.eventManager_.release();\n    this.eventManager_ = null;\n\n    super.release();\n  }\n\n  /** @override */\n  poll(positionInSeconds, wasSeeking) {\n    const RegionObserver = shaka.media.RegionObserver;\n\n    for (const region of this.timeline_.regions()) {\n      const previousPosition = this.oldPosition_.get(region);\n      const currentPosition = RegionObserver.determinePositionRelativeTo_(\n          region, positionInSeconds);\n\n      // We will only use |previousPosition| and |currentPosition|, so we can\n      // update our state now.\n      this.oldPosition_.set(region, currentPosition);\n\n      for (const rule of this.rules_) {\n        if (rule.weWere == previousPosition && rule.weAre == currentPosition) {\n          rule.invoke(region, wasSeeking);\n        }\n      }\n    }\n  }\n\n  /**\n   * Dispatch events of the given type.  All event types in this class have the\n   * same parameters: region and seeking.\n   *\n   * @param {string} eventType\n   * @param {shaka.extern.TimelineRegionInfo} region\n   * @param {boolean} seeking\n   * @private\n   */\n  onEvent_(eventType, region, seeking) {\n    const event = new shaka.util.FakeEvent(eventType, new Map([\n      ['region', region],\n      ['seeking', seeking],\n    ]));\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * Get the relative position of the playhead to |region| when the playhead is\n   * at |seconds|. We treat the region's start and end times as inclusive\n   * bounds.\n   *\n   * @param {shaka.extern.TimelineRegionInfo} region\n   * @param {number} seconds\n   * @return {shaka.media.RegionObserver.RelativePosition_}\n   * @private\n   */\n  static determinePositionRelativeTo_(region, seconds) {\n    const RelativePosition = shaka.media.RegionObserver.RelativePosition_;\n\n    if (seconds < region.startTime) {\n      return RelativePosition.BEFORE_THE_REGION;\n    }\n\n    if (seconds > region.endTime) {\n      return RelativePosition.AFTER_THE_REGION;\n    }\n\n    return RelativePosition.IN_THE_REGION;\n  }\n};\n\n/**\n * An enum of relative positions between the playhead and a region. Each is\n * phrased so that it works in \"The playhead is X\" where \"X\" is any value in\n * the enum.\n *\n * @enum {number}\n * @private\n */\nshaka.media.RegionObserver.RelativePosition_ = {\n  BEFORE_THE_REGION: 1,\n  IN_THE_REGION: 2,\n  AFTER_THE_REGION: 3,\n};\n\n/**\n * All region observer events (onEnter, onExit, and onSkip) will be passed the\n * region that the playhead is interacting with and whether or not the playhead\n * moving is part of a seek event.\n *\n * @typedef {function(shaka.extern.TimelineRegionInfo, boolean)}\n */\nshaka.media.RegionObserver.EventListener;\n\n/**\n * @typedef {{\n *    weWere: ?shaka.media.RegionObserver.RelativePosition_,\n *    weAre: ?shaka.media.RegionObserver.RelativePosition_,\n *    invoke: shaka.media.RegionObserver.EventListener\n * }}\n *\n * @private\n */\nshaka.media.RegionObserver.Rule_;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Networking');\n\ngoog.require('shaka.net.NetworkingEngine');\n\n\n/**\n * A collection of shared utilities that bridge the gap between our networking\n * code and the other parts of our code base. This is to allow\n * |shaka.net.NetworkingEngine| to remain general.\n *\n * @final\n */\nshaka.util.Networking = class {\n  /**\n   * Create a request message for a segment. Providing |start| and |end|\n   * will set the byte range. A non-zero start must be provided for |end| to\n   * be used.\n   *\n   * @param {!Array.<string>} uris\n   * @param {?number} start\n   * @param {?number} end\n   * @param {shaka.extern.RetryParameters} retryParameters\n   * @param {?function(BufferSource):!Promise=} streamDataCallback\n   * @return {shaka.extern.Request}\n   */\n  static createSegmentRequest(uris, start, end, retryParameters,\n      streamDataCallback) {\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        uris, retryParameters, streamDataCallback);\n\n    if (start == 0 && end == null) {\n      // This is a request for the entire segment.  The Range header is not\n      // required.  Note that some web servers don't accept Range headers, so\n      // don't set one if it's not strictly required.\n    } else {\n      if (end) {\n        request.headers['Range'] = 'bytes=' + start + '-' + end;\n      } else {\n        request.headers['Range'] = 'bytes=' + start + '-';\n      }\n    }\n\n    return request;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview\n * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed\n */\n\ngoog.provide('shaka.media.StreamingEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.MediaSourceEngine');\ngoog.require('shaka.media.SegmentIterator');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.net.Backoff');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.DelayedTick');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Networking');\n\n\n/**\n * @summary Creates a Streaming Engine.\n * The StreamingEngine is responsible for setting up the Manifest's Streams\n * (i.e., for calling each Stream's createSegmentIndex() function), for\n * downloading segments, for co-ordinating audio, video, and text buffering.\n * The StreamingEngine provides an interface to switch between Streams, but it\n * does not choose which Streams to switch to.\n *\n * The StreamingEngine does not need to be notified about changes to the\n * Manifest's SegmentIndexes; however, it does need to be notified when new\n * Variants are added to the Manifest.\n *\n * To start the StreamingEngine the owner must first call configure(), followed\n * by one call to switchVariant(), one optional call to switchTextStream(), and\n * finally a call to start().  After start() resolves, switch*() can be used\n * freely.\n *\n * The owner must call seeked() each time the playhead moves to a new location\n * within the presentation timeline; however, the owner may forego calling\n * seeked() when the playhead moves outside the presentation timeline.\n *\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.StreamingEngine = class {\n  /**\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.media.StreamingEngine.PlayerInterface} playerInterface\n   */\n  constructor(manifest, playerInterface) {\n    /** @private {?shaka.media.StreamingEngine.PlayerInterface} */\n    this.playerInterface_ = playerInterface;\n\n    /** @private {?shaka.extern.Manifest} */\n    this.manifest_ = manifest;\n\n    /** @private {?shaka.extern.StreamingConfiguration} */\n    this.config_ = null;\n\n    /** @private {number} */\n    this.bufferingGoalScale_ = 1;\n\n    /** @private {?shaka.extern.Variant} */\n    this.currentVariant_ = null;\n\n    /** @private {?shaka.extern.Stream} */\n    this.currentTextStream_ = null;\n\n    /** @private {number} */\n    this.textStreamSequenceId_ = 0;\n\n    /**\n     * Maps a content type, e.g., 'audio', 'video', or 'text', to a MediaState.\n     *\n     * @private {!Map.<shaka.util.ManifestParserUtils.ContentType,\n     *                 !shaka.media.StreamingEngine.MediaState_>}\n     */\n    this.mediaStates_ = new Map();\n\n    /**\n     * Set to true once the initial media states have been created.\n     *\n     * @private {boolean}\n     */\n    this.startupComplete_ = false;\n\n    /**\n     * Used for delay and backoff of failure callbacks, so that apps do not\n     * retry instantly.\n     *\n     * @private {shaka.net.Backoff}\n     */\n    this.failureCallbackBackoff_ = null;\n\n    /**\n     * Set to true on fatal error.  Interrupts fetchAndAppend_().\n     *\n     * @private {boolean}\n     */\n    this.fatalError_ = false;\n\n    /** @private {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(() => this.doDestroy_());\n  }\n\n  /** @override */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /**\n   * @return {!Promise}\n   * @private\n   */\n  async doDestroy_() {\n    const aborts = [];\n\n    for (const state of this.mediaStates_.values()) {\n      this.cancelUpdate_(state);\n      aborts.push(this.abortOperations_(state));\n    }\n\n    await Promise.all(aborts);\n\n    this.mediaStates_.clear();\n\n    this.playerInterface_ = null;\n    this.manifest_ = null;\n    this.config_ = null;\n  }\n\n  /**\n   * Called by the Player to provide an updated configuration any time it\n   * changes. Must be called at least once before start().\n   *\n   * @param {shaka.extern.StreamingConfiguration} config\n   */\n  configure(config) {\n    this.config_ = config;\n\n    // Create separate parameters for backoff during streaming failure.\n\n    /** @type {shaka.extern.RetryParameters} */\n    const failureRetryParams = {\n      // The term \"attempts\" includes the initial attempt, plus all retries.\n      // In order to see a delay, there would have to be at least 2 attempts.\n      maxAttempts: Math.max(config.retryParameters.maxAttempts, 2),\n      baseDelay: config.retryParameters.baseDelay,\n      backoffFactor: config.retryParameters.backoffFactor,\n      fuzzFactor: config.retryParameters.fuzzFactor,\n      timeout: 0,  // irrelevant\n      stallTimeout: 0, // irrelevant\n      connectionTimeout: 0, // irrelevant\n    };\n\n    // We don't want to ever run out of attempts.  The application should be\n    // allowed to retry streaming infinitely if it wishes.\n    const autoReset = true;\n    this.failureCallbackBackoff_ =\n        new shaka.net.Backoff(failureRetryParams, autoReset);\n  }\n\n\n  /**\n   * Initialize and start streaming.\n   *\n   * By calling this method, StreamingEngine will start streaming the variant\n   * chosen by a prior call to switchVariant(), and optionally, the text stream\n   * chosen by a prior call to switchTextStream().  Once the Promise resolves,\n   * switch*() may be called freely.\n   *\n   * @return {!Promise}\n   */\n  async start() {\n    goog.asserts.assert(this.config_,\n        'StreamingEngine configure() must be called before init()!');\n\n    // Setup the initial set of Streams and then begin each update cycle.\n    await this.initStreams_();\n    this.destroyer_.ensureNotDestroyed();\n\n    shaka.log.debug('init: completed initial Stream setup');\n    this.startupComplete_ = true;\n  }\n\n  /**\n   * Get the current variant we are streaming.  Returns null if nothing is\n   * streaming.\n   * @return {?shaka.extern.Variant}\n   */\n  getCurrentVariant() {\n    return this.currentVariant_;\n  }\n\n  /**\n   * Get the text stream we are streaming.  Returns null if there is no text\n   * streaming.\n   * @return {?shaka.extern.Stream}\n   */\n  getCurrentTextStream() {\n    return this.currentTextStream_;\n  }\n\n  /**\n   * Start streaming text, creating a new media state.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {!Promise}\n   * @private\n   */\n  async loadNewTextStream_(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    goog.asserts.assert(!this.mediaStates_.has(ContentType.TEXT),\n        'Should not call loadNewTextStream_ while streaming text!');\n    this.textStreamSequenceId_++;\n    const currentSequenceId = this.textStreamSequenceId_;\n\n    try {\n      // Clear MediaSource's buffered text, so that the new text stream will\n      // properly replace the old buffered text.\n      // TODO: Should this happen in unloadTextStream() instead?\n      await this.playerInterface_.mediaSourceEngine.clear(ContentType.TEXT);\n    } catch (error) {\n      if (this.playerInterface_) {\n        this.playerInterface_.onError(error);\n      }\n    }\n\n    const mimeType = shaka.util.MimeUtils.getFullType(\n        stream.mimeType, stream.codecs);\n    this.playerInterface_.mediaSourceEngine.reinitText(mimeType);\n\n    const textDisplayer =\n        this.playerInterface_.mediaSourceEngine.getTextDisplayer();\n    const streamText =\n        textDisplayer.isTextVisible() || this.config_.alwaysStreamText;\n\n    if (streamText && (this.textStreamSequenceId_ == currentSequenceId)) {\n      const state = this.createMediaState_(stream);\n      this.mediaStates_.set(ContentType.TEXT, state);\n      this.scheduleUpdate_(state, 0);\n    }\n  }\n\n\n  /**\n   * Stop fetching text stream when the user chooses to hide the captions.\n   */\n  unloadTextStream() {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const state = this.mediaStates_.get(ContentType.TEXT);\n    if (state) {\n      this.cancelUpdate_(state);\n      this.abortOperations_(state).catch(() => {});\n      this.mediaStates_.delete(ContentType.TEXT);\n    }\n    this.currentTextStream_ = null;\n  }\n\n  /**\n   * Set trick play on or off.\n   * If trick play is on, related trick play streams will be used when possible.\n   * @param {boolean} on\n   */\n  setTrickPlay(on) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const mediaState = this.mediaStates_.get(ContentType.VIDEO);\n    if (!mediaState) {\n      return;\n    }\n\n    const stream = mediaState.stream;\n    if (!stream) {\n      return;\n    }\n\n    shaka.log.debug('setTrickPlay', on);\n    if (on) {\n      const trickModeVideo = stream.trickModeVideo;\n      if (!trickModeVideo) {\n        return;  // Can't engage trick play.\n      }\n\n      const normalVideo = mediaState.restoreStreamAfterTrickPlay;\n      if (normalVideo) {\n        return;  // Already in trick play.\n      }\n\n      shaka.log.debug('Engaging trick mode stream', trickModeVideo);\n      this.switchInternal_(trickModeVideo, /* clearBuffer= */ false,\n          /* safeMargin= */ 0, /* force= */ false);\n\n      mediaState.restoreStreamAfterTrickPlay = stream;\n    } else {\n      const normalVideo = mediaState.restoreStreamAfterTrickPlay;\n      if (!normalVideo) {\n        return;\n      }\n\n      shaka.log.debug('Restoring non-trick-mode stream', normalVideo);\n      mediaState.restoreStreamAfterTrickPlay = null;\n      this.switchInternal_(normalVideo, /* clearBuffer= */ true,\n          /* safeMargin= */ 0, /* force= */ false);\n    }\n  }\n\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @param {boolean=} clearBuffer\n   * @param {number=} safeMargin\n   * @param {boolean=} force\n   *   If true, reload the variant even if it did not change.\n   */\n  switchVariant(variant, clearBuffer = false, safeMargin = 0, force = false) {\n    this.currentVariant_ = variant;\n\n    if (!this.startupComplete_) {\n      // The selected variant will be used in start().\n      return;\n    }\n\n    if (variant.video) {\n      this.switchInternal_(\n          variant.video, /* clearBuffer= */ clearBuffer,\n          /* safeMargin= */ safeMargin, /* force= */ force);\n    }\n    if (variant.audio) {\n      this.switchInternal_(\n          variant.audio, /* clearBuffer= */ clearBuffer,\n          /* safeMargin= */ safeMargin, /* force= */ force);\n    }\n  }\n\n\n  /**\n   * @param {shaka.extern.Stream} textStream\n   */\n  switchTextStream(textStream) {\n    this.currentTextStream_ = textStream;\n\n    if (!this.startupComplete_) {\n      // The selected text stream will be used in start().\n      return;\n    }\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    goog.asserts.assert(textStream && textStream.type == ContentType.TEXT,\n        'Wrong stream type passed to switchTextStream!');\n\n    this.switchInternal_(\n        textStream, /* clearBuffer= */ true,\n        /* safeMargin= */ 0, /* force= */ false);\n  }\n\n\n  /** Reload the current text stream. */\n  reloadTextStream() {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const mediaState = this.mediaStates_.get(ContentType.TEXT);\n    if (mediaState) { // Don't reload if there's no text to begin with.\n      this.switchInternal_(\n          mediaState.stream, /* clearBuffer= */ true,\n          /* safeMargin= */ 0, /* force= */ true);\n    }\n  }\n\n\n  /**\n   * Switches to the given Stream. |stream| may be from any Variant.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @param {boolean} clearBuffer\n   * @param {number} safeMargin\n   * @param {boolean} force\n   *   If true, reload the text stream even if it did not change.\n   * @private\n   */\n  switchInternal_(stream, clearBuffer, safeMargin, force) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const type = /** @type {!ContentType} */(stream.type);\n    const mediaState = this.mediaStates_.get(type);\n\n    if (!mediaState && stream.type == ContentType.TEXT) {\n      this.loadNewTextStream_(stream);\n      return;\n    }\n\n    goog.asserts.assert(mediaState, 'switch: expected mediaState to exist');\n    if (!mediaState) {\n      return;\n    }\n\n    if (mediaState.restoreStreamAfterTrickPlay) {\n      shaka.log.debug('switch during trick play mode', stream);\n\n      // Already in trick play mode, so stick with trick mode tracks if\n      // possible.\n      if (stream.trickModeVideo) {\n        // Use the trick mode stream, but revert to the new selection later.\n        mediaState.restoreStreamAfterTrickPlay = stream;\n        stream = stream.trickModeVideo;\n        shaka.log.debug('switch found trick play stream', stream);\n      } else {\n        // There is no special trick mode video for this stream!\n        mediaState.restoreStreamAfterTrickPlay = null;\n        shaka.log.debug('switch found no special trick play stream');\n      }\n    }\n\n    if (mediaState.stream == stream && !force) {\n      const streamTag = shaka.media.StreamingEngine.logPrefix_(mediaState);\n      shaka.log.debug('switch: Stream ' + streamTag + ' already active');\n      return;\n    }\n\n    if (stream.type == ContentType.TEXT) {\n      // Mime types are allowed to change for text streams.\n      // Reinitialize the text parser, but only if we are going to fetch the\n      // init segment again.\n      const fullMimeType = shaka.util.MimeUtils.getFullType(\n          stream.mimeType, stream.codecs);\n      this.playerInterface_.mediaSourceEngine.reinitText(fullMimeType);\n    }\n\n    // Releases the segmentIndex of the old stream.\n    if (mediaState.stream.closeSegmentIndex) {\n      mediaState.stream.closeSegmentIndex();\n    }\n\n    mediaState.stream = stream;\n    mediaState.segmentIterator = null;\n\n    const streamTag = shaka.media.StreamingEngine.logPrefix_(mediaState);\n    shaka.log.debug('switch: switching to Stream ' + streamTag);\n\n    if (clearBuffer) {\n      if (mediaState.clearingBuffer) {\n        // We are already going to clear the buffer, but make sure it is also\n        // flushed.\n        mediaState.waitingToFlushBuffer = true;\n      } else if (mediaState.performingUpdate) {\n        // We are performing an update, so we have to wait until it's finished.\n        // onUpdate_() will call clearBuffer_() when the update has finished.\n        // We need to save the safe margin because its value will be needed when\n        // clearing the buffer after the update.\n        mediaState.waitingToClearBuffer = true;\n        mediaState.clearBufferSafeMargin = safeMargin;\n        mediaState.waitingToFlushBuffer = true;\n      } else {\n        // Cancel the update timer, if any.\n        this.cancelUpdate_(mediaState);\n        // Clear right away.\n        this.clearBuffer_(mediaState, /* flush= */ true, safeMargin)\n            .catch((error) => {\n              if (this.playerInterface_) {\n                goog.asserts.assert(error instanceof shaka.util.Error,\n                    'Wrong error type!');\n                this.playerInterface_.onError(error);\n              }\n            });\n      }\n    }\n\n    this.makeAbortDecision_(mediaState).catch((error) => {\n      if (this.playerInterface_) {\n        goog.asserts.assert(error instanceof shaka.util.Error,\n            'Wrong error type!');\n        this.playerInterface_.onError(error);\n      }\n    });\n  }\n\n\n  /**\n   * Decide if it makes sense to abort the current operation, and abort it if\n   * so.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @private\n   */\n  async makeAbortDecision_(mediaState) {\n    // If the operation is completed, it will be set to null, and there's no\n    // need to abort the request.\n    if (!mediaState.operation) {\n      return;\n    }\n\n    const originalStream = mediaState.stream;\n    const originalOperation = mediaState.operation;\n\n    if (!originalStream.segmentIndex) {\n      // Create the new segment index so the time taken is accounted for when\n      // deciding whether to abort.\n      await originalStream.createSegmentIndex();\n    }\n\n    if (mediaState.operation != originalOperation) {\n      // The original operation completed while we were getting a segment index,\n      // so there's nothing to do now.\n      return;\n    }\n\n    if (mediaState.stream != originalStream) {\n      // The stream changed again while we were getting a segment index.  We\n      // can't carry out this check, since another one might be in progress by\n      // now.\n      return;\n    }\n\n    goog.asserts.assert(mediaState.stream.segmentIndex,\n        'Segment index should exist by now!');\n\n    if (this.shouldAbortCurrentRequest_(mediaState)) {\n      shaka.log.info('Aborting current segment request.');\n      mediaState.operation.abort();\n    }\n  }\n\n  /**\n   * Returns whether we should abort the current request.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @return {boolean}\n   * @private\n   */\n  shouldAbortCurrentRequest_(mediaState) {\n    goog.asserts.assert(mediaState.operation,\n        'Abort logic requires an ongoing operation!');\n    goog.asserts.assert(mediaState.stream && mediaState.stream.segmentIndex,\n        'Abort logic requires a segment index');\n\n    const presentationTime = this.playerInterface_.getPresentationTime();\n    const bufferEnd =\n        this.playerInterface_.mediaSourceEngine.bufferEnd(mediaState.type);\n\n    // The next segment to append from the current stream.  This doesn't\n    // account for a pending network request and will likely be different from\n    // that since we just switched.\n    const timeNeeded = this.getTimeNeeded_(mediaState, presentationTime);\n    const index = mediaState.stream.segmentIndex.find(timeNeeded);\n    const newSegment =\n        index == null ? null : mediaState.stream.segmentIndex.get(index);\n\n    let newSegmentSize = newSegment ? newSegment.getSize() : null;\n    if (newSegment && !newSegmentSize) {\n      // compute approximate segment size using stream bandwidth\n      const duration = newSegment.getEndTime() - newSegment.getStartTime();\n      const bandwidth = mediaState.stream.bandwidth || 0;\n      // bandwidth is in bits per second, and the size is in bytes\n      newSegmentSize = duration * bandwidth / 8;\n    }\n\n    if (!newSegmentSize) {\n      return false;\n    }\n\n    // When switching, we'll need to download the init segment.\n    const init = newSegment.initSegmentReference;\n    if (init) {\n      newSegmentSize += init.getSize() || 0;\n    }\n\n    const bandwidthEstimate = this.playerInterface_.getBandwidthEstimate();\n\n    // The estimate is in bits per second, and the size is in bytes.  The time\n    // remaining is in seconds after this calculation.\n    const timeToFetchNewSegment = (newSegmentSize * 8) / bandwidthEstimate;\n\n    // If the new segment can be finished in time without risking a buffer\n    // underflow, we should abort the old one and switch.\n    const bufferedAhead = (bufferEnd || 0) - presentationTime;\n    const safetyBuffer = Math.max(\n        this.manifest_.minBufferTime || 0,\n        this.config_.rebufferingGoal);\n    const safeBufferedAhead = bufferedAhead - safetyBuffer;\n    if (timeToFetchNewSegment < safeBufferedAhead) {\n      return true;\n    }\n\n    // If the thing we want to switch to will be done more quickly than what\n    // we've got in progress, we should abort the old one and switch.\n    const bytesRemaining = mediaState.operation.getBytesRemaining();\n    if (bytesRemaining > newSegmentSize) {\n      return true;\n    }\n\n    // Otherwise, complete the operation in progress.\n    return false;\n  }\n\n\n  /**\n   * Notifies the StreamingEngine that the playhead has moved to a valid time\n   * within the presentation timeline.\n   */\n  seeked() {\n    if (!this.playerInterface_) {\n      // Already destroyed.\n      return;\n    }\n\n    const presentationTime = this.playerInterface_.getPresentationTime();\n    const smallGapLimit = this.config_.smallGapLimit;\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const newTimeIsBuffered = (type) => {\n      return this.playerInterface_.mediaSourceEngine.isBuffered(\n          type, presentationTime, smallGapLimit);\n    };\n\n    let streamCleared = false;\n    for (const type of this.mediaStates_.keys()) {\n      const mediaState = this.mediaStates_.get(type);\n      const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n      // Always clear the iterator since we need to start streaming from the\n      // new time.  This also happens in clearBuffer_, but if we don't clear,\n      // we still want to reset the iterator.\n      mediaState.segmentIterator = null;\n\n      if (!newTimeIsBuffered(type)) {\n        const bufferEnd =\n            this.playerInterface_.mediaSourceEngine.bufferEnd(type);\n        const somethingBuffered = bufferEnd != null;\n\n        // Don't clear the buffer unless something is buffered.  This extra\n        // check prevents extra, useless calls to clear the buffer.\n        if (somethingBuffered || mediaState.performingUpdate) {\n          this.forceClearBuffer_(mediaState);\n          streamCleared = true;\n        }\n\n        // If there is an operation in progress, stop it now.\n        if (mediaState.operation) {\n          mediaState.operation.abort();\n          shaka.log.debug(logPrefix, 'Aborting operation due to seek');\n          mediaState.operation = null;\n        }\n\n        // The pts has shifted from the seek, invalidating captions currently\n        // in the text buffer. Thus, clear and reset the caption parser.\n        if (type === ContentType.TEXT) {\n          this.playerInterface_.mediaSourceEngine.resetCaptionParser();\n        }\n      }\n    }\n\n    if (!streamCleared) {\n      shaka.log.debug(\n          '(all): seeked: buffered seek: presentationTime=' + presentationTime);\n    }\n  }\n\n\n  /**\n   * Clear the buffer for a given stream.  Unlike clearBuffer_, this will handle\n   * cases where a MediaState is performing an update.  After this runs, the\n   * MediaState will have a pending update.\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @private\n   */\n  forceClearBuffer_(mediaState) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    if (mediaState.clearingBuffer) {\n      // We're already clearing the buffer, so we don't need to clear the\n      // buffer again.\n      shaka.log.debug(logPrefix, 'clear: already clearing the buffer');\n      return;\n    }\n\n    if (mediaState.waitingToClearBuffer) {\n      // May not be performing an update, but an update will still happen.\n      // See: https://github.com/shaka-project/shaka-player/issues/334\n      shaka.log.debug(logPrefix, 'clear: already waiting');\n      return;\n    }\n\n    if (mediaState.performingUpdate) {\n      // We are performing an update, so we have to wait until it's finished.\n      // onUpdate_() will call clearBuffer_() when the update has finished.\n      shaka.log.debug(logPrefix, 'clear: currently updating');\n      mediaState.waitingToClearBuffer = true;\n      // We can set the offset to zero to remember that this was a call to\n      // clearAllBuffers.\n      mediaState.clearBufferSafeMargin = 0;\n      return;\n    }\n\n    const type = mediaState.type;\n    if (this.playerInterface_.mediaSourceEngine.bufferStart(type) == null) {\n      // Nothing buffered.\n      shaka.log.debug(logPrefix, 'clear: nothing buffered');\n      if (mediaState.updateTimer == null) {\n        // Note: an update cycle stops when we buffer to the end of the\n        // presentation, or when we raise an error.\n        this.scheduleUpdate_(mediaState, 0);\n      }\n      return;\n    }\n\n    // An update may be scheduled, but we can just cancel it and clear the\n    // buffer right away. Note: clearBuffer_() will schedule the next update.\n    shaka.log.debug(logPrefix, 'clear: handling right now');\n    this.cancelUpdate_(mediaState);\n    this.clearBuffer_(mediaState, /* flush= */ false, 0).catch((error) => {\n      if (this.playerInterface_) {\n        goog.asserts.assert(error instanceof shaka.util.Error,\n            'Wrong error type!');\n        this.playerInterface_.onError(error);\n      }\n    });\n  }\n\n\n  /**\n   * Initializes the initial streams and media states.  This will schedule\n   * updates for the given types.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async initStreams_() {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    goog.asserts.assert(this.config_,\n        'StreamingEngine configure() must be called before init()!');\n\n    if (!this.currentVariant_) {\n      shaka.log.error('init: no Streams chosen');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STREAMING,\n          shaka.util.Error.Code.STREAMING_ENGINE_STARTUP_INVALID_STATE);\n    }\n\n    /**\n     * @type {!Map.<shaka.util.ManifestParserUtils.ContentType,\n     *              shaka.extern.Stream>}\n     */\n    const streamsByType = new Map();\n    /** @type {!Set.<shaka.extern.Stream>} */\n    const streams = new Set();\n\n    if (this.currentVariant_.audio) {\n      streamsByType.set(ContentType.AUDIO, this.currentVariant_.audio);\n      streams.add(this.currentVariant_.audio);\n    }\n\n    if (this.currentVariant_.video) {\n      streamsByType.set(ContentType.VIDEO, this.currentVariant_.video);\n      streams.add(this.currentVariant_.video);\n    }\n\n    if (this.currentTextStream_) {\n      streamsByType.set(ContentType.TEXT, this.currentTextStream_);\n      streams.add(this.currentTextStream_);\n    }\n\n    // Init MediaSourceEngine.\n    const mediaSourceEngine = this.playerInterface_.mediaSourceEngine;\n    const forceTransmuxTS = this.config_.forceTransmuxTS;\n\n    await mediaSourceEngine.init(streamsByType, forceTransmuxTS);\n    this.destroyer_.ensureNotDestroyed();\n\n    this.setDuration_();\n\n    for (const type of streamsByType.keys()) {\n      const stream = streamsByType.get(type);\n      if (!this.mediaStates_.has(type)) {\n        const mediaState = this.createMediaState_(stream);\n        this.mediaStates_.set(type, mediaState);\n        this.scheduleUpdate_(mediaState, 0);\n      }\n    }\n  }\n\n\n  /**\n   * Creates a media state.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {shaka.media.StreamingEngine.MediaState_}\n   * @private\n   */\n  createMediaState_(stream) {\n    return /** @type {shaka.media.StreamingEngine.MediaState_} */ ({\n      stream,\n      type: stream.type,\n      segmentIterator: null,\n      lastSegmentReference: null,\n      lastInitSegmentReference: null,\n      lastTimestampOffset: null,\n      lastAppendWindowStart: null,\n      lastAppendWindowEnd: null,\n      restoreStreamAfterTrickPlay: null,\n      endOfStream: false,\n      performingUpdate: false,\n      updateTimer: null,\n      waitingToClearBuffer: false,\n      clearBufferSafeMargin: 0,\n      waitingToFlushBuffer: false,\n      clearingBuffer: false,\n      recovering: false,\n      hasError: false,\n      operation: null,\n    });\n  }\n\n\n  /**\n   * Sets the MediaSource's duration.\n   * @private\n   */\n  setDuration_() {\n    const duration = this.manifest_.presentationTimeline.getDuration();\n    if (duration < Infinity) {\n      this.playerInterface_.mediaSourceEngine.setDuration(duration);\n    } else {\n      // Not all platforms support infinite durations, so set a finite duration\n      // so we can append segments and so the user agent can seek.\n      this.playerInterface_.mediaSourceEngine.setDuration(Math.pow(2, 32));\n    }\n  }\n\n\n  /**\n   * Called when |mediaState|'s update timer has expired.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @suppress {suspiciousCode} The compiler assumes that updateTimer can't\n   *   change during the await, and so complains about the null check.\n   * @private\n   */\n  async onUpdate_(mediaState) {\n    this.destroyer_.ensureNotDestroyed();\n\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    // Sanity check.\n    goog.asserts.assert(\n        !mediaState.performingUpdate && (mediaState.updateTimer != null),\n        logPrefix + ' unexpected call to onUpdate_()');\n    if (mediaState.performingUpdate || (mediaState.updateTimer == null)) {\n      return;\n    }\n\n    goog.asserts.assert(\n        !mediaState.clearingBuffer, logPrefix +\n        ' onUpdate_() should not be called when clearing the buffer');\n    if (mediaState.clearingBuffer) {\n      return;\n    }\n\n    mediaState.updateTimer = null;\n\n    // Handle pending buffer clears.\n    if (mediaState.waitingToClearBuffer) {\n      // Note: clearBuffer_() will schedule the next update.\n      shaka.log.debug(logPrefix, 'skipping update and clearing the buffer');\n      await this.clearBuffer_(\n          mediaState, mediaState.waitingToFlushBuffer,\n          mediaState.clearBufferSafeMargin);\n      return;\n    }\n\n    // Make sure the segment index exists. If not, create the segment index.\n    if (!mediaState.stream.segmentIndex) {\n      const thisStream = mediaState.stream;\n\n      await mediaState.stream.createSegmentIndex();\n\n      if (thisStream != mediaState.stream) {\n        // We switched streams while in the middle of this async call to\n        // createSegmentIndex.  Abandon this update and schedule a new one if\n        // there's not already one pending.\n        // Releases the segmentIndex of the old stream.\n        if (thisStream.closeSegmentIndex) {\n          goog.asserts.assert(!mediaState.stream.segmentIndex,\n              'mediastate.stream should not have segmentIndex yet.');\n          thisStream.closeSegmentIndex();\n        }\n        if (!mediaState.performingUpdate && !mediaState.updateTimer) {\n          this.scheduleUpdate_(mediaState, 0);\n        }\n        return;\n      }\n    }\n\n    // Update the MediaState.\n    try {\n      const delay = this.update_(mediaState);\n      if (delay != null) {\n        this.scheduleUpdate_(mediaState, delay);\n        mediaState.hasError = false;\n      }\n    } catch (error) {\n      await this.handleStreamingError_(error);\n      return;\n    }\n\n    const mediaStates = Array.from(this.mediaStates_.values());\n\n    // Check if we've buffered to the end of the presentation.  We delay adding\n    // the audio and video media states, so it is possible for the text stream\n    // to be the only state and buffer to the end.  So we need to wait until we\n    // have completed startup to determine if we have reached the end.\n    if (this.startupComplete_ &&\n        mediaStates.every((ms) => ms.endOfStream)) {\n      shaka.log.v1(logPrefix, 'calling endOfStream()...');\n      await this.playerInterface_.mediaSourceEngine.endOfStream();\n      this.destroyer_.ensureNotDestroyed();\n\n      // If the media segments don't reach the end, then we need to update the\n      // timeline duration to match the final media duration to avoid\n      // buffering forever at the end.\n      // We should only do this if the duration needs to shrink.\n      // Growing it by less than 1ms can actually cause buffering on\n      // replay, as in https://github.com/shaka-project/shaka-player/issues/979\n      // On some platforms, this can spuriously be 0, so ignore this case.\n      // https://github.com/shaka-project/shaka-player/issues/1967,\n      const duration = this.playerInterface_.mediaSourceEngine.getDuration();\n      if (duration != 0 &&\n          duration < this.manifest_.presentationTimeline.getDuration()) {\n        this.manifest_.presentationTimeline.setDuration(duration);\n      }\n    }\n  }\n\n\n  /**\n   * Updates the given MediaState.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @return {?number} The number of seconds to wait until updating again or\n   *   null if another update does not need to be scheduled.\n   * @private\n   */\n  update_(mediaState) {\n    goog.asserts.assert(this.manifest_, 'manifest_ should not be null');\n    goog.asserts.assert(this.config_, 'config_ should not be null');\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    // Do not schedule update for closed captions text mediastate, since closed\n    // captions are embedded in video streams.\n    if (shaka.media.StreamingEngine.isEmbeddedText_(mediaState)) {\n      this.playerInterface_.mediaSourceEngine.setSelectedClosedCaptionId(\n          mediaState.stream.originalId || '');\n      return null;\n    } else if (mediaState.type == ContentType.TEXT) {\n      // Disable embedded captions if not desired (e.g. if transitioning from\n      // embedded to not-embedded captions).\n      this.playerInterface_.mediaSourceEngine.clearSelectedClosedCaptionId();\n    }\n\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    // Compute how far we've buffered ahead of the playhead.\n    const presentationTime = this.playerInterface_.getPresentationTime();\n\n    // Get the next timestamp we need.\n    const timeNeeded = this.getTimeNeeded_(mediaState, presentationTime);\n    shaka.log.v2(logPrefix, 'timeNeeded=' + timeNeeded);\n\n    // Get the amount of content we have buffered, accounting for drift.  This\n    // is only used to determine if we have meet the buffering goal.  This\n    // should be the same method that PlayheadObserver uses.\n    const bufferedAhead =\n        this.playerInterface_.mediaSourceEngine.bufferedAheadOf(\n            mediaState.type, presentationTime);\n\n    shaka.log.v2(logPrefix,\n        'update_:',\n        'presentationTime=' + presentationTime,\n        'bufferedAhead=' + bufferedAhead);\n\n    const unscaledBufferingGoal = Math.max(\n        this.manifest_.minBufferTime || 0,\n        this.config_.rebufferingGoal,\n        this.config_.bufferingGoal);\n\n    const scaledBufferingGoal =\n        unscaledBufferingGoal * this.bufferingGoalScale_;\n\n    // Check if we've buffered to the end of the presentation.\n    const timeUntilEnd =\n        this.manifest_.presentationTimeline.getDuration() - timeNeeded;\n    const oneMicrosecond = 1e-6;\n\n    const bufferEnd =\n      this.playerInterface_.mediaSourceEngine.bufferEnd(mediaState.type);\n\n    if (timeUntilEnd < oneMicrosecond && !!bufferEnd) {\n      // We shouldn't rebuffer if the playhead is close to the end of the\n      // presentation.\n      shaka.log.debug(logPrefix, 'buffered to end of presentation');\n      mediaState.endOfStream = true;\n\n      if (mediaState.type == ContentType.VIDEO) {\n        // Since the text stream of CEA closed captions doesn't have update\n        // timer, we have to set the text endOfStream based on the video\n        // stream's endOfStream state.\n        const textState = this.mediaStates_.get(ContentType.TEXT);\n        if (textState &&\n            shaka.media.StreamingEngine.isEmbeddedText_(textState)) {\n          textState.endOfStream = true;\n        }\n      }\n      return null;\n    }\n    mediaState.endOfStream = false;\n\n    // If we've buffered to the buffering goal then schedule an update.\n    if (bufferedAhead >= scaledBufferingGoal) {\n      shaka.log.v2(logPrefix, 'buffering goal met');\n\n      // Do not try to predict the next update.  Just poll according to\n      // configuration (seconds). The playback rate can change at any time, so\n      // any prediction we make now could be terribly invalid soon.\n      return this.config_.updateIntervalSeconds / 2;\n    }\n\n    const reference = this.getSegmentReferenceNeeded_(\n        mediaState, presentationTime, bufferEnd);\n    if (!reference) {\n      // The segment could not be found, does not exist, or is not available.\n      // In any case just try again... if the manifest is incomplete or is not\n      // being updated then we'll idle forever; otherwise, we'll end up getting\n      // a SegmentReference eventually.\n      return this.config_.updateIntervalSeconds;\n    }\n\n    // Do not let any one stream get far ahead of any other.\n    let minTimeNeeded = Infinity;\n    const mediaStates = Array.from(this.mediaStates_.values());\n    for (const otherState of mediaStates) {\n      // Do not consider embedded captions in this calculation.  It could lead\n      // to hangs in streaming.\n      if (shaka.media.StreamingEngine.isEmbeddedText_(otherState)) {\n        continue;\n      }\n      // If there is no next segment, ignore this stream.  This happens with\n      // text when there's a Period with no text in it.\n      if (otherState.segmentIterator && !otherState.segmentIterator.current()) {\n        continue;\n      }\n\n      const timeNeeded = this.getTimeNeeded_(otherState, presentationTime);\n      minTimeNeeded = Math.min(minTimeNeeded, timeNeeded);\n    }\n\n    const maxSegmentDuration =\n        this.manifest_.presentationTimeline.getMaxSegmentDuration();\n    const maxRunAhead = maxSegmentDuration *\n        shaka.media.StreamingEngine.MAX_RUN_AHEAD_SEGMENTS_;\n    if (timeNeeded >= minTimeNeeded + maxRunAhead) {\n      // Wait and give other media types time to catch up to this one.\n      // For example, let video buffering catch up to audio buffering before\n      // fetching another audio segment.\n      shaka.log.v2(logPrefix, 'waiting for other streams to buffer');\n      return this.config_.updateIntervalSeconds;\n    }\n\n    const p = this.fetchAndAppend_(mediaState, presentationTime, reference);\n    p.catch(() => {});  // TODO(#1993): Handle asynchronous errors.\n    return null;\n  }\n\n\n  /**\n   * Gets the next timestamp needed. Returns the playhead's position if the\n   * buffer is empty; otherwise, returns the time at which the last segment\n   * appended ends.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} presentationTime\n   * @return {number} The next timestamp needed.\n   * @private\n   */\n  getTimeNeeded_(mediaState, presentationTime) {\n    // Get the next timestamp we need. We must use |lastSegmentReference|\n    // to determine this and not the actual buffer for two reasons:\n    //   1. Actual segments end slightly before their advertised end times, so\n    //      the next timestamp we need is actually larger than |bufferEnd|.\n    //   2. There may be drift (the timestamps in the segments are ahead/behind\n    //      of the timestamps in the manifest), but we need drift-free times\n    //      when comparing times against the presentation timeline.\n    if (!mediaState.lastSegmentReference) {\n      return presentationTime;\n    }\n\n    return mediaState.lastSegmentReference.endTime;\n  }\n\n\n  /**\n   * Gets the SegmentReference of the next segment needed.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} presentationTime\n   * @param {?number} bufferEnd\n   * @return {shaka.media.SegmentReference} The SegmentReference of the\n   *   next segment needed. Returns null if a segment could not be found, does\n   *   not exist, or is not available.\n   * @private\n   */\n  getSegmentReferenceNeeded_(mediaState, presentationTime, bufferEnd) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n    goog.asserts.assert(\n        mediaState.stream.segmentIndex,\n        'segment index should have been generated already');\n\n    if (mediaState.segmentIterator) {\n      // Something is buffered from the same Stream.  Use the current position\n      // in the segment index.  This is updated via next() after each segment is\n      // appended.\n      return mediaState.segmentIterator.current();\n    } else if (mediaState.lastSegmentReference || bufferEnd) {\n      // Something is buffered from another Stream.\n      const time = mediaState.lastSegmentReference ?\n          mediaState.lastSegmentReference.endTime :\n          bufferEnd;\n      goog.asserts.assert(time != null, 'Should have a time to search');\n      shaka.log.v1(\n          logPrefix, 'looking up segment from new stream endTime:', time);\n\n      mediaState.segmentIterator =\n          mediaState.stream.segmentIndex.getIteratorForTime(time);\n      const ref = mediaState.segmentIterator &&\n          mediaState.segmentIterator.next().value;\n      if (ref == null) {\n        shaka.log.warning(logPrefix, 'cannot find segment', 'endTime:', time);\n      }\n      return ref;\n    } else {\n      // Nothing is buffered.  Start at the playhead time.\n\n      // If there's positive drift then we need to adjust the lookup time, and\n      // may wind up requesting the previous segment to be safe.\n      // inaccurateManifestTolerance should be 0 for low latency streaming.\n      const inaccurateTolerance = this.config_.inaccurateManifestTolerance;\n      const lookupTime = Math.max(presentationTime - inaccurateTolerance, 0);\n\n      shaka.log.v1(logPrefix, 'looking up segment',\n          'lookupTime:', lookupTime,\n          'presentationTime:', presentationTime);\n\n      let ref = null;\n      if (inaccurateTolerance) {\n        mediaState.segmentIterator =\n            mediaState.stream.segmentIndex.getIteratorForTime(lookupTime);\n        ref = mediaState.segmentIterator &&\n            mediaState.segmentIterator.next().value;\n      }\n      if (!ref) {\n        // If we can't find a valid segment with the drifted time, look for a\n        // segment with the presentation time.\n        mediaState.segmentIterator =\n            mediaState.stream.segmentIndex.getIteratorForTime(presentationTime);\n        ref = mediaState.segmentIterator &&\n            mediaState.segmentIterator.next().value;\n      }\n      if (ref == null) {\n        shaka.log.warning(logPrefix, 'cannot find segment',\n            'lookupTime:', lookupTime,\n            'presentationTime:', presentationTime);\n      }\n      return ref;\n    }\n  }\n\n\n  /**\n   * Fetches and appends the given segment. Sets up the given MediaState's\n   * associated SourceBuffer and evicts segments if either are required\n   * beforehand. Schedules another update after completing successfully.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} presentationTime\n   * @param {!shaka.media.SegmentReference} reference\n   * @private\n   */\n  async fetchAndAppend_(mediaState, presentationTime, reference) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const StreamingEngine = shaka.media.StreamingEngine;\n    const logPrefix = StreamingEngine.logPrefix_(mediaState);\n\n    shaka.log.v1(logPrefix,\n        'fetchAndAppend_:',\n        'presentationTime=' + presentationTime,\n        'reference.startTime=' + reference.startTime,\n        'reference.endTime=' + reference.endTime);\n\n    // Subtlety: The playhead may move while asynchronous update operations are\n    // in progress, so we should avoid calling playhead.getTime() in any\n    // callbacks. Furthermore, switch() or seeked() may be called at any time,\n    // so we store the old iterator.  This allows the mediaState to change and\n    // we'll update the old iterator.\n    const stream = mediaState.stream;\n    const iter = mediaState.segmentIterator;\n\n    mediaState.performingUpdate = true;\n\n    try {\n      await this.initSourceBuffer_(mediaState, reference);\n      this.destroyer_.ensureNotDestroyed();\n      if (this.fatalError_) {\n        return;\n      }\n\n      shaka.log.v2(logPrefix, 'fetching segment');\n      const isMP4 = stream.mimeType == 'video/mp4' ||\n              stream.mimeType == 'audio/mp4';\n      const isReadableStreamSupported = window.ReadableStream;\n      // Enable MP4 low latency streaming with ReadableStream chunked data.\n      if (this.config_.lowLatencyMode && isReadableStreamSupported && isMP4) {\n        let remaining = new Uint8Array(0);\n        let processingResult = false;\n        let callbackCalled = false;\n        const streamDataCallback = async (data) => {\n          if (processingResult) {\n            // If the fallback result processing was triggered, don't also\n            // append the buffer here.  In theory this should never happen,\n            // but it does on some older TVs.\n            return;\n          }\n          callbackCalled = true;\n          this.destroyer_.ensureNotDestroyed();\n          if (this.fatalError_) {\n            return;\n          }\n          // Append the data with complete boxes.\n          // Every time streamDataCallback gets called, append the new data to\n          // the remaining data.\n          // Find the last fully completed Mdat box, and slice the data into two\n          // parts: the first part with completed Mdat boxes, and the second\n          // part with an incomplete box.\n          // Append the first part, and save the second part as remaining data,\n          // and handle it with the next streamDataCallback call.\n          remaining = this.concatArray_(remaining, data);\n          let sawMDAT = false;\n          let offset = 0;\n          new shaka.util.Mp4Parser()\n              .box('mdat', (box) => {\n                offset = box.size + box.start;\n                sawMDAT = true;\n              })\n              .parse(remaining, /* partialOkay= */ false,\n                  /* isChunkedData= */ true);\n          if (sawMDAT) {\n            const dataToAppend = remaining.subarray(0, offset);\n            remaining = remaining.subarray(offset);\n            await this.append_(\n                mediaState, presentationTime, stream, reference, dataToAppend);\n          }\n        };\n\n        const result =\n            await this.fetch_(mediaState, reference, streamDataCallback);\n        if (!callbackCalled) {\n          // In some environments, we might be forced to use network plugins\n          // that don't support streamDataCallback. In those cases, as a\n          // fallback, append the buffer here.\n          processingResult = true;\n          this.destroyer_.ensureNotDestroyed();\n          if (this.fatalError_) {\n            return;\n          }\n\n          // If the text stream gets switched between fetch_() and append_(),\n          // the new text parser is initialized, but the new init segment is\n          // not fetched yet.  That would cause an error in\n          // TextParser.parseMedia().\n          // See http://b/168253400\n          if (mediaState.waitingToClearBuffer) {\n            shaka.log.info(logPrefix, 'waitingToClearBuffer, skip append');\n            mediaState.performingUpdate = false;\n            this.scheduleUpdate_(mediaState, 0);\n            return;\n          }\n\n          await this.append_(\n              mediaState, presentationTime, stream, reference, result);\n        }\n      } else {\n        if (this.config_.lowLatencyMode && !isReadableStreamSupported) {\n          shaka.log.warning('Low latency streaming mode is enabled, but ' +\n            'ReadableStream is not supported by the browser.');\n        }\n        const fetchSegment = this.fetch_(mediaState, reference);\n        const result = await fetchSegment;\n        this.destroyer_.ensureNotDestroyed();\n        if (this.fatalError_) {\n          return;\n        }\n\n        // If the text stream gets switched between fetch_() and append_(), the\n        // new text parser is initialized, but the new init segment is not\n        // fetched yet.  That would cause an error in TextParser.parseMedia().\n        // See http://b/168253400\n        if (mediaState.waitingToClearBuffer) {\n          shaka.log.info(logPrefix, 'waitingToClearBuffer, skip append');\n          mediaState.performingUpdate = false;\n          this.scheduleUpdate_(mediaState, 0);\n          return;\n        }\n        await this.append_(\n            mediaState, presentationTime, stream, reference, result);\n      }\n\n      this.destroyer_.ensureNotDestroyed();\n      if (this.fatalError_) {\n        return;\n      }\n      // move to next segment after appending the current segment.\n      mediaState.lastSegmentReference = reference;\n      const newRef = iter.next().value;\n      shaka.log.v2(logPrefix, 'advancing to next segment', newRef);\n\n      mediaState.performingUpdate = false;\n      mediaState.recovering = false;\n\n      const info = this.playerInterface_.mediaSourceEngine.getBufferedInfo();\n      const buffered = info[mediaState.type];\n      // Convert the buffered object to a string capture its properties on\n      // WebOS.\n      shaka.log.v1(logPrefix, 'finished fetch and append',\n          JSON.stringify(buffered));\n\n      if (!mediaState.waitingToClearBuffer) {\n        this.playerInterface_.onSegmentAppended();\n      }\n\n      // Update right away.\n      this.scheduleUpdate_(mediaState, 0);\n    } catch (error) {\n      this.destroyer_.ensureNotDestroyed(error);\n      if (this.fatalError_) {\n        return;\n      }\n      goog.asserts.assert(error instanceof shaka.util.Error,\n          'Should only receive a Shaka error');\n\n      mediaState.performingUpdate = false;\n\n      if (error.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n        // If the network slows down, abort the current fetch request and start\n        // a new one, and ignore the error message.\n        mediaState.performingUpdate = false;\n        this.cancelUpdate_(mediaState);\n        this.scheduleUpdate_(mediaState, 0);\n      } else if (mediaState.type == ContentType.TEXT &&\n          this.config_.ignoreTextStreamFailures) {\n        if (error.code == shaka.util.Error.Code.BAD_HTTP_STATUS) {\n          shaka.log.warning(logPrefix,\n              'Text stream failed to download. Proceeding without it.');\n        } else {\n          shaka.log.warning(logPrefix,\n              'Text stream failed to parse. Proceeding without it.');\n        }\n        this.mediaStates_.delete(ContentType.TEXT);\n      } else if (error.code == shaka.util.Error.Code.QUOTA_EXCEEDED_ERROR) {\n        this.handleQuotaExceeded_(mediaState, error);\n      } else {\n        shaka.log.error(logPrefix, 'failed fetch and append: code=' +\n            error.code);\n        mediaState.hasError = true;\n\n        error.severity = shaka.util.Error.Severity.CRITICAL;\n        await this.handleStreamingError_(error);\n      }\n    }\n  }\n\n\n  /**\n   * Clear per-stream error states and retry any failed streams.\n   * @param {number} delaySeconds\n   * @return {boolean} False if unable to retry.\n   */\n  retry(delaySeconds) {\n    if (this.destroyer_.destroyed()) {\n      shaka.log.error('Unable to retry after StreamingEngine is destroyed!');\n      return false;\n    }\n\n    if (this.fatalError_) {\n      shaka.log.error('Unable to retry after StreamingEngine encountered a ' +\n                      'fatal error!');\n      return false;\n    }\n\n    for (const mediaState of this.mediaStates_.values()) {\n      const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n      // Only schedule an update if it has an error, but it's not mid-update\n      // and there is not already an update scheduled.\n      if (mediaState.hasError && !mediaState.performingUpdate &&\n          !mediaState.updateTimer) {\n        shaka.log.info(logPrefix, 'Retrying after failure...');\n        mediaState.hasError = false;\n        this.scheduleUpdate_(mediaState, delaySeconds);\n      }\n    }\n\n    return true;\n  }\n\n\n  /**\n   * Append the data to the remaining data.\n   * @param {!Uint8Array} remaining\n   * @param {!Uint8Array} data\n   * @return {!Uint8Array}\n   * @private\n   */\n  concatArray_(remaining, data) {\n    const result = new Uint8Array(remaining.length + data.length);\n    result.set(remaining);\n    result.set(data, remaining.length);\n    return result;\n  }\n\n\n  /**\n   * Handles a QUOTA_EXCEEDED_ERROR.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {!shaka.util.Error} error\n   * @private\n   */\n  handleQuotaExceeded_(mediaState, error) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    // The segment cannot fit into the SourceBuffer. Ideally, MediaSource would\n    // have evicted old data to accommodate the segment; however, it may have\n    // failed to do this if the segment is very large, or if it could not find\n    // a suitable time range to remove.\n    //\n    // We can overcome the latter by trying to append the segment again;\n    // however, to avoid continuous QuotaExceededErrors we must reduce the size\n    // of the buffer going forward.\n    //\n    // If we've recently reduced the buffering goals, wait until the stream\n    // which caused the first QuotaExceededError recovers. Doing this ensures\n    // we don't reduce the buffering goals too quickly.\n\n    const mediaStates = Array.from(this.mediaStates_.values());\n    const waitingForAnotherStreamToRecover = mediaStates.some((ms) => {\n      return ms != mediaState && ms.recovering;\n    });\n\n    if (!waitingForAnotherStreamToRecover) {\n      // Reduction schedule: 80%, 60%, 40%, 20%, 16%, 12%, 8%, 4%, fail.\n      // Note: percentages are used for comparisons to avoid rounding errors.\n      const percentBefore = Math.round(100 * this.bufferingGoalScale_);\n      if (percentBefore > 20) {\n        this.bufferingGoalScale_ -= 0.2;\n      } else if (percentBefore > 4) {\n        this.bufferingGoalScale_ -= 0.04;\n      } else {\n        shaka.log.error(\n            logPrefix, 'MediaSource threw QuotaExceededError too many times');\n        mediaState.hasError = true;\n        this.fatalError_ = true;\n        this.playerInterface_.onError(error);\n        return;\n      }\n      const percentAfter = Math.round(100 * this.bufferingGoalScale_);\n      shaka.log.warning(\n          logPrefix,\n          'MediaSource threw QuotaExceededError:',\n          'reducing buffering goals by ' + (100 - percentAfter) + '%');\n      mediaState.recovering = true;\n    } else {\n      shaka.log.debug(\n          logPrefix,\n          'MediaSource threw QuotaExceededError:',\n          'waiting for another stream to recover...');\n    }\n\n    // QuotaExceededError gets thrown if eviction didn't help to make room\n    // for a segment. We want to wait for a while (4 seconds is just an\n    // arbitrary number) before updating to give the playhead a chance to\n    // advance, so we don't immediately throw again.\n    this.scheduleUpdate_(mediaState, 4);\n  }\n\n\n  /**\n   * Sets the given MediaState's associated SourceBuffer's timestamp offset,\n   * append window, and init segment if they have changed. If an error occurs\n   * then neither the timestamp offset or init segment are unset, since another\n   * call to switch() will end up superseding them.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {!shaka.media.SegmentReference} reference\n   * @return {!Promise}\n   * @private\n   */\n  async initSourceBuffer_(mediaState, reference) {\n    const StreamingEngine = shaka.media.StreamingEngine;\n    const logPrefix = StreamingEngine.logPrefix_(mediaState);\n\n    /** @type {!Array.<!Promise>} */\n    const operations = [];\n\n    // Rounding issues can cause us to remove the first frame of a Period, so\n    // reduce the window start time slightly.\n    const appendWindowStart = Math.max(0,\n        reference.appendWindowStart -\n        StreamingEngine.APPEND_WINDOW_START_FUDGE_);\n    const appendWindowEnd =\n        reference.appendWindowEnd + StreamingEngine.APPEND_WINDOW_END_FUDGE_;\n\n    goog.asserts.assert(\n        reference.startTime <= appendWindowEnd,\n        logPrefix + ' segment should start before append window end');\n\n    const timestampOffset = reference.timestampOffset;\n    if (timestampOffset != mediaState.lastTimestampOffset ||\n        appendWindowStart != mediaState.lastAppendWindowStart ||\n        appendWindowEnd != mediaState.lastAppendWindowEnd) {\n      shaka.log.v1(logPrefix, 'setting timestamp offset to ' + timestampOffset);\n      shaka.log.v1(logPrefix,\n          'setting append window start to ' + appendWindowStart);\n      shaka.log.v1(logPrefix,\n          'setting append window end to ' + appendWindowEnd);\n\n      const setProperties = async () => {\n        try {\n          mediaState.lastAppendWindowStart = appendWindowStart;\n          mediaState.lastAppendWindowEnd = appendWindowEnd;\n          mediaState.lastTimestampOffset = timestampOffset;\n\n          await this.playerInterface_.mediaSourceEngine.setStreamProperties(\n              mediaState.type, timestampOffset, appendWindowStart,\n              appendWindowEnd);\n        } catch (error) {\n          mediaState.lastAppendWindowStart = null;\n          mediaState.lastAppendWindowEnd = null;\n          mediaState.lastTimestampOffset = null;\n\n          throw error;\n        }\n      };\n      operations.push(setProperties());\n    }\n\n    if (!shaka.media.InitSegmentReference.equal(\n        reference.initSegmentReference, mediaState.lastInitSegmentReference)) {\n      mediaState.lastInitSegmentReference = reference.initSegmentReference;\n\n      if (reference.initSegmentReference) {\n        shaka.log.v1(logPrefix, 'fetching init segment');\n\n        const fetchInit =\n            this.fetch_(mediaState, reference.initSegmentReference);\n        const append = async () => {\n          try {\n            const initSegment = await fetchInit;\n            this.destroyer_.ensureNotDestroyed();\n            shaka.log.v1(logPrefix, 'appending init segment');\n            const hasClosedCaptions = mediaState.stream.closedCaptions &&\n                mediaState.stream.closedCaptions.size > 0;\n            await this.playerInterface_.mediaSourceEngine.appendBuffer(\n                mediaState.type, initSegment, /* startTime= */ null,\n                /* endTime= */ null, hasClosedCaptions);\n          } catch (error) {\n            mediaState.lastInitSegmentReference = null;\n            throw error;\n          }\n        };\n        this.playerInterface_.onInitSegmentAppended(\n            reference.startTime, reference.initSegmentReference);\n        operations.push(append());\n      }\n    }\n\n    await Promise.all(operations);\n  }\n\n\n  /**\n   * Appends the given segment and evicts content if required to append.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} presentationTime\n   * @param {shaka.extern.Stream} stream\n   * @param {!shaka.media.SegmentReference} reference\n   * @param {BufferSource} segment\n   * @return {!Promise}\n   * @private\n   */\n  async append_(mediaState, presentationTime, stream, reference,\n      segment) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    const hasClosedCaptions = stream.closedCaptions &&\n        stream.closedCaptions.size > 0;\n    if ((stream.emsgSchemeIdUris != null &&\n        stream.emsgSchemeIdUris.length > 0) ||\n        this.config_.dispatchAllEmsgBoxes) {\n      new shaka.util.Mp4Parser()\n          .fullBox(\n              'emsg',\n              (box) => this.parseEMSG_(\n                  reference, stream.emsgSchemeIdUris, box))\n          .parse(segment);\n    }\n\n    await this.evict_(mediaState, presentationTime);\n    this.destroyer_.ensureNotDestroyed();\n    shaka.log.v1(logPrefix, 'appending media segment');\n\n    await this.playerInterface_.mediaSourceEngine.appendBuffer(\n        mediaState.type,\n        segment,\n        reference.startTime,\n        reference.endTime,\n        hasClosedCaptions);\n    this.destroyer_.ensureNotDestroyed();\n    shaka.log.v2(logPrefix, 'appended media segment');\n  }\n\n\n  /**\n   * Parse the EMSG box from a MP4 container.\n   *\n   * @param {!shaka.media.SegmentReference} reference\n   * @param {?Array.<string>} emsgSchemeIdUris Array of emsg\n   *     scheme_id_uri for which emsg boxes should be parsed.\n   * @param {!shaka.extern.ParsedBox} box\n   * @private\n   * https://dashif-documents.azurewebsites.net/Events/master/event.html#emsg-format\n   * aligned(8) class DASHEventMessageBox\n   *    extends FullBox(‘emsg’, version, flags = 0){\n   * if (version==0) {\n   *   string scheme_id_uri;\n   *   string value;\n   *   unsigned int(32) timescale;\n   *   unsigned int(32) presentation_time_delta;\n   *   unsigned int(32) event_duration;\n   *   unsigned int(32) id;\n   * } else if (version==1) {\n   *   unsigned int(32) timescale;\n   *   unsigned int(64) presentation_time;\n   *   unsigned int(32) event_duration;\n   *   unsigned int(32) id;\n   *   string scheme_id_uri;\n   *   string value;\n   * }\n   * unsigned int(8) message_data[];\n   */\n  parseEMSG_(reference, emsgSchemeIdUris, box) {\n    let timescale;\n    let id;\n    let eventDuration;\n    let schemeId;\n    let startTime;\n    let presentationTimeDelta;\n    let value;\n\n    if (box.version === 0) {\n      schemeId = box.reader.readTerminatedString();\n      value = box.reader.readTerminatedString();\n      timescale = box.reader.readUint32();\n      presentationTimeDelta = box.reader.readUint32();\n      eventDuration = box.reader.readUint32();\n      id = box.reader.readUint32();\n      startTime = reference.startTime + (presentationTimeDelta / timescale);\n    } else {\n      timescale = box.reader.readUint32();\n      const pts = box.reader.readUint64();\n      startTime = (pts / timescale) + reference.timestampOffset;\n      presentationTimeDelta = startTime - reference.startTime;\n      eventDuration = box.reader.readUint32();\n      id = box.reader.readUint32();\n      schemeId = box.reader.readTerminatedString();\n      value = box.reader.readTerminatedString();\n    }\n    const messageData = box.reader.readBytes(\n        box.reader.getLength() - box.reader.getPosition());\n\n\n    // See DASH sec. 5.10.3.3.1\n    // If a DASH client detects an event message box with a scheme that is not\n    // defined in MPD, the client is expected to ignore it.\n    if ((emsgSchemeIdUris && emsgSchemeIdUris.includes(schemeId)) ||\n        this.config_.dispatchAllEmsgBoxes) {\n      // See DASH sec. 5.10.4.1\n      // A special scheme in DASH used to signal manifest updates.\n      if (schemeId == 'urn:mpeg:dash:event:2012') {\n        this.playerInterface_.onManifestUpdate();\n      } else {\n        /** @type {shaka.extern.EmsgInfo} */\n        const emsg = {\n          startTime: startTime,\n          endTime: startTime + (eventDuration / timescale),\n          schemeIdUri: schemeId,\n          value: value,\n          timescale: timescale,\n          presentationTimeDelta: presentationTimeDelta,\n          eventDuration: eventDuration,\n          id: id,\n          messageData: messageData,\n        };\n\n        // Dispatch an event to notify the application about the emsg box.\n        const eventName = shaka.Player.EventName.Emsg;\n        const data = (new Map()).set('detail', emsg);\n        const event = new shaka.util.FakeEvent(eventName, data);\n        this.playerInterface_.onEvent(event);\n      }\n    }\n  }\n\n\n  /**\n   * Evicts media to meet the max buffer behind limit.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} presentationTime\n   * @private\n   */\n  async evict_(mediaState, presentationTime) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n    shaka.log.v2(logPrefix, 'checking buffer length');\n\n    // Use the max segment duration, if it is longer than the bufferBehind, to\n    // avoid accidentally clearing too much data when dealing with a manifest\n    // with a long keyframe interval.\n    const bufferBehind = Math.max(this.config_.bufferBehind,\n        this.manifest_.presentationTimeline.getMaxSegmentDuration());\n\n    const startTime =\n        this.playerInterface_.mediaSourceEngine.bufferStart(mediaState.type);\n    if (startTime == null) {\n      shaka.log.v2(logPrefix,\n          'buffer behind okay because nothing buffered:',\n          'presentationTime=' + presentationTime,\n          'bufferBehind=' + bufferBehind);\n      return;\n    }\n    const bufferedBehind = presentationTime - startTime;\n\n    const overflow = bufferedBehind - bufferBehind;\n    // See: https://github.com/shaka-project/shaka-player/issues/2982\n    if (overflow <= 0.01) {\n      shaka.log.v2(logPrefix,\n          'buffer behind okay:',\n          'presentationTime=' + presentationTime,\n          'bufferedBehind=' + bufferedBehind,\n          'bufferBehind=' + bufferBehind,\n          'underflow=' + Math.abs(overflow));\n      return;\n    }\n\n    shaka.log.v1(logPrefix,\n        'buffer behind too large:',\n        'presentationTime=' + presentationTime,\n        'bufferedBehind=' + bufferedBehind,\n        'bufferBehind=' + bufferBehind,\n        'overflow=' + overflow);\n\n    await this.playerInterface_.mediaSourceEngine.remove(mediaState.type,\n        startTime, startTime + overflow);\n\n    this.destroyer_.ensureNotDestroyed();\n    shaka.log.v1(logPrefix, 'evicted ' + overflow + ' seconds');\n  }\n\n\n  /**\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @return {boolean}\n   * @private\n   */\n  static isEmbeddedText_(mediaState) {\n    const MimeUtils = shaka.util.MimeUtils;\n    const CEA608_MIME = MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE;\n    const CEA708_MIME = MimeUtils.CEA708_CLOSED_CAPTION_MIMETYPE;\n    return mediaState &&\n        mediaState.type == shaka.util.ManifestParserUtils.ContentType.TEXT &&\n        (mediaState.stream.mimeType == CEA608_MIME ||\n         mediaState.stream.mimeType == CEA708_MIME);\n  }\n\n\n  /**\n   * Fetches the given segment.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {(!shaka.media.InitSegmentReference|!shaka.media.SegmentReference)}\n   *   reference\n   * @param {?function(BufferSource):!Promise=} streamDataCallback\n   *\n   * @return {!Promise.<BufferSource>}\n   * @private\n   * @suppress {strictMissingProperties}\n   */\n  async fetch_(mediaState, reference, streamDataCallback) {\n    const requestType = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n    const request = shaka.util.Networking.createSegmentRequest(\n        reference.getUris(),\n        reference.startByte,\n        reference.endByte,\n        this.config_.retryParameters,\n        streamDataCallback);\n\n    shaka.log.v2('fetching: reference=', reference);\n\n    const stream = mediaState.stream;\n    this.playerInterface_.modifySegmentRequest(\n        request,\n        {\n          type: stream.type,\n          init: reference instanceof shaka.media.InitSegmentReference,\n          duration: reference.endTime - reference.startTime,\n          mimeType: stream.mimeType,\n          codecs: stream.codecs,\n          bandwidth: stream.bandwidth,\n        },\n    );\n\n    const op = this.playerInterface_.netEngine.request(requestType, request);\n    mediaState.operation = op;\n    const response = await op.promise;\n    mediaState.operation = null;\n    return response.data;\n  }\n\n\n  /**\n   * Clears the buffer and schedules another update.\n   * The optional parameter safeMargin allows to retain a certain amount\n   * of buffer, which can help avoiding rebuffering events.\n   * The value of the safe margin should be provided by the ABR manager.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {boolean} flush\n   * @param {number} safeMargin\n   * @private\n   */\n  async clearBuffer_(mediaState, flush, safeMargin) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    goog.asserts.assert(\n        !mediaState.performingUpdate && (mediaState.updateTimer == null),\n        logPrefix + ' unexpected call to clearBuffer_()');\n\n    mediaState.waitingToClearBuffer = false;\n    mediaState.waitingToFlushBuffer = false;\n    mediaState.clearBufferSafeMargin = 0;\n    mediaState.clearingBuffer = true;\n    mediaState.lastSegmentReference = null;\n    mediaState.lastInitSegmentReference = null;\n    mediaState.segmentIterator = null;\n\n    shaka.log.debug(logPrefix, 'clearing buffer');\n\n    if (safeMargin) {\n      const presentationTime = this.playerInterface_.getPresentationTime();\n      const duration = this.playerInterface_.mediaSourceEngine.getDuration();\n      await this.playerInterface_.mediaSourceEngine.remove(\n          mediaState.type, presentationTime + safeMargin, duration);\n    } else {\n      await this.playerInterface_.mediaSourceEngine.clear(mediaState.type);\n      this.destroyer_.ensureNotDestroyed();\n\n      if (flush) {\n        await this.playerInterface_.mediaSourceEngine.flush(\n            mediaState.type);\n      }\n    }\n    this.destroyer_.ensureNotDestroyed();\n\n    shaka.log.debug(logPrefix, 'cleared buffer');\n    mediaState.clearingBuffer = false;\n    mediaState.endOfStream = false;\n    // Since the clear operation was async, check to make sure we're not doing\n    // another update and we don't have one scheduled yet.\n    if (!mediaState.performingUpdate && !mediaState.updateTimer) {\n      this.scheduleUpdate_(mediaState, 0);\n    }\n  }\n\n\n  /**\n   * Schedules |mediaState|'s next update.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} delay The delay in seconds.\n   * @private\n   */\n  scheduleUpdate_(mediaState, delay) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    // If the text's update is canceled and its mediaState is deleted, stop\n    // scheduling another update.\n    const type = mediaState.type;\n    if (type == shaka.util.ManifestParserUtils.ContentType.TEXT &&\n          !this.mediaStates_.has(type)) {\n      shaka.log.v1(logPrefix, 'Text stream is unloaded. No update is needed.');\n      return;\n    }\n\n    shaka.log.v2(logPrefix, 'updating in ' + delay + ' seconds');\n    goog.asserts.assert(mediaState.updateTimer == null,\n        logPrefix + ' did not expect update to be scheduled');\n\n    mediaState.updateTimer = new shaka.util.DelayedTick(async () => {\n      try {\n        await this.onUpdate_(mediaState);\n      } catch (error) {\n        if (this.playerInterface_) {\n          this.playerInterface_.onError(error);\n        }\n      }\n    }).tickAfter(delay);\n  }\n\n\n  /**\n   * If |mediaState| is scheduled to update, stop it.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @private\n   */\n  cancelUpdate_(mediaState) {\n    if (mediaState.updateTimer == null) {\n      return;\n    }\n\n    mediaState.updateTimer.stop();\n    mediaState.updateTimer = null;\n  }\n\n\n  /**\n   * If |mediaState| holds any in-progress operations, abort them.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async abortOperations_(mediaState) {\n    if (mediaState.operation) {\n      await mediaState.operation.abort();\n    }\n  }\n\n  /**\n   * Handle streaming errors by delaying, then notifying the application by\n   * error callback and by streaming failure callback.\n   *\n   * @param {!shaka.util.Error} error\n   * @return {!Promise}\n   * @private\n   */\n  async handleStreamingError_(error) {\n    // If we invoke the callback right away, the application could trigger a\n    // rapid retry cycle that could be very unkind to the server.  Instead,\n    // use the backoff system to delay and backoff the error handling.\n    await this.failureCallbackBackoff_.attempt();\n    this.destroyer_.ensureNotDestroyed();\n\n    // First fire an error event.\n    this.playerInterface_.onError(error);\n\n    // If the error was not handled by the application, call the failure\n    // callback.\n    if (!error.handled) {\n      this.config_.failureCallback(error);\n    }\n  }\n\n  /**\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @return {string} A log prefix of the form ($CONTENT_TYPE:$STREAM_ID), e.g.,\n   *   \"(audio:5)\" or \"(video:hd)\".\n   * @private\n   */\n  static logPrefix_(mediaState) {\n    return '(' + mediaState.type + ':' + mediaState.stream.id + ')';\n  }\n};\n\n\n/**\n * @typedef {{\n *   getPresentationTime: function():number,\n *   getBandwidthEstimate: function():number,\n *   modifySegmentRequest: function(shaka.extern.Request,\n *     shaka.util.CmcdManager.SegmentInfo),\n *   mediaSourceEngine: !shaka.media.MediaSourceEngine,\n *   netEngine: shaka.net.NetworkingEngine,\n *   onError: function(!shaka.util.Error),\n *   onEvent: function(!Event),\n *   onManifestUpdate: function(),\n *   onSegmentAppended: function(),\n *   onInitSegmentAppended: function(!number,!shaka.media.InitSegmentReference)\n * }}\n *\n * @property {function():number} getPresentationTime\n *   Get the position in the presentation (in seconds) of the content that the\n *   viewer is seeing on screen right now.\n * @property {function():number} getBandwidthEstimate\n *   Get the estimated bandwidth in bits per second.\n * @property {function(shaka.extern.Request,\n *   shaka.extern.Cmcd.SegmentInfo)} modifySegmentRequest\n *   The request modifier\n * @property {!shaka.media.MediaSourceEngine} mediaSourceEngine\n *   The MediaSourceEngine. The caller retains ownership.\n * @property {shaka.net.NetworkingEngine} netEngine\n *   The NetworkingEngine instance to use. The caller retains ownership.\n * @property {function(!shaka.util.Error)} onError\n *   Called when an error occurs. If the error is recoverable (see\n *   {@link shaka.util.Error}) then the caller may invoke either\n *   StreamingEngine.switch*() or StreamingEngine.seeked() to attempt recovery.\n * @property {function(!Event)} onEvent\n *   Called when an event occurs that should be sent to the app.\n * @property {function()} onManifestUpdate\n *   Called when an embedded 'emsg' box should trigger a manifest update.\n * @property {function()} onSegmentAppended\n *   Called after a segment is successfully appended to a MediaSource.\n * @property\n *  {function(!number, !shaka.media.InitSegmentReference)} onInitSegmentAppended\n *   Called when an init segment is appended to a MediaSource.\n */\nshaka.media.StreamingEngine.PlayerInterface;\n\n\n/**\n * @typedef {{\n *   type: shaka.util.ManifestParserUtils.ContentType,\n *   stream: shaka.extern.Stream,\n *   segmentIterator: shaka.media.SegmentIterator,\n *   lastSegmentReference: shaka.media.SegmentReference,\n *   lastInitSegmentReference: shaka.media.InitSegmentReference,\n *   lastTimestampOffset: ?number,\n *   lastAppendWindowStart: ?number,\n *   lastAppendWindowEnd: ?number,\n *   restoreStreamAfterTrickPlay: ?shaka.extern.Stream,\n *   endOfStream: boolean,\n *   performingUpdate: boolean,\n *   updateTimer: shaka.util.DelayedTick,\n *   waitingToClearBuffer: boolean,\n *   waitingToFlushBuffer: boolean,\n *   clearBufferSafeMargin: number,\n *   clearingBuffer: boolean,\n *   recovering: boolean,\n *   hasError: boolean,\n *   operation: shaka.net.NetworkingEngine.PendingRequest\n * }}\n *\n * @description\n * Contains the state of a logical stream, i.e., a sequence of segmented data\n * for a particular content type. At any given time there is a Stream object\n * associated with the state of the logical stream.\n *\n * @property {shaka.util.ManifestParserUtils.ContentType} type\n *   The stream's content type, e.g., 'audio', 'video', or 'text'.\n * @property {shaka.extern.Stream} stream\n *   The current Stream.\n * @property {shaka.media.SegmentIndexIterator} segmentIterator\n *   An iterator through the segments of |stream|.\n * @property {shaka.media.SegmentReference} lastSegmentReference\n *   The SegmentReference of the last segment that was appended.\n * @property {shaka.media.InitSegmentReference} lastInitSegmentReference\n *   The InitSegmentReference of the last init segment that was appended.\n * @property {?number} lastTimestampOffset\n *   The last timestamp offset given to MediaSourceEngine for this type.\n * @property {?number} lastAppendWindowStart\n *   The last append window start given to MediaSourceEngine for this type.\n * @property {?number} lastAppendWindowEnd\n *   The last append window end given to MediaSourceEngine for this type.\n * @property {?shaka.extern.Stream} restoreStreamAfterTrickPlay\n *   The Stream to restore after trick play mode is turned off.\n * @property {boolean} endOfStream\n *   True indicates that the end of the buffer has hit the end of the\n *   presentation.\n * @property {boolean} performingUpdate\n *   True indicates that an update is in progress.\n * @property {shaka.util.DelayedTick} updateTimer\n *   A timer used to update the media state.\n * @property {boolean} waitingToClearBuffer\n *   True indicates that the buffer must be cleared after the current update\n *   finishes.\n * @property {boolean} waitingToFlushBuffer\n *   True indicates that the buffer must be flushed after it is cleared.\n * @property {number} clearBufferSafeMargin\n *   The amount of buffer to retain when clearing the buffer after the update.\n * @property {boolean} clearingBuffer\n *   True indicates that the buffer is being cleared.\n * @property {boolean} recovering\n *   True indicates that the last segment was not appended because it could not\n *   fit in the buffer.\n * @property {boolean} hasError\n *   True indicates that the stream has encountered an error and has stopped\n *   updating.\n * @property {shaka.net.NetworkingEngine.PendingRequest} operation\n *   Operation with the number of bytes to be downloaded.\n */\nshaka.media.StreamingEngine.MediaState_;\n\n\n/**\n * The fudge factor for appendWindowStart.  By adjusting the window backward, we\n * avoid rounding errors that could cause us to remove the keyframe at the start\n * of the Period.\n *\n * NOTE: This was increased as part of the solution to\n * https://github.com/shaka-project/shaka-player/issues/1281\n *\n * @const {number}\n * @private\n */\nshaka.media.StreamingEngine.APPEND_WINDOW_START_FUDGE_ = 0.1;\n\n\n/**\n * The fudge factor for appendWindowEnd.  By adjusting the window backward, we\n * avoid rounding errors that could cause us to remove the last few samples of\n * the Period.  This rounding error could then create an artificial gap and a\n * stutter when the gap-jumping logic takes over.\n *\n * https://github.com/shaka-project/shaka-player/issues/1597\n *\n * @const {number}\n * @private\n */\nshaka.media.StreamingEngine.APPEND_WINDOW_END_FUDGE_ = 0.01;\n\n\n/**\n * The maximum number of segments by which a stream can get ahead of other\n * streams.\n *\n * Introduced to keep StreamingEngine from letting one media type get too far\n * ahead of another.  For example, audio segments are typically much smaller\n * than video segments, so in the time it takes to fetch one video segment, we\n * could fetch many audio segments.  This doesn't help with buffering, though,\n * since the intersection of the two buffered ranges is what counts.\n *\n * @const {number}\n * @private\n */\nshaka.media.StreamingEngine.MAX_RUN_AHEAD_SEGMENTS_ = 1;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.routing.Walker');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.routing.Node');\ngoog.require('shaka.routing.Payload');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.PublicPromise');\ngoog.requireType('shaka.util.AbortableOperation');\n\n\n/**\n * The walker moves through a graph node-by-node executing asynchronous work\n * as it enters each node.\n *\n * The walker accepts requests for where it should go next. Requests are queued\n * and executed in FIFO order. If the current request can be interrupted, it\n * will be cancelled and the next request started.\n *\n * A request says \"I want to change where we are going\". When the walker is\n * ready to change destinations, it will resolve the request, allowing the\n * destination to differ based on the current state and not the state when\n * the request was appended.\n *\n * Example (from shaka.Player):\n *  When we unload, we need to either go to the attached or detached state based\n *  on whether or not we have a video element.\n *\n *  When we are asked to unload, we don't know what other pending requests may\n *  be ahead of us (there could be attach requests or detach requests). We need\n *  to wait until its our turn to know if:\n *    - we should go to the attach state because we have a media element\n *    - we should go to the detach state because we don't have a media element\n *\n * The walker allows the caller to specify if a route can or cannot be\n * interrupted. This is to allow potentially dependent routes to wait until\n * other routes have finished.\n *\n * Example (from shaka.Player):\n *  A request to load content depends on an attach request finishing. We don't\n *  want load request to interrupt an attach request. By marking the attach\n *  request as non-interruptible we ensure that calling load before attach\n *  finishes will work.\n *\n * @implements {shaka.util.IDestroyable}\n * @final\n */\nshaka.routing.Walker = class {\n  /**\n   * Create a new walker that starts at |startingAt| and with |startingWith|.\n   * The instance of |startingWith| will be the one that the walker holds and\n   * uses for its life. No one else should reference it.\n   *\n   * The per-instance behaviour for the walker is provided via |implementation|\n   * which is used to connect this walker with the \"outside world\".\n   *\n   * @param {shaka.routing.Node} startingAt\n   * @param {shaka.routing.Payload} startingWith\n   * @param {shaka.routing.Walker.Implementation} implementation\n   */\n  constructor(startingAt, startingWith, implementation) {\n    /** @private {?shaka.routing.Walker.Implementation} */\n    this.implementation_ = implementation;\n\n    /** @private {shaka.routing.Node} */\n    this.currentlyAt_ = startingAt;\n\n    /** @private {shaka.routing.Payload} */\n    this.currentlyWith_ = startingWith;\n\n    /**\n     * When we run out of work to do, we will set this promise so that when\n     * new work is added (and this is not null) it can be resolved. The only\n     * time when this should be non-null is when we are waiting for more work.\n     *\n     * @private {?shaka.util.PublicPromise}\n     */\n    this.waitForWork_ = null;\n\n    /** @private {!Array.<shaka.routing.Walker.Request_>} */\n    this.requests_ = [];\n\n    /** @private {?shaka.routing.Walker.ActiveRoute_} */\n    this.currentRoute_ = null;\n\n    /** @private {?shaka.util.AbortableOperation} */\n    this.currentStep_ = null;\n\n    /**\n     * Hold a reference to the main loop's promise so that we know when it has\n     * exited. This will determine when |destroy| can resolve. Purposely make\n     * the main loop start next interpreter cycle so that the constructor will\n     * finish before it starts.\n     *\n     * @private {!Promise}\n     */\n    this.mainLoopPromise_ = Promise.resolve().then(() => this.mainLoop_());\n\n    /** @private {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(() => this.doDestroy_());\n  }\n\n  /**\n   * Get the current routing payload.\n   *\n   * @return {shaka.routing.Payload}\n   */\n  getCurrentPayload() {\n    return this.currentlyWith_;\n  }\n\n  /** @override */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /** @private */\n  async doDestroy_() {\n    // If we are executing a current step, we want to interrupt it so that we\n    // can force the main loop to terminate.\n    if (this.currentStep_) {\n      this.currentStep_.abort();\n    }\n\n    // If we are waiting for more work, we want to wake-up the main loop so that\n    // it can exit on its own.\n    this.unblockMainLoop_();\n\n    // Wait for the main loop to terminate so that an async operation won't\n    // try and use state that we released.\n    await this.mainLoopPromise_;\n\n    // Any routes that we are not going to finish, we need to cancel. If we\n    // don't do this, those listening will be left hanging.\n    if (this.currentRoute_) {\n      this.currentRoute_.listeners.onCancel();\n    }\n    for (const request of this.requests_) {\n      request.listeners.onCancel();\n    }\n\n    // Release anything that could hold references to anything outside of this\n    // class.\n    this.currentRoute_ = null;\n    this.requests_ = [];\n    this.implementation_ = null;\n  }\n\n  /**\n   * Ask the walker to start a new route. When the walker is ready to start a\n   * new route, it will call |create| and |create| will provide the walker with\n   * a new route to execute.\n   *\n   * If any previous calls to |startNewRoute| created non-interruptible routes,\n   * |create| won't be called until all previous non-interruptible routes have\n   * finished.\n   *\n   * This method will return a collection of listeners that the caller can hook\n   * into. Any listener that the caller is interested should be assigned\n   * immediately after calling |startNewRoute| or else they could miss the event\n   * they want to listen for.\n   *\n   * @param {function(shaka.routing.Payload):?shaka.routing.Walker.Route} create\n   * @return {shaka.routing.Walker.Listeners}\n   */\n  startNewRoute(create) {\n    const listeners = {\n      onStart: () => {},\n      onEnd: () => {},\n      onCancel: () => {},\n      onError: (error) => {},\n      onSkip: () => {},\n      onEnter: () => {},\n    };\n\n    this.requests_.push({\n      create: create,\n      listeners: listeners,\n    });\n\n    // If we are in the middle of a step, try to abort it. If this is successful\n    // the main loop will error and the walker will enter recovery mode.\n    if (this.currentStep_) {\n      this.currentStep_.abort();\n    }\n\n    // Tell the main loop that new work is available. If the main loop was not\n    // blocked, this will be a no-op.\n    this.unblockMainLoop_();\n\n    return listeners;\n  }\n\n  /**\n   * @return {!Promise}\n   * @private\n   */\n  async mainLoop_() {\n    while (!this.destroyer_.destroyed()) {\n      // eslint-disable-next-line no-await-in-loop\n      await this.doOneThing_();\n    }\n  }\n\n  /**\n   * Do one thing to move the walker closer to its destination. This can be:\n   *   1. Starting a new route.\n   *   2. Taking one more step/finishing a route.\n   *   3. Wait for a new route.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  doOneThing_() {\n    if (this.tryNewRoute_()) {\n      return Promise.resolve();\n    }\n\n    if (this.currentRoute_) {\n      return this.takeNextStep_();\n    }\n\n    goog.asserts.assert(this.waitForWork_ == null,\n        'We should not have a promise yet.');\n\n    // We have no more work to do. We will wait until new work has been provided\n    // via request route or until we are destroyed.\n\n    this.implementation_.onIdle(this.currentlyAt_);\n\n    // Wait on a new promise so that we can be resolved by |waitForWork|. This\n    // avoids us acting like a busy-wait.\n    this.waitForWork_ = new shaka.util.PublicPromise();\n    return this.waitForWork_;\n  }\n\n  /**\n   * Check if the walker can start a new route. There are a couple ways this can\n   * happen:\n   *  1. We have a new request but no current route\n   *  2. We have a new request and our current route can be interrupted\n   *\n   * @return {boolean}\n   *    |true| when a new route was started (regardless of reason) and |false|\n   *    when no new route was started.\n   *\n   * @private\n   */\n  tryNewRoute_() {\n    goog.asserts.assert(\n        this.currentStep_ == null,\n        'We should never have a current step between taking steps.');\n\n    if (this.requests_.length == 0) {\n      return false;\n    }\n\n    // If the current route cannot be interrupted, we can't start a new route.\n    if (this.currentRoute_ && !this.currentRoute_.interruptible) {\n      return false;\n    }\n\n    // Stop any previously active routes. Even if we don't pick-up a new route,\n    // this route should stop.\n    if (this.currentRoute_) {\n      this.currentRoute_.listeners.onCancel();\n      this.currentRoute_ = null;\n    }\n\n    // Create and start the next route. We may not take any steps because it may\n    // be interrupted by the next request.\n    const request = this.requests_.shift();\n    const newRoute = request.create(this.currentlyWith_);\n\n    // Based on the current state of |payload|, a new route may not be\n    // possible. In these cases |create| will return |null| to signal that\n    // we should just stop the current route and move onto the next request\n    // (in the next main loop iteration).\n    if (newRoute) {\n      request.listeners.onStart();\n\n      // Convert the route created from the request's create method to an\n      // active route.\n      this.currentRoute_ = {\n        node: newRoute.node,\n        payload: newRoute.payload,\n        interruptible: newRoute.interruptible,\n        listeners: request.listeners,\n      };\n    } else {\n      request.listeners.onSkip();\n    }\n\n    return true;\n  }\n\n\n  /**\n   * Move forward one step on our current route. This assumes that we have a\n   * current route. A couple things can happen when moving forward:\n   *  1. An error - if an error occurs, it will signal an error occurred,\n   *     attempt to recover, and drop the route.\n   *  2. Move - if no error occurs, we will move forward. When we arrive at\n   *     our destination, it will signal the end and drop the route.\n   *\n   * In the event of an error or arriving at the destination, we drop the\n   * current route. This allows us to pick-up a new route next time the main\n   * loop iterates.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async takeNextStep_() {\n    goog.asserts.assert(\n        this.currentRoute_,\n        'We need a current route to take the next step.');\n\n    // Figure out where we are supposed to go next.\n    this.currentlyAt_ = this.implementation_.getNext(\n        this.currentlyAt_,\n        this.currentlyWith_,\n        this.currentRoute_.node,\n        this.currentRoute_.payload);\n\n    this.currentRoute_.listeners.onEnter(this.currentlyAt_);\n\n    // Enter the new node, this is where things can go wrong since it is\n    // possible for \"supported errors\" to occur - errors that the code using\n    // the walker can't predict but can recover from.\n    try {\n      // TODO: This is probably a false-positive.  See eslint/eslint#11687.\n      // eslint-disable-next-line require-atomic-updates\n      this.currentStep_ = this.implementation_.enterNode(\n          /* node= */ this.currentlyAt_,\n          /* has= */ this.currentlyWith_,\n          /* wants= */ this.currentRoute_.payload);\n\n      await this.currentStep_.promise;\n      this.currentStep_ = null;\n\n      // If we are at the end of the route, we need to signal it and clear the\n      // route so that we will pick-up a new route next iteration.\n      if (this.currentlyAt_ == this.currentRoute_.node) {\n        this.currentRoute_.listeners.onEnd();\n        this.currentRoute_ = null;\n      }\n    } catch (error) {\n      if (error.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n        goog.asserts.assert(\n            this.currentRoute_.interruptible,\n            'Do not put abortable steps in non-interruptible routes!');\n        this.currentRoute_.listeners.onCancel();\n      } else {\n        // There was an error with this route, so we going to abandon it and\n        // resolve the error. We don't reset the payload because the payload may\n        // still contain useful information.\n        this.currentRoute_.listeners.onError(error);\n      }\n\n      // The route and step are done. Clear them before we handle the error or\n      // else we may attempt to abort |currentStep_| when handling the error.\n      this.currentRoute_ = null;\n      this.currentStep_ = null;\n\n      // Still need to handle error because aborting an operation could leave us\n      // in an unexpected state.\n      this.currentlyAt_ = await this.implementation_.handleError(\n          this.currentlyWith_,\n          error);\n    }\n  }\n\n  /**\n   * If the main loop is blocked waiting for new work, then resolve the promise\n   * so that the next iteration of the main loop can execute.\n   *\n   * @private\n   */\n  unblockMainLoop_() {\n    if (this.waitForWork_) {\n      this.waitForWork_.resolve();\n      this.waitForWork_ = null;\n    }\n  }\n};\n\n/**\n * @typedef {{\n *   getNext: function(\n *       shaka.routing.Node,\n *       shaka.routing.Payload,\n *       shaka.routing.Node,\n *       shaka.routing.Payload):shaka.routing.Node,\n *   enterNode: function(\n *       shaka.routing.Node,\n *       shaka.routing.Payload,\n *       shaka.routing.Payload):!shaka.util.AbortableOperation,\n *   handleError: function(\n *       shaka.routing.Payload,\n *       !Error):!Promise.<shaka.routing.Node>,\n *   onIdle: function(shaka.routing.Node)\n * }}\n *\n * @description\n *   There are some parts of the walker that will be per-instance. This type\n *   provides those per-instance parts.\n *\n * @property {function(\n *     shaka.routing.Node,\n *     shaka.routing.Payload,\n *     shaka.routing.Node,\n *     shaka.routing.Payload):shaka.routing.Node getNext\n *   Get the next node that the walker should move to. This method will be\n *   passed (in this order) the current node, current payload, destination\n *   node, and destination payload.\n *\n * @property {function(\n *     shaka.routing.Node,\n *     shaka.routing.Payload,\n *     shaka.routing.Payload):!Promise} enterNode\n *   When the walker moves into a node, it will call |enterNode| and allow the\n *   implementation to change the current payload. This method will be passed\n *   (in this order) the node the walker is entering, the current payload, and\n *   the destination payload. This method should NOT modify the destination\n *   payload.\n *\n * @property {function(\n *     shaka.routing.Payload,\n *     !Error):!Promise.<shaka.routing.Node> handleError\n *   This is the callback for when |enterNode| fails. It is passed the current\n *   payload and the error. If a step is aborted, the error will be\n *   OPERATION_ABORTED. It should reset all external dependences, modify the\n *   payload, and return the new current node. Calls to |handleError| should\n *   always resolve and the walker should always be able to continue operating.\n *\n * @property {function(shaka.routing.Node)} onIdle\n *   This is the callback for when the walker has finished processing all route\n *   requests and needs to wait for more work. |onIdle| will be passed the\n *   current node.  After |onIdle| has been called, the walker will block until\n *   a new request is made, or the walker is destroyed.\n */\nshaka.routing.Walker.Implementation;\n\n/**\n * @typedef {{\n *   onStart: function(),\n *   onEnd: function(),\n *   onCancel: function(),\n *   onError: function(!Error),\n *   onSkip: function(),\n *   onEnter: function(shaka.routing.Node)\n * }}\n *\n * @description\n *   The collection of callbacks that the walker will call while executing a\n *   route. By setting these immediately after calling |startNewRoute|\n *   the user can react to route-specific events.\n *\n * @property {function()} onStart\n *   The callback for when the walker has accepted the route and will soon take\n *   the first step unless interrupted. Either |onStart| or |onSkip| will be\n *   called.\n *\n * @property {function()} onEnd\n *   The callback for when the walker has reached the end of the route. For\n *   every route that had |onStart| called, either |onEnd|, |onCancel|, or\n *   |onError| will be called.\n *\n * @property {function()} onCancel\n *   The callback for when the walker is stopping a route before getting to the\n *   end. This will be called either when a new route is interrupting the route,\n *   or the walker is being destroyed mid-route. |onCancel| will only be called\n *   when a route has been interrupted by another route or the walker is being\n *   destroyed.\n *\n * @property {function()} onError\n *   The callback for when the walker failed to execute the route because an\n *   unexpected error occurred. The walker will enter a recovery mode and the\n *   route will be abandoned.\n *\n * @property {function()} onSkip\n *   The callback for when the walker was ready to start the route, but the\n *   create-method returned |null|.\n *\n * @property {function()} onEnter\n *   The callback for when the walker enters a node. This will allow us to\n *   track the progress of the walker within a per-route scope.\n */\nshaka.routing.Walker.Listeners;\n\n/**\n * @typedef {{\n *   node: shaka.routing.Node,\n *   payload: shaka.routing.Payload,\n *   interruptible: boolean\n * }}\n *\n * @description\n *   The public description of where the walker should go. This is created\n *   when the callback given to |startNewRoute| is called by the walker.\n *\n * @property {shaka.routing.Node} node\n *   The node that the walker should move towards. This will be passed to\n *   |shaka.routing.Walker.Implementation.getNext| to help determine where to\n *   go next.\n *\n * @property {shaka.routing.Payload| payload\n *   The payload that the walker should have once it arrives at |node|. This\n *   will be passed to the |shaka.routing.Walker.Implementation.getNext| to\n *   help determine where to go next.\n *\n * @property {boolean} interruptible\n *   Whether or not this route can be interrupted by another request. When\n *   |true| this route will be interrupted so that a pending request can be\n *   resolved. When |false|, the route will be allowed to finished before\n *   resolving the next request.\n */\nshaka.routing.Walker.Route;\n\n/**\n * @typedef {{\n *   node: shaka.routing.Node,\n *   payload: shaka.routing.Payload,\n *   interruptible: boolean,\n *   listeners: shaka.routing.Walker.Listeners\n * }}\n *\n * @description\n *   The active route is the walker's internal representation of a route. It\n *   is the union of |shaka.routing.Walker.Request_| and the\n *   |shaka.routing.Walker.Route| created by |shaka.routing.Walker.Request_|.\n *\n * @property {shaka.routing.Node} node\n *   The node that the walker should move towards. This will be passed to\n *   |shaka.routing.Walker.Implementation.getNext| to help determine where to\n *   go next.\n *\n * @property {shaka.routing.Payload| payload\n *   The payload that the walker should have once it arrives at |node|. This\n *   will be passed to the |shaka.routing.Walker.Implementation.getNext| to\n *   help determine where to go next.\n *\n * @property {boolean} interruptible\n *   Whether or not this route can be interrupted by another request. When\n *   |true| this route will be interrupted so that a pending request can be\n *   resolved. When |false|, the route will be allowed to finished before\n *   resolving the next request.\n *\n * @property {shaka.routing.Walker.Listeners} listeners\n *   The listeners that the walker can used to communicate with whoever\n *   requested the route.\n *\n * @private\n */\nshaka.routing.Walker.ActiveRoute_;\n\n/**\n * @typedef {{\n *   create: function(shaka.routing.Payload):?shaka.routing.Walker.Route,\n *   listeners: shaka.routing.Walker.Listeners\n * }}\n *\n * @description\n *   The request is how users can talk to the walker. They can give the walker\n *   a request and when the walker is ready, it will resolve the request by\n *   calling |create|.\n *\n * @property {\n *     function(shaka.routing.Payload):?shaka.routing.Walker.Route} create\n *   The function called when the walker is ready to start a new route. This can\n *   return |null| to say that the request was not possible and should be\n *   skipped.\n *\n * @property {shaka.routing.Walker.Listeners} listeners\n *   The collection of callbacks that the walker will use to talk to whoever\n *   provided the request.\n *\n * @private\n */\nshaka.routing.Walker.Request_;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview\n * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed\n */\n\ngoog.provide('shaka.text.SimpleTextDisplayer');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\n\n\n/**\n * A text displayer plugin using the browser's native VTTCue interface.\n *\n * @implements {shaka.extern.TextDisplayer}\n * @export\n */\nshaka.text.SimpleTextDisplayer = class {\n  /** @param {HTMLMediaElement} video */\n  constructor(video) {\n    /** @private {TextTrack} */\n    this.textTrack_ = null;\n\n    // TODO: Test that in all cases, the built-in CC controls in the video\n    // element are toggling our TextTrack.\n\n    // If the video element has TextTracks, disable them.  If we see one that\n    // was created by a previous instance of Shaka Player, reuse it.\n    for (const track of Array.from(video.textTracks)) {\n      // NOTE: There is no API available to remove a TextTrack from a video\n      // element.\n      track.mode = 'disabled';\n\n      if (track.label == shaka.Player.TextTrackLabel) {\n        this.textTrack_ = track;\n      }\n    }\n\n    if (!this.textTrack_) {\n      // As far as I can tell, there is no observable difference between setting\n      // kind to 'subtitles' or 'captions' when creating the TextTrack object.\n      // The individual text tracks from the manifest will still have their own\n      // kinds which can be displayed in the app's UI.\n      this.textTrack_ = video.addTextTrack(\n          'subtitles', shaka.Player.TextTrackLabel);\n    }\n    this.textTrack_.mode = 'hidden';\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  remove(start, end) {\n    // Check that the displayer hasn't been destroyed.\n    if (!this.textTrack_) {\n      return false;\n    }\n\n    const removeInRange = (cue) => {\n      const inside = cue.startTime < end && cue.endTime > start;\n      return inside;\n    };\n\n    shaka.text.SimpleTextDisplayer.removeWhere_(this.textTrack_, removeInRange);\n\n    return true;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  append(cues) {\n    // Flatten nested cue payloads recursively.  If a cue has nested cues,\n    // their contents should be combined and replace the payload of the parent.\n    const flattenPayload = (cue) => {\n      // Handle styles (currently bold/italics/underline).\n      // TODO add support for color rendering.\n      const openStyleTags = [];\n      const bold = cue.fontWeight >= shaka.text.Cue.fontWeight.BOLD;\n      const italics = cue.fontStyle == shaka.text.Cue.fontStyle.ITALIC;\n      const underline = cue.textDecoration.includes(\n          shaka.text.Cue.textDecoration.UNDERLINE);\n      if (bold) {\n        openStyleTags.push('b');\n      }\n      if (italics) {\n        openStyleTags.push('i');\n      }\n      if (underline) {\n        openStyleTags.push('u');\n      }\n\n      // Prefix opens tags, suffix closes tags in reverse order of opening.\n      const prefixStyleTags = openStyleTags.reduce((acc, tag) => {\n        return `${acc}<${tag}>`;\n      }, '');\n      const suffixStyleTags = openStyleTags.reduceRight((acc, tag) => {\n        return `${acc}</${tag}>`;\n      }, '');\n\n      if (cue.lineBreak || cue.spacer) {\n        if (cue.spacer) {\n          shaka.Deprecate.deprecateFeature(4,\n              'shaka.extern.Cue',\n              'Please use lineBreak instead of spacer.');\n        }\n        // This is a vertical lineBreak, so insert a newline.\n        return '\\n';\n      } else if (cue.nestedCues.length) {\n        return cue.nestedCues.map(flattenPayload).join('');\n      } else {\n        // This is a real cue.\n        return prefixStyleTags + cue.payload + suffixStyleTags;\n      }\n    };\n\n    // We don't want to modify the array or objects passed in, since we don't\n    // technically own them.  So we build a new array and replace certain items\n    // in it if they need to be flattened.\n    // We also don't want to flatten the text payloads starting at a container\n    // element; otherwise, for containers encapsulating multiple caption lines,\n    // the lines would merge into a single cue. This is undesirable when a\n    // subset of the captions are outside of the append time window. To fix\n    // this, we only call flattenPayload() starting at elements marked as\n    // isContainer = false.\n    const getCuesToFlatten = (cues, result) => {\n      for (const cue of cues) {\n        if (cue.isContainer) {\n          // Recurse to find the actual text payload cues.\n          getCuesToFlatten(cue.nestedCues, result);\n        } else {\n          // Flatten the payload.\n          const flatCue = cue.clone();\n          flatCue.nestedCues = [];\n          flatCue.payload = flattenPayload(cue);\n          result.push(flatCue);\n        }\n      }\n      return result;\n    };\n    const flattenedCues = getCuesToFlatten(cues, []);\n\n    // Convert cues.\n    const textTrackCues = [];\n    const cuesInTextTrack = this.textTrack_.cues ?\n                            Array.from(this.textTrack_.cues) : [];\n\n    for (const inCue of flattenedCues) {\n      // When a VTT cue spans a segment boundary, the cue will be duplicated\n      // into two segments.\n      // To avoid displaying duplicate cues, if the current textTrack cues\n      // list already contains the cue, skip it.\n      const containsCue = cuesInTextTrack.some((cueInTextTrack) => {\n        if (cueInTextTrack.startTime == inCue.startTime &&\n            cueInTextTrack.endTime == inCue.endTime &&\n            cueInTextTrack.text == inCue.payload) {\n          return true;\n        }\n        return false;\n      });\n\n      if (!containsCue) {\n        const cue =\n            shaka.text.SimpleTextDisplayer.convertToTextTrackCue_(inCue);\n        if (cue) {\n          textTrackCues.push(cue);\n        }\n      }\n    }\n\n    // Sort the cues based on start/end times.  Make a copy of the array so\n    // we can get the index in the original ordering.  Out of order cues are\n    // rejected by Edge.  See https://bit.ly/2K9VX3s\n    const sortedCues = textTrackCues.slice().sort((a, b) => {\n      if (a.startTime != b.startTime) {\n        return a.startTime - b.startTime;\n      } else if (a.endTime != b.endTime) {\n        return a.endTime - b.startTime;\n      } else {\n        // The browser will display cues with identical time ranges from the\n        // bottom up.  Reversing the order of equal cues means the first one\n        // parsed will be at the top, as you would expect.\n        // See https://github.com/shaka-project/shaka-player/issues/848 for\n        // more info.\n        // However, this ordering behavior is part of VTTCue's \"line\" field.\n        // Some platforms don't have a real VTTCue and use a polyfill instead.\n        // When VTTCue is polyfilled or does not support \"line\", we should _not_\n        // reverse the order.  This occurs on legacy Edge.\n        // eslint-disable-next-line no-restricted-syntax\n        if ('line' in VTTCue.prototype) {\n          // Native VTTCue\n          return textTrackCues.indexOf(b) - textTrackCues.indexOf(a);\n        } else {\n          // Polyfilled VTTCue\n          return textTrackCues.indexOf(a) - textTrackCues.indexOf(b);\n        }\n      }\n    });\n\n    for (const cue of sortedCues) {\n      this.textTrack_.addCue(cue);\n    }\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  destroy() {\n    if (this.textTrack_) {\n      const removeIt = (cue) => true;\n      shaka.text.SimpleTextDisplayer.removeWhere_(this.textTrack_, removeIt);\n\n      // NOTE: There is no API available to remove a TextTrack from a video\n      // element.\n      this.textTrack_.mode = 'disabled';\n    }\n\n    this.textTrack_ = null;\n    return Promise.resolve();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isTextVisible() {\n    return this.textTrack_.mode == 'showing';\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setTextVisibility(on) {\n    this.textTrack_.mode = on ? 'showing' : 'hidden';\n  }\n\n  /**\n   * @param {!shaka.extern.Cue} shakaCue\n   * @return {TextTrackCue}\n   * @private\n   */\n  static convertToTextTrackCue_(shakaCue) {\n    if (shakaCue.startTime >= shakaCue.endTime) {\n      // Edge will throw in this case.\n      // See issue #501\n      shaka.log.warning('Invalid cue times: ' + shakaCue.startTime +\n                        ' - ' + shakaCue.endTime);\n      return null;\n    }\n\n    const Cue = shaka.text.Cue;\n    /** @type {VTTCue} */\n    const vttCue = new VTTCue(\n        shakaCue.startTime,\n        shakaCue.endTime,\n        shakaCue.payload);\n\n    // NOTE: positionAlign and lineAlign settings are not supported by Chrome\n    // at the moment, so setting them will have no effect.\n    // The bug on chromium to implement them:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=633690\n\n    vttCue.lineAlign = shakaCue.lineAlign;\n    vttCue.positionAlign = shakaCue.positionAlign;\n    if (shakaCue.size) {\n      vttCue.size = shakaCue.size;\n    }\n\n    try {\n      // Safari 10 seems to throw on align='center'.\n      vttCue.align = shakaCue.textAlign;\n    } catch (exception) {}\n\n    if (shakaCue.textAlign == 'center' && vttCue.align != 'center') {\n      // We want vttCue.position = 'auto'. By default, |position| is set to\n      // \"auto\". If we set it to \"auto\" safari will throw an exception, so we\n      // must rely on the default value.\n      vttCue.align = 'middle';\n    }\n\n    if (shakaCue.writingMode ==\n            Cue.writingMode.VERTICAL_LEFT_TO_RIGHT) {\n      vttCue.vertical = 'lr';\n    } else if (shakaCue.writingMode ==\n             Cue.writingMode.VERTICAL_RIGHT_TO_LEFT) {\n      vttCue.vertical = 'rl';\n    }\n\n    // snapToLines flag is true by default\n    if (shakaCue.lineInterpretation == Cue.lineInterpretation.PERCENTAGE) {\n      vttCue.snapToLines = false;\n    }\n\n    if (shakaCue.line != null) {\n      vttCue.line = shakaCue.line;\n    }\n\n    if (shakaCue.position != null) {\n      vttCue.position = shakaCue.position;\n    }\n\n    return vttCue;\n  }\n\n  /**\n   * Iterate over all the cues in a text track and remove all those for which\n   * |predicate(cue)| returns true.\n   *\n   * @param {!TextTrack} track\n   * @param {function(!TextTrackCue):boolean} predicate\n   * @private\n   */\n  static removeWhere_(track, predicate) {\n    // Since |track.cues| can be null if |track.mode| is \"disabled\", force it to\n    // something other than \"disabled\".\n    //\n    // If the track is already showing, then we should keep it as showing. But\n    // if it something else, we will use hidden so that we don't \"flash\" cues on\n    // the screen.\n    const oldState = track.mode;\n    const tempState = oldState == 'showing' ? 'showing' : 'hidden';\n\n    track.mode = tempState;\n\n    goog.asserts.assert(\n        track.cues,\n        'Cues should be accessible when mode is set to \"' + tempState + '\".');\n\n    // Create a copy of the list to avoid errors while iterating.\n    for (const cue of Array.from(track.cues)) {\n      if (cue && predicate(cue)) {\n        track.removeCue(cue);\n      }\n    }\n\n    track.mode = oldState;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.util.Dom');\n\ngoog.require('goog.asserts');\n\n\n// TODO: revisit this when Closure Compiler supports partially-exported classes.\n/** @export */\nshaka.util.Dom = class {\n  /**\n   * Creates an element, and cast the type from Element to HTMLElement.\n   *\n   * @param {string} tagName\n   * @return {!HTMLElement}\n   */\n  static createHTMLElement(tagName) {\n    const element =\n      /** @type {!HTMLElement} */ (document.createElement(tagName));\n    return element;\n  }\n\n\n  /**\n   * Create a \"button\" element with the correct type.\n   *\n   * The compiler is very picky about the use of the \"disabled\" property on\n   * HTMLElement, since it is only defined on certain subclasses of that.  This\n   * method merely creates a button and casts it to the correct type.\n   *\n   * @return {!HTMLButtonElement}\n   */\n  static createButton() {\n    const button = document.createElement('button');\n    button.setAttribute('type', 'button');\n    return /** @type {!HTMLButtonElement} */ (button);\n  }\n\n\n  /**\n   * Cast a Node/Element to an HTMLElement\n   *\n   * @param {!Node|!Element} original\n   * @return {!HTMLElement}\n   */\n  static asHTMLElement(original) {\n    return /** @type {!HTMLElement}*/ (original);\n  }\n\n\n  /**\n   * Cast a Node/Element to an HTMLMediaElement\n   *\n   * @param {!Node|!Element} original\n   * @return {!HTMLMediaElement}\n   */\n  static asHTMLMediaElement(original) {\n    return /** @type {!HTMLMediaElement}*/ (original);\n  }\n\n\n  /**\n   * Returns the element with a given class name.\n   * Assumes the class name to be unique for a given parent.\n   *\n   * @param {string} className\n   * @param {!HTMLElement} parent\n   * @return {!HTMLElement}\n   */\n  static getElementByClassName(className, parent) {\n    const elements = parent.getElementsByClassName(className);\n    goog.asserts.assert(elements.length == 1,\n        'Should only be one element with class name ' + className);\n\n    return shaka.util.Dom.asHTMLElement(elements[0]);\n  }\n\n\n  /**\n   * Remove all of the child nodes of an element.\n   * @param {!Element} element\n   * @export\n   */\n  static removeAllChildren(element) {\n    while (element.firstChild) {\n      element.removeChild(element.firstChild);\n    }\n  }\n};\n\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.text.UITextDisplayer');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.CueRegion');\ngoog.require('shaka.util.Dom');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * The text displayer plugin for the Shaka Player UI.  Can also be used directly\n * by providing an appropriate container element.\n *\n * @implements {shaka.extern.TextDisplayer}\n * @final\n * @export\n */\nshaka.text.UITextDisplayer = class {\n  /**\n   * Constructor.\n   * @param {HTMLMediaElement} video\n   * @param {HTMLElement} videoContainer\n   */\n  constructor(video, videoContainer) {\n    goog.asserts.assert(videoContainer, 'videoContainer should be valid.');\n\n    /** @private {boolean} */\n    this.isTextVisible_ = false;\n\n    /** @private {!Array.<!shaka.text.Cue>} */\n    this.cues_ = [];\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {HTMLElement} */\n    this.videoContainer_ = videoContainer;\n\n    /** @type {HTMLElement} */\n    this.textContainer_ = shaka.util.Dom.createHTMLElement('div');\n    this.textContainer_.classList.add('shaka-text-container');\n\n    // Set the subtitles text-centered by default.\n    this.textContainer_.style.textAlign = 'center';\n\n    // Set the captions in the middle horizontally by default.\n    this.textContainer_.style.display = 'flex';\n    this.textContainer_.style.flexDirection = 'column';\n    this.textContainer_.style.alignItems = 'center';\n\n    // Set the captions at the bottom by default.\n    this.textContainer_.style.justifyContent = 'flex-end';\n\n    this.videoContainer_.appendChild(this.textContainer_);\n\n    /**\n     * The captions' update period in seconds.\n     * @private {number}\n     */\n    const updatePeriod = 0.25;\n\n    /** @private {shaka.util.Timer} */\n    this.captionsTimer_ = new shaka.util.Timer(() => {\n      this.updateCaptions_();\n    }).tickEvery(updatePeriod);\n\n    /**\n     * Maps cues to cue elements. Specifically points out the wrapper element of\n     * the cue (e.g. the HTML element to put nested cues inside).\n     * @private {Map.<!shaka.extern.Cue, !{\n     *   cueElement: !HTMLElement,\n     *   regionElement: HTMLElement,\n     *   wrapper: !HTMLElement\n     * }>}\n     */\n    this.currentCuesMap_ = new Map();\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    this.eventManager_.listen(document, 'fullscreenchange', () => {\n      this.updateCaptions_(/* forceUpdate= */ true);\n    });\n\n    /** @private {ResizeObserver} */\n    this.resizeObserver_ = null;\n    if ('ResizeObserver' in window) {\n      this.resizeObserver_ = new ResizeObserver(() => {\n        this.updateCaptions_(/* forceUpdate= */ true);\n      });\n      this.resizeObserver_.observe(this.textContainer_);\n    }\n\n    /** @private {Map.<string, !HTMLElement>} */\n    this.regionElements_ = new Map();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  append(cues) {\n    // Clone the cues list for performace optimization. We can avoid the cues\n    // list growing during the comparisons for duplicate cues.\n    // See: https://github.com/shaka-project/shaka-player/issues/3018\n    const cuesList = [...this.cues_];\n    for (const cue of cues) {\n      // When a VTT cue spans a segment boundary, the cue will be duplicated\n      // into two segments.\n      // To avoid displaying duplicate cues, if the current cue list already\n      // contains the cue, skip it.\n      const containsCue = cuesList.some(\n          (cueInList) => shaka.text.Cue.equal(cueInList, cue));\n      if (!containsCue) {\n        this.cues_.push(cue);\n      }\n    }\n\n    this.updateCaptions_();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  destroy() {\n    // Remove the text container element from the UI.\n    this.videoContainer_.removeChild(this.textContainer_);\n    this.textContainer_ = null;\n\n    this.isTextVisible_ = false;\n    this.cues_ = [];\n    if (this.captionsTimer_) {\n      this.captionsTimer_.stop();\n    }\n\n    this.currentCuesMap_.clear();\n\n    // Tear-down the event manager to ensure messages stop moving around.\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    if (this.resizeObserver_) {\n      this.resizeObserver_.disconnect();\n      this.resizeObserver_ = null;\n    }\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  remove(start, end) {\n    // Return false if destroy() has been called.\n    if (!this.textContainer_) {\n      return false;\n    }\n\n    // Remove the cues out of the time range.\n    const oldNumCues = this.cues_.length;\n    this.cues_ = this.cues_.filter(\n        (cue) => cue.startTime < start || cue.endTime >= end);\n    // If anything was actually removed in this process, force the captions to\n    // update. This makes sure that the currently-displayed cues will stop\n    // displaying if removed (say, due to the user changing languages).\n    const forceUpdate = oldNumCues > this.cues_.length;\n    this.updateCaptions_(forceUpdate);\n\n    return true;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  isTextVisible() {\n    return this.isTextVisible_;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setTextVisibility(on) {\n    this.isTextVisible_ = on;\n  }\n\n  /**\n   * @private\n   */\n  isElementUnderTextContainer_(elemToCheck) {\n    while (elemToCheck != null) {\n      if (elemToCheck == this.textContainer_) {\n        return true;\n      }\n      elemToCheck = elemToCheck.parentElement;\n    }\n    return false;\n  }\n\n  /**\n   * @param {!Array.<!shaka.extern.Cue>} cues\n   * @param {!HTMLElement} container\n   * @param {number} currentTime\n   * @param {!Array.<!shaka.extern.Cue>} parents\n   * @private\n   */\n  updateCuesRecursive_(cues, container, currentTime, parents) {\n    // Set to true if the cues have changed in some way, which will require\n    // DOM changes. E.g. if a cue was added or removed.\n    let updateDOM = false;\n    /**\n     * The elements to remove from the DOM.\n     * Some of these elements may be added back again, if their corresponding\n     * cue is in toPlant.\n     * These elements are only removed if updateDOM is true.\n     * @type {!Array.<!HTMLElement>}\n     */\n    const toUproot = [];\n    /**\n     * The cues whose corresponding elements should be in the DOM.\n     * Some of these might be new, some might have been displayed beforehand.\n     * These will only be added if updateDOM is true.\n     * @type {!Array.<!shaka.extern.Cue>}\n     */\n    const toPlant = [];\n    for (const cue of cues) {\n      parents.push(cue);\n\n      let cueRegistry = this.currentCuesMap_.get(cue);\n      const shouldBeDisplayed =\n          cue.startTime <= currentTime && cue.endTime > currentTime;\n      let wrapper = cueRegistry ? cueRegistry.wrapper : null;\n\n      if (cueRegistry) {\n        // If the cues are replanted, all existing cues should be uprooted,\n        // even ones which are going to be planted again.\n        toUproot.push(cueRegistry.cueElement);\n\n        // Also uproot all displayed region elements.\n        if (cueRegistry.regionElement) {\n          toUproot.push(cueRegistry.regionElement);\n        }\n\n        // If the cue should not be displayed, remove it entirely.\n        if (!shouldBeDisplayed) {\n          // Since something has to be removed, we will need to update the DOM.\n          updateDOM = true;\n          this.currentCuesMap_.delete(cue);\n          cueRegistry = null;\n        }\n      }\n\n      if (shouldBeDisplayed) {\n        toPlant.push(cue);\n        if (!cueRegistry) {\n          // The cue has to be made!\n          this.createCue_(cue, parents);\n          cueRegistry = this.currentCuesMap_.get(cue);\n          wrapper = cueRegistry.wrapper;\n          updateDOM = true;\n        } else if (!this.isElementUnderTextContainer_(wrapper)) {\n          // We found that the wrapper needs to be in the DOM\n          updateDOM = true;\n        }\n      }\n\n      // Recursively check the nested cues, to see if they need to be added or\n      // removed.\n      // If wrapper is null, that means that the cue is not only not being\n      // displayed currently, it also was not removed this tick. So it's\n      // guaranteed that the children will neither need to be added nor removed.\n      if (cue.nestedCues.length > 0 && wrapper) {\n        this.updateCuesRecursive_(\n            cue.nestedCues, wrapper, currentTime, parents);\n      }\n\n      const topCue = parents.pop();\n      goog.asserts.assert(topCue == cue, 'Parent cues should be kept in order');\n    }\n\n    if (updateDOM) {\n      for (const element of toUproot) {\n        // NOTE: Because we uproot shared region elements, too, we might hit an\n        // element here that has no parent because we've already processed it.\n        if (element.parentElement) {\n          element.parentElement.removeChild(element);\n        }\n      }\n      toPlant.sort((a, b) => {\n        if (a.startTime != b.startTime) {\n          return a.startTime - b.startTime;\n        } else {\n          return a.endTime - b.endTime;\n        }\n      });\n      for (const cue of toPlant) {\n        const cueRegistry = this.currentCuesMap_.get(cue);\n        goog.asserts.assert(cueRegistry, 'cueRegistry should exist.');\n        if (cueRegistry.regionElement) {\n          container.appendChild(cueRegistry.regionElement);\n          cueRegistry.regionElement.appendChild(cueRegistry.cueElement);\n        } else {\n          container.appendChild(cueRegistry.cueElement);\n        }\n      }\n    }\n  }\n\n  /**\n   * Display the current captions.\n   * @param {boolean=} forceUpdate\n   * @private\n   */\n  updateCaptions_(forceUpdate = false) {\n    if (!this.textContainer_) {\n      return;\n    }\n\n    const currentTime = this.video_.currentTime;\n    if (!this.isTextVisible_ || forceUpdate) {\n      // Remove child elements from all regions.\n      for (const regionElement of this.regionElements_.values()) {\n        shaka.util.Dom.removeAllChildren(regionElement);\n      }\n      // Remove all top-level elements in the text container.\n      shaka.util.Dom.removeAllChildren(this.textContainer_);\n      // Clear the element maps.\n      this.currentCuesMap_.clear();\n      this.regionElements_.clear();\n    }\n    if (this.isTextVisible_) {\n      // Log currently attached cue elements for verification, later.\n      const previousCuesMap = new Map();\n      for (const cue of this.currentCuesMap_.keys()) {\n        previousCuesMap.set(cue, this.currentCuesMap_.get(cue));\n      }\n\n      // Update the cues.\n      this.updateCuesRecursive_(\n          this.cues_, this.textContainer_, currentTime, /* parents= */ []);\n\n      if (goog.DEBUG) {\n        // Previously, we had an issue (#2076) where cues sometimes were not\n        // properly removed from the DOM. It is not clear if this issue still\n        // happens, so the previous fix for it has been changed to an assert.\n        for (const cue of previousCuesMap.keys()) {\n          if (!this.currentCuesMap_.has(cue)) {\n            // TODO: If the problem does not appear again, then we should remove\n            // this assert (and the previousCuesMap code) in Shaka v4.\n            const cueElement = previousCuesMap.get(cue).cueElement;\n            goog.asserts.assert(\n                !cueElement.parentNode, 'Cue was not properly removed!');\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Compute a unique internal id:\n   * Regions can reuse the id but have different dimensions, we need to\n   * consider those differences\n   * @param {shaka.extern.CueRegion} region\n   * @private\n   */\n  generateRegionId_(region) {\n    const percentageUnit = shaka.text.CueRegion.units.PERCENTAGE;\n    const heightUnit = region.heightUnits == percentageUnit ? '%' : 'px';\n    const viewportAnchorUnit =\n        region.viewportAnchorUnits == percentageUnit ? '%' : 'px';\n    const uniqueRegionId = `${region.id}_${\n      region.width}x${region.height}${heightUnit}-${\n      region.viewportAnchorX}x${region.viewportAnchorY}${viewportAnchorUnit}`;\n\n    return uniqueRegionId;\n  }\n\n  /**\n   * Get or create a region element corresponding to the cue region.  These are\n   * cached by ID.\n   *\n   * @param {!shaka.extern.Cue} cue\n   * @return {!HTMLElement}\n   * @private\n   */\n  getRegionElement_(cue) {\n    const region = cue.region;\n\n    const regionId = this.generateRegionId_(region);\n    if (this.regionElements_.has(regionId)) {\n      return this.regionElements_.get(regionId);\n    }\n\n    const regionElement = shaka.util.Dom.createHTMLElement('span');\n\n    const percentageUnit = shaka.text.CueRegion.units.PERCENTAGE;\n    const heightUnit = region.heightUnits == percentageUnit ? '%' : 'px';\n    const widthUnit = region.widthUnits == percentageUnit ? '%' : 'px';\n    const viewportAnchorUnit =\n        region.viewportAnchorUnits == percentageUnit ? '%' : 'px';\n\n    regionElement.id = 'shaka-text-region---' + regionId;\n    regionElement.classList.add('shaka-text-region');\n\n    regionElement.style.height = region.height + heightUnit;\n    regionElement.style.width = region.width + widthUnit;\n    regionElement.style.position = 'absolute';\n    regionElement.style.top = region.viewportAnchorY + viewportAnchorUnit;\n    regionElement.style.left = region.viewportAnchorX + viewportAnchorUnit;\n\n    regionElement.style.display = 'flex';\n    regionElement.style.flexDirection = 'column';\n    regionElement.style.alignItems = 'center';\n\n    if (cue.displayAlign == shaka.text.Cue.displayAlign.BEFORE) {\n      regionElement.style.justifyContent = 'flex-start';\n    } else if (cue.displayAlign == shaka.text.Cue.displayAlign.CENTER) {\n      regionElement.style.justifyContent = 'center';\n    } else {\n      regionElement.style.justifyContent = 'flex-end';\n    }\n\n    this.regionElements_.set(regionId, regionElement);\n    return regionElement;\n  }\n\n  /**\n   * Creates the object for a cue.\n   *\n   * @param {!shaka.extern.Cue} cue\n   * @param {!Array.<!shaka.extern.Cue>} parents\n   * @private\n   */\n  createCue_(cue, parents) {\n    const isNested = parents.length > 1;\n    let type = isNested ? 'span' : 'div';\n    if (cue.lineBreak || cue.spacer) {\n      if (cue.spacer) {\n        shaka.Deprecate.deprecateFeature(4,\n            'shaka.extern.Cue',\n            'Please use lineBreak instead of spacer.');\n      }\n      type = 'br';\n    }\n\n    const needWrapper = !isNested && cue.nestedCues.length > 0;\n\n    // Nested cues are inline elements.  Top-level cues are block elements.\n    const cueElement = shaka.util.Dom.createHTMLElement(type);\n    if (type != 'br') {\n      this.setCaptionStyles_(cueElement, cue, parents, needWrapper);\n    }\n\n    let regionElement = null;\n    if (cue.region && cue.region.id) {\n      regionElement = this.getRegionElement_(cue);\n    }\n\n    let wrapper = cueElement;\n    if (needWrapper) {\n      // Create a wrapper element which will serve to contain all children into\n      // a single item.  This ensures that nested span elements appear\n      // horizontally and br elements occupy no vertical space.\n      wrapper = shaka.util.Dom.createHTMLElement('span');\n      wrapper.classList.add('shaka-text-wrapper');\n      wrapper.style.backgroundColor = cue.backgroundColor;\n      wrapper.style.lineHeight = 'normal';\n      cueElement.appendChild(wrapper);\n    }\n\n    this.currentCuesMap_.set(cue, {cueElement, wrapper, regionElement});\n  }\n\n  /**\n   * @param {!HTMLElement} cueElement\n   * @param {!shaka.extern.Cue} cue\n   * @param {!Array.<!shaka.extern.Cue>} parents\n   * @param {boolean} hasWrapper\n   * @private\n   */\n  setCaptionStyles_(cueElement, cue, parents, hasWrapper) {\n    const Cue = shaka.text.Cue;\n    const inherit =\n        (cb) => shaka.text.UITextDisplayer.inheritProperty_(parents, cb);\n    const style = cueElement.style;\n    const isLeaf = cue.nestedCues.length == 0;\n    const isNested = parents.length > 1;\n\n    // TODO: wrapLine is not yet supported.  Lines always wrap.\n\n    // White space should be preserved if emitted by the text parser.  It's the\n    // job of the parser to omit any whitespace that should not be displayed.\n    // Using 'pre-wrap' means that whitespace is preserved even at the end of\n    // the text, but that lines which overflow can still be broken.\n    style.whiteSpace = 'pre-wrap';\n\n    // Using 'break-spaces' would be better, as it would preserve even trailing\n    // spaces, but that only shipped in Chrome 76.  As of July 2020, Safari\n    // still has not implemented break-spaces, and the original Chromecast will\n    // never have this feature since it no longer gets firmware updates.\n    // So we need to replace trailing spaces with non-breaking spaces.\n    const text = cue.payload.replace(/\\s+$/g, (match) => {\n      const nonBreakingSpace = '\\xa0';\n      return nonBreakingSpace.repeat(match.length);\n    });\n\n    style.webkitTextStrokeColor = cue.textStrokeColor;\n    style.webkitTextStrokeWidth = cue.textStrokeWidth;\n    style.color = cue.color;\n    style.direction = cue.direction;\n    style.opacity = cue.opacity;\n    style.paddingLeft = shaka.text.UITextDisplayer.convertLengthValue_(\n        cue.linePadding, cue, this.videoContainer_);\n    style.paddingRight =\n        shaka.text.UITextDisplayer.convertLengthValue_(\n            cue.linePadding, cue, this.videoContainer_);\n    style.textShadow = cue.textShadow;\n\n    if (cue.backgroundImage) {\n      style.backgroundImage = 'url(\\'' + cue.backgroundImage + '\\')';\n      style.backgroundRepeat = 'no-repeat';\n      style.backgroundSize = 'contain';\n      style.backgroundPosition = 'center';\n\n      // Quoting https://www.w3.org/TR/ttml-imsc1.2/:\n      // \"The width and height (in pixels) of the image resource referenced by\n      // smpte:backgroundImage SHALL be equal to the width and height expressed\n      // by the tts:extent attribute of the region in which the div element is\n      // presented\".\n      style.width = '100%';\n      style.height = '100%';\n    } else {\n      // If we have both text and nested cues, then style everything; otherwise\n      // place the text in its own <span> so the background doesn't fill the\n      // whole region.\n      let elem;\n      if (cue.nestedCues.length) {\n        elem = cueElement;\n      } else {\n        elem = shaka.util.Dom.createHTMLElement('span');\n        cueElement.appendChild(elem);\n      }\n\n      if (cue.border) {\n        elem.style.border = cue.border;\n      }\n      if (!hasWrapper) {\n        const bgColor = inherit((c) => c.backgroundColor);\n        if (bgColor) {\n          elem.style.backgroundColor = bgColor;\n        } else if (text) {\n          // If there is no background, default to a semi-transparent black.\n          // Only do this for the text itself.\n          elem.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';\n        }\n      }\n      if (text) {\n        elem.textContent = text;\n      }\n    }\n\n    // The displayAlign attribute specifies the vertical alignment of the\n    // captions inside the text container. Before means at the top of the\n    // text container, and after means at the bottom.\n    if (isNested && !parents[parents.length - 1].isContainer) {\n      style.display = 'inline';\n    } else {\n      style.display = 'flex';\n      style.flexDirection = 'column';\n      style.alignItems = 'center';\n\n      if (cue.displayAlign == Cue.displayAlign.BEFORE) {\n        style.justifyContent = 'flex-start';\n      } else if (cue.displayAlign == Cue.displayAlign.CENTER) {\n        style.justifyContent = 'center';\n      } else {\n        style.justifyContent = 'flex-end';\n      }\n    }\n\n    if (!isLeaf) {\n      style.margin = '0';\n    }\n\n    style.fontFamily = cue.fontFamily;\n    style.fontWeight = cue.fontWeight.toString();\n    style.fontStyle = cue.fontStyle;\n    style.letterSpacing = cue.letterSpacing;\n    style.fontSize = shaka.text.UITextDisplayer.convertLengthValue_(\n        cue.fontSize, cue, this.videoContainer_);\n\n    // The line attribute defines the positioning of the text container inside\n    // the video container.\n    // - The line offsets the text container from the top, the right or left of\n    //   the video viewport as defined by the writing direction.\n    // - The value of the line is either as a number of lines, or a percentage\n    //   of the video viewport height or width.\n    // The lineAlign is an alignment for the text container's line.\n    // - The Start alignment means the text container’s top side (for horizontal\n    //   cues), left side (for vertical growing right), or right side (for\n    //   vertical growing left) is aligned at the line.\n    // - The Center alignment means the text container is centered at the line\n    //   (to be implemented).\n    // - The End Alignment means The text container’s bottom side (for\n    //   horizontal cues), right side (for vertical growing right), or left side\n    //   (for vertical growing left) is aligned at the line.\n    // TODO: Implement line alignment with line number.\n    // TODO: Implement lineAlignment of 'CENTER'.\n    if (cue.line != null) {\n      if (cue.lineInterpretation == Cue.lineInterpretation.PERCENTAGE) {\n        style.position = 'absolute';\n        if (cue.writingMode == Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM) {\n          style.width = '100%';\n          if (cue.lineAlign == Cue.lineAlign.START) {\n            style.top = cue.line + '%';\n          } else if (cue.lineAlign == Cue.lineAlign.END) {\n            style.bottom = (100 - cue.line) + '%';\n          }\n        } else if (cue.writingMode == Cue.writingMode.VERTICAL_LEFT_TO_RIGHT) {\n          style.height = '100%';\n          if (cue.lineAlign == Cue.lineAlign.START) {\n            style.left = cue.line + '%';\n          } else if (cue.lineAlign == Cue.lineAlign.END) {\n            style.right = (100 - cue.line) + '%';\n          }\n        } else {\n          style.height = '100%';\n          if (cue.lineAlign == Cue.lineAlign.START) {\n            style.right = cue.line + '%';\n          } else if (cue.lineAlign == Cue.lineAlign.END) {\n            style.left = (100 - cue.line) + '%';\n          }\n        }\n      }\n    }\n\n    style.lineHeight = cue.lineHeight;\n\n    // The position defines the indent of the text container in the\n    // direction defined by the writing direction.\n    if (cue.position != null) {\n      if (cue.writingMode == Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM) {\n        style.paddingLeft = cue.position;\n      } else {\n        style.paddingTop = cue.position;\n      }\n    }\n\n    // The positionAlign attribute is an alignment for the text container in\n    // the dimension of the writing direction.\n    if (cue.positionAlign == Cue.positionAlign.LEFT) {\n      style.cssFloat = 'left';\n    } else if (cue.positionAlign == Cue.positionAlign.RIGHT) {\n      style.cssFloat = 'right';\n    }\n\n    style.textAlign = cue.textAlign;\n    style.textDecoration = cue.textDecoration.join(' ');\n    style.writingMode = cue.writingMode;\n\n    // Old versions of Chromium, which may be found in certain versions of Tizen\n    // and WebOS, may require the prefixed version: webkitWritingMode.\n    // https://caniuse.com/css-writing-mode\n    // However, testing shows that Tizen 3, at least, has a 'writingMode'\n    // property, but the setter for it does nothing.  Therefore we need to\n    // detect that and fall back to the prefixed version in this case, too.\n    if (!('writingMode' in document.documentElement.style) ||\n        style.writingMode != cue.writingMode) {\n      // Note that here we do not bother to check for webkitWritingMode support\n      // explicitly.  We try the unprefixed version, then fall back to the\n      // prefixed version unconditionally.\n      style.webkitWritingMode = cue.writingMode;\n    }\n\n    // The size is a number giving the size of the text container, to be\n    // interpreted as a percentage of the video, as defined by the writing\n    // direction.\n    if (cue.size) {\n      if (cue.writingMode == Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM) {\n        style.width = cue.size + '%';\n      } else {\n        style.height = cue.size + '%';\n      }\n    }\n  }\n\n  /**\n   * Returns info about provided lengthValue\n   * @example 100px => { value: 100, unit: 'px' }\n   * @param {?string} lengthValue\n   *\n   * @return {?{ value: number, unit: string }}\n   * @private\n   */\n  static getLengthValueInfo_(lengthValue) {\n    const matches = new RegExp(/(\\d*\\.?\\d+)([a-z]+|%+)/).exec(lengthValue);\n\n    if (!matches) {\n      return null;\n    }\n\n    return {\n      value: Number(matches[1]),\n      unit: matches[2],\n    };\n  }\n\n  /**\n   * Converts length value to an absolute value in pixels.\n   * If lengthValue is already an absolute value it will not\n   * be modified. Relative lengthValue will be converted to an\n   * absolute value in pixels based on Computed Cell Size\n   *\n   * @param {string} lengthValue\n   * @param {!shaka.extern.Cue} cue\n   * @param {HTMLElement} videoContainer\n   * @return {string}\n   * @private\n  */\n  static convertLengthValue_(lengthValue, cue, videoContainer) {\n    const lengthValueInfo =\n        shaka.text.UITextDisplayer.getLengthValueInfo_(lengthValue);\n\n    if (!lengthValueInfo) {\n      return lengthValue;\n    }\n\n    const {unit, value} = lengthValueInfo;\n\n    switch (unit) {\n      case '%':\n        return shaka.text.UITextDisplayer.getAbsoluteLengthInPixels_(\n            value / 100, cue, videoContainer);\n      case 'c':\n        return shaka.text.UITextDisplayer.getAbsoluteLengthInPixels_(\n            value, cue, videoContainer);\n      default:\n        return lengthValue;\n    }\n  }\n\n  /**\n   * Returns computed absolute length value in pixels based on cell\n   * and a video container size\n   * @param {number} value\n   * @param {!shaka.extern.Cue} cue\n   * @param {HTMLElement} videoContainer\n   * @return {string}\n   *\n   * @private\n   * */\n  static getAbsoluteLengthInPixels_(value, cue, videoContainer) {\n    const containerHeight = videoContainer.clientHeight;\n\n    return (containerHeight * value / cue.cellResolution.rows) + 'px';\n  }\n\n  /**\n   * Inherits a property from the parent Cue elements.  If the value is falsy,\n   * it is assumed to be inherited from the parent. This returns null if the\n   * value isn't found.\n   *\n   * @param {!Array.<!shaka.extern.Cue>} parents\n   * @param {function(!shaka.extern.Cue):?T} cb\n   * @return {?T}\n   * @template T\n   * @private\n   */\n  static inheritProperty_(parents, cb) {\n    for (let i = parents.length - 1; i >= 0; i--) {\n      const val = cb(parents[i]);\n      if (val || val === 0) {\n        return val;\n      }\n    }\n    return null;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.WebVttGenerator');\n\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.text.Cue');\n\n\n/**\n * @summary Manage the conversion to WebVTT.\n * @export\n */\nshaka.text.WebVttGenerator = class {\n  /**\n   * @param {!Array.<!shaka.text.Cue>} cues\n   * @param {!Array.<!shaka.extern.AdCuePoint>} adCuePoints\n   * @return {string}\n   */\n  static convert(cues, adCuePoints) {\n    // Flatten nested cue payloads recursively.  If a cue has nested cues,\n    // their contents should be combined and replace the payload of the parent.\n    const flattenPayload = (cue) => {\n      // Handle styles (currently bold/italics/underline).\n      // TODO: add support for color rendering.\n      const openStyleTags = [];\n      const bold = cue.fontWeight >= shaka.text.Cue.fontWeight.BOLD;\n      const italics = cue.fontStyle == shaka.text.Cue.fontStyle.ITALIC;\n      const underline = cue.textDecoration.includes(\n          shaka.text.Cue.textDecoration.UNDERLINE);\n      if (bold) {\n        openStyleTags.push('b');\n      }\n      if (italics) {\n        openStyleTags.push('i');\n      }\n      if (underline) {\n        openStyleTags.push('u');\n      }\n\n      // Prefix opens tags, suffix closes tags in reverse order of opening.\n      const prefixStyleTags = openStyleTags.reduce((acc, tag) => {\n        return `${acc}<${tag}>`;\n      }, '');\n      const suffixStyleTags = openStyleTags.reduceRight((acc, tag) => {\n        return `${acc}</${tag}>`;\n      }, '');\n\n      if (cue.lineBreak || cue.spacer) {\n        if (cue.spacer) {\n          shaka.Deprecate.deprecateFeature(4,\n              'shaka.text.Cue',\n              'Please use lineBreak instead of spacer.');\n        }\n        // This is a vertical lineBreak, so insert a newline.\n        return '\\n';\n      } else if (cue.nestedCues.length) {\n        return cue.nestedCues.map(flattenPayload).join('');\n      } else {\n        // This is a real cue.\n        return prefixStyleTags + cue.payload + suffixStyleTags;\n      }\n    };\n\n    const webvttTimeString = (time) => {\n      let newTime = time;\n      for (const adCuePoint of adCuePoints) {\n        if (adCuePoint.end && adCuePoint.start < time) {\n          const offset = adCuePoint.end - adCuePoint.start;\n          newTime += offset;\n        }\n      }\n      const hours = Math.floor(newTime / 3600);\n      const minutes = Math.floor(newTime / 60 % 60);\n      const seconds = Math.floor(newTime % 60);\n      const milliseconds = Math.floor(newTime * 1000 % 1000);\n      return (hours < 10 ? '0' : '') + hours + ':' +\n          (minutes < 10 ? '0' : '') + minutes + ':' +\n          (seconds < 10 ? '0' : '') + seconds + '.' +\n          (milliseconds < 100 ? (milliseconds < 10 ? '00' : '0') : '') +\n          milliseconds;\n    };\n\n    // We don't want to modify the array or objects passed in, since we don't\n    // technically own them.  So we build a new array and replace certain items\n    // in it if they need to be flattened.\n    // We also don't want to flatten the text payloads starting at a container\n    // element; otherwise, for containers encapsulating multiple caption lines,\n    // the lines would merge into a single cue. This is undesirable when a\n    // subset of the captions are outside of the append time window. To fix\n    // this, we only call flattenPayload() starting at elements marked as\n    // isContainer = false.\n    const getCuesToFlatten = (cues, result) => {\n      for (const cue of cues) {\n        if (cue.isContainer) {\n          // Recurse to find the actual text payload cues.\n          getCuesToFlatten(cue.nestedCues, result);\n        } else {\n          // Flatten the payload.\n          const flatCue = cue.clone();\n          flatCue.nestedCues = [];\n          flatCue.payload = flattenPayload(cue);\n          result.push(flatCue);\n        }\n      }\n      return result;\n    };\n    const flattenedCues = getCuesToFlatten(cues, []);\n\n    let webvttString = 'WEBVTT\\n\\n';\n    for (const cue of flattenedCues) {\n      const webvttSettings = (cue) => {\n        const settings = [];\n        const Cue = shaka.text.Cue;\n        switch (cue.textAlign) {\n          case Cue.textAlign.LEFT:\n            settings.push('align:left');\n            break;\n          case Cue.textAlign.RIGHT:\n            settings.push('align:right');\n            break;\n          case Cue.textAlign.CENTER:\n            settings.push('align:middle');\n            break;\n          case Cue.textAlign.START:\n            settings.push('align:start');\n            break;\n          case Cue.textAlign.END:\n            settings.push('align:end');\n            break;\n        }\n        switch (cue.writingMode) {\n          case Cue.writingMode.VERTICAL_LEFT_TO_RIGHT:\n            settings.push('vertical:lr');\n            break;\n          case Cue.writingMode.VERTICAL_RIGHT_TO_LEFT:\n            settings.push('vertical:rl');\n            break;\n        }\n\n        if (settings.length) {\n          return ' ' + settings.join(' ');\n        }\n        return '';\n      };\n      webvttString += webvttTimeString(cue.startTime) + ' --> ' +\n          webvttTimeString(cue.endTime) + webvttSettings(cue) + '\\n';\n      webvttString += cue.payload + '\\n\\n';\n    }\n    return webvttString;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.CmcdManager');\n\ngoog.require('goog.Uri');\ngoog.require('shaka.log');\n\n\n/**\n * @summary\n * A CmcdManager maintains CMCD state as well as a collection of utility\n * functions.\n */\nshaka.util.CmcdManager = class {\n  /**\n   * @param {shaka.util.CmcdManager.PlayerInterface} playerInterface\n   * @param {shaka.extern.CmcdConfiguration} config\n   */\n  constructor(playerInterface, config) {\n    /** @private {shaka.util.CmcdManager.PlayerInterface} */\n    this.playerInterface_ = playerInterface;\n\n    /** @private {?shaka.extern.CmcdConfiguration} */\n    this.config_ = config;\n\n    /**\n     * Session ID\n     *\n     * @private {string}\n     */\n    this.sid_ = '';\n\n    /**\n     * Streaming format\n     *\n     * @private {(shaka.util.CmcdManager.StreamingFormat|undefined)}\n     */\n    this.sf_ = undefined;\n\n    /**\n     * @private {boolean}\n     */\n    this.playbackStarted_ = false;\n\n    /**\n    * @private {boolean}\n    */\n    this.buffering_ = true;\n\n    /**\n     * @private {boolean}\n     */\n    this.starved_ = false;\n  }\n\n  /**\n   * Set the buffering state\n   *\n   * @param {boolean} buffering\n   */\n  setBuffering(buffering) {\n    if (!buffering && !this.playbackStarted_) {\n      this.playbackStarted_ = true;\n    }\n\n    if (this.playbackStarted_ && buffering) {\n      this.starved_ = true;\n    }\n\n    this.buffering_ = buffering;\n  }\n\n  /**\n   * Apply CMCD data to a manifest request.\n   *\n   * @param {!shaka.extern.Request} request\n   *   The request to apply CMCD data to\n   * @param {shaka.util.CmcdManager.ManifestInfo} manifestInfo\n   *   The manifest format\n   */\n  applyManifestData(request, manifestInfo) {\n    try {\n      if (!this.config_.enabled) {\n        return;\n      }\n\n      this.sf_ = manifestInfo.format;\n\n      this.apply_(request, {\n        ot: shaka.util.CmcdManager.ObjectType.MANIFEST,\n        su: !this.playbackStarted_,\n      });\n    } catch (error) {\n      shaka.log.warnOnce('CMCD_MANIFEST_ERROR',\n          'Could not generate manifest CMCD data.', error);\n    }\n  }\n\n  /**\n   * Apply CMCD data to a segment request\n   *\n   * @param {!shaka.extern.Request} request\n   * @param {shaka.util.CmcdManager.SegmentInfo} segmentInfo\n   */\n  applySegmentData(request, segmentInfo) {\n    try {\n      if (!this.config_.enabled) {\n        return;\n      }\n\n      const data = {\n        d: segmentInfo.duration * 1000,\n        st: this.getStreamType_(),\n      };\n\n      data.ot = this.getObjectType_(segmentInfo);\n\n      const ObjectType = shaka.util.CmcdManager.ObjectType;\n      const isMedia = data.ot === ObjectType.VIDEO ||\n                      data.ot === ObjectType.AUDIO ||\n                      data.ot === ObjectType.MUXED ||\n                      data.ot === ObjectType.TIMED_TEXT;\n\n      if (isMedia) {\n        data.bl = this.getBufferLength_(segmentInfo.type);\n      }\n\n      if (segmentInfo.bandwidth) {\n        data.br = segmentInfo.bandwidth / 1000;\n      }\n\n      if (isMedia && data.ot !== ObjectType.TIMED_TEXT) {\n        data.tb = this.getTopBandwidth_(data.ot) / 1000;\n      }\n\n      this.apply_(request, data);\n    } catch (error) {\n      shaka.log.warnOnce('CMCD_SEGMENT_ERROR',\n          'Could not generate segment CMCD data.', error);\n    }\n  }\n\n  /**\n   * Apply CMCD data to a text request\n   *\n   * @param {!shaka.extern.Request} request\n   */\n  applyTextData(request) {\n    try {\n      if (!this.config_.enabled) {\n        return;\n      }\n\n      this.apply_(request, {\n        ot: shaka.util.CmcdManager.ObjectType.CAPTION,\n        su: true,\n      });\n    } catch (error) {\n      shaka.log.warnOnce('CMCD_TEXT_ERROR',\n          'Could not generate text CMCD data.', error);\n    }\n  }\n\n  /**\n   * Apply CMCD data to streams loaded via src=.\n   *\n   * @param {string} uri\n   * @param {string} mimeType\n   * @return {string}\n   */\n  appendSrcData(uri, mimeType) {\n    try {\n      if (!this.config_.enabled) {\n        return uri;\n      }\n\n      const data = this.createData_();\n      data.ot = this.getObjectTypeFromMimeType_(mimeType);\n      data.su = true;\n\n      const query = shaka.util.CmcdManager.toQuery(data);\n\n      return shaka.util.CmcdManager.appendQueryToUri(uri, query);\n    } catch (error) {\n      shaka.log.warnOnce('CMCD_SRC_ERROR',\n          'Could not generate src CMCD data.', error);\n      return uri;\n    }\n  }\n\n  /**\n   * Apply CMCD data to side car text track uri.\n   *\n   * @param {string} uri\n   * @return {string}\n   */\n  appendTextTrackData(uri) {\n    try {\n      if (!this.config_.enabled) {\n        return uri;\n      }\n\n      const data = this.createData_();\n      data.ot = shaka.util.CmcdManager.ObjectType.CAPTION;\n      data.su = true;\n\n      const query = shaka.util.CmcdManager.toQuery(data);\n\n      return shaka.util.CmcdManager.appendQueryToUri(uri, query);\n    } catch (error) {\n      shaka.log.warnOnce('CMCD_TEXT_TRACK_ERROR',\n          'Could not generate text track CMCD data.', error);\n      return uri;\n    }\n  }\n\n  /**\n   * Create baseline CMCD data\n   *\n   * @return {CmcdData}\n   * @private\n   */\n  createData_() {\n    if (!this.sid_) {\n      this.sid_ = this.config_.sessionId || window.crypto.randomUUID();\n    }\n    return {\n      v: shaka.util.CmcdManager.Version,\n      sf: this.sf_,\n      sid: this.sid_,\n      cid: this.config_.contentId,\n      mtp: this.playerInterface_.getBandwidthEstimate() / 1000,\n    };\n  }\n\n  /**\n   * Apply CMCD data to a request.\n   *\n   * @param {!shaka.extern.Request} request The request to apply CMCD data to\n   * @param {!CmcdData} data The data object\n   * @param {boolean} useHeaders Send data via request headers\n   * @private\n   */\n  apply_(request, data = {}, useHeaders = this.config_.useHeaders) {\n    if (!this.config_.enabled) {\n      return;\n    }\n\n    // apply baseline data\n    Object.assign(data, this.createData_());\n\n    data.pr = this.playerInterface_.getPlaybackRate();\n\n    const isVideo = data.ot === shaka.util.CmcdManager.ObjectType.VIDEO ||\n      data.ot === shaka.util.CmcdManager.ObjectType.MUXED;\n\n    if (this.starved_ && isVideo) {\n      data.bs = true;\n      data.su = true;\n      this.starved_ = false;\n    }\n\n    if (data.su == null) {\n      data.su = this.buffering_;\n    }\n\n    // TODO: Implement rtp, nrr, nor, dl\n\n    if (useHeaders) {\n      const headers = shaka.util.CmcdManager.toHeaders(data);\n      if (!Object.keys(headers).length) {\n        return;\n      }\n\n      Object.assign(request.headers, headers);\n    } else {\n      const query = shaka.util.CmcdManager.toQuery(data);\n      if (!query) {\n        return;\n      }\n\n      request.uris = request.uris.map((uri) => {\n        return shaka.util.CmcdManager.appendQueryToUri(uri, query);\n      });\n    }\n  }\n\n  /**\n   * The CMCD object type.\n   *\n   * @param {shaka.util.CmcdManager.SegmentInfo} segmentInfo\n   * @private\n   */\n  getObjectType_(segmentInfo) {\n    const type = segmentInfo.type;\n\n    if (segmentInfo.init) {\n      return shaka.util.CmcdManager.ObjectType.INIT;\n    }\n\n    if (type == 'video') {\n      if (segmentInfo.codecs.includes(',')) {\n        return shaka.util.CmcdManager.ObjectType.MUXED;\n      }\n      return shaka.util.CmcdManager.ObjectType.VIDEO;\n    }\n\n    if (type == 'audio') {\n      return shaka.util.CmcdManager.ObjectType.AUDIO;\n    }\n\n    if (type == 'text') {\n      if (segmentInfo.mimeType === 'application/mp4') {\n        return shaka.util.CmcdManager.ObjectType.TIMED_TEXT;\n      }\n      return shaka.util.CmcdManager.ObjectType.CAPTION;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * The CMCD object type from mimeType.\n   *\n   * @param {!string} mimeType\n   * @return {(shaka.util.CmcdManager.ObjectType|undefined)}\n   * @private\n   */\n  getObjectTypeFromMimeType_(mimeType) {\n    switch (mimeType) {\n      case 'video/webm':\n      case 'video/mp4':\n        return shaka.util.CmcdManager.ObjectType.MUXED;\n\n      case 'application/x-mpegurl':\n        return shaka.util.CmcdManager.ObjectType.MANIFEST;\n\n      default:\n        return undefined;\n    }\n  }\n\n  /**\n   * Get the buffer length for a media type in milliseconds\n   *\n   * @param {string} type\n   * @return {number}\n   * @private\n   */\n  getBufferLength_(type) {\n    const ranges = this.playerInterface_.getBufferedInfo()[type];\n\n    if (!ranges.length) {\n      return NaN;\n    }\n\n    const start = this.playerInterface_.getCurrentTime();\n    const range = ranges.find((r) => r.start <= start && r.end >= start);\n\n    if (!range) {\n      return NaN;\n    }\n\n    return (range.end - start) * 1000;\n  }\n\n  /**\n   * Get the stream type\n   *\n   * @return {shaka.util.CmcdManager.StreamType}\n   * @private\n   */\n  getStreamType_() {\n    const isLive = this.playerInterface_.isLive();\n    if (isLive) {\n      return shaka.util.CmcdManager.StreamType.LIVE;\n    } else {\n      return shaka.util.CmcdManager.StreamType.VOD;\n    }\n  }\n\n  /**\n   * Get the highest bandwidth for a given type.\n   *\n   * @param {string} type\n   * @return {number}\n   * @private\n   */\n  getTopBandwidth_(type) {\n    const variants = this.playerInterface_.getVariantTracks();\n    if (!variants.length) {\n      return NaN;\n    }\n\n    let top = variants[0];\n\n    for (const variant of variants) {\n      if (variant.type === 'variant' && variant.bandwidth > top.bandwidth) {\n        top = variant;\n      }\n    }\n\n    const ObjectType = shaka.util.CmcdManager.ObjectType;\n\n    switch (type) {\n      case ObjectType.VIDEO:\n        return top.videoBandwidth || NaN;\n\n      case ObjectType.AUDIO:\n        return top.audioBandwidth || NaN;\n\n      default:\n        return top.bandwidth;\n    }\n  }\n\n  /**\n   * Serialize a CMCD data object according to the rules defined in the\n   * section 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   *\n   * @param {CmcdData} data The CMCD data object\n   * @return {string}\n   */\n  static serialize(data) {\n    const results = [];\n    const isValid = (value) =>\n      !Number.isNaN(value) && value != null && value !== '' && value !== false;\n    const toRounded = (value) => Math.round(value);\n    const toHundred = (value) => toRounded(value / 100) * 100;\n    const toUrlSafe = (value) => encodeURIComponent(value);\n    const formatters = {\n      br: toRounded,\n      d: toRounded,\n      bl: toHundred,\n      dl: toHundred,\n      mtp: toHundred,\n      nor: toUrlSafe,\n      rtp: toHundred,\n      tb: toRounded,\n    };\n\n    const keys = Object.keys(data || {}).sort();\n\n    for (const key of keys) {\n      let value = data[key];\n\n      // ignore invalid values\n      if (!isValid(value)) {\n        continue;\n      }\n\n      // Version should only be reported if not equal to 1.\n      if (key === 'v' && value === 1) {\n        continue;\n      }\n\n      // Playback rate should only be sent if not equal to 1.\n      if (key == 'pr' && value === 1) {\n        continue;\n      }\n\n      // Certain values require special formatting\n      const formatter = formatters[key];\n      if (formatter) {\n        value = formatter(value);\n      }\n\n      // Serialize the key/value pair\n      const type = typeof value;\n      let result;\n\n      if (type === 'string' && key !== 'ot' && key !== 'sf' && key !== 'st') {\n        result = `${key}=${JSON.stringify(value)}`;\n      } else if (type === 'boolean') {\n        result = key;\n      } else if (type === 'symbol') {\n        result = `${key}=${value.description}`;\n      } else {\n        result = `${key}=${value}`;\n      }\n\n      results.push(result);\n    }\n\n    return results.join(',');\n  }\n\n  /**\n   * Convert a CMCD data object to request headers according to the rules\n   * defined in the section 2.1 and 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   *\n   * @param {CmcdData} data The CMCD data object\n   * @return {!Object}\n   */\n  static toHeaders(data) {\n    const keys = Object.keys(data);\n    const headers = {};\n    const headerNames = ['Object', 'Request', 'Session', 'Status'];\n    const headerGroups = [{}, {}, {}, {}];\n    const headerMap = {\n      br: 0, d: 0, ot: 0, tb: 0,\n      bl: 1, dl: 1, mtp: 1, nor: 1, nrr: 1, su: 1,\n      cid: 2, pr: 2, sf: 2, sid: 2, st: 2, v: 2,\n      bs: 3, rtp: 3,\n    };\n\n    for (const key of keys) {\n      // Unmapped fields are mapped to the Request header\n      const index = (headerMap[key] != null) ? headerMap[key] : 1;\n      headerGroups[index][key] = data[key];\n    }\n\n    for (let i = 0; i < headerGroups.length; i++) {\n      const value = shaka.util.CmcdManager.serialize(headerGroups[i]);\n      if (value) {\n        headers[`CMCD-${headerNames[i]}`] = value;\n      }\n    }\n\n    return headers;\n  }\n\n  /**\n   * Convert a CMCD data object to query args according to the rules\n   * defined in the section 2.2 and 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   *\n   * @param {CmcdData} data The CMCD data object\n   * @return {string}\n   */\n  static toQuery(data) {\n    return shaka.util.CmcdManager.serialize(data);\n  }\n\n  /**\n   * Append query args to a uri.\n   *\n   * @param {string} uri\n   * @param {string} query\n   * @return {string}\n   */\n  static appendQueryToUri(uri, query) {\n    if (!query) {\n      return uri;\n    }\n\n    if (uri.includes('offline:')) {\n      return uri;\n    }\n\n    const url = new goog.Uri(uri);\n    url.getQueryData().set('CMCD', query);\n    return url.toString();\n  }\n};\n\n\n/**\n * @typedef {{\n *   getBandwidthEstimate: function():number,\n *   getBufferedInfo: function():shaka.extern.BufferedInfo,\n *   getCurrentTime: function():number,\n *   getVariantTracks: function():Array.<shaka.extern.Track>,\n *   getPlaybackRate: function():number,\n *   isLive: function():boolean\n * }}\n *\n * @property {function():number} getBandwidthEstimate\n *   Get the estimated bandwidth in bits per second.\n * @property {function():shaka.extern.BufferedInfo} getBufferedInfo\n *   Get information about what the player has buffered.\n * @property {function():number} getCurrentTime\n *   Get the current time\n * @property {function():Array.<shaka.extern.Track>} getVariantTracks\n *   Get the variant tracks\n * @property {function():number} getPlaybackRate\n *   Get the playback rate\n * @property {function():boolean} isLive\n *   Get if the player is playing live content.\n */\nshaka.util.CmcdManager.PlayerInterface;\n\n\n/**\n * @typedef {{\n *   type: string,\n *   init: boolean,\n *   duration: number,\n *   mimeType: string,\n *   codecs: string,\n *   bandwidth: (number|undefined)\n * }}\n *\n * @property {string} type\n *   The media type\n * @property {boolean} init\n *   Flag indicating whether the segment is an init segment\n * @property {number} duration\n *   The duration of the segment in seconds\n * @property {string} mimeType\n *   The segment's mime type\n * @property {string} codecs\n *   The segment's codecs\n * @property {(number|undefined)} bandwidth\n *   The segment's variation bandwidth\n *\n * @export\n */\nshaka.util.CmcdManager.SegmentInfo;\n\n\n/**\n * @typedef {{\n *   format: shaka.util.CmcdManager.StreamingFormat\n * }}\n *\n * @property {shaka.util.CmcdManager.StreamingFormat} format\n *   The manifest's stream format\n *\n * @export\n */\nshaka.util.CmcdManager.ManifestInfo;\n\n\n/**\n * @enum {string}\n */\nshaka.util.CmcdManager.ObjectType = {\n  MANIFEST: 'm',\n  AUDIO: 'a',\n  VIDEO: 'v',\n  MUXED: 'av',\n  INIT: 'i',\n  CAPTION: 'c',\n  TIMED_TEXT: 'tt',\n  KEY: 'k',\n  OTHER: 'o',\n};\n\n\n/**\n * @enum {string}\n */\nshaka.util.CmcdManager.StreamType = {\n  VOD: 'v',\n  LIVE: 'l',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.util.CmcdManager.StreamingFormat = {\n  DASH: 'd',\n  HLS: 'h',\n  SMOOTH: 's',\n  OTHER: 'o',\n};\n\n\n/**\n * The CMCD spec version\n * @const {number}\n */\nshaka.util.CmcdManager.Version = 1;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.ConfigUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.ObjectUtils');\n\n\n/** @export */\nshaka.util.ConfigUtils = class {\n  /**\n   * @param {!Object} destination\n   * @param {!Object} source\n   * @param {!Object} template supplies default values\n   * @param {!Object} overrides\n   *   Supplies override type checking.  When the current path matches\n   *   the key in this object, each sub-value must match the type in this\n   *   object. If this contains an Object, it is used as the template.\n   * @param {string} path to this part of the config\n   * @return {boolean}\n   * @export\n   */\n  static mergeConfigObjects(destination, source, template, overrides, path) {\n    goog.asserts.assert(destination, 'Destination config must not be null!');\n\n    /**\n     * @type {boolean}\n     * If true, don't validate the keys in the next level.\n     */\n    const ignoreKeys = path in overrides;\n\n    let isValid = true;\n\n    for (const k in source) {\n      const subPath = path + '.' + k;\n      const subTemplate = ignoreKeys ? overrides[path] : template[k];\n\n      // The order of these checks is important.\n      if (!ignoreKeys && !(k in template)) {\n        shaka.log.alwaysError('Invalid config, unrecognized key ' + subPath);\n        isValid = false;\n      } else if (source[k] === undefined) {\n        // An explicit 'undefined' value causes the key to be deleted from the\n        // destination config and replaced with a default from the template if\n        // possible.\n        if (subTemplate === undefined || ignoreKeys) {\n          // There is nothing in the template, so delete.\n          delete destination[k];\n        } else {\n          // There is something in the template, so go back to that.\n          destination[k] = shaka.util.ObjectUtils.cloneObject(subTemplate);\n        }\n      } else if (subTemplate.constructor == Object &&\n                 source[k] &&\n                 source[k].constructor == Object) {\n        // These are plain Objects with no other constructor.\n\n        if (!destination[k]) {\n          // Initialize the destination with the template so that normal\n          // merging and type-checking can happen.\n          destination[k] = shaka.util.ObjectUtils.cloneObject(subTemplate);\n        }\n\n        const subMergeValid = shaka.util.ConfigUtils.mergeConfigObjects(\n            destination[k], source[k], subTemplate, overrides, subPath);\n        isValid = isValid && subMergeValid;\n      } else if (typeof source[k] != typeof subTemplate ||\n                 source[k] == null ||\n                 // Function cosntructors are not informative, and differ\n                 // between sync and async functions.  So don't look at\n                 // constructor for function types.\n                 (typeof source[k] != 'function' &&\n                  source[k].constructor != subTemplate.constructor)) {\n        // The source is the wrong type.  This check allows objects to be\n        // nulled, but does not allow null for any non-object fields.\n        shaka.log.alwaysError('Invalid config, wrong type for ' + subPath);\n        isValid = false;\n      } else if (typeof template[k] == 'function' &&\n                 template[k].length != source[k].length) {\n        shaka.log.alwaysWarn(\n            'Unexpected number of arguments for ' + subPath);\n        destination[k] = source[k];\n      } else {\n        destination[k] = source[k];\n      }\n    }\n\n    return isValid;\n  }\n\n\n  /**\n   * Convert config from ('fieldName', value) format to a partial config object.\n   *\n   * E. g. from ('manifest.retryParameters.maxAttempts', 1) to\n   * { manifest: { retryParameters: { maxAttempts: 1 }}}.\n   *\n   * @param {string} fieldName\n   * @param {*} value\n   * @return {!Object}\n   * @export\n   */\n  static convertToConfigObject(fieldName, value) {\n    const configObject = {};\n    let last = configObject;\n    let searchIndex = 0;\n    let nameStart = 0;\n    while (true) {  // eslint-disable-line no-constant-condition\n      const idx = fieldName.indexOf('.', searchIndex);\n      if (idx < 0) {\n        break;\n      }\n      if (idx == 0 || fieldName[idx - 1] != '\\\\') {\n        const part = fieldName.substring(nameStart, idx).replace(/\\\\\\./g, '.');\n        last[part] = {};\n        last = last[part];\n        nameStart = idx + 1;\n      }\n      searchIndex = idx + 1;\n    }\n\n    last[fieldName.substring(nameStart).replace(/\\\\\\./g, '.')] = value;\n    return configObject;\n  }\n\n  /**\n   * Reference the input parameters so the compiler doesn't remove them from\n   * the calling function.  Return whatever value is specified.\n   *\n   * This allows an empty or default implementation of a config callback that\n   * still bears the complete function signature even in compiled mode.\n   *\n   * The caller should look something like this:\n   *\n   *   const callback = (a, b, c, d) => {\n   *     return referenceParametersAndReturn(\n             [a, b, c, d],\n             a);  // Can be anything, doesn't need to be one of the parameters\n   *   };\n   *\n   * @param {!Array.<?>} parameters\n   * @param {T} returnValue\n   * @return {T}\n   * @template T\n   * @noinline\n   */\n  static referenceParametersAndReturn(parameters, returnValue) {\n    return parameters && returnValue;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.PlayerConfiguration');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.abr.SimpleAbrManager');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.ConfigUtils');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.Platform');\n\n\n/**\n * @final\n * @export\n */\nshaka.util.PlayerConfiguration = class {\n  /** @return {shaka.extern.PlayerConfiguration} */\n  static createDefault() {\n    // This is a relatively safe default in the absence of clues from the\n    // browser.  For slower connections, the default estimate may be too high.\n    const bandwidthEstimate = 1e6; // 1Mbps\n\n    let abrMaxHeight = Infinity;\n\n    // Some browsers implement the Network Information API, which allows\n    // retrieving information about a user's network connection.\n    if (navigator.connection) {\n      // If the user has checked a box in the browser to ask it to use less\n      // data, the browser will expose this intent via connection.saveData.\n      // When that is true, we will default the max ABR height to 360p. Apps\n      // can override this if they wish.\n      //\n      // The decision to use 360p was somewhat arbitrary. We needed a default\n      // limit, and rather than restrict to a certain bandwidth, we decided to\n      // restrict resolution. This will implicitly restrict bandwidth and\n      // therefore save data. We (Shaka+Chrome) judged that:\n      //   - HD would be inappropriate\n      //   - If a user is asking their browser to save data, 360p it reasonable\n      //   - 360p would not look terrible on small mobile device screen\n      // We also found that:\n      //   - YouTube's website on mobile defaults to 360p (as of 2018)\n      //   - iPhone 6, in portrait mode, has a physical resolution big enough\n      //     for 360p widescreen, but a little smaller than 480p widescreen\n      //     (https://apple.co/2yze4es)\n      // If the content's lowest resolution is above 360p, AbrManager will use\n      // the lowest resolution.\n      if (navigator.connection.saveData) {\n        abrMaxHeight = 360;\n      }\n    }\n\n    const drm = {\n      retryParameters: shaka.net.NetworkingEngine.defaultRetryParameters(),\n      // These will all be verified by special cases in mergeConfigObjects_():\n      servers: {},    // key is arbitrary key system ID, value must be string\n      clearKeys: {},  // key is arbitrary key system ID, value must be string\n      advanced: {},    // key is arbitrary key system ID, value is a record type\n      delayLicenseRequestUntilPlayed: false,\n      initDataTransform: shaka.media.DrmEngine.defaultInitDataTransform,\n      logLicenseExchange: false,\n      updateExpirationTime: 1,\n      preferredKeySystems: [],\n    };\n\n    const manifest = {\n      retryParameters: shaka.net.NetworkingEngine.defaultRetryParameters(),\n      availabilityWindowOverride: NaN,\n      disableAudio: false,\n      disableVideo: false,\n      disableText: false,\n      disableThumbnails: false,\n      defaultPresentationDelay: 0,\n      dash: {\n        clockSyncUri: '',\n        ignoreDrmInfo: false,\n        disableXlinkProcessing: false,\n        xlinkFailGracefully: false,\n        ignoreMinBufferTime: false,\n        autoCorrectDrift: true,\n        initialSegmentLimit: 1000,\n        ignoreSuggestedPresentationDelay: false,\n        ignoreEmptyAdaptationSet: false,\n        ignoreMaxSegmentDuration: false,\n        keySystemsByURI: {\n          'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b':\n            'org.w3.clearkey',\n          'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed':\n            'com.widevine.alpha',\n          'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95':\n            'com.microsoft.playready',\n          'urn:uuid:79f0049a-4098-8642-ab92-e65be0885f95':\n            'com.microsoft.playready',\n          'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb':\n            'com.adobe.primetime',\n        },\n        manifestPreprocessor: (element) => {\n          return shaka.util.ConfigUtils.referenceParametersAndReturn(\n              [element],\n              element);\n        },\n      },\n      hls: {\n        ignoreTextStreamFailures: false,\n        ignoreImageStreamFailures: false,\n        useFullSegmentsForStartTime: false,\n        defaultAudioCodec: 'mp4a.40.2',\n        defaultVideoCodec: 'avc1.42E01E',\n      },\n    };\n\n    const streaming = {\n      retryParameters: shaka.net.NetworkingEngine.defaultRetryParameters(),\n      // Need some operation in the callback or else closure may remove calls\n      // to the function as it would be a no-op.  The operation can't just be a\n      // log message, because those are stripped in the compiled build.\n      failureCallback: (error) => {\n        shaka.log.error('Unhandled streaming error', error);\n        return shaka.util.ConfigUtils.referenceParametersAndReturn(\n            [error],\n            undefined);\n      },\n      // When low latency streaming is enabled, rebufferingGoal will default to\n      // 0.01 if not specified.\n      rebufferingGoal: 2,\n      bufferingGoal: 10,\n      bufferBehind: 30,\n      ignoreTextStreamFailures: false,\n      alwaysStreamText: false,\n      startAtSegmentBoundary: false,\n      gapDetectionThreshold: 0.1,\n      smallGapLimit: 0.5,\n      jumpLargeGaps: false,\n      durationBackoff: 1,\n      forceTransmuxTS: false,\n      // Offset by 5 seconds since Chromecast takes a few seconds to start\n      // playing after a seek, even when buffered.\n      safeSeekOffset: 5,\n      stallEnabled: true,\n      stallThreshold: 1 /* seconds */,\n      stallSkip: 0.1 /* seconds */,\n      useNativeHlsOnSafari: true,\n      // If we are within 2 seconds of the start of a live segment, fetch the\n      // previous one.  This allows for segment drift, but won't download an\n      // extra segment if we aren't close to the start.\n      // When low latency streaming is enabled,  inaccurateManifestTolerance\n      // will default to 0 if not specified.\n      inaccurateManifestTolerance: 2,\n      lowLatencyMode: false,\n      autoLowLatencyMode: false,\n      forceHTTPS: false,\n      preferNativeHls: false,\n      updateIntervalSeconds: 1,\n      dispatchAllEmsgBoxes: false,\n      observeQualityChanges: false,\n    };\n\n    // Some browsers will stop earlier than others before a gap (e.g., Edge\n    // stops 0.5 seconds before a gap). So for some browsers we need to use a\n    // larger threshold. See: https://bit.ly/2K5xmJO\n    if (shaka.util.Platform.isLegacyEdge() ||\n        shaka.util.Platform.isTizen() ||\n        shaka.util.Platform.isChromecast()) {\n      streaming.gapDetectionThreshold = 0.5;\n    }\n\n    // WebOS, Tizen, and Chromecast have long hardware pipelines that respond\n    // slowly to seeking.  Therefore we should not seek when we detect a stall\n    // on one of these platforms.  Instead, default stallSkip to 0 to force the\n    // stall detector to pause and play instead.\n    if (shaka.util.Platform.isWebOS() ||\n        shaka.util.Platform.isTizen() ||\n        shaka.util.Platform.isChromecast()) {\n      streaming.stallSkip = 0;\n    }\n\n    const offline = {\n      // We need to set this to a throw-away implementation for now as our\n      // default implementation will need to reference other fields in the\n      // config. We will set it to our intended implementation after we have\n      // the top-level object created.\n      // eslint-disable-next-line require-await\n      trackSelectionCallback: async (tracks) => tracks,\n\n      downloadSizeCallback: async (sizeEstimate) => {\n        if (navigator.storage && navigator.storage.estimate) {\n          const estimate = await navigator.storage.estimate();\n          // Limit to 95% of quota.\n          return estimate.usage + sizeEstimate < estimate.quota * 0.95;\n        } else {\n          return true;\n        }\n      },\n\n      // Need some operation in the callback or else closure may remove calls\n      // to the function as it would be a no-op.  The operation can't just be a\n      // log message, because those are stripped in the compiled build.\n      progressCallback: (content, progress) => {\n        return shaka.util.ConfigUtils.referenceParametersAndReturn(\n            [content, progress],\n            undefined);\n      },\n\n      // By default we use persistent licenses as forces errors to surface if\n      // a platform does not support offline licenses rather than causing\n      // unexpected behaviours when someone tries to plays downloaded content\n      // without a persistent license.\n      usePersistentLicense: true,\n    };\n\n    const abr = {\n      enabled: true,\n      useNetworkInformation: true,\n      defaultBandwidthEstimate: bandwidthEstimate,\n      switchInterval: 8,\n      bandwidthUpgradeTarget: 0.85,\n      bandwidthDowngradeTarget: 0.95,\n      restrictions: {\n        minWidth: 0,\n        maxWidth: Infinity,\n        minHeight: 0,\n        maxHeight: abrMaxHeight,\n        minPixels: 0,\n        maxPixels: Infinity,\n        minFrameRate: 0,\n        maxFrameRate: Infinity,\n        minBandwidth: 0,\n        maxBandwidth: Infinity,\n      },\n      advanced: {\n        minTotalBytes: 128e3,\n        minBytes: 16e3,\n        fastHalfLife: 2,\n        slowHalfLife: 5,\n      },\n    };\n\n    const cmcd = {\n      enabled: false,\n      sessionId: '',\n      contentId: '',\n      useHeaders: false,\n    };\n\n    /** @type {shaka.extern.PlayerConfiguration} */\n    const config = {\n      drm: drm,\n      manifest: manifest,\n      streaming: streaming,\n      offline: offline,\n      abrFactory: () => new shaka.abr.SimpleAbrManager(),\n      abr: abr,\n      preferredAudioLanguage: '',\n      preferredTextLanguage: '',\n      preferredVariantRole: '',\n      preferredTextRole: '',\n      preferredAudioChannelCount: 2,\n      preferredVideoCodecs: [],\n      preferredAudioCodecs: [],\n      preferForcedSubs: false,\n      preferredDecodingAttributes: [],\n      restrictions: {\n        minWidth: 0,\n        maxWidth: Infinity,\n        minHeight: 0,\n        maxHeight: Infinity,\n        minPixels: 0,\n        maxPixels: Infinity,\n        minFrameRate: 0,\n        maxFrameRate: Infinity,\n        minBandwidth: 0,\n        maxBandwidth: Infinity,\n      },\n      playRangeStart: 0,\n      playRangeEnd: Infinity,\n      textDisplayFactory: () => null,\n      cmcd: cmcd,\n    };\n\n    // Add this callback so that we can reference the preferred audio language\n    // through the config object so that if it gets updated, we have the\n    // updated value.\n    // eslint-disable-next-line require-await\n    offline.trackSelectionCallback = async (tracks) => {\n      return shaka.util.PlayerConfiguration.defaultTrackSelect(\n          tracks, config.preferredAudioLanguage);\n    };\n\n    return config;\n  }\n\n  /**\n   * Merges the given configuration changes into the given destination.  This\n   * uses the default Player configurations as the template.\n   *\n   * @param {shaka.extern.PlayerConfiguration} destination\n   * @param {!Object} updates\n   * @param {shaka.extern.PlayerConfiguration=} template\n   * @return {boolean}\n   * @export\n   */\n  static mergeConfigObjects(destination, updates, template) {\n    const overrides = {\n      '.drm.servers': '',\n      '.drm.clearKeys': '',\n      '.drm.advanced': {\n        distinctiveIdentifierRequired: false,\n        persistentStateRequired: false,\n        videoRobustness: '',\n        audioRobustness: '',\n        sessionType: '',\n        serverCertificate: new Uint8Array(0),\n        serverCertificateUri: '',\n        individualizationServer: '',\n      },\n    };\n    return shaka.util.ConfigUtils.mergeConfigObjects(\n        destination, updates,\n        template || shaka.util.PlayerConfiguration.createDefault(), overrides,\n        '');\n  }\n\n  /**\n   * @param {!Array.<shaka.extern.Track>} tracks\n   * @param {string} preferredAudioLanguage\n   * @return {!Array.<shaka.extern.Track>}\n   */\n  static defaultTrackSelect(tracks, preferredAudioLanguage) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    const allVariants = tracks.filter((track) => track.type == 'variant');\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    let selectedVariants = [];\n\n    // Find the locale that best matches our preferred audio locale.\n    const closestLocale = LanguageUtils.findClosestLocale(\n        preferredAudioLanguage,\n        allVariants.map((variant) => variant.language));\n    // If we found a locale that was close to our preference, then only use\n    // variants that use that locale.\n    if (closestLocale) {\n      selectedVariants = allVariants.filter((variant) => {\n        const locale = LanguageUtils.normalize(variant.language);\n        return locale == closestLocale;\n      });\n    }\n\n    // If we failed to get a language match, go with primary.\n    if (selectedVariants.length == 0) {\n      selectedVariants = allVariants.filter((variant) => {\n        return variant.primary;\n      });\n    }\n\n    // Otherwise, there is no good way to choose the language, so we don't\n    // choose a language at all.\n    if (selectedVariants.length == 0) {\n      // Issue a warning, but only if the content has multiple languages.\n      // Otherwise, this warning would just be noise.\n      const languages = new Set(allVariants.map((track) => {\n        return track.language;\n      }));\n\n      if (languages.size > 1) {\n        shaka.log.warning('Could not choose a good audio track based on ' +\n                          'language preferences or primary tracks.  An ' +\n                          'arbitrary language will be stored!');\n      }\n\n      // Default back to all variants.\n      selectedVariants = allVariants;\n    }\n\n    // From previously selected variants, choose the SD ones (height <= 480).\n    const tracksByHeight = selectedVariants.filter((track) => {\n      return track.height && track.height <= 480;\n    });\n\n    // If variants don't have video or no video with height <= 480 was\n    // found, proceed with the previously selected tracks.\n    if (tracksByHeight.length) {\n      // Sort by resolution, then select all variants which match the height\n      // of the highest SD res.  There may be multiple audio bitrates for the\n      // same video resolution.\n      tracksByHeight.sort((a, b) => {\n        // The items in this list have already been screened for height, but the\n        // compiler doesn't know that.\n        goog.asserts.assert(a.height != null, 'Null height');\n        goog.asserts.assert(b.height != null, 'Null height');\n\n        return b.height - a.height;\n      });\n      selectedVariants = tracksByHeight.filter((track) => {\n        return track.height == tracksByHeight[0].height;\n      });\n    }\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    const selectedTracks = [];\n\n    // If there are multiple matches at different audio bitrates, select the\n    // middle bandwidth one.\n    if (selectedVariants.length) {\n      const middleIndex = Math.floor(selectedVariants.length / 2);\n      selectedVariants.sort((a, b) => a.bandwidth - b.bandwidth);\n      selectedTracks.push(selectedVariants[middleIndex]);\n    }\n\n    // Since this default callback is used primarily by our own demo app and by\n    // app developers who haven't thought about which tracks they want, we\n    // should select all image/text tracks, regardless of language.  This makes\n    // for a better demo for us, and does not rely on user preferences for the\n    // unconfigured app.\n    for (const track of tracks) {\n      if (track.type == ContentType.TEXT || track.type == ContentType.IMAGE) {\n        selectedTracks.push(track);\n      }\n    }\n\n    return selectedTracks;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.StateHistory');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\n\n\n/**\n * This class is used to track the time spent in arbitrary states. When told of\n * a state, it will assume that state was active until a new state is provided.\n * When provided with identical states back-to-back, the existing entry will be\n * updated.\n *\n * @final\n */\nshaka.util.StateHistory = class {\n  /** */\n  constructor() {\n    /**\n     * The state that we think is still the current change. It is \"open\" for\n     * updating.\n     *\n     * @private {?shaka.extern.StateChange}\n     */\n    this.open_ = null;\n\n    /**\n     * The stats that are \"closed\" for updating. The \"open\" state becomes closed\n     * once we move to a new state.\n     *\n     * @private {!Array.<shaka.extern.StateChange>}\n     */\n    this.closed_ = [];\n  }\n\n  /**\n   * @param {string} state\n   */\n  update(state) {\n    // |open_| will only be |null| when we first call |update|.\n    if (this.open_ == null) {\n      this.start_(state);\n    } else {\n      this.update_(state);\n    }\n  }\n\n  /**\n   * Go through all entries in the history and count how much time was spend in\n   * the given state.\n   *\n   * @param {string} state\n   * @return {number}\n   */\n  getTimeSpentIn(state) {\n    let sum = 0;\n\n    if (this.open_ && this.open_.state == state) {\n      sum += this.open_.duration;\n    }\n\n    for (const entry of this.closed_) {\n      sum += entry.state == state ? entry.duration : 0;\n    }\n\n    return sum;\n  }\n\n  /**\n   * Get a copy of each state change entry in the history. A copy of each entry\n   * is created to break the reference to the internal data.\n   *\n   * @return {!Array.<shaka.extern.StateChange>}\n   */\n  getCopy() {\n    const clone = (entry) => {\n      return {\n        timestamp: entry.timestamp,\n        state: entry.state,\n        duration: entry.duration,\n      };\n    };\n\n    const copy = [];\n    for (const entry of this.closed_) {\n      copy.push(clone(entry));\n    }\n    if (this.open_) {\n      copy.push(clone(this.open_));\n    }\n\n    return copy;\n  }\n\n  /**\n   * @param {string} state\n   * @private\n   */\n  start_(state) {\n    goog.asserts.assert(\n        this.open_ == null,\n        'There must be no open entry in order when we start');\n    shaka.log.v1('Changing Player state to', state);\n\n    this.open_ = {\n      timestamp: this.getNowInSeconds_(),\n      state: state,\n      duration: 0,\n    };\n  }\n\n  /**\n   * @param {string} state\n   * @private\n   */\n  update_(state) {\n    goog.asserts.assert(\n        this.open_,\n        'There must be an open entry in order to update it');\n\n    const currentTimeSeconds = this.getNowInSeconds_();\n\n    // Always update the duration so that it can always be as accurate as\n    // possible.\n    this.open_.duration = currentTimeSeconds - this.open_.timestamp;\n\n    // If the state has not changed, there is no need to add a new entry.\n    if (this.open_.state == state) {\n      return;\n    }\n\n    // We have changed states, so \"close\" the open state.\n    shaka.log.v1('Changing Player state to', state);\n    this.closed_.push(this.open_);\n    this.open_ = {\n      timestamp: currentTimeSeconds,\n      state: state,\n      duration: 0,\n    };\n  }\n\n  /**\n   * Get the system time in seconds.\n   *\n   * @return {number}\n   * @private\n   */\n  getNowInSeconds_() {\n    return Date.now() / 1000;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.SwitchHistory');\n\n\n/**\n * This class is used to track changes in variant and text selections. This\n * class will make sure that redundant switches are not recorded in the history.\n *\n * @final\n */\nshaka.util.SwitchHistory = class {\n  /** */\n  constructor() {\n    /** @private {?shaka.extern.Variant} */\n    this.currentVariant_ = null;\n\n    /** @private {?shaka.extern.Stream} */\n    this.currentText_ = null;\n\n    /** @private {!Array.<shaka.extern.TrackChoice>} */\n    this.history_ = [];\n  }\n\n  /**\n   * Update the history to show that we are currently playing |newVariant|. If\n   * we are already playing |newVariant|, this update will be ignored.\n   *\n   * @param {shaka.extern.Variant} newVariant\n   * @param {boolean} fromAdaptation\n   */\n  updateCurrentVariant(newVariant, fromAdaptation) {\n    if (this.currentVariant_ == newVariant) {\n      return;\n    }\n\n    this.currentVariant_ = newVariant;\n    this.history_.push({\n      timestamp: this.getNowInSeconds_(),\n      id: newVariant.id,\n      type: 'variant',\n      fromAdaptation: fromAdaptation,\n      bandwidth: newVariant.bandwidth,\n    });\n  }\n\n  /**\n   * Update the history to show that we are currently playing |newText|. If we\n   * are already playing |newText|, this update will be ignored.\n   *\n   * @param {shaka.extern.Stream} newText\n   * @param {boolean} fromAdaptation\n   */\n  updateCurrentText(newText, fromAdaptation) {\n    if (this.currentText_ == newText) {\n      return;\n    }\n\n    this.currentText_ = newText;\n    this.history_.push({\n      timestamp: this.getNowInSeconds_(),\n      id: newText.id,\n      type: 'text',\n      fromAdaptation: fromAdaptation,\n      bandwidth: null,\n    });\n  }\n\n  /**\n   * Get a copy of the switch history. This will make sure to expose no internal\n   * references.\n   *\n   * @return {!Array.<shaka.extern.TrackChoice>}\n   */\n  getCopy() {\n    const copy = [];\n\n    for (const entry of this.history_) {\n      copy.push(this.clone_(entry));\n    }\n\n    return copy;\n  }\n\n  /**\n   * Get the system time in seconds.\n   *\n   * @return {number}\n   * @private\n   */\n  getNowInSeconds_() {\n    return Date.now() / 1000;\n  }\n\n  /**\n   * @param {shaka.extern.TrackChoice} entry\n   * @return {shaka.extern.TrackChoice}\n   * @private\n   */\n  clone_(entry) {\n    return {\n      timestamp: entry.timestamp,\n      id: entry.id,\n      type: entry.type,\n      fromAdaptation: entry.fromAdaptation,\n      bandwidth: entry.bandwidth,\n    };\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Stats');\n\ngoog.require('shaka.util.StateHistory');\ngoog.require('shaka.util.SwitchHistory');\n\n\n/**\n * This class tracks all the various components (some optional) that are used to\n * populate |shaka.extern.Stats| which is passed to the app.\n *\n * @final\n */\nshaka.util.Stats = class {\n  /** */\n  constructor() {\n    /** @private {number} */\n    this.width_ = NaN;\n    /** @private {number} */\n    this.height_ = NaN;\n\n    /** @private {number} */\n    this.totalDroppedFrames_ = NaN;\n    /** @private {number} */\n    this.totalDecodedFrames_ = NaN;\n    /** @private {number} */\n    this.totalCorruptedFrames_ = NaN;\n\n    /** @private {number} */\n    this.completionPercent_ = NaN;\n\n    /** @private {number} */\n    this.loadLatencySeconds_ = NaN;\n\n    /** @private {number} */\n    this.manifestTimeSeconds_ = NaN;\n\n    /** @private {number} */\n    this.drmTimeSeconds_ = NaN;\n\n    /** @private {number} */\n    this.licenseTimeSeconds_ = NaN;\n\n    /** @private {number} */\n    this.liveLatencySeconds_ = NaN;\n\n    /** @private {number} */\n    this.maxSegmentDurationSeconds_ = NaN;\n\n    /** @private {number} */\n    this.currentStreamBandwidth_ = NaN;\n    /** @private {number} */\n    this.bandwidthEstimate_ = NaN;\n\n    /** @private {!shaka.util.StateHistory} */\n    this.stateHistory_ = new shaka.util.StateHistory();\n\n    /** @private {!shaka.util.SwitchHistory} */\n    this.switchHistory_ = new shaka.util.SwitchHistory();\n  }\n\n  /**\n   * Update the ratio of dropped frames to total frames. This will replace the\n   * previous values.\n   *\n   * @param {number} dropped\n   * @param {number} decoded\n   */\n  setDroppedFrames(dropped, decoded) {\n    this.totalDroppedFrames_ = dropped;\n    this.totalDecodedFrames_ = decoded;\n  }\n\n\n  /**\n   * Update corrupted frames. This will replace the previous values.\n   *\n   * @param {number} corrupted\n   */\n  setCorruptedFrames(corrupted) {\n    this.totalCorruptedFrames_ = corrupted;\n  }\n\n  /**\n   * Set the width and height of the video we are currently playing.\n   *\n   * @param {number} width\n   * @param {number} height\n   */\n  setResolution(width, height) {\n    this.width_ = width;\n    this.height_ = height;\n  }\n\n  /**\n   * Record the time it took between the user signalling \"I want to play this\"\n   * to \"I am now seeing this\".\n   *\n   * @param {number} seconds\n   */\n  setLoadLatency(seconds) {\n    this.loadLatencySeconds_ = seconds;\n  }\n\n  /**\n   * Record the time it took to download and parse the manifest.\n   *\n   * @param {number} seconds\n   */\n  setManifestTime(seconds) {\n    this.manifestTimeSeconds_ = seconds;\n  }\n\n  /**\n   * Record the current completion percent. This is the \"high water mark\", so it\n   * will store the highest provided completion percent.\n   *\n   * @param {number} percent\n   */\n  setCompletionPercent(percent) {\n    if (isNaN(this.completionPercent_)) {\n      this.completionPercent_ = percent;\n    } else {\n      this.completionPercent_ = Math.max(this.completionPercent_, percent);\n    }\n  }\n\n  /**\n   * Record the time it took to download the first drm key.\n   *\n   * @param {number} seconds\n   */\n  setDrmTime(seconds) {\n    this.drmTimeSeconds_ = seconds;\n  }\n\n  /**\n   * Record the cumulative time spent on license requests during this session.\n   *\n   * @param {number} seconds\n   */\n  setLicenseTime(seconds) {\n    this.licenseTimeSeconds_ = seconds;\n  }\n\n  /**\n   * Record the latency in live streams.\n   *\n   * @param {number} seconds\n   */\n  setLiveLatency(seconds) {\n    this.liveLatencySeconds_ = seconds;\n  }\n\n  /**\n   * Record the presentation's max segment duration.\n   *\n   * @param {number} seconds\n   */\n  setMaxSegmentDuration(seconds) {\n    this.maxSegmentDurationSeconds_ = seconds;\n  }\n\n  /**\n   * @param {number} bandwidth\n   */\n  setCurrentStreamBandwidth(bandwidth) {\n    this.currentStreamBandwidth_ = bandwidth;\n  }\n\n  /**\n   * @param {number} bandwidth\n   */\n  setBandwidthEstimate(bandwidth) {\n    this.bandwidthEstimate_ = bandwidth;\n  }\n\n  /**\n   * @return {!shaka.util.StateHistory}\n   */\n  getStateHistory() {\n    return this.stateHistory_;\n  }\n\n  /**\n   * @return {!shaka.util.SwitchHistory}\n   */\n  getSwitchHistory() {\n    return this.switchHistory_;\n  }\n\n  /**\n   * Create a stats blob that we can pass up to the app. This blob will not\n   * reference any internal data.\n   *\n   * @return {shaka.extern.Stats}\n   */\n  getBlob() {\n    return {\n      width: this.width_,\n      height: this.height_,\n      streamBandwidth: this.currentStreamBandwidth_,\n      decodedFrames: this.totalDecodedFrames_,\n      droppedFrames: this.totalDroppedFrames_,\n      corruptedFrames: this.totalCorruptedFrames_,\n      estimatedBandwidth: this.bandwidthEstimate_,\n      completionPercent: this.completionPercent_,\n      loadLatency: this.loadLatencySeconds_,\n      manifestTimeSeconds: this.manifestTimeSeconds_,\n      drmTimeSeconds: this.drmTimeSeconds_,\n      playTime: this.stateHistory_.getTimeSpentIn('playing'),\n      pauseTime: this.stateHistory_.getTimeSpentIn('paused'),\n      bufferingTime: this.stateHistory_.getTimeSpentIn('buffering'),\n      licenseTime: this.licenseTimeSeconds_,\n      liveLatency: this.liveLatencySeconds_,\n      maxSegmentDuration: this.maxSegmentDurationSeconds_,\n      stateHistory: this.stateHistory_.getCopy(),\n      switchHistory: this.switchHistory_.getCopy(),\n    };\n  }\n\n  /**\n   * Create an empty stats blob. This resembles the stats when we are not\n   * playing any content.\n   *\n   * @return {shaka.extern.Stats}\n   */\n  static getEmptyBlob() {\n    return {\n      width: NaN,\n      height: NaN,\n      streamBandwidth: NaN,\n      decodedFrames: NaN,\n      droppedFrames: NaN,\n      corruptedFrames: NaN,\n      estimatedBandwidth: NaN,\n      completionPercent: NaN,\n      loadLatency: NaN,\n      manifestTimeSeconds: NaN,\n      drmTimeSeconds: NaN,\n      playTime: NaN,\n      pauseTime: NaN,\n      bufferingTime: NaN,\n      licenseTime: NaN,\n      liveLatency: NaN,\n      maxSegmentDuration: NaN,\n      switchHistory: [],\n      stateHistory: [],\n    };\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.ads.AdsStats');\n\n\n/**\n * This class tracks all the various components (some optional) that are used to\n * populate |shaka.extern.AdsStats| which is passed to the app.\n *\n * @final\n */\nshaka.ads.AdsStats = class {\n  /** */\n  constructor() {\n    /** @private {!Array.<number>} */\n    this.loadTimes_ = [];\n    /** @private {number} */\n    this.started_ = 0;\n    /** @private {number} */\n    this.playedCompletely_ = 0;\n    /** @private {number} */\n    this.skipped_ = 0;\n  }\n\n  /**\n   * Record the time it took to get the final manifest.\n   *\n   * @param {number} seconds\n   */\n  addLoadTime(seconds) {\n    this.loadTimes_.push(seconds);\n  }\n\n  /**\n   * Increase the number of ads started by one.\n   */\n  incrementStarted() {\n    this.started_++;\n  }\n\n  /**\n   * Increase the number of ads played completely by one.\n   */\n  incrementPlayedCompletely() {\n    this.playedCompletely_++;\n  }\n\n  /**\n   * Increase the number of ads skipped by one.\n   */\n  incrementSkipped() {\n    this.skipped_++;\n  }\n\n  /**\n   * Create a stats blob that we can pass up to the app. This blob will not\n   * reference any internal data.\n   *\n   * @return {shaka.extern.AdsStats}\n   */\n  getBlob() {\n    return {\n      loadTimes: this.loadTimes_,\n      started: this.started_,\n      playedCompletely: this.playedCompletely_,\n      skipped: this.skipped_,\n    };\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.ads.ClientSideAd');\n\ngoog.require('shaka.util.EventManager');\n\n\n/**\n * @implements {shaka.extern.IAd}\n * @export\n */\nshaka.ads.ClientSideAd = class {\n  /**\n   * @param {!google.ima.Ad} imaAd\n   * @param {!google.ima.AdsManager} imaAdManager\n   */\n  constructor(imaAd, imaAdManager) {\n    /** @private {google.ima.Ad} */\n    this.ad_ = imaAd;\n\n    /** @private {google.ima.AdsManager} */\n    this.manager_ = imaAdManager;\n\n    /** @private {boolean} */\n    this.isPaused_ = false;\n\n    /** @private {number} */\n    this.volume_ = this.manager_.getVolume();\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    this.eventManager_.listen(this.manager_,\n        google.ima.AdEvent.Type.PAUSED, () => {\n          this.isPaused_ = true;\n        });\n\n    this.eventManager_.listen(this.manager_,\n        google.ima.AdEvent.Type.RESUMED, () => {\n          this.isPaused_ = false;\n        });\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getDuration() {\n    return this.ad_.getDuration();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getMinSuggestedDuration() {\n    return this.ad_.getMinSuggestedDuration();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getRemainingTime() {\n    return this.manager_.getRemainingTime();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isPaused() {\n    return this.isPaused_;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isSkippable() {\n    // IMA returns -1 for non-skippable ads. Any positive number is a genuine\n    // skip offset, meaning the ad is skippable.\n    return this.ad_.getSkipTimeOffset() >= 0;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getTimeUntilSkippable() {\n    const skipOffset = this.ad_.getSkipTimeOffset();\n    const canSkipIn = this.getRemainingTime() - skipOffset;\n    return Math.max(canSkipIn, 0);\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  canSkipNow() {\n    return this.manager_.getAdSkippableState();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  skip() {\n    return this.manager_.skip();\n  }\n\n  /**\n   * @param {boolean} paused\n   */\n  setPaused(paused) {\n    this.isPaused_ = paused;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  pause() {\n    return this.manager_.pause();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  play() {\n    return this.manager_.resume();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getVolume() {\n    return this.manager_.getVolume();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setVolume(volume) {\n    return this.manager_.setVolume(volume);\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isMuted() {\n    return this.manager_.getVolume() == 0;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isLinear() {\n    return this.ad_.isLinear();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  resize(width, height) {\n    const viewMode = document.fullscreenElement ?\n        google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL;\n    this.manager_.resize(width, height, viewMode);\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setMuted(muted) {\n    // Emulate the \"mute\" functionality, where current, pre-mute\n    // volume is saved and can be restored on unmute.\n    if (muted) {\n      this.volume_ = this.getVolume();\n      this.setVolume(0);\n    } else {\n      this.setVolume(this.volume_);\n    }\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getSequenceLength() {\n    const podInfo = this.ad_.getAdPodInfo();\n    if (podInfo == null) {\n      // No pod, just one ad.\n      return 1;\n    }\n\n    return podInfo.getTotalAds();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getPositionInSequence() {\n    const podInfo = this.ad_.getAdPodInfo();\n    if (podInfo == null) {\n      // No pod, just one ad.\n      return 1;\n    }\n\n    return podInfo.getAdPosition();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  release() {\n    this.ad_ = null;\n    this.manager_ = null;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview\n * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed\n */\n\ngoog.provide('shaka.ads.ClientSideAdManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.ads.ClientSideAd');\ngoog.require('shaka.util.IReleasable');\n\n/**\n * A class responsible for client-side ad interactions.\n * @implements {shaka.util.IReleasable}\n */\nshaka.ads.ClientSideAdManager = class {\n  /**\n   * @param {HTMLElement} adContainer\n   * @param {HTMLMediaElement} video\n   * @param {string} locale\n   * @param {function(!shaka.util.FakeEvent)} onEvent\n   */\n  constructor(adContainer, video, locale, onEvent) {\n    /** @private {HTMLElement} */\n    this.adContainer_ = adContainer;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {ResizeObserver} */\n    this.resizeObserver_ = null;\n\n    /** @private {number} */\n    this.requestAdsStartTime_ = NaN;\n\n    /** @private {function(!shaka.util.FakeEvent)} */\n    this.onEvent_ = onEvent;\n\n    /** @private {shaka.ads.ClientSideAd} */\n    this.ad_ = null;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    google.ima.settings.setLocale(locale);\n\n    const adDisplayContainer = new google.ima.AdDisplayContainer(\n        this.adContainer_,\n        this.video_);\n\n    // TODO: IMA: Must be done as the result of a user action on mobile\n    adDisplayContainer.initialize();\n\n    // IMA: This instance should be re-used for the entire lifecycle of\n    // the page.\n    this.adsLoader_ = new google.ima.AdsLoader(adDisplayContainer);\n\n    this.adsLoader_.getSettings().setPlayerType('shaka-player');\n    this.adsLoader_.getSettings().setPlayerVersion(shaka.Player.version);\n\n    /** @private {google.ima.AdsManager} */\n    this.imaAdsManager_ = null;\n\n    this.eventManager_.listenOnce(this.adsLoader_,\n        google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, (e) => {\n          this.onAdsManagerLoaded_(\n              /** @type {!google.ima.AdsManagerLoadedEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.adsLoader_,\n        google.ima.AdErrorEvent.Type.AD_ERROR, (e) => {\n          this.onAdError_( /** @type {!google.ima.AdErrorEvent} */ (e));\n        });\n\n    // Notify the SDK when the video has ended, so it can play post-roll ads.\n    this.eventManager_.listen(this.video_, 'ended', () => {\n      this.adsLoader_.contentComplete();\n    });\n  }\n\n  /**\n   * @param {!google.ima.AdsRequest} imaRequest\n   */\n  requestAds(imaRequest) {\n    goog.asserts.assert(\n        imaRequest.adTagUrl || imaRequest.adsResponse,\n        'The ad tag needs to be set up before requesting ads, ' +\n          'or adsResponse must be filled.');\n    this.requestAdsStartTime_ = Date.now() / 1000;\n    this.adsLoader_.requestAds(imaRequest);\n  }\n\n  /**\n   * Stop all currently playing ads.\n   */\n  stop() {\n    // this.imaAdsManager_ might not be set yet... if, for example, an ad\n    // blocker prevented the ads from ever loading.\n    if (this.imaAdsManager_) {\n      this.imaAdsManager_.stop();\n    }\n    if (this.adContainer_) {\n      shaka.util.Dom.removeAllChildren(this.adContainer_);\n    }\n  }\n\n  /** @override */\n  release() {\n    this.stop();\n    if (this.resizeObserver_) {\n      this.resizeObserver_.disconnect();\n    }\n    if (this.eventManager_) {\n      this.eventManager_.release();\n    }\n    if (this.imaAdsManager_) {\n      this.imaAdsManager_.destroy();\n    }\n    this.adsLoader_.destroy();\n  }\n\n  /**\n   * @param {!google.ima.AdErrorEvent} e\n   * @private\n   */\n  onAdError_(e) {\n    shaka.log.warning(\n        'There was an ad error from the IMA SDK: ' + e.getError());\n    shaka.log.warning('Resuming playback.');\n    this.onAdComplete_(/* adEvent= */ null);\n    // Remove ad breaks from the timeline\n    this.onEvent_(\n        new shaka.util.FakeEvent(shaka.ads.AdManager.CUEPOINTS_CHANGED,\n            (new Map()).set('cuepoints', [])));\n  }\n\n\n  /**\n   * @param {!google.ima.AdsManagerLoadedEvent} e\n   * @private\n   */\n  onAdsManagerLoaded_(e) {\n    goog.asserts.assert(this.video_ != null, 'Video should not be null!');\n\n    const now = Date.now() / 1000;\n    const loadTime = now - this.requestAdsStartTime_;\n    this.onEvent_(new shaka.util.FakeEvent(shaka.ads.AdManager.ADS_LOADED,\n        (new Map()).set('loadTime', loadTime)));\n\n    this.imaAdsManager_ = e.getAdsManager(this.video_);\n\n    this.onEvent_(new shaka.util.FakeEvent(\n        shaka.ads.AdManager.IMA_AD_MANAGER_LOADED,\n        (new Map()).set('imaAdManager', this.imaAdsManager_)));\n\n    const cuePointStarts = this.imaAdsManager_.getCuePoints();\n    if (cuePointStarts.length) {\n      /** @type {!Array.<!shaka.extern.AdCuePoint>} */\n      const cuePoints = [];\n      for (const start of cuePointStarts) {\n        /** @type {shaka.extern.AdCuePoint} */\n        const shakaCuePoint = {\n          start: start,\n          end: null,\n        };\n        cuePoints.push(shakaCuePoint);\n      }\n\n      this.onEvent_(new shaka.util.FakeEvent(\n          shaka.ads.AdManager.CUEPOINTS_CHANGED,\n          (new Map()).set('cuepoints', cuePoints)));\n    }\n\n    this.addImaEventListeners_();\n\n    try {\n      const viewMode = document.fullscreenElement ?\n          google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL;\n\n      this.imaAdsManager_.init(this.video_.offsetWidth,\n          this.video_.offsetHeight, viewMode);\n\n      // Wait on the 'loadeddata' event rather than the 'loadedmetadata' event\n      // because 'loadedmetadata' is sometimes called before the video resizes\n      // on some platforms (e.g. Safari).\n      this.eventManager_.listen(this.video_, 'loadeddata', () => {\n        const viewMode = document.fullscreenElement ?\n            google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL;\n        this.imaAdsManager_.resize(this.video_.offsetWidth,\n            this.video_.offsetHeight, viewMode);\n      });\n\n      if ('ResizeObserver' in window) {\n        this.resizeObserver_ = new ResizeObserver(() => {\n          const viewMode = document.fullscreenElement ?\n              google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL;\n          this.imaAdsManager_.resize(this.video_.offsetWidth,\n              this.video_.offsetHeight, viewMode);\n        });\n        this.resizeObserver_.observe(this.video_);\n      }\n\n      // Single video and overlay ads will start at this time\n      // TODO (ismena): Need a better inderstanding of what this does.\n      // The docs say it's called to 'start playing the ads,' but I haven't\n      // seen the ads actually play until requestAds() is called.\n      // Note: We listen for a play event to avoid autoplay issues that might\n      // crash IMA.\n      this.eventManager_.listenOnce(this.video_, 'play', () => {\n        this.imaAdsManager_.start();\n      });\n    } catch (adError) {\n      // If there was a problem with the VAST response,\n      // we we won't be getting an ad. Hide ad UI if we showed it already\n      // and get back to the presentation.\n      this.onAdComplete_(/* adEvent= */ null);\n    }\n  }\n\n\n  /**\n   * @private\n   */\n  addImaEventListeners_() {\n    /**\n     * @param {!Event} e\n     * @param {string} type\n     */\n    const convertEventAndSend = (e, type) => {\n      const data = (new Map()).set('originalEvent', e);\n      this.onEvent_(new shaka.util.FakeEvent(type, data));\n    };\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdErrorEvent.Type.AD_ERROR, (error) => {\n          this.onAdError_(/** @type {!google.ima.AdErrorEvent} */ (error));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED, (e) => {\n          this.onAdStart_(/** @type {!google.ima.AdEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.STARTED, (e) => {\n          this.onAdStart_(/** @type {!google.ima.AdEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.FIRST_QUARTILE, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_FIRST_QUARTILE);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.MIDPOINT, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_MIDPOINT);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.THIRD_QUARTILE, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_THIRD_QUARTILE);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.COMPLETE, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_COMPLETE);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED, (e) => {\n          this.onAdComplete_(/** @type {!google.ima.AdEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.ALL_ADS_COMPLETED, (e) => {\n          this.onAdComplete_(/** @type {!google.ima.AdEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.SKIPPED, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_SKIPPED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.VOLUME_CHANGED, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_VOLUME_CHANGED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.VOLUME_MUTED, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_MUTED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.PAUSED, (e) => {\n          goog.asserts.assert(this.ad_ != null, 'Ad should not be null!');\n          this.ad_.setPaused(true);\n          convertEventAndSend(e, shaka.ads.AdManager.AD_PAUSED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.RESUMED, (e) => {\n          goog.asserts.assert(this.ad_ != null, 'Ad should not be null!');\n          this.ad_.setPaused(false);\n          convertEventAndSend(e, shaka.ads.AdManager.AD_RESUMED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.SKIPPABLE_STATE_CHANGED, (e) => {\n          goog.asserts.assert(this.ad_ != null, 'Ad should not be null!');\n          convertEventAndSend(e, shaka.ads.AdManager.AD_SKIP_STATE_CHANGED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.CLICK, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_CLICKED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.AD_PROGRESS, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_PROGRESS);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.AD_BUFFERING, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_BUFFERING);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.IMPRESSION, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_IMPRESSION);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.DURATION_CHANGE, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_DURATION_CHANGED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.USER_CLOSE, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_CLOSED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.LOADED, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_LOADED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.ALL_ADS_COMPLETED, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.ALL_ADS_COMPLETED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.LINEAR_CHANGED, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_LINEAR_CHANGED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.AD_METADATA, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_METADATA);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.LOG, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_RECOVERABLE_ERROR);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.AD_BREAK_READY, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_BREAK_READY);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.INTERACTION, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_INTERACTION);\n        });\n  }\n\n  /**\n   * @param {!google.ima.AdEvent} e\n   * @private\n   */\n  onAdStart_(e) {\n    goog.asserts.assert(this.imaAdsManager_,\n        'Should have an ads manager at this point!');\n\n    const imaAd = e.getAd();\n    this.ad_ = new shaka.ads.ClientSideAd(imaAd, this.imaAdsManager_);\n    const data = new Map()\n        .set('ad', this.ad_)\n        .set('sdkAdObject', imaAd)\n        .set('originalEvent', e);\n    this.onEvent_(new shaka.util.FakeEvent(\n        shaka.ads.AdManager.AD_STARTED, data));\n    if (this.ad_.isLinear()) {\n      this.adContainer_.setAttribute('ad-active', 'true');\n      this.video_.pause();\n      this.ad_.setVolume(this.video_.volume);\n      if (this.video_.muted) {\n        this.ad_.setMuted(true);\n      }\n    }\n  }\n\n  /**\n   * @param {?google.ima.AdEvent} e\n   * @private\n   */\n  onAdComplete_(e) {\n    this.onEvent_(new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STOPPED,\n        (new Map()).set('originalEvent', e)));\n    if (this.ad_ && this.ad_.isLinear()) {\n      this.adContainer_.removeAttribute('ad-active');\n      if (!this.video_.ended) {\n        this.video_.play();\n      }\n    }\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.ads.AdManager');\n\ngoog.require('shaka.Player');\ngoog.require('shaka.ads.AdsStats');\ngoog.require('shaka.ads.ClientSideAdManager');\ngoog.require('shaka.ads.ServerSideAdManager');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IReleasable');\n\n\n/**\n * @event shaka.ads.AdManager.AdsLoadedEvent\n * @description Fired when a sequence of ads has been loaded.\n * @property {string} type\n *   'ads-loaded'\n * @property {number} loadTime\n *    The time it takes to load ads.\n * @exportDoc\n */\n\n/**\n * @event shaka.ads.AdManager.AdStartedEvent\n * @description Fired when an ad has started playing.\n * @property {string} type\n *   'ad-started'\n * @property {!shaka.extern.IAd} ad\n *    The ad that has started playing.\n * @property {Object} sdkAdObject\n *    The ad object in the SDK format, if there is one.\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdCompleteEvent\n * @description Fired when an ad has played through.\n * @property {string} type\n *   'ad-complete'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdSkippedEvent\n * @description Fired when an ad has been skipped.\n * @property {string} type\n *   'ad-skipped'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdFirstQuartileEvent\n * @description Fired when an ad has played through the first 1/4.\n * @property {string} type\n *   'ad-first-quartile'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdMidpointEvent\n * @description Fired when an ad has played through its midpoint.\n * @property {string} type\n *   'ad-midpoint'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdThirdQuartileEvent\n * @description Fired when an ad has played through the third quartile.\n * @property {string} type\n *   'ad-third-quartile'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdStoppedEvent\n * @description Fired when an ad has stopped playing, was skipped,\n *   or was unable to proceed due to an error.\n * @property {string} type\n *   'ad-stopped'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdVolumeChangedEvent\n * @description Fired when an ad's volume changed.\n * @property {string} type\n *   'ad-volume-changed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdMutedEvent\n * @description Fired when an ad was muted.\n * @property {string} type\n *   'ad-muted'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdPausedEvent\n * @description Fired when an ad was paused.\n * @property {string} type\n *   'ad-paused'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdResumedEvent\n * @description Fired when an ad was resumed after a pause.\n * @property {string} type\n *   'ad-resumed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdSkipStateChangedEvent\n * @description Fired when an ad's skip state changes (for example, when\n *  it becomes possible to skip the ad).\n * @property {string} type\n *   'ad-skip-state-changed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdResumedEvent\n * @description Fired when the ad cue points change, signalling ad breaks\n *  change.\n * @property {string} type\n *   'ad-cue-points-changed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdProgressEvent\n * @description Fired when there is an update to the current ad's progress.\n * @property {string} type\n *   'ad-progress'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdBufferingEvent\n * @description Fired when the ad has stalled playback to buffer.\n * @property {string} type\n *   'ad-buffering'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdImpressionEvent\n * @description Fired when the impression URL has been pinged.\n * @property {string} type\n *   'ad-impression'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdClickEvent\n * @description Fired when the ad was clicked.\n * @property {string} type\n *   'ad-clicked'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdDurationChangedEvent\n * @description Fired when the ad's duration changes.\n * @property {string} type\n *   'ad-duration-changed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdClosedEvent\n * @description Fired when the ad was closed by the user.\n * @property {string} type\n *   'ad-closed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdLoadedEvent\n * @description Fired when the ad data becomes available.\n * @property {string} type\n *   'ad-loaded'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AllAdsCompletedEvent\n * @description Fired when the ads manager is done playing all the ads.\n * @property {string} type\n *   'all-ads-completed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdLinearChangedEvent\n * @description Fired when the displayed ad changes from\n *   linear to nonlinear, or vice versa.\n * @property {string} type\n *   'ad-linear-changed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdMetadataEvent\n * @description Fired when the ad's metadata becomes available.\n * @property {string} type\n *   'ad-metadata'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager#AdBreakReadyEvent\n * @description Fired when the client-side SDK is ready to play a\n *   VPAID ad or an ad rule.\n * @property {string} type\n *   'ad-break-ready'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdRecoverableErrorEvent\n * @description Fired when the a non-fatal error was encountered.\n *   The presentation will continue with the same or next ad playback\n *   depending on the error situation.\n * @property {string} type\n *   'ad-recoverable-error'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdInteractionEvent\n * @description Fired when an ad triggers the interaction callback.\n * @property {string} type\n *   'ad-interaction'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager#ImaAdManagerLoadedEvent\n * @description Fired when the native IMA ad manager becomes available.\n * @property {string} type\n *   'ima-ad-manager-loaded'\n * @property {!Object} imaAdManager\n *    The native IMA ad manager.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager#ImaStreamManagerLoadedEvent\n * @description Fired when the native IMA stream manager becomes available.\n * @property {string} type\n *   'ima-stream-manager-loaded'\n * @property {!Object} imaStreamManager\n *    The native IMA stream manager.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdClickedEvent\n * @description Fired when the ad was clicked.\n * @property {string} type\n *   'ad-clicked'\n * @exportDoc\n */\n\n\n/**\n * A class responsible for ad-related interactions.\n * @implements {shaka.extern.IAdManager}\n * @implements {shaka.util.IReleasable}\n * @export\n */\nshaka.ads.AdManager = class extends shaka.util.FakeEventTarget {\n  /** */\n  constructor() {\n    super();\n    /** @private {shaka.ads.ClientSideAdManager} */\n    this.csAdManager_ = null;\n    /** @private {shaka.ads.ServerSideAdManager} */\n    this.ssAdManager_ = null;\n    /** @private {shaka.ads.AdsStats} */\n    this.stats_ = new shaka.ads.AdsStats();\n    /** @private {string} locale */\n    this.locale_ = navigator.language;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  setLocale(locale) {\n    this.locale_ = locale;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  initClientSide(adContainer, video) {\n    // Check that Client Side IMA SDK has been included\n    // NOTE: (window['google'] && google.ima) check for any\n    // IMA SDK, including SDK for Server Side ads.\n    // The 3rd check insures we have the right SDK:\n    // {google.ima.AdsLoader} is an object that's part of CS IMA SDK\n    // but not SS SDK.\n    if (!window['google'] || !google.ima || !google.ima.AdsLoader) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.CS_IMA_SDK_MISSING);\n    }\n\n    if (this.csAdManager_) {\n      this.csAdManager_.release();\n    }\n\n    this.csAdManager_ = new shaka.ads.ClientSideAdManager(\n        adContainer, video, this.locale_,\n        (e) => {\n          const event = /** @type {!shaka.util.FakeEvent} */ (e);\n          if (event && event.type) {\n            switch (event.type) {\n              case shaka.ads.AdManager.ADS_LOADED: {\n                const loadTime = (/** @type {!Object} */ (e))['loadTime'];\n                this.stats_.addLoadTime(loadTime);\n                break;\n              }\n              case shaka.ads.AdManager.AD_STARTED:\n                this.stats_.incrementStarted();\n                break;\n              case shaka.ads.AdManager.AD_COMPLETE:\n                this.stats_.incrementPlayedCompletely();\n                break;\n              case shaka.ads.AdManager.AD_SKIPPED:\n                this.stats_.incrementSkipped();\n                break;\n            }\n          }\n          this.dispatchEvent(event);\n        });\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  release() {\n    if (this.csAdManager_) {\n      this.csAdManager_.release();\n      this.csAdManager_ = null;\n    }\n    if (this.ssAdManager_) {\n      this.ssAdManager_.release();\n      this.ssAdManager_ = null;\n    }\n    super.release();\n  }\n\n\n  /**\n  * @override\n  * @export\n  */\n  onAssetUnload() {\n    if (this.csAdManager_) {\n      this.csAdManager_.stop();\n    }\n    if (this.ssAdManager_) {\n      this.ssAdManager_.stop();\n    }\n\n    this.dispatchEvent(\n        new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STOPPED));\n\n    this.stats_ = new shaka.ads.AdsStats();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  requestClientSideAds(imaRequest) {\n    if (!this.csAdManager_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.CS_AD_MANAGER_NOT_INITIALIZED);\n    }\n\n    this.csAdManager_.requestAds(imaRequest);\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  initServerSide(adContainer, video) {\n    // Check that Client Side IMA SDK has been included\n    // NOTE: (window['google'] && google.ima) check for any\n    // IMA SDK, including SDK for Server Side ads.\n    // The 3rd check insures we have the right SDK:\n    // {google.ima.dai} is an object that's part of DAI IMA SDK\n    // but not SS SDK.\n    if (!window['google'] || !google.ima || !google.ima.dai) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.SS_IMA_SDK_MISSING);\n    }\n\n    if (this.ssAdManager_) {\n      this.ssAdManager_.release();\n    }\n\n    this.ssAdManager_ = new shaka.ads.ServerSideAdManager(\n        adContainer, video, this.locale_,\n        (e) => {\n          const event = /** @type {!shaka.util.FakeEvent} */ (e);\n          if (event && event.type) {\n            switch (event.type) {\n              case shaka.ads.AdManager.ADS_LOADED: {\n                const loadTime = (/** @type {!Object} */ (e))['loadTime'];\n                this.stats_.addLoadTime(loadTime);\n                break;\n              }\n              case shaka.ads.AdManager.AD_STARTED:\n                this.stats_.incrementStarted();\n                break;\n              case shaka.ads.AdManager.AD_COMPLETE:\n                this.stats_.incrementPlayedCompletely();\n                break;\n              case shaka.ads.AdManager.AD_SKIPPED:\n                this.stats_.incrementSkipped();\n                break;\n            }\n          }\n          this.dispatchEvent(event);\n        });\n  }\n\n\n  /**\n   * @param {!google.ima.dai.api.StreamRequest} imaRequest\n   * @param {string=} backupUrl\n   * @return {!Promise.<string>}\n   * @override\n   * @export\n   */\n  requestServerSideStream(imaRequest, backupUrl = '') {\n    if (!this.ssAdManager_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.SS_AD_MANAGER_NOT_INITIALIZED);\n    }\n\n    if (!imaRequest.adTagParameters) {\n      imaRequest.adTagParameters = {};\n    }\n    const adTagParams = imaRequest.adTagParameters;\n\n    if (adTagParams['mpt'] || adTagParams['mpv']) {\n      shaka.log.alwaysWarn('You have attempted to set \"mpt\" and/or \"mpv\" ' +\n        'parameters of the ad tag. Please note that those parameters are ' +\n        'used for Shaka adoption tracking and will be overriden.');\n    }\n\n    // Set player and version parameters for tracking\n    imaRequest.adTagParameters['mpt'] = 'shaka-player';\n    imaRequest.adTagParameters['mpv'] = shaka.Player.version;\n    return this.ssAdManager_.streamRequest(imaRequest, backupUrl);\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  replaceServerSideAdTagParameters(adTagParameters) {\n    if (!this.ssAdManager_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.SS_AD_MANAGER_NOT_INITIALIZED);\n    }\n\n    if (adTagParameters['mpt'] || adTagParameters['mpv']) {\n      shaka.log.alwaysWarn('You have attempted to set \"mpt\" and/or \"mpv\" ' +\n        'parameters of the ad tag. Please note that those parameters are ' +\n        'used for Shaka adoption tracking and will be overriden.');\n    }\n\n    adTagParameters['mpt'] = 'Shaka Player';\n    adTagParameters['mpv'] = shaka.Player.version;\n\n    this.ssAdManager_.replaceAdTagParameters(adTagParameters);\n  }\n\n\n  /**\n   * @return {!Array.<!shaka.extern.AdCuePoint>}\n   * @override\n   * @export\n   */\n  getServerSideCuePoints() {\n    if (!this.ssAdManager_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.SS_AD_MANAGER_NOT_INITIALIZED);\n    }\n    return this.ssAdManager_.getCuePoints();\n  }\n\n\n  /**\n   * @return {shaka.extern.AdsStats}\n   * @override\n   * @export\n   */\n  getStats() {\n    return this.stats_.getBlob();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  onDashTimedMetadata(region) {\n    if (this.ssAdManager_ && region.schemeIdUri == 'urn:google:dai:2018') {\n      const type = region.schemeIdUri;\n      const data = region.eventElement ?\n          region.eventElement.getAttribute('messageData') : null;\n      const timestamp = region.startTime;\n      this.ssAdManager_.onTimedMetadata(type, data, timestamp);\n    }\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  onHlsTimedMetadata(metadata, timestamp) {\n    if (this.ssAdManager_) {\n      this.ssAdManager_.onTimedMetadata('ID3', metadata['data'], timestamp);\n    } else {\n      shaka.log.warning('ID3 metadata processing was called without ' +\n        'initializing server side ad logic. Ad-related metadata will ' +\n        'not take effect');\n    }\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  onCueMetadataChange(value) {\n    if (this.ssAdManager_) {\n      this.ssAdManager_.onCueMetadataChange(value);\n    } else {\n      shaka.log.warning('ID3 metadata processing was called without ' +\n        'initializing server side ad logic. Ad-related metadata will ' +\n        'not take effect');\n    }\n  }\n};\n\n/**\n * The event name for when a sequence of ads has been loaded.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.ADS_LOADED = 'ads-loaded';\n\n/**\n * The event name for when an ad has started playing.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_STARTED = 'ad-started';\n\n\n/**\n * The event name for when an ad playhead crosses first quartile.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_FIRST_QUARTILE = 'ad-first-quartile';\n\n\n/**\n * The event name for when an ad playhead crosses midpoint.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_MIDPOINT = 'ad-midpoint';\n\n\n/**\n * The event name for when an ad playhead crosses third quartile.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_THIRD_QUARTILE = 'ad-third-quartile';\n\n\n/**\n * The event name for when an ad has completed playing.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_COMPLETE = 'ad-complete';\n\n\n/**\n * The event name for when an ad has finished playing\n * (played all the way through, was skipped, or was unable to proceed\n * due to an error).\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_STOPPED = 'ad-stopped';\n\n\n/**\n * The event name for when an ad is skipped by the user..\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_SKIPPED = 'ad-skipped';\n\n\n/**\n * The event name for when the ad volume has changed.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_VOLUME_CHANGED = 'ad-volume-changed';\n\n\n/**\n * The event name for when the ad was muted.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_MUTED = 'ad-muted';\n\n\n/**\n * The event name for when the ad was paused.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_PAUSED = 'ad-paused';\n\n\n/**\n * The event name for when the ad was resumed after a pause.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_RESUMED = 'ad-resumed';\n\n\n/**\n * The event name for when the ad's skip status changes\n * (usually it becomes skippable when it wasn't before).\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_SKIP_STATE_CHANGED = 'ad-skip-state-changed';\n\n\n/**\n * The event name for when the ad's cue points (start/end markers)\n * have changed.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.CUEPOINTS_CHANGED = 'ad-cue-points-changed';\n\n\n/**\n * The event name for when the native IMA ad manager object has\n * loaded and become available.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.IMA_AD_MANAGER_LOADED = 'ima-ad-manager-loaded';\n\n\n/**\n * The event name for when the native IMA stream manager object has\n * loaded and become available.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.IMA_STREAM_MANAGER_LOADED = 'ima-stream-manager-loaded';\n\n\n/**\n * The event name for when the ad was clicked.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_CLICKED = 'ad-clicked';\n\n\n/**\n * The event name for when there is an update to the current ad's progress.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_PROGRESS = 'ad-progress';\n\n\n/**\n * The event name for when the ad is buffering.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_BUFFERING = 'ad-buffering';\n\n\n/**\n * The event name for when the ad's URL was hit.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_IMPRESSION = 'ad-impression';\n\n\n/**\n * The event name for when the ad's duration changed.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_DURATION_CHANGED = 'ad-duration-changed';\n\n\n/**\n * The event name for when the ad was closed by the user.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_CLOSED = 'ad-closed';\n\n\n/**\n * The event name for when the ad data becomes available.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_LOADED = 'ad-loaded';\n\n\n/**\n * The event name for when all the ads were completed.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.ALL_ADS_COMPLETED = 'all-ads-completed';\n\n\n/**\n * The event name for when the ad changes from or to linear.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_LINEAR_CHANGED = 'ad-linear-changed';\n\n\n/**\n * The event name for when the ad's metadata becomes available.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_METADATA = 'ad-metadata';\n\n\n/**\n * The event name for when the ad display encountered a recoverable\n * error.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_RECOVERABLE_ERROR = 'ad-recoverable-error';\n\n\n/**\n * The event name for when the client side SDK signalled its readiness\n * to play a VPAID ad or an ad rule.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_BREAK_READY = 'ad-break-ready';\n\n\n/**\n * The event name for when the interaction callback for the ad was\n * triggered.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_INTERACTION = 'ad-interaction';\n\n\n/**\n * Set this is a default ad manager for the player.\n * Apps can also set their own ad manager, if they'd like.\n */\nshaka.Player.setAdManagerFactory(() => new shaka.ads.AdManager());\n\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.ads.ServerSideAd');\n\n/**\n * @implements {shaka.extern.IAd}\n * @export\n */\nshaka.ads.ServerSideAd = class {\n  /**\n   * @param {google.ima.dai.api.Ad} imaAd\n   * @param {HTMLMediaElement} video\n   */\n  constructor(imaAd, video) {\n    /** @private {google.ima.dai.api.Ad} */\n    this.ad_ = imaAd;\n\n    /** @private {?google.ima.dai.api.AdProgressData} */\n    this.adProgressData_ = null;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n  }\n\n\n  /**\n   * @param {google.ima.dai.api.AdProgressData} data\n   */\n  setProgressData(data) {\n    this.adProgressData_ = data;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getDuration() {\n    if (!this.adProgressData_) {\n      // Unknown yet\n      return -1;\n    }\n    return this.adProgressData_.duration;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getMinSuggestedDuration() {\n    return this.getDuration();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getRemainingTime() {\n    if (!this.adProgressData_) {\n      // Unknown yet\n      return -1;\n    }\n\n    return this.adProgressData_.duration - this.adProgressData_.currentTime;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isPaused() {\n    return this.video_.paused;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isSkippable() {\n    return this.ad_.isSkippable();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getTimeUntilSkippable() {\n    const skipOffset = this.ad_.getSkipTimeOffset();\n    const canSkipIn = this.getRemainingTime() - skipOffset;\n    return Math.max(canSkipIn, 0);\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  canSkipNow() {\n    return this.getTimeUntilSkippable() == 0;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  skip() {\n    this.video_.currentTime += this.getRemainingTime();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  pause() {\n    return this.video_.pause();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  play() {\n    return this.video_.play();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getVolume() {\n    return this.video_.volume;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setVolume(volume) {\n    this.video_.volume = volume;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isMuted() {\n    return this.video_.muted;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isLinear() {\n    return true;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  resize(width, height) {\n    // Nothing\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setMuted(muted) {\n    this.video_.muted = muted;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getSequenceLength() {\n    const podInfo = this.ad_.getAdPodInfo();\n    if (podInfo == null) {\n      // No pod, just one ad.\n      return 1;\n    }\n\n    return podInfo.getTotalAds();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getPositionInSequence() {\n    const podInfo = this.ad_.getAdPodInfo();\n    if (podInfo == null) {\n      // No pod, just one ad.\n      return 1;\n    }\n\n    return podInfo.getAdPosition();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  release() {\n    this.ad_ = null;\n    this.adProgressData_ = null;\n    this.video_ = null;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview\n * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed\n */\n\ngoog.provide('shaka.ads.ServerSideAdManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.ads.ServerSideAd');\ngoog.require('shaka.log');\ngoog.require('shaka.util.IReleasable');\n\n\n/**\n * A class responsible for server-side ad interactions.\n * @implements {shaka.util.IReleasable}\n */\nshaka.ads.ServerSideAdManager = class {\n  /**\n   * @param {HTMLElement} adContainer\n   * @param {HTMLMediaElement} video\n   * @param {string} locale\n   * @param {function(!shaka.util.FakeEvent)} onEvent\n   */\n  constructor(adContainer, video, locale, onEvent) {\n    /** @private {HTMLElement} */\n    this.adContainer_ = adContainer;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private\n        {?shaka.util.PublicPromise.<string>} */\n    this.streamPromise_ = null;\n\n    /** @private {number} */\n    this.streamRequestStartTime_ = NaN;\n\n    /** @private {function(!shaka.util.FakeEvent)} */\n    this.onEvent_ = onEvent;\n\n    /** @private {boolean} */\n    this.isLiveContent_ = false;\n\n    /**\n     * Time to seek to after an ad if that ad was played as the result of\n     * snapback.\n     * @private {?number}\n     */\n    this.snapForwardTime_ = null;\n\n    /** @private {shaka.ads.ServerSideAd} */\n    this.ad_ = null;\n\n    /** @private {?google.ima.dai.api.AdProgressData} */\n    this.adProgressData_ = null;\n\n    /** @private {string} */\n    this.backupUrl_ = '';\n\n    /** @private {!Array.<!shaka.extern.AdCuePoint>} */\n    this.currentCuePoints_ = [];\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {google.ima.dai.api.UiSettings} */\n    const uiSettings = new google.ima.dai.api.UiSettings();\n    uiSettings.setLocale(locale);\n\n    /** @private {google.ima.dai.api.StreamManager} */\n    this.streamManager_ = new google.ima.dai.api.StreamManager(\n        this.video_, this.adContainer_, uiSettings);\n\n    this.onEvent_(new shaka.util.FakeEvent(\n        shaka.ads.AdManager.IMA_STREAM_MANAGER_LOADED,\n        (new Map()).set('imaStreamManager', this.streamManager_)));\n\n    // Events\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.LOADED, (e) => {\n          shaka.log.info('Ad SS Loaded');\n          this.onLoaded_(\n              /** @type {!google.ima.dai.api.StreamEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.ERROR, () => {\n          shaka.log.info('Ad SS Error');\n          this.onError_();\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.AD_BREAK_STARTED, () => {\n          shaka.log.info('Ad Break Started');\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.STARTED, (e) => {\n          shaka.log.info('Ad Started');\n          this.onAdStart_(/** @type {!google.ima.dai.api.StreamEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.AD_BREAK_ENDED, () => {\n          shaka.log.info('Ad Break Ended');\n          this.onAdBreakEnded_();\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.AD_PROGRESS, (e) => {\n          this.onAdProgress_(\n              /** @type {!google.ima.dai.api.StreamEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.FIRST_QUARTILE, () => {\n          shaka.log.info('Ad event: First Quartile');\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_FIRST_QUARTILE));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.MIDPOINT, () => {\n          shaka.log.info('Ad event: Midpoint');\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_MIDPOINT));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.THIRD_QUARTILE, () => {\n          shaka.log.info('Ad event: Third Quartile');\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_THIRD_QUARTILE));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.COMPLETE, () => {\n          shaka.log.info('Ad event: Complete');\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_COMPLETE));\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STOPPED));\n          this.adContainer_.removeAttribute('ad-active');\n          this.ad_ = null;\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.SKIPPED, () => {\n          shaka.log.info('Ad event: Skipped');\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_SKIPPED));\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STOPPED));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.CUEPOINTS_CHANGED, (e) => {\n          shaka.log.info('Ad event: Cue points changed');\n          this.onCuePointsChanged_(\n              /** @type {!google.ima.dai.api.StreamEvent} */ (e));\n        });\n  }\n\n  /**\n   * @param {!google.ima.dai.api.StreamRequest} streamRequest\n   * @param {string=} backupUrl\n   * @return {!Promise.<string>}\n   */\n  streamRequest(streamRequest, backupUrl) {\n    if (this.streamPromise_) {\n      return Promise.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.CURRENT_DAI_REQUEST_NOT_FINISHED));\n    }\n    if (streamRequest instanceof google.ima.dai.api.LiveStreamRequest) {\n      this.isLiveContent_ = true;\n    }\n\n    this.streamPromise_ = new shaka.util.PublicPromise();\n    this.streamManager_.requestStream(streamRequest);\n    this.backupUrl_ = backupUrl || '';\n\n    this.streamRequestStartTime_ = Date.now() / 1000;\n\n    return this.streamPromise_;\n  }\n\n  /**\n   * @param {Object} adTagParameters\n   */\n  replaceAdTagParameters(adTagParameters) {\n    this.streamManager_.replaceAdTagParameters(adTagParameters);\n  }\n\n  /**\n   * Resets the stream manager and removes any continuous polling.\n   */\n  stop() {\n    // TODO:\n    // For SS DAI streams, if a different asset gets unloaded as\n    // part of the process\n    // of loading a DAI asset, stream manager state gets reset and we\n    // don't get any ad events.\n    // We need to figure out if it makes sense to stop the SS\n    // manager on unload, and, if it does, find\n    // a way to do it safely.\n    // this.streamManager_.reset();\n    this.backupUrl_ = '';\n    this.snapForwardTime_ = null;\n    this.currentCuePoints_ = [];\n  }\n\n  /** @override */\n  release() {\n    this.stop();\n    if (this.eventManager_) {\n      this.eventManager_.release();\n    }\n  }\n\n  /**\n   * @param {string} type\n   * @param {Uint8Array|string} data\n   *   Comes as string in DASH and as Uint8Array in HLS.\n   * @param {number} timestamp (in seconds)\n   */\n  onTimedMetadata(type, data, timestamp) {\n    this.streamManager_.processMetadata(type, data, timestamp);\n  }\n\n  /**\n   * @param {shaka.extern.ID3Metadata} value\n   */\n  onCueMetadataChange(value) {\n    // Native HLS over Safari/iOS/iPadOS\n    // For live event streams, the stream needs some way of informing the SDK\n    // that an ad break is coming up or ending. In the IMA DAI SDK, this is\n    // done through timed metadata. Timed metadata is carried as part of the\n    // DAI stream content and carries ad break timing information used by the\n    // SDK to track ad breaks.\n    if (value['key'] && value['data']) {\n      const metadata = {};\n      metadata[value['key']] = value['data'];\n      this.streamManager_.onTimedMetadata(metadata);\n    }\n  }\n\n  /**\n   * @return {!Array.<!shaka.extern.AdCuePoint>}\n   */\n  getCuePoints() {\n    return this.currentCuePoints_;\n  }\n\n  /**\n   * If a seek jumped over the ad break, return to the start of the\n   * ad break, then complete the seek after the ad played through.\n   * @private\n   */\n  checkForSnapback_() {\n    const currentTime = this.video_.currentTime;\n    if (currentTime == 0) {\n      return;\n    }\n\n    this.streamManager_.streamTimeForContentTime(currentTime);\n    const previousCuePoint =\n        this.streamManager_.previousCuePointForStreamTime(currentTime);\n    // The cue point gets marked as 'played' as soon as the playhead hits it\n    // (at the start of an ad), so when we come back to this method as a result\n    // of seeking back to the user-selected time, the 'played' flag will be set.\n    if (previousCuePoint && !previousCuePoint.played) {\n      shaka.log.info('Seeking back to the start of the ad break at ' +\n          previousCuePoint.start + ' and will return to ' + currentTime);\n      this.snapForwardTime_ = currentTime;\n      this.video_.currentTime = previousCuePoint.start;\n    }\n  }\n\n  /**\n   * @param {!google.ima.dai.api.StreamEvent} e\n   * @private\n   */\n  onAdStart_(e) {\n    goog.asserts.assert(this.streamManager_,\n        'Should have a stream manager at this point!');\n\n    const imaAd = e.getAd();\n    this.ad_ = new shaka.ads.ServerSideAd(imaAd, this.video_);\n\n    // Ad object and ad progress data come from two different IMA events.\n    // It's a race, and we don't know, which one will fire first - the\n    // event that contains an ad object (AD_STARTED) or the one that\n    // contains ad progress info (AD_PROGRESS).\n    // If the progress event fired first, we must've saved the progress\n    // info and can now add it to the ad object.\n    if (this.adProgressData_) {\n      this.ad_.setProgressData(this.adProgressData_);\n    }\n\n    this.onEvent_(new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STARTED,\n        (new Map()).set('ad', this.ad_)));\n    this.adContainer_.setAttribute('ad-active', 'true');\n  }\n\n  /**\n   * @private\n   */\n  onAdBreakEnded_() {\n    this.adContainer_.removeAttribute('ad-active');\n    const currentTime = this.video_.currentTime;\n    // If the ad break was a result of snapping back (a user seeked over\n    // an ad break and was returned to it), seek forward to the point,\n    // originally chosen by the user.\n    if (this.snapForwardTime_ && this.snapForwardTime_ > currentTime) {\n      this.video_.currentTime = this.snapForwardTime_;\n      this.snapForwardTime_ = null;\n    }\n  }\n\n  /**\n   * @param {!google.ima.dai.api.StreamEvent} e\n   * @private\n   */\n  onLoaded_(e) {\n    const now = Date.now() / 1000;\n    const loadTime = now - this.streamRequestStartTime_;\n    this.onEvent_(new shaka.util.FakeEvent(shaka.ads.AdManager.ADS_LOADED,\n        (new Map()).set('loadTime', loadTime)));\n\n    const streamData = e.getStreamData();\n    const url = streamData.url;\n    this.streamPromise_.resolve(url);\n    this.streamPromise_ = null;\n\n    if (!this.isLiveContent_) {\n      this.eventManager_.listen(this.video_, 'seeked', () => {\n        this.checkForSnapback_();\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  onError_() {\n    if (!this.backupUrl_.length) {\n      this.streamPromise_.reject('IMA Stream request returned an error ' +\n          'and there was no backup asset uri provided.');\n      this.streamPromise_ = null;\n      return;\n    }\n\n    shaka.log.warning('IMA stream request returned an error. ' +\n        'Falling back to the backup asset uri.');\n    this.streamPromise_.resolve(this.backupUrl_);\n    this.streamPromise_ = null;\n  }\n\n\n  /**\n   * @param {!google.ima.dai.api.StreamEvent} e\n   * @private\n   */\n  onAdProgress_(e) {\n    const streamData = e.getStreamData();\n    const adProgressData = streamData.adProgressData;\n    this.adProgressData_ = adProgressData;\n    if (this.ad_) {\n      this.ad_.setProgressData(this.adProgressData_);\n    }\n  }\n\n\n  /**\n   * @param {!google.ima.dai.api.StreamEvent} e\n   * @private\n   */\n  onCuePointsChanged_(e) {\n    const streamData = e.getStreamData();\n\n    /** @type {!Array.<!shaka.extern.AdCuePoint>} */\n    const cuePoints = [];\n    for (const point of streamData.cuepoints) {\n      /** @type {shaka.extern.AdCuePoint} */\n      const shakaCuePoint = {\n        start: point.start,\n        end: point.end,\n      };\n      cuePoints.push(shakaCuePoint);\n    }\n\n    this.currentCuePoints_ = cuePoints;\n\n    this.onEvent_(new shaka.util.FakeEvent(\n        shaka.ads.AdManager.CUEPOINTS_CHANGED,\n        (new Map()).set('cuepoints', cuePoints)));\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cast.CastUtils');\n\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.util.FakeEvent');\n\n\n/**\n * @summary A set of cast utility functions and variables shared between sender\n *   and receiver.\n */\nshaka.cast.CastUtils = class {\n  /**\n   * Serialize as JSON, but specially encode things JSON will not otherwise\n   * represent.\n   * @param {?} thing\n   * @return {string}\n   */\n  static serialize(thing) {\n    return JSON.stringify(thing, (key, value) => {\n      if (typeof value == 'function') {\n        // Functions can't be (safely) serialized.\n        return undefined;\n      }\n\n      if (value instanceof Event || value instanceof shaka.util.FakeEvent) {\n        // Events don't serialize to JSON well because of the DOM objects\n        // and other complex objects they contain, so we strip these out.\n        // Note that using Object.keys or JSON.stringify directly on the event\n        // will not capture its properties.  We must use a for loop.\n        const simpleEvent = {};\n        for (const eventKey in value) {\n          const eventValue = value[eventKey];\n          if (eventValue && typeof eventValue == 'object') {\n            if (eventKey == 'detail') {\n              // Keep the detail value, because it contains important\n              // information for diagnosing errors.\n              simpleEvent[eventKey] = eventValue;\n            }\n            // Strip out non-null object types because they are complex and we\n            // don't need them.\n          } else if (eventKey in Event) {\n            // Strip out keys that are found on Event itself because they are\n            // class-level constants we don't need, like Event.MOUSEMOVE == 16.\n          } else {\n            simpleEvent[eventKey] = eventValue;\n          }\n        }\n        return simpleEvent;\n      }\n\n      if (value instanceof Error) {\n        // Errors don't serialize to JSON well, either.  TypeError, for example,\n        // turns in \"{}\", leading to messages like \"Error UNKNOWN.UNKNOWN\" when\n        // deserialized on the sender and displayed in the demo app.\n        return shaka.cast.CastUtils.unpackError_(value);\n      }\n\n      if (value instanceof TimeRanges) {\n        // TimeRanges must be unpacked into plain data for serialization.\n        return shaka.cast.CastUtils.unpackTimeRanges_(value);\n      }\n\n      if (value instanceof Uint8Array) {\n        // Some of our code cares about Uint8Arrays actually being Uint8Arrays,\n        // so this gives them special treatment.\n        return shaka.cast.CastUtils.unpackUint8Array_(value);\n      }\n\n      if (typeof value == 'number') {\n        // NaN and infinity cannot be represented directly in JSON.\n        if (isNaN(value)) {\n          return 'NaN';\n        }\n        if (isFinite(value)) {\n          return value;\n        }\n        if (value < 0) {\n          return '-Infinity';\n        }\n        return 'Infinity';\n      }\n\n      return value;\n    });\n  }\n\n\n  /**\n   * Deserialize JSON using our special encodings.\n   * @param {string} str\n   * @return {?}\n   */\n  static deserialize(str) {\n    return JSON.parse(str, (key, value) => {\n      if (value == 'NaN') {\n        return NaN;\n      } else if (value == '-Infinity') {\n        return -Infinity;\n      } else if (value == 'Infinity') {\n        return Infinity;\n      } else if (value && typeof value == 'object' &&\n                 value['__type__'] == 'TimeRanges') {\n        // TimeRanges objects have been unpacked and sent as plain data.\n        // Simulate the original TimeRanges object.\n        return shaka.cast.CastUtils.simulateTimeRanges_(value);\n      } else if (value && typeof value == 'object' &&\n                 value['__type__'] == 'Uint8Array') {\n        return shaka.cast.CastUtils.makeUint8Array_(value);\n      } else if (value && typeof value == 'object' &&\n                 value['__type__'] == 'Error') {\n        return shaka.cast.CastUtils.makeError_(value);\n      }\n      return value;\n    });\n  }\n\n\n  /**\n   * @param {!TimeRanges} ranges\n   * @return {!Object}\n   * @private\n   */\n  static unpackTimeRanges_(ranges) {\n    const obj = {\n      '__type__': 'TimeRanges',  // a signal to deserialize\n      'length': ranges.length,\n      'start': [],\n      'end': [],\n    };\n\n    const TimeRangesUtils = shaka.media.TimeRangesUtils;\n    for (const {start, end} of TimeRangesUtils.getBufferedInfo(ranges)) {\n      obj['start'].push(start);\n      obj['end'].push(end);\n    }\n\n    return obj;\n  }\n\n\n  /**\n   * Creates a simulated TimeRanges object from data sent by the cast receiver.\n   * @param {?} obj\n   * @return {{\n   *   length: number,\n   *   start: function(number): number,\n   *   end: function(number): number\n   * }}\n   * @private\n   */\n  static simulateTimeRanges_(obj) {\n    return {\n      length: obj.length,\n      // NOTE: a more complete simulation would throw when |i| was out of range,\n      // but for simplicity we will assume a well-behaved application that uses\n      // length instead of catch to stop iterating.\n      start: (i) => { return obj.start[i]; },\n      end: (i) => { return obj.end[i]; },\n    };\n  }\n\n\n  /**\n   * @param {!Uint8Array} array\n   * @return {!Object}\n   * @private\n   */\n  static unpackUint8Array_(array) {\n    return {\n      '__type__': 'Uint8Array',  // a signal to deserialize\n      'entries': Array.from(array),\n    };\n  }\n\n\n  /**\n   * Creates a Uint8Array object from data sent by the cast receiver.\n   * @param {?} obj\n   * @return {!Uint8Array}\n   * @private\n   */\n  static makeUint8Array_(obj) {\n    return new Uint8Array(/** @type {!Array.<number>} */ (obj['entries']));\n  }\n\n\n  /**\n   * @param {!Error} error\n   * @return {!Object}\n   * @private\n   */\n  static unpackError_(error) {\n    // None of the properties in TypeError are enumerable, but there are some\n    // common Error properties we expect.  We also enumerate any enumerable\n    // properties and \"own\" properties of the type, in case there is an Error\n    // subtype with additional properties we don't know about in advance.\n    const properties = new Set(['name', 'message', 'stack']);\n    for (const key in error) {\n      properties.add(key);\n    }\n    for (const key of Object.getOwnPropertyNames(error)) {\n      properties.add(key);\n    }\n\n    const contents = {};\n    for (const key of properties) {\n      contents[key] = error[key];\n    }\n\n    return {\n      '__type__': 'Error',  // a signal to deserialize\n      'contents': contents,\n    };\n  }\n\n\n  /**\n   * Creates an Error object from data sent by the cast receiver.\n   * @param {?} obj\n   * @return {!Error}\n   * @private\n   */\n  static makeError_(obj) {\n    const contents = obj['contents'];\n    const error = new Error(contents['message']);\n    for (const key in contents) {\n      error[key] = contents[key];\n    }\n    return error;\n  }\n};\n\n/**\n * HTMLMediaElement events that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoEvents = [\n  'ended',\n  'play',\n  'playing',\n  'pause',\n  'pausing',\n  'ratechange',\n  'seeked',\n  'seeking',\n  'timeupdate',\n  'volumechange',\n];\n\n\n/**\n * HTMLMediaElement attributes that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoAttributes = [\n  'buffered',\n  'currentTime',\n  'duration',\n  'ended',\n  'loop',\n  'muted',\n  'paused',\n  'playbackRate',\n  'seeking',\n  'videoHeight',\n  'videoWidth',\n  'volume',\n];\n\n\n/**\n * HTMLMediaElement attributes that are transferred when casting begins.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoInitStateAttributes = [\n  'loop',\n  'playbackRate',\n];\n\n\n/**\n * HTMLMediaElement methods with no return value that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoVoidMethods = [\n  'pause',\n  'play',\n];\n\n\n/**\n * Player getter methods that are proxied while casting.\n * The key is the method, the value is the frequency of updates.\n * Frequency 1 translates to every update; frequency 2 to every 2 updates, etc.\n * @const {!Object.<string, number>}\n */\nshaka.cast.CastUtils.PlayerGetterMethods = {\n  // NOTE: The 'drmInfo' property is not proxied, as it is very large.\n  'getAssetUri': 2,\n  'getAudioLanguages': 4,\n  'getAudioLanguagesAndRoles': 4,\n  'getBufferFullness': 1,\n  'getBufferedInfo': 2,\n  'getExpiration': 2,\n  'getKeyStatuses': 2,\n  // NOTE: The 'getManifest' property is not proxied, as it is very large.\n  // NOTE: The 'getManifestParserFactory' property is not proxied, as it would\n  // not serialize.\n  'getPlaybackRate': 2,\n  'getTextLanguages': 4,\n  'getTextLanguagesAndRoles': 4,\n  'getImageTracks': 2,\n  'getThumbnails': 2,\n  'isAudioOnly': 10,\n  'isBuffering': 1,\n  'isInProgress': 1,\n  'isLive': 10,\n  'isTextTrackVisible': 1,\n  'keySystem': 10,\n  'seekRange': 1,\n  'getLoadMode': 10,\n};\n\n\n/**\n * Player getter methods with data large enough to be sent in their own update\n * messages, to reduce the size of each message.  The format of this is\n * identical to PlayerGetterMethods.\n * @const {!Object.<string, number>}\n */\nshaka.cast.CastUtils.LargePlayerGetterMethods = {\n  // NOTE: The 'getSharedConfiguration' property is not proxied as it would\n  //       not be possible to share a reference.\n  'getConfiguration': 4,\n  'getStats': 5,\n  'getTextTracks': 2,\n  'getVariantTracks': 2,\n};\n\n\n/**\n * Player getter methods that are proxied while casting, but only when casting\n * a livestream.\n * The key is the method, the value is the frequency of updates.\n * Frequency 1 translates to every update; frequency 2 to every 2 updates, etc.\n * @const {!Object.<string, number>}\n */\nshaka.cast.CastUtils.PlayerGetterMethodsThatRequireLive = {\n  'getPlayheadTimeAsDate': 1,\n  'getPresentationStartTimeAsDate': 20,\n};\n\n\n/**\n * Player getter and setter methods that are used to transfer state when casting\n * begins.\n * @const {!Array.<!Array.<string>>}\n */\nshaka.cast.CastUtils.PlayerInitState = [\n  ['getConfiguration', 'configure'],\n];\n\n\n/**\n * Player getter and setter methods that are used to transfer state after\n * load() is resolved.\n * @const {!Array.<!Array.<string>>}\n */\nshaka.cast.CastUtils.PlayerInitAfterLoadState = [\n  ['isTextTrackVisible', 'setTextTrackVisibility'],\n];\n\n\n/**\n * Player methods with no return value that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.PlayerVoidMethods = [\n  'addChaptersTrack',\n  'addTextTrack',\n  'addTextTrackAsync',\n  'cancelTrickPlay',\n  'configure',\n  'getChapters',\n  'getChaptersTracks',\n  'resetConfiguration',\n  'retryStreaming',\n  'selectAudioLanguage',\n  'selectTextLanguage',\n  'selectTextTrack',\n  'selectVariantTrack',\n  'selectVariantsByLabel',\n  'setTextTrackVisibility',\n  'trickPlay',\n  'updateStartTime',\n  'goToLive',\n];\n\n\n/**\n * Player methods returning a Promise that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.PlayerPromiseMethods = [\n  'attach',\n  'detach',\n  // The manifestFactory parameter of load is not supported.\n  'load',\n  'unload',\n];\n\n\n/**\n * @typedef {{\n *   video: Object,\n *   player: Object,\n *   manifest: ?string,\n *   startTime: ?number\n * }}\n * @property {Object} video\n *   Dictionary of video properties to be set.\n * @property {Object} player\n *   Dictionary of player setters to be called.\n * @property {?string} manifest\n *   The currently-selected manifest, if present.\n * @property {?number} startTime\n *   The playback start time, if currently playing.\n */\nshaka.cast.CastUtils.InitStateType;\n\n\n/**\n * The namespace for Shaka messages on the cast bus.\n * @const {string}\n */\nshaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE = 'urn:x-cast:com.google.shaka.v2';\n\n\n/**\n * The namespace for generic messages on the cast bus.\n * @const {string}\n */\nshaka.cast.CastUtils.GENERIC_MESSAGE_NAMESPACE =\n    'urn:x-cast:com.google.cast.media';\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cast.CastSender');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.cast.CastUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * @implements {shaka.util.IDestroyable}\n */\nshaka.cast.CastSender = class {\n  /**\n   * @param {string} receiverAppId The ID of the cast receiver application.\n   * @param {function()} onStatusChanged A callback invoked when the cast status\n   *   changes.\n   * @param {function()} onFirstCastStateUpdate A callback invoked when an\n   *   \"update\" event has been received for the first time.\n   * @param {function(string, !shaka.util.FakeEvent)} onRemoteEvent A callback\n   *   invoked with target name and event when a remote event is received.\n   * @param {function()} onResumeLocal A callback invoked when the local player\n   *   should resume playback.  Called before the cached remote state is wiped.\n   * @param {function()} onInitStateRequired A callback to get local player's.\n   *   state.  Invoked when casting is initiated from Chrome's cast button.\n   */\n  constructor(receiverAppId, onStatusChanged, onFirstCastStateUpdate,\n      onRemoteEvent, onResumeLocal, onInitStateRequired) {\n    /** @private {string} */\n    this.receiverAppId_ = receiverAppId;\n\n    /** @private {shaka.util.Timer} */\n    this.statusChangeTimer_ = new shaka.util.Timer(onStatusChanged);\n\n    /** @private {?function()} */\n    this.onFirstCastStateUpdate_ = onFirstCastStateUpdate;\n\n    /** @private {boolean} */\n    this.hasJoinedExistingSession_ = false;\n\n    /** @private {?function(string, !shaka.util.FakeEvent)} */\n    this.onRemoteEvent_ = onRemoteEvent;\n\n    /** @private {?function()} */\n    this.onResumeLocal_ = onResumeLocal;\n\n    /** @private {?function()} */\n    this.onInitStateRequired_ = onInitStateRequired;\n\n    /** @private {boolean} */\n    this.apiReady_ = false;\n\n    /** @private {boolean} */\n    this.isCasting_ = false;\n\n    /** @private {string} */\n    this.receiverName_ = '';\n\n    /** @private {Object} */\n    this.appData_ = null;\n\n    /** @private {?function()} */\n    this.onConnectionStatusChangedBound_ =\n        () => this.onConnectionStatusChanged_();\n\n    /** @private {?function(string, string)} */\n    this.onMessageReceivedBound_ = (namespace, serialized) =>\n      this.onMessageReceived_(namespace, serialized);\n\n    /** @private {Object} */\n    this.cachedProperties_ = {\n      'video': {},\n      'player': {},\n    };\n\n    /** @private {number} */\n    this.nextAsyncCallId_ = 0;\n\n    /** @private {Object.<string, !shaka.util.PublicPromise>} */\n    this.asyncCallPromises_ = {};\n\n    /** @private {shaka.util.PublicPromise} */\n    this.castPromise_ = null;\n\n    shaka.cast.CastSender.instances_.add(this);\n  }\n\n\n  /** @override */\n  destroy() {\n    shaka.cast.CastSender.instances_.delete(this);\n\n    this.rejectAllPromises_();\n    if (shaka.cast.CastSender.session_) {\n      this.removeListeners_();\n      // Don't leave the session, so that this session can be re-used later if\n      // necessary.\n    }\n\n    if (this.statusChangeTimer_) {\n      this.statusChangeTimer_.stop();\n      this.statusChangeTimer_ = null;\n    }\n\n    this.onRemoteEvent_ = null;\n    this.onResumeLocal_ = null;\n    this.apiReady_ = false;\n    this.isCasting_ = false;\n    this.appData_ = null;\n    this.cachedProperties_ = null;\n    this.asyncCallPromises_ = null;\n    this.castPromise_ = null;\n    this.onConnectionStatusChangedBound_ = null;\n    this.onMessageReceivedBound_ = null;\n\n    return Promise.resolve();\n  }\n\n\n  /**\n   * @return {boolean} True if the cast API is available.\n   */\n  apiReady() {\n    return this.apiReady_;\n  }\n\n\n  /**\n   * @return {boolean} True if there are receivers.\n   */\n  hasReceivers() {\n    return shaka.cast.CastSender.hasReceivers_;\n  }\n\n\n  /**\n   * @return {boolean} True if we are currently casting.\n   */\n  isCasting() {\n    return this.isCasting_;\n  }\n\n\n  /**\n   * @return {string} The name of the Cast receiver device, if isCasting().\n   */\n  receiverName() {\n    return this.receiverName_;\n  }\n\n\n  /**\n   * @return {boolean} True if we have a cache of remote properties from the\n   *   receiver.\n   */\n  hasRemoteProperties() {\n    return Object.keys(this.cachedProperties_['video']).length != 0;\n  }\n\n\n  /** Initialize the Cast API. */\n  init() {\n    const CastSender = shaka.cast.CastSender;\n\n    if (!this.receiverAppId_.length) {\n      // Return if no cast receiver id has been provided.\n      // Nothing will be initialized, no global hooks will be installed.\n      // If the receiver ID changes before this instance dies, init will be\n      // called again.\n      return;\n    }\n\n    // Check for the cast API.\n    if (!window.chrome || !chrome.cast || !chrome.cast.isAvailable) {\n      // If the API is not available on this platform or is not ready yet,\n      // install a hook to be notified when it becomes available.\n      // If the API becomes available before this instance dies, init will be\n      // called again.\n\n      // Check if our callback is already installed.\n      if (window.__onGCastApiAvailable !== CastSender.onGCastApiAvailable_) {\n        // Save pre-existing __onGCastApiAvailable in order to restore later.\n        CastSender.__onGCastApiAvailable_ =\n          window.__onGCastApiAvailable || null;\n        window.__onGCastApiAvailable = CastSender.onGCastApiAvailable_;\n      }\n\n      return;\n    }\n\n    // The API is now available.\n    this.apiReady_ = true;\n    this.statusChangeTimer_.tickNow();\n\n    // Use static versions of the API callbacks, since the ChromeCast API is\n    // static. If we used local versions, we might end up retaining references\n    // to destroyed players here.\n    const sessionRequest = new chrome.cast.SessionRequest(this.receiverAppId_);\n    const apiConfig = new chrome.cast.ApiConfig(sessionRequest,\n        (session) => CastSender.onExistingSessionJoined_(session),\n        (availability) => CastSender.onReceiverStatusChanged_(availability),\n        'origin_scoped');\n\n    // TODO: Have never seen this fail.  When would it and how should we react?\n    chrome.cast.initialize(apiConfig,\n        () => { shaka.log.debug('CastSender: init'); },\n        (error) => { shaka.log.error('CastSender: init error', error); });\n    if (shaka.cast.CastSender.hasReceivers_) {\n      // Fire a fake cast status change, to simulate the update that\n      // would be fired normally.\n      // This is after a brief delay, to give users a chance to add event\n      // listeners.\n      this.statusChangeTimer_.tickAfter(shaka.cast.CastSender.STATUS_DELAY);\n    }\n\n    const oldSession = shaka.cast.CastSender.session_;\n    if (oldSession && oldSession.status != chrome.cast.SessionStatus.STOPPED) {\n      // The old session still exists, so re-use it.\n      shaka.log.debug('CastSender: re-using existing connection');\n      this.onExistingSessionJoined_(oldSession);\n    } else {\n      // The session has been canceled in the meantime, so ignore it.\n      shaka.cast.CastSender.session_ = null;\n    }\n  }\n\n\n  /**\n   * Set application-specific data.\n   *\n   * @param {Object} appData Application-specific data to relay to the receiver.\n   */\n  setAppData(appData) {\n    this.appData_ = appData;\n    if (this.isCasting_) {\n      this.sendMessage_({\n        'type': 'appData',\n        'appData': this.appData_,\n      });\n    }\n  }\n\n\n  /**\n   * @param {shaka.cast.CastUtils.InitStateType} initState Video and player\n   *   state to be sent to the receiver.\n   * @return {!Promise} Resolved when connected to a receiver.  Rejected if the\n   *   connection fails or is canceled by the user.\n   */\n  async cast(initState) {\n    if (!this.apiReady_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.CAST,\n          shaka.util.Error.Code.CAST_API_UNAVAILABLE);\n    }\n    if (!shaka.cast.CastSender.hasReceivers_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.CAST,\n          shaka.util.Error.Code.NO_CAST_RECEIVERS);\n    }\n    if (this.isCasting_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.CAST,\n          shaka.util.Error.Code.ALREADY_CASTING);\n    }\n\n    this.castPromise_ = new shaka.util.PublicPromise();\n    chrome.cast.requestSession(\n        (session) => this.onSessionInitiated_(initState, session),\n        (error) => this.onConnectionError_(error));\n    await this.castPromise_;\n  }\n\n\n  /**\n   * Shows user a cast dialog where they can choose to stop\n   * casting.  Relies on Chrome to perform disconnect if they do.\n   * Doesn't do anything if not connected.\n   */\n  showDisconnectDialog() {\n    if (!this.isCasting_) {\n      return;\n    }\n    const initState = this.onInitStateRequired_();\n\n    chrome.cast.requestSession(\n        (session) => this.onSessionInitiated_(initState, session),\n        (error) => this.onConnectionError_(error));\n  }\n\n\n  /**\n   * Forces the receiver app to shut down by disconnecting.  Does nothing if not\n   * connected.\n   */\n  forceDisconnect() {\n    if (!this.isCasting_) {\n      return;\n    }\n\n    this.rejectAllPromises_();\n\n    if (shaka.cast.CastSender.session_) {\n      this.removeListeners_();\n\n      // This can throw if we've already been disconnected somehow.\n      try {\n        shaka.cast.CastSender.session_.stop(() => {}, () => {});\n      } catch (error) {}\n\n      shaka.cast.CastSender.session_ = null;\n    }\n\n    // Update casting status.\n    this.onConnectionStatusChanged_();\n  }\n\n\n  /**\n   * Getter for properties of remote objects.\n   * @param {string} targetName\n   * @param {string} property\n   * @return {?}\n   */\n  get(targetName, property) {\n    goog.asserts.assert(targetName == 'video' || targetName == 'player',\n        'Unexpected target name');\n    const CastUtils = shaka.cast.CastUtils;\n    if (targetName == 'video') {\n      if (CastUtils.VideoVoidMethods.includes(property)) {\n        return (...args) => this.remoteCall_(targetName, property, ...args);\n      }\n    } else if (targetName == 'player') {\n      if (CastUtils.PlayerGetterMethodsThatRequireLive[property]) {\n        const isLive = this.get('player', 'isLive')();\n        goog.asserts.assert(isLive,\n            property + ' should be called on a live stream!');\n        // If the property shouldn't exist, return a fake function so that the\n        // user doesn't call an undefined function and get a second error.\n        if (!isLive) {\n          return () => undefined;\n        }\n      }\n      if (CastUtils.PlayerVoidMethods.includes(property)) {\n        return (...args) => this.remoteCall_(targetName, property, ...args);\n      }\n      if (CastUtils.PlayerPromiseMethods.includes(property)) {\n        return (...args) =>\n          this.remoteAsyncCall_(targetName, property, ...args);\n      }\n      if (CastUtils.PlayerGetterMethods[property] ||\n          CastUtils.LargePlayerGetterMethods[property]) {\n        return () => this.propertyGetter_(targetName, property);\n      }\n    }\n\n    return this.propertyGetter_(targetName, property);\n  }\n\n\n  /**\n   * Setter for properties of remote objects.\n   * @param {string} targetName\n   * @param {string} property\n   * @param {?} value\n   */\n  set(targetName, property, value) {\n    goog.asserts.assert(targetName == 'video' || targetName == 'player',\n        'Unexpected target name');\n\n    this.cachedProperties_[targetName][property] = value;\n    this.sendMessage_({\n      'type': 'set',\n      'targetName': targetName,\n      'property': property,\n      'value': value,\n    });\n  }\n\n\n  /**\n   * @param {shaka.cast.CastUtils.InitStateType} initState\n   * @param {chrome.cast.Session} session\n   * @private\n   */\n  onSessionInitiated_(initState, session) {\n    shaka.log.debug('CastSender: onSessionInitiated');\n    this.onSessionCreated_(session);\n\n    this.sendMessage_({\n      'type': 'init',\n      'initState': initState,\n      'appData': this.appData_,\n    });\n\n    this.castPromise_.resolve();\n  }\n\n\n  /**\n   * @param {chrome.cast.Error} error\n   * @private\n   */\n  onConnectionError_(error) {\n    // Default error code:\n    let code = shaka.util.Error.Code.UNEXPECTED_CAST_ERROR;\n\n    switch (error.code) {\n      case 'cancel':\n        code = shaka.util.Error.Code.CAST_CANCELED_BY_USER;\n        break;\n      case 'timeout':\n        code = shaka.util.Error.Code.CAST_CONNECTION_TIMED_OUT;\n        break;\n      case 'receiver_unavailable':\n        code = shaka.util.Error.Code.CAST_RECEIVER_APP_UNAVAILABLE;\n        break;\n    }\n\n    this.castPromise_.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.CAST,\n        code,\n        error));\n  }\n\n\n  /**\n   * @param {string} targetName\n   * @param {string} property\n   * @return {?}\n   * @private\n   */\n  propertyGetter_(targetName, property) {\n    goog.asserts.assert(targetName == 'video' || targetName == 'player',\n        'Unexpected target name');\n    return this.cachedProperties_[targetName][property];\n  }\n\n\n  /**\n   * @param {string} targetName\n   * @param {string} methodName\n   * @param {...*} varArgs\n   * @private\n   */\n  remoteCall_(targetName, methodName, ...varArgs) {\n    goog.asserts.assert(targetName == 'video' || targetName == 'player',\n        'Unexpected target name');\n    this.sendMessage_({\n      'type': 'call',\n      'targetName': targetName,\n      'methodName': methodName,\n      'args': varArgs,\n    });\n  }\n\n\n  /**\n   * @param {string} targetName\n   * @param {string} methodName\n   * @param {...*} varArgs\n   * @return {!Promise}\n   * @private\n   */\n  remoteAsyncCall_(targetName, methodName, ...varArgs) {\n    goog.asserts.assert(targetName == 'video' || targetName == 'player',\n        'Unexpected target name');\n\n    const p = new shaka.util.PublicPromise();\n    const id = this.nextAsyncCallId_.toString();\n    this.nextAsyncCallId_++;\n    this.asyncCallPromises_[id] = p;\n\n    try {\n      this.sendMessage_({\n        'type': 'asyncCall',\n        'targetName': targetName,\n        'methodName': methodName,\n        'args': varArgs,\n        'id': id,\n      });\n    } catch (error) {\n      p.reject(error);\n    }\n    return p;\n  }\n\n\n  /**\n   * A static version of onExistingSessionJoined_, that calls that method for\n   * each known instance.\n   * @param {chrome.cast.Session} session\n   * @private\n   */\n  static onExistingSessionJoined_(session) {\n    for (const instance of shaka.cast.CastSender.instances_) {\n      instance.onExistingSessionJoined_(session);\n    }\n  }\n\n\n  /**\n   * @param {chrome.cast.Session} session\n   * @private\n   */\n  onExistingSessionJoined_(session) {\n    shaka.log.debug('CastSender: onExistingSessionJoined');\n\n    const initState = this.onInitStateRequired_();\n\n    this.castPromise_ = new shaka.util.PublicPromise();\n    this.hasJoinedExistingSession_ = true;\n\n    this.onSessionInitiated_(initState, session);\n  }\n\n\n  /**\n   * A static version of onReceiverStatusChanged_, that calls that method for\n   * each known instance.\n   * @param {string} availability\n   * @private\n   */\n  static onReceiverStatusChanged_(availability) {\n    for (const instance of shaka.cast.CastSender.instances_) {\n      instance.onReceiverStatusChanged_(availability);\n    }\n  }\n\n\n  /**\n   * @param {string} availability\n   * @private\n   */\n  onReceiverStatusChanged_(availability) {\n    // The cast API is telling us whether there are any cast receiver devices\n    // available.\n    shaka.log.debug('CastSender: receiver status', availability);\n    shaka.cast.CastSender.hasReceivers_ = availability == 'available';\n    this.statusChangeTimer_.tickNow();\n  }\n\n\n  /**\n   * @param {chrome.cast.Session} session\n   * @private\n   */\n  onSessionCreated_(session) {\n    shaka.cast.CastSender.session_ = session;\n    session.addUpdateListener(this.onConnectionStatusChangedBound_);\n    session.addMessageListener(shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE,\n        this.onMessageReceivedBound_);\n    this.onConnectionStatusChanged_();\n  }\n\n\n  /**\n   * @private\n   */\n  removeListeners_() {\n    const session = shaka.cast.CastSender.session_;\n    session.removeUpdateListener(this.onConnectionStatusChangedBound_);\n    session.removeMessageListener(shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE,\n        this.onMessageReceivedBound_);\n  }\n\n\n  /**\n   * @private\n   */\n  onConnectionStatusChanged_() {\n    const connected = shaka.cast.CastSender.session_ ?\n        shaka.cast.CastSender.session_.status == 'connected' :\n        false;\n    shaka.log.debug('CastSender: connection status', connected);\n    if (this.isCasting_ && !connected) {\n      // Tell CastProxy to transfer state back to local player.\n      this.onResumeLocal_();\n\n      // Clear whatever we have cached.\n      for (const targetName in this.cachedProperties_) {\n        this.cachedProperties_[targetName] = {};\n      }\n\n      this.rejectAllPromises_();\n    }\n\n    this.isCasting_ = connected;\n    this.receiverName_ = connected ?\n        shaka.cast.CastSender.session_.receiver.friendlyName :\n        '';\n    this.statusChangeTimer_.tickNow();\n  }\n\n\n  /**\n   * Reject any async call promises that are still pending.\n   * @private\n   */\n  rejectAllPromises_() {\n    for (const id in this.asyncCallPromises_) {\n      const p = this.asyncCallPromises_[id];\n      delete this.asyncCallPromises_[id];\n\n      // Reject pending async operations as if they were interrupted.\n      // At the moment, load() is the only async operation we are worried about.\n      p.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.LOAD_INTERRUPTED));\n    }\n  }\n\n\n  /**\n   * @param {string} namespace\n   * @param {string} serialized\n   * @private\n   */\n  onMessageReceived_(namespace, serialized) {\n    // Since this method is in the compiled library, make sure all messages\n    // passed in here were created with quoted property names.\n\n    const message = shaka.cast.CastUtils.deserialize(serialized);\n    shaka.log.v2('CastSender: message', message);\n\n    switch (message['type']) {\n      case 'event': {\n        const targetName = message['targetName'];\n        const event = message['event'];\n        const fakeEvent = shaka.util.FakeEvent.fromRealEvent(event);\n        this.onRemoteEvent_(targetName, fakeEvent);\n        break;\n      }\n      case 'update': {\n        const update = message['update'];\n        for (const targetName in update) {\n          const target = this.cachedProperties_[targetName] || {};\n          for (const property in update[targetName]) {\n            target[property] = update[targetName][property];\n          }\n        }\n        if (this.hasJoinedExistingSession_) {\n          this.onFirstCastStateUpdate_();\n          this.hasJoinedExistingSession_ = false;\n        }\n        break;\n      }\n      case 'asyncComplete': {\n        const id = message['id'];\n        const error = message['error'];\n        const p = this.asyncCallPromises_[id];\n        delete this.asyncCallPromises_[id];\n\n        goog.asserts.assert(p, 'Unexpected async id');\n        if (!p) {\n          break;\n        }\n\n        if (error) {\n          // This is a hacky way to reconstruct the serialized error.\n          const reconstructedError = new shaka.util.Error(\n              error.severity, error.category, error.code);\n          for (const k in error) {\n            (/** @type {Object} */(reconstructedError))[k] = error[k];\n          }\n          p.reject(reconstructedError);\n        } else {\n          p.resolve();\n        }\n        break;\n      }\n    }\n  }\n\n\n  /**\n   * @param {!Object} message\n   * @private\n   */\n  sendMessage_(message) {\n    // Since this method is in the compiled library, make sure all messages\n    // passed in here were created with quoted property names.\n\n    const serialized = shaka.cast.CastUtils.serialize(message);\n    const session = shaka.cast.CastSender.session_;\n\n    // NOTE: This takes an error callback that we have not seen fire.  We don't\n    // know if it would fire synchronously or asynchronously.  Until we know how\n    // it works, we just log from that callback.  But we _have_ seen\n    // sendMessage() throw synchronously, so we handle that.\n    try {\n      session.sendMessage(shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE,\n          serialized,\n          () => {},  // success callback\n          shaka.log.error);  // error callback\n    } catch (error) {\n      shaka.log.error('Cast session sendMessage threw', error);\n\n      // Translate the error\n      const shakaError = new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.CAST,\n          shaka.util.Error.Code.CAST_CONNECTION_TIMED_OUT,\n          error);\n\n      // Dispatch it through the Player proxy\n      const fakeEvent = new shaka.util.FakeEvent(\n          'error', (new Map()).set('detail', shakaError));\n      this.onRemoteEvent_('player', fakeEvent);\n\n      // Force this session to disconnect and transfer playback to the local\n      // device\n      this.forceDisconnect();\n\n      // Throw the translated error from this getter/setter/method to the UI/app\n      throw shakaError;\n    }\n  }\n};\n\n/** @type {number} */\nshaka.cast.CastSender.STATUS_DELAY = 0.02;\n\n/** @private {boolean} */\nshaka.cast.CastSender.hasReceivers_ = false;\n\n/** @private {chrome.cast.Session} */\nshaka.cast.CastSender.session_ = null;\n\n/** @private {?function(boolean)} */\nshaka.cast.CastSender.__onGCastApiAvailable_ = null;\n\n/**\n * A set of all living CastSender instances.  The constructor and destroy\n * methods will add and remove instances from this set.\n *\n * This is used to deal with delayed initialization of the Cast SDK.  When the\n * SDK becomes available, instances will be reinitialized.\n *\n * @private {!Set.<shaka.cast.CastSender>}\n */\nshaka.cast.CastSender.instances_ = new Set();\n\n/**\n * If the cast SDK is not available yet, it will invoke this callback once it\n * becomes available.\n *\n * @param {boolean} loaded\n * @private\n */\nshaka.cast.CastSender.onSdkLoaded_ = (loaded) => {\n  if (loaded) {\n    // Any living instances of CastSender should have their init methods called\n    // again now that the API is available.\n    for (const sender of shaka.cast.CastSender.instances_) {\n      sender.init();\n    }\n  }\n};\n\n/**\n * @param {boolean} available\n * @private\n */\nshaka.cast.CastSender.onGCastApiAvailable_ = (available) => {\n  // Restore callback from saved.\n  if (shaka.cast.CastSender.__onGCastApiAvailable_) {\n    window.__onGCastApiAvailable =\n      shaka.cast.CastSender.__onGCastApiAvailable_;\n  } else {\n    delete window.__onGCastApiAvailable;\n  }\n  shaka.cast.CastSender.__onGCastApiAvailable_ = null;\n\n  // A note about this value: In our testing environment, we load both\n  // uncompiled and compiled code.  This global callback in uncompiled mode\n  // can be overwritten by the same in compiled mode.  The two versions will\n  // each have their own instances_ map.  Therefore the callback must have a\n  // name, as opposed to being anonymous.  This way, the CastSender tests\n  // can invoke the named static method instead of using a global that could\n  // be overwritten.\n  shaka.cast.CastSender.onSdkLoaded_(available);\n\n  // call restored callback (if any)\n  if (typeof window.__onGCastApiAvailable === 'function') {\n    window.__onGCastApiAvailable(available);\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cast.CastProxy');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Player');\ngoog.require('shaka.cast.CastSender');\ngoog.require('shaka.cast.CastUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\n\n\n/**\n * @event shaka.cast.CastProxy.CastStatusChangedEvent\n * @description Fired when cast status changes.  The status change will be\n *   reflected in canCast() and isCasting().\n * @property {string} type\n *   'caststatuschanged'\n * @exportDoc\n */\n\n\n/**\n * @summary A proxy to switch between local and remote playback for Chromecast\n * in a way that is transparent to the app's controls.\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.cast.CastProxy = class extends shaka.util.FakeEventTarget {\n  /**\n   * @param {!HTMLMediaElement} video The local video element associated with\n   *   the local Player instance.\n   * @param {!shaka.Player} player A local Player instance.\n   * @param {string} receiverAppId The ID of the cast receiver application.\n   *   If blank, casting will not be available, but the proxy will still\n   *   function otherwise.\n   */\n  constructor(video, player, receiverAppId) {\n    super();\n\n    /** @private {HTMLMediaElement} */\n    this.localVideo_ = video;\n\n    /** @private {shaka.Player} */\n    this.localPlayer_ = player;\n\n    /** @private {Object} */\n    this.videoProxy_ = null;\n\n    /** @private {Object} */\n    this.playerProxy_ = null;\n\n    /** @private {shaka.util.FakeEventTarget} */\n    this.videoEventTarget_ = null;\n\n    /** @private {shaka.util.FakeEventTarget} */\n    this.playerEventTarget_ = null;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = null;\n\n    /** @private {string} */\n    this.receiverAppId_ = receiverAppId;\n\n    /** @private {!Map} */\n    this.compiledToExternNames_ = new Map();\n\n    /** @private {shaka.cast.CastSender} */\n    this.sender_ = new shaka.cast.CastSender(\n        receiverAppId,\n        () => this.onCastStatusChanged_(),\n        () => this.onFirstCastStateUpdate_(),\n        (targetName, event) => this.onRemoteEvent_(targetName, event),\n        () => this.onResumeLocal_(),\n        () => this.getInitState_());\n\n\n    this.init_();\n  }\n\n  /**\n   * Destroys the proxy and the underlying local Player.\n   *\n   * @param {boolean=} forceDisconnect If true, force the receiver app to shut\n   *   down by disconnecting.  Does nothing if not connected.\n   * @override\n   * @export\n   */\n  destroy(forceDisconnect) {\n    if (forceDisconnect) {\n      this.sender_.forceDisconnect();\n    }\n\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    const waitFor = [];\n    if (this.localPlayer_) {\n      waitFor.push(this.localPlayer_.destroy());\n      this.localPlayer_ = null;\n    }\n\n    if (this.sender_) {\n      waitFor.push(this.sender_.destroy());\n      this.sender_ = null;\n    }\n\n    this.localVideo_ = null;\n    this.videoProxy_ = null;\n    this.playerProxy_ = null;\n\n    // FakeEventTarget implements IReleasable\n    super.release();\n\n    return Promise.all(waitFor);\n  }\n\n  /**\n   * Get a proxy for the video element that delegates to local and remote video\n   * elements as appropriate.\n   *\n   * @suppress {invalidCasts} to cast proxy Objects to unrelated types\n   * @return {!HTMLMediaElement}\n   * @export\n   */\n  getVideo() {\n    return /** @type {!HTMLMediaElement} */(this.videoProxy_);\n  }\n\n  /**\n   * Get a proxy for the Player that delegates to local and remote Player\n   * objects as appropriate.\n   *\n   * @suppress {invalidCasts} to cast proxy Objects to unrelated types\n   * @return {!shaka.Player}\n   * @export\n   */\n  getPlayer() {\n    return /** @type {!shaka.Player} */(this.playerProxy_);\n  }\n\n  /**\n   * @return {boolean} True if the cast API is available and there are\n   *   receivers.\n   * @export\n   */\n  canCast() {\n    return this.sender_.apiReady() && this.sender_.hasReceivers();\n  }\n\n  /**\n   * @return {boolean} True if we are currently casting.\n   * @export\n   */\n  isCasting() {\n    return this.sender_.isCasting();\n  }\n\n  /**\n   * @return {string} The name of the Cast receiver device, if isCasting().\n   * @export\n   */\n  receiverName() {\n    return this.sender_.receiverName();\n  }\n\n  /**\n   * @return {!Promise} Resolved when connected to a receiver.  Rejected if the\n   *   connection fails or is canceled by the user.\n   * @export\n   */\n  async cast() {\n    const initState = this.getInitState_();\n\n    // TODO: transfer manually-selected tracks?\n    // TODO: transfer side-loaded text tracks?\n\n    await this.sender_.cast(initState);\n    if (!this.localPlayer_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    // Unload the local manifest when casting succeeds.\n    await this.localPlayer_.unload();\n  }\n\n  /**\n   * Set application-specific data.\n   *\n   * @param {Object} appData Application-specific data to relay to the receiver.\n   * @export\n   */\n  setAppData(appData) {\n    this.sender_.setAppData(appData);\n  }\n\n  /**\n   * Show a dialog where user can choose to disconnect from the cast connection.\n   * @export\n   */\n  suggestDisconnect() {\n    this.sender_.showDisconnectDialog();\n  }\n\n  /**\n   * Force the receiver app to shut down by disconnecting.\n   * @export\n   */\n  forceDisconnect() {\n    this.sender_.forceDisconnect();\n  }\n\n\n  /**\n   * @param {string} newAppId\n   * @export\n   */\n  async changeReceiverId(newAppId) {\n    if (newAppId == this.receiverAppId_) {\n      // Nothing to change\n      return;\n    }\n\n    this.receiverAppId_ = newAppId;\n\n    // Destroy the old sender\n    this.sender_.forceDisconnect();\n    await this.sender_.destroy();\n    this.sender_ = null;\n\n\n    // Create the new one\n    this.sender_ = new shaka.cast.CastSender(\n        newAppId,\n        () => this.onCastStatusChanged_(),\n        () => this.onFirstCastStateUpdate_(),\n        (targetName, event) => this.onRemoteEvent_(targetName, event),\n        () => this.onResumeLocal_(),\n        () => this.getInitState_());\n\n    this.sender_.init();\n  }\n\n  /**\n   * Initialize the Proxies and the Cast sender.\n   * @private\n   */\n  init_() {\n    this.sender_.init();\n\n    this.eventManager_ = new shaka.util.EventManager();\n\n    for (const name of shaka.cast.CastUtils.VideoEvents) {\n      this.eventManager_.listen(this.localVideo_, name,\n          (event) => this.videoProxyLocalEvent_(event));\n    }\n\n    for (const key in shaka.Player.EventName) {\n      const name = shaka.Player.EventName[key];\n      this.eventManager_.listen(this.localPlayer_, name,\n          (event) => this.playerProxyLocalEvent_(event));\n    }\n\n    // We would like to use Proxy here, but it is not supported on Safari.\n    this.videoProxy_ = {};\n    for (const k in this.localVideo_) {\n      Object.defineProperty(this.videoProxy_, k, {\n        configurable: false,\n        enumerable: true,\n        get: () => this.videoProxyGet_(k),\n        set: (value) => { this.videoProxySet_(k, value); },\n      });\n    }\n\n    this.playerProxy_ = {};\n    this.iterateOverPlayerMethods_((name, method) => {\n      goog.asserts.assert(this.playerProxy_, 'Must have player proxy!');\n      Object.defineProperty(this.playerProxy_, name, {\n        configurable: false,\n        enumerable: true,\n        get: () => this.playerProxyGet_(name),\n      });\n    });\n\n    if (COMPILED) {\n      this.mapCompiledToUncompiledPlayerMethodNames_();\n    }\n\n    this.videoEventTarget_ = new shaka.util.FakeEventTarget();\n    this.videoEventTarget_.dispatchTarget =\n      /** @type {EventTarget} */(this.videoProxy_);\n\n    this.playerEventTarget_ = new shaka.util.FakeEventTarget();\n    this.playerEventTarget_.dispatchTarget =\n      /** @type {EventTarget} */(this.playerProxy_);\n  }\n\n\n  /**\n   * Maps compiled to uncompiled player names so we can figure out\n   * which method to call in compiled build, while casting.\n   * @private\n   */\n  mapCompiledToUncompiledPlayerMethodNames_() {\n    // In compiled mode, UI tries to access player methods by their internal\n    // renamed names, but the proxy object doesn't know about those.  See\n    // https://github.com/shaka-project/shaka-player/issues/2130 for details.\n    const methodsToNames = new Map();\n    this.iterateOverPlayerMethods_((name, method) => {\n      if (methodsToNames.has(method)) {\n        // If two method names, point to the same method, add them to the\n        // map as aliases of each other.\n        const name2 = methodsToNames.get(method);\n        // Assumes that the compiled name is shorter\n        if (name.length < name2.length) {\n          this.compiledToExternNames_.set(name, name2);\n        } else {\n          this.compiledToExternNames_.set(name2, name);\n        }\n      } else {\n        methodsToNames.set(method, name);\n      }\n    });\n  }\n\n  /**\n   * Iterates over all of the methods of the player, including inherited methods\n   * from FakeEventTarget.\n   * @param {function(string, function())} operation\n   * @private\n   */\n  iterateOverPlayerMethods_(operation) {\n    goog.asserts.assert(this.localPlayer_, 'Must have player!');\n    const player = /** @type {!Object} */ (this.localPlayer_);\n    // Avoid accessing any over-written methods in the prototype chain.\n    const seenNames = new Set();\n\n    /**\n     * @param {string} name\n     * @return {boolean}\n     */\n    function shouldAddToTheMap(name) {\n      if (name == 'constructor') {\n        // Don't proxy the constructor.\n        return false;\n      }\n\n      const method = /** @type {Object} */(player)[name];\n      if (typeof method != 'function') {\n        // Don't proxy non-methods.\n        return false;\n      }\n\n      // Add if the map does not already have it\n      return !seenNames.has(name);\n    }\n\n    // First, look at the methods on the object itself, so this can properly\n    // proxy any methods not on the prototype (for example, in the mock player).\n    for (const key in player) {\n      if (shouldAddToTheMap(key)) {\n        seenNames.add(key);\n        operation(key, player[key]);\n      }\n    }\n\n    // The exact length of the prototype chain might vary; for resiliency, this\n    // will just look at the entire chain, rather than assuming a set length.\n    let proto = /** @type {!Object} */ (Object.getPrototypeOf(player));\n    const objProto = /** @type {!Object} */ (Object.getPrototypeOf({}));\n    while (proto && proto != objProto) { // Don't proxy Object methods.\n      for (const name of Object.getOwnPropertyNames(proto)) {\n        if (shouldAddToTheMap(name)) {\n          seenNames.add(name);\n          operation(name, (player)[name]);\n        }\n      }\n      proto = /** @type {!Object} */ (Object.getPrototypeOf(proto));\n    }\n  }\n\n  /**\n   * @return {shaka.cast.CastUtils.InitStateType} initState Video and player\n   *   state to be sent to the receiver.\n   * @private\n   */\n  getInitState_() {\n    const initState = {\n      'video': {},\n      'player': {},\n      'playerAfterLoad': {},\n      'manifest': this.localPlayer_.getAssetUri(),\n      'startTime': null,\n    };\n\n    // Pause local playback before capturing state.\n    this.localVideo_.pause();\n\n    for (const name of shaka.cast.CastUtils.VideoInitStateAttributes) {\n      initState['video'][name] = this.localVideo_[name];\n    }\n\n    // If the video is still playing, set the startTime.\n    // Has no effect if nothing is loaded.\n    if (!this.localVideo_.ended) {\n      initState['startTime'] = this.localVideo_.currentTime;\n    }\n\n    for (const pair of shaka.cast.CastUtils.PlayerInitState) {\n      const getter = pair[0];\n      const setter = pair[1];\n      const value = /** @type {Object} */(this.localPlayer_)[getter]();\n\n      initState['player'][setter] = value;\n    }\n\n    for (const pair of shaka.cast.CastUtils.PlayerInitAfterLoadState) {\n      const getter = pair[0];\n      const setter = pair[1];\n      const value = /** @type {Object} */(this.localPlayer_)[getter]();\n\n      initState['playerAfterLoad'][setter] = value;\n    }\n\n    return initState;\n  }\n\n  /**\n   * Dispatch an event to notify the app that the status has changed.\n   * @private\n   */\n  onCastStatusChanged_() {\n    const event = new shaka.util.FakeEvent('caststatuschanged');\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * Dispatch a synthetic play or pause event to ensure that the app correctly\n   * knows that the player is playing, if joining an existing receiver.\n   * @private\n   */\n  onFirstCastStateUpdate_() {\n    const type = this.videoProxy_['paused'] ? 'pause' : 'play';\n    const fakeEvent = new shaka.util.FakeEvent(type);\n    this.videoEventTarget_.dispatchEvent(fakeEvent);\n  }\n\n  /**\n   * Transfer remote state back and resume local playback.\n   * @private\n   */\n  onResumeLocal_() {\n    // Transfer back the player state.\n    for (const pair of shaka.cast.CastUtils.PlayerInitState) {\n      const getter = pair[0];\n      const setter = pair[1];\n      const value = this.sender_.get('player', getter)();\n      /** @type {Object} */(this.localPlayer_)[setter](value);\n    }\n\n    // Get the most recent manifest URI and ended state.\n    const assetUri = this.sender_.get('player', 'getAssetUri')();\n    const ended = this.sender_.get('video', 'ended');\n\n    let manifestReady = Promise.resolve();\n    const autoplay = this.localVideo_.autoplay;\n\n    let startTime = null;\n\n    // If the video is still playing, set the startTime.\n    // Has no effect if nothing is loaded.\n    if (!ended) {\n      startTime = this.sender_.get('video', 'currentTime');\n    }\n\n    // Now load the manifest, if present.\n    if (assetUri) {\n      // Don't autoplay the content until we finish setting up initial state.\n      this.localVideo_.autoplay = false;\n      manifestReady = this.localPlayer_.load(assetUri, startTime);\n    }\n\n    // Get the video state into a temp variable since we will apply it async.\n    const videoState = {};\n    for (const name of shaka.cast.CastUtils.VideoInitStateAttributes) {\n      videoState[name] = this.sender_.get('video', name);\n    }\n\n    // Finally, take on video state and player's \"after load\" state.\n    manifestReady.then(() => {\n      if (!this.localVideo_) {\n        // We've already been destroyed.\n        return;\n      }\n\n      for (const name of shaka.cast.CastUtils.VideoInitStateAttributes) {\n        this.localVideo_[name] = videoState[name];\n      }\n\n      for (const pair of shaka.cast.CastUtils.PlayerInitAfterLoadState) {\n        const getter = pair[0];\n        const setter = pair[1];\n        const value = this.sender_.get('player', getter)();\n        /** @type {Object} */(this.localPlayer_)[setter](value);\n      }\n\n      // Restore the original autoplay setting.\n      this.localVideo_.autoplay = autoplay;\n      if (assetUri) {\n        // Resume playback with transferred state.\n        this.localVideo_.play();\n      }\n    }, (error) => {\n      // Pass any errors through to the app.\n      goog.asserts.assert(error instanceof shaka.util.Error,\n          'Wrong error type!');\n      const eventType = shaka.Player.EventName.Error;\n      const data = (new Map()).set('detail', error);\n      const event = new shaka.util.FakeEvent(eventType, data);\n      this.localPlayer_.dispatchEvent(event);\n    });\n  }\n\n  /**\n   * @param {string} name\n   * @return {?}\n   * @private\n   */\n  videoProxyGet_(name) {\n    if (name == 'addEventListener') {\n      return (type, listener, options) => {\n        return this.videoEventTarget_.addEventListener(type, listener, options);\n      };\n    }\n    if (name == 'removeEventListener') {\n      return (type, listener, options) => {\n        return this.videoEventTarget_.removeEventListener(\n            type, listener, options);\n      };\n    }\n\n    // If we are casting, but the first update has not come in yet, use local\n    // values, but not local methods.\n    if (this.sender_.isCasting() && !this.sender_.hasRemoteProperties()) {\n      const value = this.localVideo_[name];\n      if (typeof value != 'function') {\n        return value;\n      }\n    }\n\n    // Use local values and methods if we are not casting.\n    if (!this.sender_.isCasting()) {\n      let value = this.localVideo_[name];\n      if (typeof value == 'function') {\n        // eslint-disable-next-line no-restricted-syntax\n        value = value.bind(this.localVideo_);\n      }\n      return value;\n    }\n\n    return this.sender_.get('video', name);\n  }\n\n  /**\n   * @param {string} name\n   * @param {?} value\n   * @private\n   */\n  videoProxySet_(name, value) {\n    if (!this.sender_.isCasting()) {\n      this.localVideo_[name] = value;\n      return;\n    }\n\n    this.sender_.set('video', name, value);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   */\n  videoProxyLocalEvent_(event) {\n    if (this.sender_.isCasting()) {\n      // Ignore any unexpected local events while casting.  Events can still be\n      // fired by the local video and Player when we unload() after the Cast\n      // connection is complete.\n      return;\n    }\n\n    // Convert this real Event into a FakeEvent for dispatch from our\n    // FakeEventListener.\n    const fakeEvent = shaka.util.FakeEvent.fromRealEvent(event);\n    this.videoEventTarget_.dispatchEvent(fakeEvent);\n  }\n\n  /**\n   * @param {string} name\n   * @return {?}\n   * @private\n   */\n  playerProxyGet_(name) {\n    // If name is a shortened compiled name, get the original version\n    // from our map.\n    if (this.compiledToExternNames_.has(name)) {\n      name = this.compiledToExternNames_.get(name);\n    }\n\n    if (name == 'addEventListener') {\n      return (type, listener, options) => {\n        return this.playerEventTarget_.addEventListener(\n            type, listener, options);\n      };\n    }\n    if (name == 'removeEventListener') {\n      return (type, listener, options) => {\n        return this.playerEventTarget_.removeEventListener(\n            type, listener, options);\n      };\n    }\n\n    if (name == 'getMediaElement') {\n      return () => this.videoProxy_;\n    }\n\n    if (name == 'getSharedConfiguration') {\n      shaka.log.warning(\n          'Can\\'t share configuration across a network. Returning copy.');\n      return this.sender_.get('player', 'getConfiguration');\n    }\n\n    if (name == 'getNetworkingEngine') {\n      // Always returns a local instance, in case you need to make a request.\n      // Issues a warning, in case you think you are making a remote request\n      // or affecting remote filters.\n      if (this.sender_.isCasting()) {\n        shaka.log.warning('NOTE: getNetworkingEngine() is always local!');\n      }\n      return () => this.localPlayer_.getNetworkingEngine();\n    }\n\n    if (name == 'getDrmEngine') {\n      // Always returns a local instance.\n      if (this.sender_.isCasting()) {\n        shaka.log.warning('NOTE: getDrmEngine() is always local!');\n      }\n      return () => this.localPlayer_.getDrmEngine();\n    }\n\n    if (name == 'getAdManager') {\n      // Always returns a local instance.\n      if (this.sender_.isCasting()) {\n        shaka.log.warning('NOTE: getAdManager() is always local!');\n      }\n      return () => this.localPlayer_.getAdManager();\n    }\n\n    if (name == 'setVideoContainer') {\n      // Always returns a local instance.\n      if (this.sender_.isCasting()) {\n        shaka.log.warning('NOTE: setVideoContainer() is always local!');\n      }\n      return (container) => this.localPlayer_.setVideoContainer(container);\n    }\n\n    if (this.sender_.isCasting()) {\n      // These methods are unavailable or otherwise stubbed during casting.\n      if (name == 'getManifest' || name == 'drmInfo') {\n        return () => {\n          shaka.log.alwaysWarn(name + '() does not work while casting!');\n          return null;\n        };\n      }\n\n      if (name == 'attach' || name == 'detach') {\n        return () => {\n          shaka.log.alwaysWarn(name + '() does not work while casting!');\n          return Promise.resolve();\n        };\n      }\n    }  // if (this.sender_.isCasting())\n\n    // If we are casting, but the first update has not come in yet, use local\n    // getters, but not local methods.\n    if (this.sender_.isCasting() && !this.sender_.hasRemoteProperties()) {\n      if (shaka.cast.CastUtils.PlayerGetterMethods[name] ||\n          shaka.cast.CastUtils.LargePlayerGetterMethods[name]) {\n        const value = /** @type {Object} */(this.localPlayer_)[name];\n        goog.asserts.assert(typeof value == 'function',\n            'only methods on Player');\n        // eslint-disable-next-line no-restricted-syntax\n        return value.bind(this.localPlayer_);\n      }\n    }\n\n    // Use local getters and methods if we are not casting.\n    if (!this.sender_.isCasting()) {\n      const value = /** @type {Object} */(this.localPlayer_)[name];\n      goog.asserts.assert(typeof value == 'function',\n          'only methods on Player');\n      // eslint-disable-next-line no-restricted-syntax\n      return value.bind(this.localPlayer_);\n    }\n\n    return this.sender_.get('player', name);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   */\n  playerProxyLocalEvent_(event) {\n    if (this.sender_.isCasting()) {\n      // Ignore any unexpected local events while casting.\n      return;\n    }\n\n    this.playerEventTarget_.dispatchEvent(event);\n  }\n\n  /**\n   * @param {string} targetName\n   * @param {!shaka.util.FakeEvent} event\n   * @private\n   */\n  onRemoteEvent_(targetName, event) {\n    goog.asserts.assert(this.sender_.isCasting(),\n        'Should only receive remote events while casting');\n    if (!this.sender_.isCasting()) {\n      // Ignore any unexpected remote events.\n      return;\n    }\n\n    if (targetName == 'video') {\n      this.videoEventTarget_.dispatchEvent(event);\n    } else if (targetName == 'player') {\n      this.playerEventTarget_.dispatchEvent(event);\n    }\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cast.CastReceiver');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Player');\ngoog.require('shaka.cast.CastUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * A receiver to communicate between the Chromecast-hosted player and the\n * sender application.\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.cast.CastReceiver = class extends shaka.util.FakeEventTarget {\n  /**\n   * @param {!HTMLMediaElement} video The local video element associated with\n   *   the local Player instance.\n   * @param {!shaka.Player} player A local Player instance.\n   * @param {function(Object)=} appDataCallback A callback to handle\n   *   application-specific data passed from the sender.  This can come either\n   *   from a Shaka-based sender through CastProxy.setAppData, or from a\n   *   sender using the customData field of the LOAD message of the standard\n   *   Cast message namespace.  It can also be null if no such data is sent.\n   * @param {function(string):string=} contentIdCallback A callback to\n   *   retrieve manifest URI from the provided content id.\n   */\n  constructor(video, player, appDataCallback, contentIdCallback) {\n    super();\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {shaka.Player} */\n    this.player_ = player;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {Object} */\n    this.targets_ = {\n      'video': video,\n      'player': player,\n    };\n\n    /** @private {?function(Object)} */\n    this.appDataCallback_ = appDataCallback || (() => {});\n\n    /** @private {?function(string):string} */\n    this.contentIdCallback_ = contentIdCallback ||\n                          /** @param {string} contentId\n                              @return {string} */\n                          ((contentId) => contentId);\n\n    /**\n     * A Cast metadata object, one of:\n     *  - https://developers.google.com/cast/docs/reference/messages#GenericMediaMetadata\n     *  - https://developers.google.com/cast/docs/reference/messages#MovieMediaMetadata\n     *  - https://developers.google.com/cast/docs/reference/messages#TvShowMediaMetadata\n     *  - https://developers.google.com/cast/docs/reference/messages#MusicTrackMediaMetadata\n     * @private {Object}\n     */\n    this.metadata_ = null;\n\n    /** @private {boolean} */\n    this.isConnected_ = false;\n\n    /** @private {boolean} */\n    this.isIdle_ = true;\n\n    /** @private {number} */\n    this.updateNumber_ = 0;\n\n    /** @private {boolean} */\n    this.startUpdatingUpdateNumber_ = false;\n\n    /** @private {boolean} */\n    this.initialStatusUpdatePending_ = true;\n\n    /** @private {cast.receiver.CastMessageBus} */\n    this.shakaBus_ = null;\n\n    /** @private {cast.receiver.CastMessageBus} */\n    this.genericBus_ = null;\n\n    /** @private {shaka.util.Timer} */\n    this.pollTimer_ = new shaka.util.Timer(() => {\n      this.pollAttributes_();\n    });\n\n    this.init_();\n  }\n\n  /**\n   * @return {boolean} True if the cast API is available and there are\n   *   receivers.\n   * @export\n   */\n  isConnected() {\n    return this.isConnected_;\n  }\n\n  /**\n   * @return {boolean} True if the receiver is not currently doing loading or\n   *   playing anything.\n   * @export\n   */\n  isIdle() {\n    return this.isIdle_;\n  }\n\n  /**\n   * Set all Cast content metadata, as defined by the Cast SDK.\n   * Should be called from an appDataCallback.\n   *\n   * For a simpler way to set basic metadata, see:\n   *  - setContentTitle()\n   *  - setContentImage()\n   *  - setContentArtist()\n   *\n   * @param {Object} metadata\n   *   A Cast metadata object, one of:\n   *    - https://developers.google.com/cast/docs/reference/messages#GenericMediaMetadata\n   *    - https://developers.google.com/cast/docs/reference/messages#MovieMediaMetadata\n   *    - https://developers.google.com/cast/docs/reference/messages#TvShowMediaMetadata\n   *    - https://developers.google.com/cast/docs/reference/messages#MusicTrackMediaMetadata\n   * @export\n   */\n  setContentMetadata(metadata) {\n    this.metadata_ = metadata;\n  }\n\n  /**\n   * Clear all Cast content metadata.\n   * Should be called from an appDataCallback.\n   *\n   * @export\n   */\n  clearContentMetadata() {\n    this.metadata_ = null;\n  }\n\n  /**\n   * Set the Cast content's title.\n   * Should be called from an appDataCallback.\n   *\n   * @param {string} title\n   * @export\n   */\n  setContentTitle(title) {\n    if (!this.metadata_) {\n      this.metadata_ = {\n        'metadataType': cast.receiver.media.MetadataType.GENERIC,\n      };\n    }\n    this.metadata_['title'] = title;\n  }\n\n  /**\n   * Set the Cast content's thumbnail image.\n   * Should be called from an appDataCallback.\n   *\n   * @param {string} imageUrl\n   * @export\n   */\n  setContentImage(imageUrl) {\n    if (!this.metadata_) {\n      this.metadata_ = {\n        'metadataType': cast.receiver.media.MetadataType.GENERIC,\n      };\n    }\n    this.metadata_['images'] = [\n      {\n        'url': imageUrl,\n      },\n    ];\n  }\n\n  /**\n   * Set the Cast content's artist.\n   * Also sets the metadata type to music.\n   * Should be called from an appDataCallback.\n   *\n   * @param {string} artist\n   * @export\n   */\n  setContentArtist(artist) {\n    if (!this.metadata_) {\n      this.metadata_ = {};\n    }\n    this.metadata_['artist'] = artist;\n    this.metadata_['metadataType'] =\n        cast.receiver.media.MetadataType.MUSIC_TRACK;\n  }\n\n  /**\n   * Destroys the underlying Player, then terminates the cast receiver app.\n   *\n   * @override\n   * @export\n   */\n  async destroy() {\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    const waitFor = [];\n    if (this.player_) {\n      waitFor.push(this.player_.destroy());\n      this.player_ = null;\n    }\n\n    if (this.pollTimer_) {\n      this.pollTimer_.stop();\n      this.pollTimer_ = null;\n    }\n\n    this.video_ = null;\n    this.targets_ = null;\n    this.appDataCallback_ = null;\n    this.isConnected_ = false;\n    this.isIdle_ = true;\n    this.shakaBus_ = null;\n    this.genericBus_ = null;\n\n    // FakeEventTarget implements IReleasable\n    super.release();\n\n    await Promise.all(waitFor);\n\n    const manager = cast.receiver.CastReceiverManager.getInstance();\n    manager.stop();\n  }\n\n  /** @private */\n  init_() {\n    const manager = cast.receiver.CastReceiverManager.getInstance();\n    manager.onSenderConnected = () => this.onSendersChanged_();\n    manager.onSenderDisconnected = () => this.onSendersChanged_();\n    manager.onSystemVolumeChanged = () => this.fakeVolumeChangeEvent_();\n\n    this.genericBus_ = manager.getCastMessageBus(\n        shaka.cast.CastUtils.GENERIC_MESSAGE_NAMESPACE);\n    this.genericBus_.onMessage = (event) => this.onGenericMessage_(event);\n\n    this.shakaBus_ = manager.getCastMessageBus(\n        shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE);\n    this.shakaBus_.onMessage = (event) => this.onShakaMessage_(event);\n\n    if (goog.DEBUG) {\n      // Sometimes it is useful to load the receiver app in Chrome to work on\n      // the UI.  To avoid log spam caused by the SDK trying to connect to web\n      // sockets that don't exist, in uncompiled mode we check if the hosting\n      // browser is a Chromecast before starting the receiver manager.  We\n      // wouldn't do browser detection except for debugging, so only do this in\n      // uncompiled mode.\n      if (shaka.util.Platform.isChromecast()) {\n        manager.start();\n      }\n    } else {\n      manager.start();\n    }\n\n    for (const name of shaka.cast.CastUtils.VideoEvents) {\n      this.eventManager_.listen(\n          this.video_, name, (event) => this.proxyEvent_('video', event));\n    }\n\n    for (const key in shaka.Player.EventName) {\n      const name = shaka.Player.EventName[key];\n      this.eventManager_.listen(\n          this.player_, name, (event) => this.proxyEvent_('player', event));\n    }\n\n    // In our tests, the original Chromecast seems to have trouble decoding\n    // above 1080p.  It would be a waste to select a higher res anyway, given\n    // that the device only outputs 1080p to begin with.\n\n    // Chromecast has an extension to query the device/display's resolution.\n    if (cast.__platform__ && cast.__platform__.canDisplayType(\n        'video/mp4; codecs=\"avc1.640028\"; width=3840; height=2160')) {\n      // The device and display can both do 4k.  Assume a 4k limit.\n      this.player_.setMaxHardwareResolution(3840, 2160);\n    } else {\n      // Chromecast has always been able to do 1080p.  Assume a 1080p limit.\n      this.player_.setMaxHardwareResolution(1920, 1080);\n    }\n\n    // Do not start excluding values from update messages until the video is\n    // fully loaded.\n    this.eventManager_.listen(this.video_, 'loadeddata', () => {\n      this.startUpdatingUpdateNumber_ = true;\n    });\n\n    // Maintain idle state.\n    this.eventManager_.listen(this.player_, 'loading', () => {\n      // No longer idle once loading.  This allows us to show the spinner during\n      // the initial buffering phase.\n      this.isIdle_ = false;\n      this.onCastStatusChanged_();\n    });\n    this.eventManager_.listen(this.video_, 'playing', () => {\n      // No longer idle once playing.  This allows us to replay a video without\n      // reloading.\n      this.isIdle_ = false;\n      this.onCastStatusChanged_();\n    });\n    this.eventManager_.listen(this.video_, 'pause', () => {\n      this.onCastStatusChanged_();\n    });\n    this.eventManager_.listen(this.player_, 'unloading', () => {\n      // Go idle when unloading content.\n      this.isIdle_ = true;\n      this.onCastStatusChanged_();\n    });\n    this.eventManager_.listen(this.video_, 'ended', () => {\n      // Go idle 5 seconds after 'ended', assuming we haven't started again or\n      // been destroyed.\n      const timer = new shaka.util.Timer(() => {\n        if (this.video_ && this.video_.ended) {\n          this.isIdle_ = true;\n          this.onCastStatusChanged_();\n        }\n      });\n\n      timer.tickAfter(shaka.cast.CastReceiver.IDLE_INTERVAL);\n    });\n\n    // Do not start polling until after the sender's 'init' message is handled.\n  }\n\n  /** @private */\n  onSendersChanged_() {\n    // Reset update message frequency values, to make sure whomever joined\n    // will get a full update message.\n    this.updateNumber_ = 0;\n    // Don't reset startUpdatingUpdateNumber_, because this operation does not\n    // result in new data being loaded.\n    this.initialStatusUpdatePending_ = true;\n\n    const manager = cast.receiver.CastReceiverManager.getInstance();\n    this.isConnected_ = manager.getSenders().length != 0;\n    this.onCastStatusChanged_();\n  }\n\n  /**\n   * Dispatch an event to notify the receiver app that the status has changed.\n   * @private\n   */\n  async onCastStatusChanged_() {\n    // Do this asynchronously so that synchronous changes to idle state (such as\n    // Player calling unload() as part of load()) are coalesced before the event\n    // goes out.\n    await Promise.resolve();\n    if (!this.player_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    const event = new shaka.util.FakeEvent('caststatuschanged');\n    this.dispatchEvent(event);\n    // Send a media status message, with a media info message if appropriate.\n    if (!this.maybeSendMediaInfoMessage_()) {\n      this.sendMediaStatus_();\n    }\n  }\n\n  /**\n   * Take on initial state from the sender.\n   * @param {shaka.cast.CastUtils.InitStateType} initState\n   * @param {Object} appData\n   * @private\n   */\n  async initState_(initState, appData) {\n    // Take on player state first.\n    for (const k in initState['player']) {\n      const v = initState['player'][k];\n      // All player state vars are setters to be called.\n      /** @type {Object} */(this.player_)[k](v);\n    }\n\n    // Now process custom app data, which may add additional player configs:\n    this.appDataCallback_(appData);\n\n    const autoplay = this.video_.autoplay;\n\n    // Now load the manifest, if present.\n    if (initState['manifest']) {\n      // Don't autoplay the content until we finish setting up initial state.\n      this.video_.autoplay = false;\n      try {\n        await this.player_.load(initState['manifest'], initState['startTime']);\n      } catch (error) {\n        // Pass any errors through to the app.\n        goog.asserts.assert(error instanceof shaka.util.Error,\n            'Wrong error type!');\n        const eventType = shaka.Player.EventName.Error;\n        const data = (new Map()).set('detail', error);\n        const event = new shaka.util.FakeEvent(eventType, data);\n        // Only dispatch the event if the player still exists.\n        if (this.player_) {\n          this.player_.dispatchEvent(event);\n        }\n        return;\n      }\n    } else {\n      // Ensure the below happens async.\n      await Promise.resolve();\n    }\n\n    if (!this.player_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    // Finally, take on video state and player's \"after load\" state.\n    for (const k in initState['video']) {\n      const v = initState['video'][k];\n      this.video_[k] = v;\n    }\n\n    for (const k in initState['playerAfterLoad']) {\n      const v = initState['playerAfterLoad'][k];\n      // All player state vars are setters to be called.\n      /** @type {Object} */(this.player_)[k](v);\n    }\n\n    // Restore original autoplay setting.\n    this.video_.autoplay = autoplay;\n    if (initState['manifest']) {\n      // Resume playback with transferred state.\n      this.video_.play();\n      // Notify generic controllers of the state change.\n      this.sendMediaStatus_();\n    }\n  }\n\n  /**\n   * @param {string} targetName\n   * @param {!Event} event\n   * @private\n   */\n  proxyEvent_(targetName, event) {\n    if (!this.player_) {\n      // The receiver is destroyed, so it should ignore further events.\n      return;\n    }\n\n    // Poll and send an update right before we send the event.  Some events\n    // indicate an attribute change, so that change should be visible when the\n    // event is handled.\n    this.pollAttributes_();\n\n    this.sendMessage_({\n      'type': 'event',\n      'targetName': targetName,\n      'event': event,\n    }, this.shakaBus_);\n  }\n\n  /** @private */\n  pollAttributes_() {\n    // The poll timer may have been pre-empted by an event (e.g. timeupdate).\n    // Calling |start| will cancel any pending calls and therefore will avoid us\n    // polling too often.\n    this.pollTimer_.tickAfter(shaka.cast.CastReceiver.POLL_INTERVAL);\n\n    const update = {\n      'video': {},\n      'player': {},\n    };\n\n    for (const name of shaka.cast.CastUtils.VideoAttributes) {\n      update['video'][name] = this.video_[name];\n    }\n\n    // TODO: Instead of this variable frequency update system, instead cache the\n    // previous player state and only send over changed values, with complete\n    // updates every ~20 updates to account for dropped messages.\n\n    if (this.player_.isLive()) {\n      const PlayerGetterMethodsThatRequireLive =\n          shaka.cast.CastUtils.PlayerGetterMethodsThatRequireLive;\n      for (const name in PlayerGetterMethodsThatRequireLive) {\n        const frequency = PlayerGetterMethodsThatRequireLive[name];\n        if (this.updateNumber_ % frequency == 0) {\n          update['player'][name] = /** @type {Object} */ (this.player_)[name]();\n        }\n      }\n    }\n    for (const name in shaka.cast.CastUtils.PlayerGetterMethods) {\n      const frequency = shaka.cast.CastUtils.PlayerGetterMethods[name];\n      if (this.updateNumber_ % frequency == 0) {\n        update['player'][name] = /** @type {Object} */ (this.player_)[name]();\n      }\n    }\n\n    // Volume attributes are tied to the system volume.\n    const manager = cast.receiver.CastReceiverManager.getInstance();\n    const systemVolume = manager.getSystemVolume();\n    if (systemVolume) {\n      update['video']['volume'] = systemVolume.level;\n      update['video']['muted'] = systemVolume.muted;\n    }\n\n    this.sendMessage_({\n      'type': 'update',\n      'update': update,\n    }, this.shakaBus_);\n\n    // Getters with large outputs each get sent in their own update message.\n    for (const name in shaka.cast.CastUtils.LargePlayerGetterMethods) {\n      const frequency = shaka.cast.CastUtils.LargePlayerGetterMethods[name];\n      if (this.updateNumber_ % frequency == 0) {\n        const update = {'player': {}};\n        update['player'][name] = /** @type {Object} */ (this.player_)[name]();\n\n        this.sendMessage_({\n          'type': 'update',\n          'update': update,\n        }, this.shakaBus_);\n      }\n    }\n\n    // Only start progressing the update number once data is loaded,\n    // just in case any of the \"rarely changing\" properties with less frequent\n    // update messages changes significantly during the loading process.\n    if (this.startUpdatingUpdateNumber_) {\n      this.updateNumber_ += 1;\n    }\n\n    this.maybeSendMediaInfoMessage_();\n  }\n\n  /**\n   * Composes and sends a mediaStatus message if appropriate.\n   * @return {boolean}\n   * @private\n   */\n  maybeSendMediaInfoMessage_() {\n    if (this.initialStatusUpdatePending_ &&\n        (this.video_.duration || this.player_.isLive())) {\n      // Send over a media status message to set the duration of the cast\n      // dialogue.\n      this.sendMediaInfoMessage_();\n      this.initialStatusUpdatePending_ = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Composes and sends a mediaStatus message with a mediaInfo component.\n   *\n   * @param {number=} requestId\n   * @private\n   */\n  sendMediaInfoMessage_(requestId = 0) {\n    const media = {\n      'contentId': this.player_.getAssetUri(),\n      'streamType': this.player_.isLive() ? 'LIVE' : 'BUFFERED',\n      // Sending an empty string for now since it's a mandatory field.\n      // We don't have this info, and it doesn't seem to be useful, anyway.\n      'contentType': '',\n    };\n    if (!this.player_.isLive()) {\n      // Optional, and only sent when the duration is known.\n      media['duration'] = this.video_.duration;\n    }\n    if (this.metadata_) {\n      media['metadata'] = this.metadata_;\n    }\n    this.sendMediaStatus_(requestId, media);\n  }\n\n  /**\n   * Dispatch a fake 'volumechange' event to mimic the video element, since\n   * volume changes are routed to the system volume on the receiver.\n   * @private\n   */\n  fakeVolumeChangeEvent_() {\n    // Volume attributes are tied to the system volume.\n    const manager = cast.receiver.CastReceiverManager.getInstance();\n    const systemVolume = manager.getSystemVolume();\n    goog.asserts.assert(systemVolume, 'System volume should not be null!');\n\n    if (systemVolume) {\n      // Send an update message with just the latest volume level and muted\n      // state.\n      this.sendMessage_({\n        'type': 'update',\n        'update': {\n          'video': {\n            'volume': systemVolume.level,\n            'muted': systemVolume.muted,\n          },\n        },\n      }, this.shakaBus_);\n    }\n\n    // Send another message with a 'volumechange' event to update the sender's\n    // UI.\n    this.sendMessage_({\n      'type': 'event',\n      'targetName': 'video',\n      'event': {'type': 'volumechange'},\n    }, this.shakaBus_);\n  }\n\n  /**\n   * Since this method is in the compiled library, make sure all messages are\n   * read with quoted properties.\n   * @param {!cast.receiver.CastMessageBus.Event} event\n   * @private\n   */\n  onShakaMessage_(event) {\n    const message = shaka.cast.CastUtils.deserialize(event.data);\n    shaka.log.debug('CastReceiver: message', message);\n\n    switch (message['type']) {\n      case 'init':\n        // Reset update message frequency values after initialization.\n        this.updateNumber_ = 0;\n        this.startUpdatingUpdateNumber_ = false;\n        this.initialStatusUpdatePending_ = true;\n\n        this.initState_(message['initState'], message['appData']);\n        // The sender is supposed to reflect the cast system volume after\n        // connecting.  Using fakeVolumeChangeEvent_() would create a race on\n        // the sender side, since it would have volume properties, but no\n        // others.\n        // This would lead to hasRemoteProperties() being true, even though a\n        // complete set had never been sent.\n        // Now that we have init state, this is a good time for the first update\n        // message anyway.\n        this.pollAttributes_();\n        break;\n      case 'appData':\n        this.appDataCallback_(message['appData']);\n        break;\n      case 'set': {\n        const targetName = message['targetName'];\n        const property = message['property'];\n        const value = message['value'];\n\n        if (targetName == 'video') {\n          // Volume attributes must be rerouted to the system.\n          const manager = cast.receiver.CastReceiverManager.getInstance();\n          if (property == 'volume') {\n            manager.setSystemVolumeLevel(value);\n            break;\n          } else if (property == 'muted') {\n            manager.setSystemVolumeMuted(value);\n            break;\n          }\n        }\n\n        this.targets_[targetName][property] = value;\n        break;\n      }\n      case 'call': {\n        const targetName = message['targetName'];\n        const methodName = message['methodName'];\n        const args = message['args'];\n        const target = this.targets_[targetName];\n        // eslint-disable-next-line prefer-spread\n        target[methodName].apply(target, args);\n        break;\n      }\n      case 'asyncCall': {\n        const targetName = message['targetName'];\n        const methodName = message['methodName'];\n        if (targetName == 'player' && methodName == 'load') {\n          // Reset update message frequency values after a load.\n          this.updateNumber_ = 0;\n          this.startUpdatingUpdateNumber_ = false;\n        }\n        const args = message['args'];\n        const id = message['id'];\n        const senderId = event.senderId;\n        const target = this.targets_[targetName];\n        // eslint-disable-next-line prefer-spread\n        let p = target[methodName].apply(target, args);\n        if (targetName == 'player' && methodName == 'load') {\n          // Wait until the manifest has actually loaded to send another media\n          // info message, so on a new load it doesn't send the old info over.\n          p = p.then(() => {\n            this.initialStatusUpdatePending_ = true;\n          });\n        }\n        // Replies must go back to the specific sender who initiated, so that we\n        // don't have to deal with conflicting IDs between senders.\n        p.then(\n            () => this.sendAsyncComplete_(senderId, id, /* error= */ null),\n            (error) => this.sendAsyncComplete_(senderId, id, error));\n        break;\n      }\n    }\n  }\n\n  /**\n   * @param {!cast.receiver.CastMessageBus.Event} event\n   * @private\n   */\n  onGenericMessage_(event) {\n    const message = shaka.cast.CastUtils.deserialize(event.data);\n    shaka.log.debug('CastReceiver: message', message);\n    // TODO(ismena): error message on duplicate request id from the same sender\n    switch (message['type']) {\n      case 'PLAY':\n        this.video_.play();\n        // Notify generic controllers that the player state changed.\n        // requestId=0 (the parameter) means that the message was not\n        // triggered by a GET_STATUS request.\n        this.sendMediaStatus_();\n        break;\n      case 'PAUSE':\n        this.video_.pause();\n        this.sendMediaStatus_();\n        break;\n      case 'SEEK': {\n        const currentTime = message['currentTime'];\n        const resumeState = message['resumeState'];\n        if (currentTime != null) {\n          this.video_.currentTime = Number(currentTime);\n        }\n        if (resumeState && resumeState == 'PLAYBACK_START') {\n          this.video_.play();\n          this.sendMediaStatus_();\n        } else if (resumeState && resumeState == 'PLAYBACK_PAUSE') {\n          this.video_.pause();\n          this.sendMediaStatus_();\n        }\n        break;\n      }\n      case 'STOP':\n        this.player_.unload().then(() => {\n          if (!this.player_) {\n            // We've already been destroyed.\n            return;\n          }\n\n          this.sendMediaStatus_();\n        });\n        break;\n      case 'GET_STATUS':\n        // TODO(ismena): According to the SDK this is supposed to be a\n        // unicast message to the sender that requested the status,\n        // but it doesn't appear to be working.\n        // Look into what's going on there and change this to be a\n        // unicast.\n        this.sendMediaInfoMessage_(Number(message['requestId']));\n        break;\n      case 'VOLUME': {\n        const volumeObject = message['volume'];\n        const level = volumeObject['level'];\n        const muted = volumeObject['muted'];\n        const oldVolumeLevel = this.video_.volume;\n        const oldVolumeMuted = this.video_.muted;\n        if (level != null) {\n          this.video_.volume = Number(level);\n        }\n        if (muted != null) {\n          this.video_.muted = muted;\n        }\n        // Notify generic controllers if the volume changed.\n        if (oldVolumeLevel != this.video_.volume ||\n            oldVolumeMuted != this.video_.muted) {\n          this.sendMediaStatus_();\n        }\n        break;\n      }\n      case 'LOAD': {\n        // Reset update message frequency values after a load.\n        this.updateNumber_ = 0;\n        this.startUpdatingUpdateNumber_ = false;\n        // This already sends an update.\n        this.initialStatusUpdatePending_ = false;\n\n        const mediaInfo = message['media'];\n        const contentId = mediaInfo['contentId'];\n        const currentTime = message['currentTime'];\n        const assetUri = this.contentIdCallback_(contentId);\n        const autoplay = message['autoplay'] || true;\n        const customData = mediaInfo['customData'];\n\n        this.appDataCallback_(customData);\n\n        if (autoplay) {\n          this.video_.autoplay = true;\n        }\n        this.player_.load(assetUri, currentTime).then(() => {\n          if (!this.player_) {\n            // We've already been destroyed.\n            return;\n          }\n\n          // Notify generic controllers that the media has changed.\n          this.sendMediaInfoMessage_();\n        }).catch((error) => {\n          goog.asserts.assert(error instanceof shaka.util.Error,\n              'Wrong error type!');\n\n          // Load failed.  Dispatch the error message to the sender.\n          let type = 'LOAD_FAILED';\n          if (error.category == shaka.util.Error.Category.PLAYER &&\n              error.code == shaka.util.Error.Code.LOAD_INTERRUPTED) {\n            type = 'LOAD_CANCELLED';\n          }\n\n          this.sendMessage_({\n            'requestId': Number(message['requestId']),\n            'type': type,\n          }, this.genericBus_);\n        });\n        break;\n      }\n      default:\n        shaka.log.warning(\n            'Unrecognized message type from the generic Chromecast controller!',\n            message['type']);\n        // Dispatch an error to the sender.\n        this.sendMessage_({\n          'requestId': Number(message['requestId']),\n          'type': 'INVALID_REQUEST',\n          'reason': 'INVALID_COMMAND',\n        }, this.genericBus_);\n        break;\n    }\n  }\n\n  /**\n   * Tell the sender that the async operation is complete.\n   * @param {string} senderId\n   * @param {string} id\n   * @param {shaka.util.Error} error\n   * @private\n   */\n  sendAsyncComplete_(senderId, id, error) {\n    if (!this.player_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    this.sendMessage_({\n      'type': 'asyncComplete',\n      'id': id,\n      'error': error,\n    }, this.shakaBus_, senderId);\n  }\n\n  /**\n   * Since this method is in the compiled library, make sure all messages passed\n   * in here were created with quoted property names.\n   * @param {!Object} message\n   * @param {cast.receiver.CastMessageBus} bus\n   * @param {string=} senderId\n   * @private\n   */\n  sendMessage_(message, bus, senderId) {\n    // Cuts log spam when debugging the receiver UI in Chrome.\n    if (!this.isConnected_) {\n      return;\n    }\n\n    const serialized = shaka.cast.CastUtils.serialize(message);\n    if (senderId) {\n      bus.getCastChannel(senderId).send(serialized);\n    } else {\n      bus.broadcast(serialized);\n    }\n  }\n\n  /**\n   * @return {string}\n   * @private\n   */\n  getPlayState_() {\n    const playState = shaka.cast.CastReceiver.PLAY_STATE;\n    if (this.isIdle_) {\n      return playState.IDLE;\n    } else if (this.player_.isBuffering()) {\n      return playState.BUFFERING;\n    } else if (this.video_.paused) {\n      return playState.PAUSED;\n    } else {\n      return playState.PLAYING;\n    }\n  }\n\n  /**\n   * @param {number=} requestId\n   * @param {Object=} media\n   * @private\n   */\n  sendMediaStatus_(requestId = 0, media = null) {\n    const mediaStatus = {\n      // mediaSessionId is a unique ID for the playback of this specific\n      // session.\n      // It's used to identify a specific instance of a playback.\n      // We don't support multiple playbacks, so just return 0.\n      'mediaSessionId': 0,\n      'playbackRate': this.video_.playbackRate,\n      'playerState': this.getPlayState_(),\n      'currentTime': this.video_.currentTime,\n      // supportedMediaCommands is a sum of all the flags of commands that the\n      // player supports.\n      // The list of comands with respective flags is:\n      // 1 - Pause\n      // 2 - Seek\n      // 4 - Stream volume\n      // 8 - Stream mute\n      // 16 - Skip forward\n      // 32 - Skip backward\n      // We support all of them, and their sum is 63.\n      'supportedMediaCommands': 63,\n      'volume': {\n        'level': this.video_.volume,\n        'muted': this.video_.muted,\n      },\n    };\n\n    if (media) {\n      mediaStatus['media'] = media;\n    }\n\n    const ret = {\n      'requestId': requestId,\n      'type': 'MEDIA_STATUS',\n      'status': [mediaStatus],\n    };\n\n    this.sendMessage_(ret, this.genericBus_);\n  }\n};\n\n/** @type {number} The interval, in seconds, to poll for changes. */\nshaka.cast.CastReceiver.POLL_INTERVAL = 0.5;\n\n/** @type {number} The interval, in seconds, to go \"idle\". */\nshaka.cast.CastReceiver.IDLE_INTERVAL = 5;\n\n/**\n * @enum {string}\n */\nshaka.cast.CastReceiver.PLAY_STATE = {\n  IDLE: 'IDLE',\n  PLAYING: 'PLAYING',\n  BUFFERING: 'BUFFERING',\n  PAUSED: 'PAUSED',\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Pssh');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @summary\n * Parse a PSSH box and extract the system IDs.\n */\nshaka.util.Pssh = class {\n  /**\n   * @param {!Uint8Array} psshBox\n   */\n  constructor(psshBox) {\n    /**\n     * In hex.\n     * @type {!Array.<string>}\n     */\n    this.systemIds = [];\n\n    /**\n     * In hex.\n     * @type {!Array.<string>}\n     */\n    this.cencKeyIds = [];\n\n    /**\n     * Array with the pssh boxes found.\n     * @type {!Array.<!Uint8Array>}\n     */\n    this.data = [];\n\n    new shaka.util.Mp4Parser()\n        .box('moov', shaka.util.Mp4Parser.children)\n        .fullBox('pssh', (box) => this.parsePsshBox_(box))\n        .parse(psshBox);\n\n    if (this.data.length == 0) {\n      shaka.log.warning('No pssh box found!');\n    }\n  }\n\n\n  /**\n   * @param {!shaka.extern.ParsedBox} box\n   * @private\n   */\n  parsePsshBox_(box) {\n    goog.asserts.assert(\n        box.version != null,\n        'PSSH boxes are full boxes and must have a valid version');\n\n    goog.asserts.assert(\n        box.flags != null,\n        'PSSH boxes are full boxes and must have a valid flag');\n\n    if (box.version > 1) {\n      shaka.log.warning('Unrecognized PSSH version found!');\n      return;\n    }\n\n    // The \"reader\" gives us a view on the payload of the box.  Create a new\n    // view that contains the whole box.\n    const dataView = box.reader.getDataView();\n    goog.asserts.assert(\n        dataView.byteOffset >= 12, 'DataView at incorrect position');\n    const pssh = shaka.util.BufferUtils.toUint8(dataView, -12, box.size);\n    this.data.push(pssh);\n\n    this.systemIds.push(\n        shaka.util.Uint8ArrayUtils.toHex(box.reader.readBytes(16)));\n    if (box.version > 0) {\n      const numKeyIds = box.reader.readUint32();\n      for (let i = 0; i < numKeyIds; i++) {\n        const keyId =\n            shaka.util.Uint8ArrayUtils.toHex(box.reader.readBytes(16));\n        this.cencKeyIds.push(keyId);\n      }\n    }\n  }\n\n  /**\n   * Creates a pssh blob from the given system ID and data.\n   *\n   * @param {!Uint8Array} data\n   * @param {!Uint8Array} systemId\n   * @return {!Uint8Array}\n   */\n  static createPssh(data, systemId) {\n    goog.asserts.assert(systemId.byteLength == 16, 'Invalid system ID length');\n    const dataLength = data.length;\n    const psshSize = 0x4 + 0x4 + 0x4 + systemId.length + 0x4 + dataLength;\n\n    /** @type {!Uint8Array} */\n    const psshBox = new Uint8Array(psshSize);\n    /** @type {!DataView} */\n    const psshData = shaka.util.BufferUtils.toDataView(psshBox);\n\n    let byteCursor = 0;\n    psshData.setUint32(byteCursor, psshSize);\n    byteCursor += 0x4;\n    psshData.setUint32(byteCursor, 0x70737368);  // 'pssh'\n    byteCursor += 0x4;\n    psshData.setUint32(byteCursor, 0);  // flags\n    byteCursor += 0x4;\n    psshBox.set(systemId, byteCursor);\n    byteCursor += systemId.length;\n    psshData.setUint32(byteCursor, dataLength);\n    byteCursor += 0x4;\n    psshBox.set(data, byteCursor);\n    byteCursor += dataLength;\n\n    goog.asserts.assert(byteCursor === psshSize, 'PSSH invalid length.');\n    return psshBox;\n  }\n\n\n  /**\n   * Normalise the initData array. This is to apply browser specific\n   * work-arounds, e.g. removing duplicates which appears to occur\n   * intermittently when the native msneedkey event fires (i.e. event.initData\n   * contains dupes).\n   *\n   * @param {!Uint8Array} initData\n   * @return {!Uint8Array}\n   */\n  static normaliseInitData(initData) {\n    if (!initData) {\n      return initData;\n    }\n\n    const pssh = new shaka.util.Pssh(initData);\n\n    // If there is only a single pssh, return the original array.\n    if (pssh.data.length <= 1) {\n      return initData;\n    }\n\n    // Dedupe psshData.\n    /** @type {!Array.<!Uint8Array>} */\n    const dedupedInitDatas = [];\n    for (const initData of pssh.data) {\n      const found = dedupedInitDatas.some((x) => {\n        return shaka.util.BufferUtils.equal(x, initData);\n      });\n\n      if (!found) {\n        dedupedInitDatas.push(initData);\n      }\n    }\n\n    return shaka.util.Uint8ArrayUtils.concat(...dedupedInitDatas);\n  }\n};\n\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.ContentProtection');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.Pssh');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Uint8ArrayUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @summary A set of functions for parsing and interpreting ContentProtection\n *   elements.\n */\nshaka.dash.ContentProtection = class {\n  /**\n   * Parses info from the ContentProtection elements at the AdaptationSet level.\n   *\n   * @param {!Array.<!Element>} elems\n   * @param {boolean} ignoreDrmInfo\n   * @param {!Object.<string, string>} keySystemsByURI\n   * @return {shaka.dash.ContentProtection.Context}\n   */\n  static parseFromAdaptationSet(elems, ignoreDrmInfo, keySystemsByURI) {\n    const ContentProtection = shaka.dash.ContentProtection;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const parsed = ContentProtection.parseElements_(elems);\n    /** @type {Array.<shaka.extern.InitDataOverride>} */\n    let defaultInit = null;\n    /** @type {!Array.<shaka.extern.DrmInfo>} */\n    let drmInfos = [];\n    let parsedNonCenc = [];\n\n    // Get the default key ID; if there are multiple, they must all match.\n    const keyIds = new Set(parsed.map((element) => element.keyId));\n    // Remove any possible null value (elements may have no key ids).\n    keyIds.delete(null);\n\n    if (keyIds.size > 1) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_CONFLICTING_KEY_IDS);\n    }\n\n    if (!ignoreDrmInfo) {\n      // Find the default key ID and init data.  Create a new array of all the\n      // non-CENC elements.\n      parsedNonCenc = parsed.filter((elem) => {\n        if (elem.schemeUri == ContentProtection.MP4Protection_) {\n          goog.asserts.assert(!elem.init || elem.init.length,\n              'Init data must be null or non-empty.');\n          defaultInit = elem.init || defaultInit;\n          return false;\n        } else {\n          return true;\n        }\n      });\n\n      if (parsedNonCenc.length) {\n        drmInfos = ContentProtection.convertElements_(\n            defaultInit, parsedNonCenc, keySystemsByURI);\n\n        // If there are no drmInfos after parsing, then add a dummy entry.\n        // This may be removed in parseKeyIds.\n        if (drmInfos.length == 0) {\n          drmInfos = [ManifestParserUtils.createDrmInfo('', defaultInit)];\n        }\n      }\n    }\n\n    // If there are only CENC element(s) or ignoreDrmInfo flag is set, assume\n    // all key-systems are supported.\n    if (parsed.length && (ignoreDrmInfo || !parsedNonCenc.length)) {\n      drmInfos = [];\n\n      for (const keySystem of Object.values(keySystemsByURI)) {\n        // If the manifest doesn't specify any key systems, we shouldn't\n        // put clearkey in this list.  Otherwise, it may be triggered when\n        // a real key system should be used instead.\n        if (keySystem != 'org.w3.clearkey') {\n          const info =\n              ManifestParserUtils.createDrmInfo(keySystem, defaultInit);\n          drmInfos.push(info);\n        }\n      }\n    }\n\n    // If we have a default key id, apply it to every initData.\n    const defaultKeyId = Array.from(keyIds)[0] || null;\n\n    if (defaultKeyId) {\n      for (const info of drmInfos) {\n        for (const initData of info.initData) {\n          initData.keyId = defaultKeyId;\n        }\n      }\n    }\n\n    return {\n      defaultKeyId: defaultKeyId,\n      defaultInit: defaultInit,\n      drmInfos: drmInfos,\n      firstRepresentation: true,\n    };\n  }\n\n  /**\n   * Parses the given ContentProtection elements found at the Representation\n   * level.  This may update the |context|.\n   *\n   * @param {!Array.<!Element>} elems\n   * @param {shaka.dash.ContentProtection.Context} context\n   * @param {boolean} ignoreDrmInfo\n   * @param {!Object.<string, string>} keySystemsByURI\n   * @return {?string} The parsed key ID\n   */\n  static parseFromRepresentation(\n      elems, context, ignoreDrmInfo, keySystemsByURI) {\n    const ContentProtection = shaka.dash.ContentProtection;\n    const repContext = ContentProtection.parseFromAdaptationSet(\n        elems, ignoreDrmInfo, keySystemsByURI);\n\n    if (context.firstRepresentation) {\n      const asUnknown = context.drmInfos.length == 1 &&\n          !context.drmInfos[0].keySystem;\n      const asUnencrypted = context.drmInfos.length == 0;\n      const repUnencrypted = repContext.drmInfos.length == 0;\n\n      // There are two cases where we need to replace the |drmInfos| in the\n      // context with those in the Representation:\n      //   1. The AdaptationSet does not list any ContentProtection.\n      //   2. The AdaptationSet only lists unknown key-systems.\n      if (asUnencrypted || (asUnknown && !repUnencrypted)) {\n        context.drmInfos = repContext.drmInfos;\n      }\n      context.firstRepresentation = false;\n    } else if (repContext.drmInfos.length > 0) {\n      // If this is not the first Representation, then we need to remove entries\n      // from the context that do not appear in this Representation.\n      context.drmInfos = context.drmInfos.filter((asInfo) => {\n        return repContext.drmInfos.some((repInfo) => {\n          return repInfo.keySystem == asInfo.keySystem;\n        });\n      });\n      // If we have filtered out all key-systems, throw an error.\n      if (context.drmInfos.length == 0) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.DASH_NO_COMMON_KEY_SYSTEM);\n      }\n    }\n\n    return repContext.defaultKeyId || context.defaultKeyId;\n  }\n\n  /**\n   * Gets a Widevine license URL from a content protection element\n   * containing a custom `ms:laurl` element\n   *\n   * @param {shaka.dash.ContentProtection.Element} element\n   * @return {string}\n   */\n  static getWidevineLicenseUrl(element) {\n    const mslaurlNode = shaka.util.XmlUtils.findChildNS(\n        element.node, 'urn:microsoft', 'laurl');\n    if (mslaurlNode) {\n      return mslaurlNode.getAttribute('licenseUrl') || '';\n    }\n    return '';\n  }\n\n  /**\n   * Parses an Array buffer starting at byteOffset for PlayReady Object Records.\n   * Each PRO Record is preceded by its PlayReady Record type and length in\n   * bytes.\n   *\n   * PlayReady Object Record format: https://goo.gl/FTcu46\n   *\n   * @param {!DataView} view\n   * @param {number} byteOffset\n   * @return {!Array.<shaka.dash.ContentProtection.PlayReadyRecord>}\n   * @private\n   */\n  static parseMsProRecords_(view, byteOffset) {\n    const records = [];\n\n    while (byteOffset < view.byteLength - 1) {\n      const type = view.getUint16(byteOffset, true);\n      byteOffset += 2;\n\n      const byteLength = view.getUint16(byteOffset, true);\n      byteOffset += 2;\n\n      if ((byteLength & 1) != 0 || byteLength + byteOffset > view.byteLength) {\n        shaka.log.warning('Malformed MS PRO object');\n        return [];\n      }\n\n      const recordValue = shaka.util.BufferUtils.toUint8(\n          view, byteOffset, byteLength);\n      records.push({\n        type: type,\n        value: recordValue,\n      });\n\n      byteOffset += byteLength;\n    }\n\n    return records;\n  }\n\n  /**\n   * Parses a buffer for PlayReady Objects.  The data\n   * should contain a 32-bit integer indicating the length of\n   * the PRO in bytes.  Following that, a 16-bit integer for\n   * the number of PlayReady Object Records in the PRO.  Lastly,\n   * a byte array of the PRO Records themselves.\n   *\n   * PlayReady Object format: https://goo.gl/W8yAN4\n   *\n   * @param {BufferSource} data\n   * @return {!Array.<shaka.dash.ContentProtection.PlayReadyRecord>}\n   * @private\n   */\n  static parseMsPro_(data) {\n    let byteOffset = 0;\n    const view = shaka.util.BufferUtils.toDataView(data);\n\n    // First 4 bytes is the PRO length (DWORD)\n    const byteLength = view.getUint32(byteOffset, /* littleEndian= */ true);\n    byteOffset += 4;\n\n    if (byteLength != data.byteLength) {\n      // Malformed PRO\n      shaka.log.warning('PlayReady Object with invalid length encountered.');\n      return [];\n    }\n\n    // Skip PRO Record count (WORD)\n    byteOffset += 2;\n\n    // Rest of the data contains the PRO Records\n    const ContentProtection = shaka.dash.ContentProtection;\n    return ContentProtection.parseMsProRecords_(view, byteOffset);\n  }\n\n  /**\n   * PlayReady Header format: https://goo.gl/dBzxNA\n   *\n   * @param {!Element} xml\n   * @return {string}\n   * @private\n   */\n  static getLaurl_(xml) {\n    // LA_URL element is optional and no more than one is\n    // allowed inside the DATA element. Only absolute URLs are allowed.\n    // If the LA_URL element exists, it must not be empty.\n    for (const elem of xml.getElementsByTagName('DATA')) {\n      for (const child of elem.childNodes) {\n        if (child instanceof Element && child.tagName == 'LA_URL') {\n          return child.textContent;\n        }\n      }\n    }\n\n    // Not found\n    return '';\n  }\n\n  /**\n   * Gets a PlayReady license URL from a content protection element\n   * containing a PlayReady Header Object\n   *\n   * @param {shaka.dash.ContentProtection.Element} element\n   * @return {string}\n   */\n  static getPlayReadyLicenseUrl(element) {\n    const proNode = shaka.util.XmlUtils.findChildNS(\n        element.node, 'urn:microsoft:playready', 'pro');\n\n    if (!proNode) {\n      return '';\n    }\n\n    const ContentProtection = shaka.dash.ContentProtection;\n    const PLAYREADY_RECORD_TYPES = ContentProtection.PLAYREADY_RECORD_TYPES;\n\n    const bytes = shaka.util.Uint8ArrayUtils.fromBase64(proNode.textContent);\n    const records = ContentProtection.parseMsPro_(bytes);\n    const record = records.filter((record) => {\n      return record.type === PLAYREADY_RECORD_TYPES.RIGHTS_MANAGEMENT;\n    })[0];\n\n    if (!record) {\n      return '';\n    }\n\n    const xml = shaka.util.StringUtils.fromUTF16(record.value, true);\n    const rootElement = shaka.util.XmlUtils.parseXmlString(xml, 'WRMHEADER');\n    if (!rootElement) {\n      return '';\n    }\n\n    return ContentProtection.getLaurl_(rootElement);\n  }\n\n  /**\n   * Gets a PlayReady initData from a content protection element\n   * containing a PlayReady Pro Object\n   *\n   * @param {shaka.dash.ContentProtection.Element} element\n   * @return {?Array.<shaka.extern.InitDataOverride>}\n   * @private\n   */\n  static getInitDataFromPro_(element) {\n    const proNode = shaka.util.XmlUtils.findChildNS(\n        element.node, 'urn:microsoft:playready', 'pro');\n    if (!proNode) {\n      return null;\n    }\n    const Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n    const data = Uint8ArrayUtils.fromBase64(proNode.textContent);\n    const systemId = new Uint8Array([\n      0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86,\n      0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95,\n    ]);\n    const pssh = shaka.util.Pssh.createPssh(data, systemId);\n    return [\n      {\n        initData: pssh,\n        initDataType: 'cenc',\n        keyId: element.keyId,\n      },\n    ];\n  }\n\n  /**\n   * Creates DrmInfo objects from the given element.\n   *\n   * @param {Array.<shaka.extern.InitDataOverride>} defaultInit\n   * @param {!Array.<shaka.dash.ContentProtection.Element>} elements\n   * @param {!Object.<string, string>} keySystemsByURI\n   * @return {!Array.<shaka.extern.DrmInfo>}\n   * @private\n   */\n  static convertElements_(defaultInit, elements, keySystemsByURI) {\n    const ContentProtection = shaka.dash.ContentProtection;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const licenseUrlParsers = ContentProtection.licenseUrlParsers_;\n\n    /** @type {!Array.<shaka.extern.DrmInfo>} */\n    const out = [];\n\n    for (const element of elements) {\n      const keySystem = keySystemsByURI[element.schemeUri];\n      if (keySystem) {\n        goog.asserts.assert(\n            !element.init || element.init.length,\n            'Init data must be null or non-empty.');\n\n        const proInitData = ContentProtection.getInitDataFromPro_(element);\n        const initData = element.init || defaultInit || proInitData;\n        const info = ManifestParserUtils.createDrmInfo(keySystem, initData);\n        const licenseParser = licenseUrlParsers.get(keySystem);\n        if (licenseParser) {\n          info.licenseServerUri = licenseParser(element);\n        }\n\n        out.push(info);\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Parses the given ContentProtection elements.  If there is an error, it\n   * removes those elements.\n   *\n   * @param {!Array.<!Element>} elems\n   * @return {!Array.<shaka.dash.ContentProtection.Element>}\n   * @private\n   */\n  static parseElements_(elems) {\n    /** @type {!Array.<shaka.dash.ContentProtection.Element>} */\n    const out = [];\n\n    for (const elem of elems) {\n      const parsed = shaka.dash.ContentProtection.parseElement_(elem);\n      if (parsed) {\n        out.push(parsed);\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Parses the given ContentProtection element.\n   *\n   * @param {!Element} elem\n   * @return {?shaka.dash.ContentProtection.Element}\n   * @private\n   */\n  static parseElement_(elem) {\n    const NS = shaka.dash.ContentProtection.CencNamespaceUri_;\n\n    /** @type {?string} */\n    let schemeUri = elem.getAttribute('schemeIdUri');\n    /** @type {?string} */\n    let keyId = shaka.util.XmlUtils.getAttributeNS(elem, NS, 'default_KID');\n    /** @type {!Array.<string>} */\n    const psshs = shaka.util.XmlUtils.findChildrenNS(elem, NS, 'pssh')\n        .map(shaka.util.XmlUtils.getContents);\n\n    if (!schemeUri) {\n      shaka.log.error('Missing required schemeIdUri attribute on',\n          'ContentProtection element', elem);\n      return null;\n    }\n\n    schemeUri = schemeUri.toLowerCase();\n    if (keyId) {\n      keyId = keyId.replace(/-/g, '').toLowerCase();\n      if (keyId.includes(' ')) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED);\n      }\n    }\n\n    /** @type {!Array.<shaka.extern.InitDataOverride>} */\n    let init = [];\n    try {\n      // Try parsing PSSH data.\n      init = psshs.map((pssh) => {\n        return {\n          initDataType: 'cenc',\n          initData: shaka.util.Uint8ArrayUtils.fromBase64(pssh),\n          keyId: null,\n        };\n      });\n    } catch (e) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_PSSH_BAD_ENCODING);\n    }\n\n    return {\n      node: elem,\n      schemeUri: schemeUri,\n      keyId: keyId,\n      init: (init.length > 0 ? init : null),\n    };\n  }\n};\n\n/**\n * @typedef {{\n *   type: number,\n *   value: !Uint8Array\n * }}\n *\n * @description\n * The parsed result of a PlayReady object record.\n *\n * @property {number} type\n *   Type of data stored in the record.\n * @property {!Uint8Array} value\n *   Record content.\n */\nshaka.dash.ContentProtection.PlayReadyRecord;\n\n/**\n * Enum for PlayReady record types.\n * @enum {number}\n */\nshaka.dash.ContentProtection.PLAYREADY_RECORD_TYPES = {\n  RIGHTS_MANAGEMENT: 0x001,\n  RESERVED: 0x002,\n  EMBEDDED_LICENSE: 0x003,\n};\n\n/**\n * @typedef {{\n *   defaultKeyId: ?string,\n *   defaultInit: Array.<shaka.extern.InitDataOverride>,\n *   drmInfos: !Array.<shaka.extern.DrmInfo>,\n *   firstRepresentation: boolean\n * }}\n *\n * @description\n * Contains information about the ContentProtection elements found at the\n * AdaptationSet level.\n *\n * @property {?string} defaultKeyId\n *   The default key ID to use.  This is used by parseKeyIds as a default.  This\n *   can be null to indicate that there is no default.\n * @property {Array.<shaka.extern.InitDataOverride>} defaultInit\n *   The default init data override.  This can be null to indicate that there\n *   is no default.\n * @property {!Array.<shaka.extern.DrmInfo>} drmInfos\n *   The DrmInfo objects.\n * @property {boolean} firstRepresentation\n *   True when first parsed; changed to false after the first call to\n *   parseKeyIds.  This is used to determine if a dummy key-system should be\n *   overwritten; namely that the first representation can replace the dummy\n *   from the AdaptationSet.\n */\nshaka.dash.ContentProtection.Context;\n\n\n/**\n * @typedef {{\n *   node: !Element,\n *   schemeUri: string,\n *   keyId: ?string,\n *   init: Array.<shaka.extern.InitDataOverride>\n * }}\n *\n * @description\n * The parsed result of a single ContentProtection element.\n *\n * @property {!Element} node\n *   The ContentProtection XML element.\n * @property {string} schemeUri\n *   The scheme URI.\n * @property {?string} keyId\n *   The default key ID, if present.\n * @property {Array.<shaka.extern.InitDataOverride>} init\n *   The init data, if present.  If there is no init data, it will be null.  If\n *   this is non-null, there is at least one element.\n */\nshaka.dash.ContentProtection.Element;\n\n/**\n * A map of key system name to license server url parser.\n *\n * @const {!Map.<string, function(shaka.dash.ContentProtection.Element)>}\n * @private\n */\nshaka.dash.ContentProtection.licenseUrlParsers_ = new Map()\n    .set('com.widevine.alpha',\n        shaka.dash.ContentProtection.getWidevineLicenseUrl)\n    .set('com.microsoft.playready',\n        shaka.dash.ContentProtection.getPlayReadyLicenseUrl)\n    .set('com.microsoft.playready.recommendation',\n        shaka.dash.ContentProtection.getPlayReadyLicenseUrl)\n    .set('com.microsoft.playready.software',\n        shaka.dash.ContentProtection.getPlayReadyLicenseUrl)\n    .set('com.microsoft.playready.hardware',\n        shaka.dash.ContentProtection.getPlayReadyLicenseUrl);\n\n/**\n * @const {string}\n * @private\n */\nshaka.dash.ContentProtection.MP4Protection_ =\n    'urn:mpeg:dash:mp4protection:2011';\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.dash.ContentProtection.CencNamespaceUri_ = 'urn:mpeg:cenc:2013';\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.MpdUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.XmlUtils');\ngoog.requireType('shaka.dash.DashParser');\n\n\n/**\n * @summary MPD processing utility functions.\n */\nshaka.dash.MpdUtils = class {\n  /**\n   * Fills a SegmentTemplate URI template.  This function does not validate the\n   * resulting URI.\n   *\n   * @param {string} uriTemplate\n   * @param {?string} representationId\n   * @param {?number} number\n   * @param {?number} bandwidth\n   * @param {?number} time\n   * @return {string} A URI string.\n   * @see ISO/IEC 23009-1:2014 section 5.3.9.4.4\n   */\n  static fillUriTemplate(\n      uriTemplate, representationId, number, bandwidth, time) {\n    /** @type {!Object.<string, ?number|?string>} */\n    const valueTable = {\n      'RepresentationID': representationId,\n      'Number': number,\n      'Bandwidth': bandwidth,\n      'Time': time,\n    };\n\n    const re = /\\$(RepresentationID|Number|Bandwidth|Time)?(?:%0([0-9]+)([diouxX]))?\\$/g;  // eslint-disable-line max-len\n    const uri = uriTemplate.replace(re, (match, name, widthStr, format) => {\n      if (match == '$$') {\n        return '$';\n      }\n\n      let value = valueTable[name];\n      goog.asserts.assert(value !== undefined, 'Unrecognized identifier');\n\n      // Note that |value| may be 0 or ''.\n      if (value == null) {\n        shaka.log.warning(\n            'URL template does not have an available substitution for ',\n            'identifier \"' + name + '\":',\n            uriTemplate);\n        return match;\n      }\n\n      if (name == 'RepresentationID' && widthStr) {\n        shaka.log.warning(\n            'URL template should not contain a width specifier for identifier',\n            '\"RepresentationID\":',\n            uriTemplate);\n        widthStr = undefined;\n      }\n\n      if (name == 'Time') {\n        goog.asserts.assert(typeof value == 'number',\n            'Time value should be a number!');\n        goog.asserts.assert(Math.abs(value - Math.round(value)) < 0.2,\n            'Calculated $Time$ values must be close to integers');\n        value = Math.round(value);\n      }\n\n      /** @type {string} */\n      let valueString;\n      switch (format) {\n        case undefined:  // Happens if there is no format specifier.\n        case 'd':\n        case 'i':\n        case 'u':\n          valueString = value.toString();\n          break;\n        case 'o':\n          valueString = value.toString(8);\n          break;\n        case 'x':\n          valueString = value.toString(16);\n          break;\n        case 'X':\n          valueString = value.toString(16).toUpperCase();\n          break;\n        default:\n          goog.asserts.assert(false, 'Unhandled format specifier');\n          valueString = value.toString();\n          break;\n      }\n\n      // Create a padding string.\n      const width = window.parseInt(widthStr, 10) || 1;\n      const paddingSize = Math.max(0, width - valueString.length);\n      const padding = (new Array(paddingSize + 1)).join('0');\n\n      return padding + valueString;\n    });\n\n    return uri;\n  }\n\n  /**\n   * Expands a SegmentTimeline into an array-based timeline.  The results are in\n   * seconds.\n   *\n   * @param {!Element} segmentTimeline\n   * @param {number} timescale\n   * @param {number} unscaledPresentationTimeOffset\n   * @param {number} periodDuration The Period's duration in seconds.\n   *   Infinity indicates that the Period continues indefinitely.\n   * @return {!Array.<shaka.dash.MpdUtils.TimeRange>}\n   */\n  static createTimeline(\n      segmentTimeline, timescale, unscaledPresentationTimeOffset,\n      periodDuration) {\n    goog.asserts.assert(\n        timescale > 0 && timescale < Infinity,\n        'timescale must be a positive, finite integer');\n    goog.asserts.assert(\n        periodDuration > 0, 'period duration must be a positive integer');\n\n    // Alias.\n    const XmlUtils = shaka.util.XmlUtils;\n\n    const timePoints = XmlUtils.findChildren(segmentTimeline, 'S');\n\n    /** @type {!Array.<shaka.dash.MpdUtils.TimeRange>} */\n    const timeline = [];\n    let lastEndTime = -unscaledPresentationTimeOffset;\n\n    for (let i = 0; i < timePoints.length; ++i) {\n      const timePoint = timePoints[i];\n      const next = timePoints[i + 1];\n      let t = XmlUtils.parseAttr(timePoint, 't', XmlUtils.parseNonNegativeInt);\n      const d =\n          XmlUtils.parseAttr(timePoint, 'd', XmlUtils.parseNonNegativeInt);\n      const r = XmlUtils.parseAttr(timePoint, 'r', XmlUtils.parseInt);\n\n      // Adjust the start time to account for the presentation time offset.\n      if (t != null) {\n        t -= unscaledPresentationTimeOffset;\n      }\n\n      if (!d) {\n        shaka.log.warning(\n            '\"S\" element must have a duration:',\n            'ignoring the remaining \"S\" elements.', timePoint);\n        return timeline;\n      }\n\n      let startTime = t != null ? t : lastEndTime;\n\n      let repeat = r || 0;\n      if (repeat < 0) {\n        if (next) {\n          const nextStartTime =\n              XmlUtils.parseAttr(next, 't', XmlUtils.parseNonNegativeInt);\n          if (nextStartTime == null) {\n            shaka.log.warning(\n                'An \"S\" element cannot have a negative repeat',\n                'if the next \"S\" element does not have a valid start time:',\n                'ignoring the remaining \"S\" elements.', timePoint);\n            return timeline;\n          } else if (startTime >= nextStartTime) {\n            shaka.log.warning(\n                'An \"S\" element cannot have a negative repeatif its start ',\n                'time exceeds the next \"S\" element\\'s start time:',\n                'ignoring the remaining \"S\" elements.', timePoint);\n            return timeline;\n          }\n          repeat = Math.ceil((nextStartTime - startTime) / d) - 1;\n        } else {\n          if (periodDuration == Infinity) {\n            // The DASH spec. actually allows the last \"S\" element to have a\n            // negative repeat value even when the Period has an infinite\n            // duration.  No one uses this feature and no one ever should,\n            // ever.\n            shaka.log.warning(\n                'The last \"S\" element cannot have a negative repeat',\n                'if the Period has an infinite duration:',\n                'ignoring the last \"S\" element.', timePoint);\n            return timeline;\n          } else if (startTime / timescale >= periodDuration) {\n            shaka.log.warning(\n                'The last \"S\" element cannot have a negative repeat',\n                'if its start time exceeds the Period\\'s duration:',\n                'igoring the last \"S\" element.', timePoint);\n            return timeline;\n          }\n          repeat = Math.ceil((periodDuration * timescale - startTime) / d) - 1;\n        }\n      }\n\n      // The end of the last segment may be before the start of the current\n      // segment (a gap) or after the start of the current segment (an\n      // overlap). If there is a gap/overlap then stretch/compress the end of\n      // the last segment to the start of the current segment.\n      //\n      // Note: it is possible to move the start of the current segment to the\n      // end of the last segment, but this would complicate the computation of\n      // the $Time$ placeholder later on.\n      if ((timeline.length > 0) && (startTime != lastEndTime)) {\n        const delta = startTime - lastEndTime;\n\n        if (Math.abs(delta / timescale) >=\n            shaka.util.ManifestParserUtils.GAP_OVERLAP_TOLERANCE_SECONDS) {\n          shaka.log.warning(\n              'SegmentTimeline contains a large gap/overlap:',\n              'the content may have errors in it.', timePoint);\n        }\n\n        timeline[timeline.length - 1].end = startTime / timescale;\n      }\n\n      for (let j = 0; j <= repeat; ++j) {\n        const endTime = startTime + d;\n        const item = {\n          start: startTime / timescale,\n          end: endTime / timescale,\n          unscaledStart: startTime,\n        };\n        timeline.push(item);\n\n        startTime = endTime;\n        lastEndTime = endTime;\n      }\n    }\n\n    return timeline;\n  }\n\n  /**\n   * Parses common segment info for SegmentList and SegmentTemplate.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n   *   Gets the element that contains the segment info.\n   * @return {shaka.dash.MpdUtils.SegmentInfo}\n   */\n  static parseSegmentInfo(context, callback) {\n    goog.asserts.assert(\n        callback(context.representation),\n        'There must be at least one element of the given type.');\n    const MpdUtils = shaka.dash.MpdUtils;\n    const XmlUtils = shaka.util.XmlUtils;\n\n    const timescaleStr =\n        MpdUtils.inheritAttribute(context, callback, 'timescale');\n    let timescale = 1;\n    if (timescaleStr) {\n      timescale = XmlUtils.parsePositiveInt(timescaleStr) || 1;\n    }\n\n    const durationStr =\n        MpdUtils.inheritAttribute(context, callback, 'duration');\n    let segmentDuration = XmlUtils.parsePositiveInt(durationStr || '');\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    // TODO: The specification is not clear, check this once it is resolved:\n    // https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/404\n    if (context.representation.contentType == ContentType.IMAGE) {\n      segmentDuration = XmlUtils.parseFloat(durationStr || '');\n    }\n    if (segmentDuration) {\n      segmentDuration /= timescale;\n    }\n\n    const startNumberStr =\n        MpdUtils.inheritAttribute(context, callback, 'startNumber');\n    const unscaledPresentationTimeOffset =\n        Number(MpdUtils.inheritAttribute(context, callback,\n            'presentationTimeOffset')) || 0;\n    let startNumber = XmlUtils.parseNonNegativeInt(startNumberStr || '');\n    if (startNumberStr == null || startNumber == null) {\n      startNumber = 1;\n    }\n\n    const timelineNode =\n        MpdUtils.inheritChild(context, callback, 'SegmentTimeline');\n    /** @type {Array.<shaka.dash.MpdUtils.TimeRange>} */\n    let timeline = null;\n    if (timelineNode) {\n      timeline = MpdUtils.createTimeline(\n          timelineNode, timescale, unscaledPresentationTimeOffset,\n          context.periodInfo.duration || Infinity);\n    }\n\n    const scaledPresentationTimeOffset =\n        (unscaledPresentationTimeOffset / timescale) || 0;\n    return {\n      timescale: timescale,\n      segmentDuration: segmentDuration,\n      startNumber: startNumber,\n      scaledPresentationTimeOffset: scaledPresentationTimeOffset,\n      unscaledPresentationTimeOffset: unscaledPresentationTimeOffset,\n      timeline: timeline,\n    };\n  }\n\n  /**\n   * Searches the inheritance for a Segment* with the given attribute.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n   *   Gets the Element that contains the attribute to inherit.\n   * @param {string} attribute\n   * @return {?string}\n   */\n  static inheritAttribute(context, callback, attribute) {\n    const Functional = shaka.util.Functional;\n    goog.asserts.assert(\n        callback(context.representation),\n        'There must be at least one element of the given type');\n\n    /** @type {!Array.<!Element>} */\n    const nodes = [\n      callback(context.representation),\n      callback(context.adaptationSet),\n      callback(context.period),\n    ].filter(Functional.isNotNull);\n\n    return nodes\n        .map((s) => { return s.getAttribute(attribute); })\n        .reduce((all, part) => { return all || part; });\n  }\n\n  /**\n   * Searches the inheritance for a Segment* with the given child.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n   *   Gets the Element that contains the child to inherit.\n   * @param {string} child\n   * @return {Element}\n   */\n  static inheritChild(context, callback, child) {\n    const Functional = shaka.util.Functional;\n    goog.asserts.assert(\n        callback(context.representation),\n        'There must be at least one element of the given type');\n\n    /** @type {!Array.<!Element>} */\n    const nodes = [\n      callback(context.representation),\n      callback(context.adaptationSet),\n      callback(context.period),\n    ].filter(Functional.isNotNull);\n\n    const XmlUtils = shaka.util.XmlUtils;\n    return nodes\n        .map((s) => { return XmlUtils.findChild(s, child); })\n        .reduce((all, part) => { return all || part; });\n  }\n\n  /**\n   * Follow the xlink link contained in the given element.\n   * It also strips the xlink properties off of the element,\n   * even if the process fails.\n   *\n   * @param {!Element} element\n   * @param {!shaka.extern.RetryParameters} retryParameters\n   * @param {boolean} failGracefully\n   * @param {string} baseUri\n   * @param {!shaka.net.NetworkingEngine} networkingEngine\n   * @param {number} linkDepth\n   * @return {!shaka.util.AbortableOperation.<!Element>}\n   * @private\n   */\n  static handleXlinkInElement_(\n      element, retryParameters, failGracefully, baseUri, networkingEngine,\n      linkDepth) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const XmlUtils = shaka.util.XmlUtils;\n    const Error = shaka.util.Error;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const NS = MpdUtils.XlinkNamespaceUri_;\n\n    const xlinkHref = XmlUtils.getAttributeNS(element, NS, 'href');\n    const xlinkActuate =\n        XmlUtils.getAttributeNS(element, NS, 'actuate') || 'onRequest';\n\n    // Remove the xlink properties, so it won't download again\n    // when re-processed.\n    for (const attribute of Array.from(element.attributes)) {\n      if (attribute.namespaceURI == NS) {\n        element.removeAttributeNS(attribute.namespaceURI, attribute.localName);\n      }\n    }\n\n    if (linkDepth >= 5) {\n      return shaka.util.AbortableOperation.failed(new Error(\n          Error.Severity.CRITICAL, Error.Category.MANIFEST,\n          Error.Code.DASH_XLINK_DEPTH_LIMIT));\n    }\n\n    if (xlinkActuate != 'onLoad') {\n      // Only xlink:actuate=\"onLoad\" is supported.\n      // When no value is specified, the assumed value is \"onRequest\".\n      return shaka.util.AbortableOperation.failed(new Error(\n          Error.Severity.CRITICAL, Error.Category.MANIFEST,\n          Error.Code.DASH_UNSUPPORTED_XLINK_ACTUATE));\n    }\n\n    // Resolve the xlink href, in case it's a relative URL.\n    const uris = ManifestParserUtils.resolveUris([baseUri], [xlinkHref]);\n\n    // Load in the linked elements.\n    const requestType = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n    const request =\n        shaka.net.NetworkingEngine.makeRequest(uris, retryParameters);\n\n    const requestOperation = networkingEngine.request(requestType, request);\n    // The interface is abstract, but we know it was implemented with the\n    // more capable internal class.\n    goog.asserts.assert(\n        requestOperation instanceof shaka.util.AbortableOperation,\n        'Unexpected implementation of IAbortableOperation!');\n    // Satisfy the compiler with a cast.\n    const networkOperation =\n    /** @type {!shaka.util.AbortableOperation.<shaka.extern.Response>} */ (\n        requestOperation);\n\n    // Chain onto that operation.\n    return networkOperation.chain(\n        (response) => {\n          // This only supports the case where the loaded xml has a single\n          // top-level element.  If there are multiple roots, it will be\n          // rejected.\n          const rootElem =\n          shaka.util.XmlUtils.parseXml(response.data, element.tagName);\n          if (!rootElem) {\n            // It was not valid XML.\n            return shaka.util.AbortableOperation.failed(new Error(\n                Error.Severity.CRITICAL, Error.Category.MANIFEST,\n                Error.Code.DASH_INVALID_XML, xlinkHref));\n          }\n\n          // Now that there is no other possibility of the process erroring,\n          // the element can be changed further.\n\n          // Remove the current contents of the node.\n          while (element.childNodes.length) {\n            element.removeChild(element.childNodes[0]);\n          }\n\n          // Move the children of the loaded xml into the current element.\n          while (rootElem.childNodes.length) {\n            const child = rootElem.childNodes[0];\n            rootElem.removeChild(child);\n            element.appendChild(child);\n          }\n\n          // Move the attributes of the loaded xml into the current element.\n          for (const attribute of Array.from(rootElem.attributes)) {\n            element.setAttributeNode(attribute.cloneNode(/* deep= */ false));\n          }\n\n          return shaka.dash.MpdUtils.processXlinks(\n              element, retryParameters, failGracefully, uris[0],\n              networkingEngine, linkDepth + 1);\n        });\n  }\n\n  /**\n   * Filter the contents of a node recursively, replacing xlink links\n   * with their associated online data.\n   *\n   * @param {!Element} element\n   * @param {!shaka.extern.RetryParameters} retryParameters\n   * @param {boolean} failGracefully\n   * @param {string} baseUri\n   * @param {!shaka.net.NetworkingEngine} networkingEngine\n   * @param {number=} linkDepth, default set to 0\n   * @return {!shaka.util.AbortableOperation.<!Element>}\n   */\n  static processXlinks(\n      element, retryParameters, failGracefully, baseUri, networkingEngine,\n      linkDepth = 0) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const XmlUtils = shaka.util.XmlUtils;\n    const NS = MpdUtils.XlinkNamespaceUri_;\n\n    if (XmlUtils.getAttributeNS(element, NS, 'href')) {\n      let handled = MpdUtils.handleXlinkInElement_(\n          element, retryParameters, failGracefully, baseUri, networkingEngine,\n          linkDepth);\n      if (failGracefully) {\n        // Catch any error and go on.\n        handled = handled.chain(undefined, (error) => {\n          // handleXlinkInElement_ strips the xlink properties off of the\n          // element even if it fails, so calling processXlinks again will\n          // handle whatever contents the element natively has.\n          return MpdUtils.processXlinks(\n              element, retryParameters, failGracefully, baseUri,\n              networkingEngine, linkDepth);\n        });\n      }\n      return handled;\n    }\n\n    const childOperations = [];\n    for (const child of Array.from(element.childNodes)) {\n      if (child instanceof Element) {\n        const resolveToZeroString = 'urn:mpeg:dash:resolve-to-zero:2013';\n        if (XmlUtils.getAttributeNS(child, NS, 'href') == resolveToZeroString) {\n          // This is a 'resolve to zero' code; it means the element should\n          // be removed, as specified by the mpeg-dash rules for xlink.\n          element.removeChild(child);\n        } else if (child.tagName != 'SegmentTimeline') {\n          // Don't recurse into a SegmentTimeline since xlink attributes\n          // aren't valid in there and looking at each segment can take a long\n          // time with larger manifests.\n\n          // Replace the child with its processed form.\n          childOperations.push(shaka.dash.MpdUtils.processXlinks(\n              /** @type {!Element} */ (child), retryParameters, failGracefully,\n              baseUri, networkingEngine, linkDepth));\n        }\n      }\n    }\n\n    return shaka.util.AbortableOperation.all(childOperations).chain(() => {\n      return element;\n    });\n  }\n};\n\n\n/**\n * @typedef {{\n *   start: number,\n *   unscaledStart: number,\n *   end: number\n * }}\n *\n * @description\n * Defines a time range of a media segment.  Times are in seconds.\n *\n * @property {number} start\n *   The start time of the range.\n * @property {number} unscaledStart\n *   The start time of the range in representation timescale units.\n * @property {number} end\n *   The end time (exclusive) of the range.\n */\nshaka.dash.MpdUtils.TimeRange;\n\n\n/**\n * @typedef {{\n *   timescale: number,\n *   segmentDuration: ?number,\n *   startNumber: number,\n *   scaledPresentationTimeOffset: number,\n *   unscaledPresentationTimeOffset: number,\n *   timeline: Array.<shaka.dash.MpdUtils.TimeRange>\n * }}\n *\n * @description\n * Contains common information between SegmentList and SegmentTemplate items.\n *\n * @property {number} timescale\n *   The time-scale of the representation.\n * @property {?number} segmentDuration\n *   The duration of the segments in seconds, if given.\n * @property {number} startNumber\n *   The start number of the segments; 1 or greater.\n * @property {number} scaledPresentationTimeOffset\n *   The presentation time offset of the representation, in seconds.\n * @property {number} unscaledPresentationTimeOffset\n *   The presentation time offset of the representation, in timescale units.\n * @property {Array.<shaka.dash.MpdUtils.TimeRange>} timeline\n *   The timeline of the representation, if given.  Times in seconds.\n */\nshaka.dash.MpdUtils.SegmentInfo;\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.dash.MpdUtils.XlinkNamespaceUri_ = 'http://www.w3.org/1999/xlink';\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.Mp4SegmentIndexParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Mp4Parser');\n\n\nshaka.media.Mp4SegmentIndexParser = class {\n  /**\n   * Parses SegmentReferences from an ISO BMFF SIDX structure.\n   * @param {BufferSource} sidxData The MP4's container's SIDX.\n   * @param {number} sidxOffset The SIDX's offset, in bytes, from the start of\n   *   the MP4 container.\n   * @param {!Array.<string>} uris The possible locations of the MP4 file that\n   *   contains the segments.\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {number} timestampOffset\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   */\n  static parse(\n      sidxData, sidxOffset, uris, initSegmentReference, timestampOffset,\n      appendWindowStart, appendWindowEnd) {\n    const Mp4SegmentIndexParser = shaka.media.Mp4SegmentIndexParser;\n\n    let references;\n\n    const parser = new shaka.util.Mp4Parser()\n        .fullBox('sidx', (box) => {\n          references = Mp4SegmentIndexParser.parseSIDX_(\n              sidxOffset,\n              initSegmentReference,\n              timestampOffset,\n              appendWindowStart,\n              appendWindowEnd,\n              uris,\n              box);\n        });\n\n    if (sidxData) {\n      parser.parse(sidxData);\n    }\n\n    if (references) {\n      return references;\n    } else {\n      shaka.log.error('Invalid box type, expected \"sidx\".');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.MP4_SIDX_WRONG_BOX_TYPE);\n    }\n  }\n\n\n  /**\n   * Parse a SIDX box from the given reader.\n   *\n   * @param {number} sidxOffset\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {number} timestampOffset\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @param {!Array.<string>} uris The possible locations of the MP4 file that\n   *   contains the segments.\n   * @param {!shaka.extern.ParsedBox} box\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @private\n   */\n  static parseSIDX_(\n      sidxOffset, initSegmentReference, timestampOffset, appendWindowStart,\n      appendWindowEnd, uris, box) {\n    goog.asserts.assert(\n        box.version != null,\n        'SIDX is a full box and should have a valid version.');\n\n    const references = [];\n\n    // Parse the SIDX structure.\n    // Skip reference_ID (32 bits).\n    box.reader.skip(4);\n\n    const timescale = box.reader.readUint32();\n\n    if (timescale == 0) {\n      shaka.log.error('Invalid timescale.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.MP4_SIDX_INVALID_TIMESCALE);\n    }\n\n    let earliestPresentationTime;\n    let firstOffset;\n\n    if (box.version == 0) {\n      earliestPresentationTime = box.reader.readUint32();\n      firstOffset = box.reader.readUint32();\n    } else {\n      earliestPresentationTime = box.reader.readUint64();\n      firstOffset = box.reader.readUint64();\n    }\n\n    // Skip reserved (16 bits).\n    box.reader.skip(2);\n\n    // Add references.\n    const referenceCount = box.reader.readUint16();\n\n    // Subtract the presentation time offset\n    let unscaledStartTime = earliestPresentationTime;\n    let startByte = sidxOffset + box.size + firstOffset;\n\n    for (let i = 0; i < referenceCount; i++) {\n      // |chunk| is 1 bit for |referenceType|, and 31 bits for |referenceSize|.\n      const chunk = box.reader.readUint32();\n      const referenceType = (chunk & 0x80000000) >>> 31;\n      const referenceSize = chunk & 0x7FFFFFFF;\n\n      const subsegmentDuration = box.reader.readUint32();\n\n      // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n      // for |sapDelta|.\n      box.reader.skip(4);\n\n      // If |referenceType| is 1 then the reference is to another SIDX.\n      // We do not support this.\n      if (referenceType == 1) {\n        shaka.log.error('Heirarchical SIDXs are not supported.');\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MEDIA,\n            shaka.util.Error.Code.MP4_SIDX_TYPE_NOT_SUPPORTED);\n      }\n\n      // The media timestamps inside the container.\n      const nativeStartTime = unscaledStartTime / timescale;\n      const nativeEndTime =\n          (unscaledStartTime + subsegmentDuration) / timescale;\n\n      references.push(\n          new shaka.media.SegmentReference(\n              nativeStartTime + timestampOffset,\n              nativeEndTime + timestampOffset,\n              (() => { return uris; }),\n              startByte,\n              startByte + referenceSize - 1,\n              initSegmentReference,\n              timestampOffset,\n              appendWindowStart,\n              appendWindowEnd));\n\n      unscaledStartTime += subsegmentDuration;\n      startByte += referenceSize;\n    }\n\n    box.parser.stop();\n    return references;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.EbmlElement');\ngoog.provide('shaka.util.EbmlParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @summary\n * Extensible Binary Markup Language (EBML) parser.\n */\nshaka.util.EbmlParser = class {\n  /**\n   * @param {BufferSource} data\n   */\n  constructor(data) {\n    /** @private {!DataView} */\n    this.dataView_ = shaka.util.BufferUtils.toDataView(data);\n\n    /** @private {!shaka.util.DataViewReader} */\n    this.reader_ = new shaka.util.DataViewReader(\n        this.dataView_, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n  }\n\n\n  /**\n   * @return {boolean} True if the parser has more data, false otherwise.\n   */\n  hasMoreData() {\n    return this.reader_.hasMoreData();\n  }\n\n\n  /**\n   * Parses an EBML element from the parser's current position, and advances\n   * the parser.\n   * @return {!shaka.util.EbmlElement} The EBML element.\n   * @see http://matroska.org/technical/specs/rfc/index.html\n   */\n  parseElement() {\n    const id = this.parseId_();\n\n    // Parse the element's size.\n    const vint = this.parseVint_();\n    let size;\n    if (shaka.util.EbmlParser.isDynamicSizeValue_(vint)) {\n      // If this has an unknown size, assume that it takes up the rest of the\n      // data.\n      size = this.dataView_.byteLength - this.reader_.getPosition();\n    } else {\n      size = shaka.util.EbmlParser.getVintValue_(vint);\n    }\n\n    // Note that if the element's size is larger than the buffer then we are\n    // parsing a \"partial element\". This may occur if for example we are\n    // parsing the beginning of some WebM container data, but our buffer does\n    // not contain the entire WebM container data.\n    const elementSize =\n        this.reader_.getPosition() + size <= this.dataView_.byteLength ?\n        size :\n        this.dataView_.byteLength - this.reader_.getPosition();\n\n    const dataView = shaka.util.BufferUtils.toDataView(\n        this.dataView_, this.reader_.getPosition(), elementSize);\n\n    this.reader_.skip(elementSize);\n\n    return new shaka.util.EbmlElement(id, dataView);\n  }\n\n\n  /**\n   * Parses an EBML ID from the parser's current position, and advances the\n   * parser.\n   * @return {number} The EBML ID.\n   * @private\n   */\n  parseId_() {\n    const vint = this.parseVint_();\n\n    if (vint.length > 7) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.EBML_OVERFLOW);\n    }\n\n    let id = 0;\n    for (const /* byte */ b of vint) {\n      // Note that we cannot use << since |value| may exceed 32 bits.\n      id = (256 * id) + b;\n    }\n\n    return id;\n  }\n\n\n  /**\n   * Parses a variable sized integer from the parser's current position, and\n   * advances the parser.\n   * For example:\n   *   1 byte  wide: 1xxx xxxx\n   *   2 bytes wide: 01xx xxxx xxxx xxxx\n   *   3 bytes wide: 001x xxxx xxxx xxxx xxxx xxxx\n   * @return {!Uint8Array} The variable sized integer.\n   * @private\n   */\n  parseVint_() {\n    const position = this.reader_.getPosition();\n    const firstByte = this.reader_.readUint8();\n    if (firstByte == 0) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.EBML_OVERFLOW);\n    }\n\n    // Determine the index of the highest bit set.\n    const index = Math.floor(Math.log2(firstByte));\n    const numBytes = 8 - index;\n    goog.asserts.assert(numBytes <= 8 && numBytes >= 1, 'Incorrect log2 value');\n    this.reader_.skip(numBytes - 1);\n    return shaka.util.BufferUtils.toUint8(this.dataView_, position, numBytes);\n  }\n\n\n  /**\n   * Gets the value of a variable sized integer.\n   * For example, the x's below are part of the vint's value.\n   *    7-bit value: 1xxx xxxx\n   *   14-bit value: 01xx xxxx xxxx xxxx\n   *   21-bit value: 001x xxxx xxxx xxxx xxxx xxxx\n   * @param {!Uint8Array} vint The variable sized integer.\n   * @return {number} The value of the variable sized integer.\n   * @private\n   */\n  static getVintValue_(vint) {\n    // If |vint| is 8 bytes wide then we must ensure that it does not have more\n    // than 53 meaningful bits. For example, assume |vint| is 8 bytes wide,\n    // so it has the following structure,\n    // 0000 0001 | xxxx xxxx ...\n    // Thus, the first 3 bits following the first byte of |vint| must be 0.\n    if ((vint.length == 8) && (vint[1] & 0xe0)) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.JS_INTEGER_OVERFLOW);\n    }\n\n    let value = 0;\n    for (let i = 0; i < vint.length; i++) {\n      const item = vint[i];\n      if (i == 0) {\n        // Mask out the first few bits of |vint|'s first byte to get the most\n        // significant bits of |vint|'s value. If |vint| is 8 bytes wide then\n        // |value| will be set to 0.\n        const mask = 0x1 << (8 - vint.length);\n        value = item & (mask - 1);\n      } else {\n        // Note that we cannot use << since |value| may exceed 32 bits.\n        value = (256 * value) + item;\n      }\n    }\n\n    return value;\n  }\n\n\n  /**\n   * Checks if the given variable sized integer represents a dynamic size value.\n   * @param {!Uint8Array} vint The variable sized integer.\n   * @return {boolean} true if |vint| represents a dynamic size value,\n   *   false otherwise.\n   * @private\n   */\n  static isDynamicSizeValue_(vint) {\n    const EbmlParser = shaka.util.EbmlParser;\n    const BufferUtils = shaka.util.BufferUtils;\n\n    for (const dynamicSizeConst of EbmlParser.DYNAMIC_SIZES) {\n      if (BufferUtils.equal(vint, new Uint8Array(dynamicSizeConst))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n};\n\n\n/**\n * A list of EBML dynamic size constants.\n * @const {!Array.<!Array.<number>>}\n */\nshaka.util.EbmlParser.DYNAMIC_SIZES = [\n  [0xff],\n  [0x7f, 0xff],\n  [0x3f, 0xff, 0xff],\n  [0x1f, 0xff, 0xff, 0xff],\n  [0x0f, 0xff, 0xff, 0xff, 0xff],\n  [0x07, 0xff, 0xff, 0xff, 0xff, 0xff],\n  [0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff],\n  [0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff],\n];\n\n\nshaka.util.EbmlElement = class {\n  /**\n   * @param {number} id The ID.\n   * @param {!DataView} dataView The DataView.\n   */\n  constructor(id, dataView) {\n    /** @type {number} */\n    this.id = id;\n\n    /** @private {!DataView} */\n    this.dataView_ = dataView;\n  }\n\n\n  /**\n   * Gets the element's offset from the beginning of the buffer.\n   * @return {number}\n   */\n  getOffset() {\n    return this.dataView_.byteOffset;\n  }\n\n\n  /**\n   * Interpret the element's data as a list of sub-elements.\n   * @return {!shaka.util.EbmlParser} A parser over the sub-elements.\n   */\n  createParser() {\n    return new shaka.util.EbmlParser(this.dataView_);\n  }\n\n\n  /**\n   * Interpret the element's data as an unsigned integer.\n   * @return {number}\n   */\n  getUint() {\n    if (this.dataView_.byteLength > 8) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.EBML_OVERFLOW);\n    }\n\n    // Ensure we have at most 53 meaningful bits.\n    if ((this.dataView_.byteLength == 8) &&\n        (this.dataView_.getUint8(0) & 0xe0)) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.JS_INTEGER_OVERFLOW);\n    }\n\n    let value = 0;\n\n    for (let i = 0; i < this.dataView_.byteLength; i++) {\n      const chunk = this.dataView_.getUint8(i);\n      value = (256 * value) + chunk;\n    }\n\n    return value;\n  }\n\n\n  /**\n   * Interpret the element's data as a floating point number\n   * (32 bits or 64 bits). 80-bit floating point numbers are not supported.\n   * @return {number}\n   */\n  getFloat() {\n    if (this.dataView_.byteLength == 4) {\n      return this.dataView_.getFloat32(0);\n    } else if (this.dataView_.byteLength == 8) {\n      return this.dataView_.getFloat64(0);\n    } else {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.EBML_BAD_FLOATING_POINT_SIZE);\n    }\n  }\n};\n\n\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.WebmSegmentIndexParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.EbmlElement');\ngoog.require('shaka.util.EbmlParser');\ngoog.require('shaka.util.Error');\n\n\nshaka.media.WebmSegmentIndexParser = class {\n  /**\n   * Parses SegmentReferences from a WebM container.\n   * @param {BufferSource} cuesData The WebM container's \"Cueing Data\" section.\n   * @param {BufferSource} initData The WebM container's headers.\n   * @param {!Array.<string>} uris The possible locations of the WebM file that\n   *   contains the segments.\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {number} timestampOffset\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @see http://www.matroska.org/technical/specs/index.html\n   * @see http://www.webmproject.org/docs/container/\n   */\n  static parse(\n      cuesData, initData, uris, initSegmentReference, timestampOffset,\n      appendWindowStart, appendWindowEnd) {\n    const tuple =\n        shaka.media.WebmSegmentIndexParser.parseWebmContainer_(initData);\n    const parser = new shaka.util.EbmlParser(cuesData);\n    const cuesElement = parser.parseElement();\n    if (cuesElement.id != shaka.media.WebmSegmentIndexParser.CUES_ID) {\n      shaka.log.error('Not a Cues element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_CUES_ELEMENT_MISSING);\n    }\n\n    return shaka.media.WebmSegmentIndexParser.parseCues_(\n        cuesElement, tuple.segmentOffset, tuple.timecodeScale, tuple.duration,\n        uris, initSegmentReference, timestampOffset, appendWindowStart,\n        appendWindowEnd);\n  }\n\n\n  /**\n   * Parses a WebM container to get the segment's offset, timecode scale, and\n   * duration.\n   *\n   * @param {BufferSource} initData\n   * @return {{segmentOffset: number, timecodeScale: number, duration: number}}\n   *   The segment's offset in bytes, the segment's timecode scale in seconds,\n   *   and the duration in seconds.\n   * @private\n   */\n  static parseWebmContainer_(initData) {\n    const parser = new shaka.util.EbmlParser(initData);\n\n    // Check that the WebM container data starts with the EBML header, but\n    // skip its contents.\n    const ebmlElement = parser.parseElement();\n    if (ebmlElement.id != shaka.media.WebmSegmentIndexParser.EBML_ID) {\n      shaka.log.error('Not an EBML element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_EBML_HEADER_ELEMENT_MISSING);\n    }\n\n    const segmentElement = parser.parseElement();\n    if (segmentElement.id != shaka.media.WebmSegmentIndexParser.SEGMENT_ID) {\n      shaka.log.error('Not a Segment element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_SEGMENT_ELEMENT_MISSING);\n    }\n\n    // This value is used as the initial offset to the first referenced segment.\n    const segmentOffset = segmentElement.getOffset();\n\n    // Parse the Segment element to get the segment info.\n    const segmentInfo = shaka.media.WebmSegmentIndexParser.parseSegment_(\n        segmentElement);\n    return {\n      segmentOffset: segmentOffset,\n      timecodeScale: segmentInfo.timecodeScale,\n      duration: segmentInfo.duration,\n    };\n  }\n\n\n  /**\n   * Parses a WebM Info element to get the segment's timecode scale and\n   * duration.\n   * @param {!shaka.util.EbmlElement} segmentElement\n   * @return {{timecodeScale: number, duration: number}} The segment's timecode\n   *   scale in seconds and duration in seconds.\n   * @private\n   */\n  static parseSegment_(segmentElement) {\n    const parser = segmentElement.createParser();\n\n    // Find the Info element.\n    let infoElement = null;\n    while (parser.hasMoreData()) {\n      const elem = parser.parseElement();\n      if (elem.id != shaka.media.WebmSegmentIndexParser.INFO_ID) {\n        continue;\n      }\n\n      infoElement = elem;\n\n      break;\n    }\n\n    if (!infoElement) {\n      shaka.log.error('Not an Info element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_INFO_ELEMENT_MISSING);\n    }\n\n    return shaka.media.WebmSegmentIndexParser.parseInfo_(infoElement);\n  }\n\n\n  /**\n   * Parses a WebM Info element to get the segment's timecode scale and\n   * duration.\n   * @param {!shaka.util.EbmlElement} infoElement\n   * @return {{timecodeScale: number, duration: number}} The segment's timecode\n   *   scale in seconds and duration in seconds.\n   * @private\n   */\n  static parseInfo_(infoElement) {\n    const parser = infoElement.createParser();\n\n    // The timecode scale factor in units of [nanoseconds / T], where [T] are\n    // the units used to express all other time values in the WebM container.\n    // By default it's assumed that [T] == [milliseconds].\n    let timecodeScaleNanoseconds = 1000000;\n    /** @type {?number} */\n    let durationScale = null;\n\n    while (parser.hasMoreData()) {\n      const elem = parser.parseElement();\n      if (elem.id == shaka.media.WebmSegmentIndexParser.TIMECODE_SCALE_ID) {\n        timecodeScaleNanoseconds = elem.getUint();\n      } else if (elem.id == shaka.media.WebmSegmentIndexParser.DURATION_ID) {\n        durationScale = elem.getFloat();\n      }\n    }\n    if (durationScale == null) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_DURATION_ELEMENT_MISSING);\n    }\n\n    // The timecode scale factor in units of [seconds / T].\n    const timecodeScale = timecodeScaleNanoseconds / 1000000000;\n    // The duration is stored in units of [T]\n    const durationSeconds = durationScale * timecodeScale;\n\n    return {timecodeScale: timecodeScale, duration: durationSeconds};\n  }\n\n\n  /**\n   * Parses a WebM CuesElement.\n   * @param {!shaka.util.EbmlElement} cuesElement\n   * @param {number} segmentOffset\n   * @param {number} timecodeScale\n   * @param {number} duration\n   * @param {!Array.<string>} uris\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {number} timestampOffset\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @private\n   */\n  static parseCues_(cuesElement, segmentOffset, timecodeScale, duration,\n      uris, initSegmentReference, timestampOffset, appendWindowStart,\n      appendWindowEnd) {\n    const references = [];\n    const getUris = () => uris;\n\n    const parser = cuesElement.createParser();\n\n    let lastTime = null;\n    let lastOffset = null;\n\n    while (parser.hasMoreData()) {\n      const elem = parser.parseElement();\n      if (elem.id != shaka.media.WebmSegmentIndexParser.CUE_POINT_ID) {\n        continue;\n      }\n\n      const tuple = shaka.media.WebmSegmentIndexParser.parseCuePoint_(elem);\n      if (!tuple) {\n        continue;\n      }\n\n      // Subtract the presentation time offset from the unscaled time\n      const currentTime = timecodeScale * tuple.unscaledTime;\n      const currentOffset = segmentOffset + tuple.relativeOffset;\n\n      if (lastTime != null) {\n        goog.asserts.assert(lastOffset != null, 'last offset cannot be null');\n\n        references.push(\n            new shaka.media.SegmentReference(\n                lastTime + timestampOffset,\n                currentTime + timestampOffset,\n                getUris,\n                /* startByte= */ lastOffset, /* endByte= */ currentOffset - 1,\n                initSegmentReference,\n                timestampOffset,\n                appendWindowStart,\n                appendWindowEnd));\n      }\n\n      lastTime = currentTime;\n      lastOffset = currentOffset;\n    }\n\n    if (lastTime != null) {\n      goog.asserts.assert(lastOffset != null, 'last offset cannot be null');\n\n      references.push(\n          new shaka.media.SegmentReference(\n              lastTime + timestampOffset,\n              duration + timestampOffset,\n              getUris,\n              /* startByte= */ lastOffset, /* endByte= */ null,\n              initSegmentReference,\n              timestampOffset,\n              appendWindowStart,\n              appendWindowEnd));\n    }\n\n    return references;\n  }\n\n\n  /**\n   * Parses a WebM CuePointElement to get an \"unadjusted\" segment reference.\n   * @param {shaka.util.EbmlElement} cuePointElement\n   * @return {{unscaledTime: number, relativeOffset: number}} The referenced\n   *   segment's start time in units of [T] (see parseInfo_()), and the\n   *   referenced segment's offset in bytes, relative to a WebM Segment\n   *   element.\n   * @private\n   */\n  static parseCuePoint_(cuePointElement) {\n    const parser = cuePointElement.createParser();\n\n    // Parse CueTime element.\n    const cueTimeElement = parser.parseElement();\n    if (cueTimeElement.id != shaka.media.WebmSegmentIndexParser.CUE_TIME_ID) {\n      shaka.log.warning('Not a CueTime element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_CUE_TIME_ELEMENT_MISSING);\n    }\n    const unscaledTime = cueTimeElement.getUint();\n\n    // Parse CueTrackPositions element.\n    const cueTrackPositionsElement = parser.parseElement();\n    if (cueTrackPositionsElement.id !=\n        shaka.media.WebmSegmentIndexParser.CUE_TRACK_POSITIONS_ID) {\n      shaka.log.warning('Not a CueTrackPositions element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING);\n    }\n\n    const cueTrackParser = cueTrackPositionsElement.createParser();\n    let relativeOffset = 0;\n\n    while (cueTrackParser.hasMoreData()) {\n      const elem = cueTrackParser.parseElement();\n      if (elem.id != shaka.media.WebmSegmentIndexParser.CUE_CLUSTER_POSITION) {\n        continue;\n      }\n\n      relativeOffset = elem.getUint();\n      break;\n    }\n\n    return {unscaledTime: unscaledTime, relativeOffset: relativeOffset};\n  }\n};\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.EBML_ID = 0x1a45dfa3;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.SEGMENT_ID = 0x18538067;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.INFO_ID = 0x1549a966;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.TIMECODE_SCALE_ID = 0x2ad7b1;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.DURATION_ID = 0x4489;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUES_ID = 0x1c53bb6b;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_POINT_ID = 0xbb;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_TIME_ID = 0xb3;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_TRACK_POSITIONS_ID = 0xb7;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_CLUSTER_POSITION = 0xf1;\n\n\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.SegmentBase');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.Mp4SegmentIndexParser');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.WebmSegmentIndexParser');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.ObjectUtils');\ngoog.require('shaka.util.XmlUtils');\ngoog.requireType('shaka.dash.DashParser');\ngoog.requireType('shaka.media.PresentationTimeline');\ngoog.requireType('shaka.media.SegmentReference');\n\n\n/**\n * @summary A set of functions for parsing SegmentBase elements.\n */\nshaka.dash.SegmentBase = class {\n  /**\n   * Creates an init segment reference from a Context object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n   * @return {shaka.media.InitSegmentReference}\n   */\n  static createInitSegment(context, callback) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const XmlUtils = shaka.util.XmlUtils;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n    const initialization =\n        MpdUtils.inheritChild(context, callback, 'Initialization');\n    if (!initialization) {\n      return null;\n    }\n\n    let resolvedUris = context.representation.baseUris;\n    const uri = initialization.getAttribute('sourceURL');\n    if (uri) {\n      resolvedUris = ManifestParserUtils.resolveUris(\n          context.representation.baseUris, [uri]);\n    }\n\n    let startByte = 0;\n    let endByte = null;\n    const range =\n        XmlUtils.parseAttr(initialization, 'range', XmlUtils.parseRange);\n    if (range) {\n      startByte = range.start;\n      endByte = range.end;\n    }\n\n    const getUris = () => resolvedUris;\n    const qualityInfo = shaka.dash.SegmentBase.createQualityInfo(context);\n    return new shaka.media.InitSegmentReference(\n        getUris, startByte, endByte, qualityInfo);\n  }\n\n  /**\n   * Creates a new StreamInfo object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.DashParser.RequestInitSegmentCallback}\n   *     requestInitSegment\n   * @return {shaka.dash.DashParser.StreamInfo}\n   */\n  static createStreamInfo(context, requestInitSegment) {\n    goog.asserts.assert(context.representation.segmentBase,\n        'Should only be called with SegmentBase');\n    // Since SegmentBase does not need updates, simply treat any call as\n    // the initial parse.\n    const MpdUtils = shaka.dash.MpdUtils;\n    const SegmentBase = shaka.dash.SegmentBase;\n    const XmlUtils = shaka.util.XmlUtils;\n\n    const unscaledPresentationTimeOffset = Number(MpdUtils.inheritAttribute(\n        context, SegmentBase.fromInheritance_, 'presentationTimeOffset')) || 0;\n\n    const timescaleStr = MpdUtils.inheritAttribute(\n        context, SegmentBase.fromInheritance_, 'timescale');\n    let timescale = 1;\n    if (timescaleStr) {\n      timescale = XmlUtils.parsePositiveInt(timescaleStr) || 1;\n    }\n\n    const scaledPresentationTimeOffset =\n        (unscaledPresentationTimeOffset / timescale) || 0;\n\n    const initSegmentReference =\n        SegmentBase.createInitSegment(context, SegmentBase.fromInheritance_);\n\n    // Throws an immediate error if the format is unsupported.\n    SegmentBase.checkSegmentIndexRangeSupport_(context, initSegmentReference);\n\n    // Direct fields of context will be reassigned by the parser before\n    // generateSegmentIndex is called.  So we must make a shallow copy first,\n    // and use that in the generateSegmentIndex callbacks.\n    const shallowCopyOfContext =\n        shaka.util.ObjectUtils.shallowCloneObject(context);\n\n    return {\n      generateSegmentIndex: () => {\n        return SegmentBase.generateSegmentIndex_(\n            shallowCopyOfContext, requestInitSegment, initSegmentReference,\n            scaledPresentationTimeOffset);\n      },\n    };\n  }\n\n  /**\n   * Creates a SegmentIndex for the given URIs and context.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.DashParser.RequestInitSegmentCallback}\n   *     requestInitSegment\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {!Array.<string>} uris\n   * @param {number} startByte\n   * @param {?number} endByte\n   * @param {number} scaledPresentationTimeOffset\n   * @return {!Promise.<shaka.media.SegmentIndex>}\n   */\n  static async generateSegmentIndexFromUris(\n      context, requestInitSegment, initSegmentReference, uris, startByte,\n      endByte, scaledPresentationTimeOffset) {\n    // Unpack context right away, before we start an async process.\n    // This immunizes us against changes to the context object later.\n    /** @type {shaka.media.PresentationTimeline} */\n    const presentationTimeline = context.presentationTimeline;\n    const fitLast = !context.dynamic || !context.periodInfo.isLastPeriod;\n    const periodStart = context.periodInfo.start;\n    const periodDuration = context.periodInfo.duration;\n    const containerType = context.representation.mimeType.split('/')[1];\n\n    // Create a local variable to bind to so we can set to null to help the GC.\n    let localRequest = requestInitSegment;\n    let segmentIndex = null;\n\n    const responses = [\n      localRequest(uris, startByte, endByte),\n      containerType == 'webm' ?\n          localRequest(\n              initSegmentReference.getUris(),\n              initSegmentReference.startByte,\n              initSegmentReference.endByte) :\n          null,\n    ];\n\n    localRequest = null;\n    const results = await Promise.all(responses);\n    const indexData = results[0];\n    const initData = results[1] || null;\n    /** @type {Array.<!shaka.media.SegmentReference>} */\n    let references = null;\n\n    const timestampOffset = periodStart - scaledPresentationTimeOffset;\n    const appendWindowStart = periodStart;\n    const appendWindowEnd = periodDuration ?\n        periodStart + periodDuration : Infinity;\n\n    if (containerType == 'mp4') {\n      references = shaka.media.Mp4SegmentIndexParser.parse(\n          indexData, startByte, uris, initSegmentReference, timestampOffset,\n          appendWindowStart, appendWindowEnd);\n    } else {\n      goog.asserts.assert(initData, 'WebM requires init data');\n      references = shaka.media.WebmSegmentIndexParser.parse(\n          indexData, initData, uris, initSegmentReference, timestampOffset,\n          appendWindowStart, appendWindowEnd);\n    }\n\n    presentationTimeline.notifySegments(references);\n\n    // Since containers are never updated, we don't need to store the\n    // segmentIndex in the map.\n    goog.asserts.assert(!segmentIndex,\n        'Should not call generateSegmentIndex twice');\n\n    segmentIndex = new shaka.media.SegmentIndex(references);\n    if (fitLast) {\n      segmentIndex.fit(appendWindowStart, appendWindowEnd, /* isNew= */ true);\n    }\n    return segmentIndex;\n  }\n\n  /**\n   * @param {?shaka.dash.DashParser.InheritanceFrame} frame\n   * @return {Element}\n   * @private\n   */\n  static fromInheritance_(frame) {\n    return frame.segmentBase;\n  }\n\n  /**\n   * Compute the byte range of the segment index from the container.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {?{start: number, end: number}}\n   * @private\n   */\n  static computeIndexRange_(context) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const SegmentBase = shaka.dash.SegmentBase;\n    const XmlUtils = shaka.util.XmlUtils;\n\n    const representationIndex = MpdUtils.inheritChild(\n        context, SegmentBase.fromInheritance_, 'RepresentationIndex');\n    const indexRangeElem = MpdUtils.inheritAttribute(\n        context, SegmentBase.fromInheritance_, 'indexRange');\n\n    let indexRange = XmlUtils.parseRange(indexRangeElem || '');\n    if (representationIndex) {\n      indexRange = XmlUtils.parseAttr(\n          representationIndex, 'range', XmlUtils.parseRange, indexRange);\n    }\n    return indexRange;\n  }\n\n  /**\n   * Compute the URIs of the segment index from the container.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {!Array.<string>}\n   * @private\n   */\n  static computeIndexUris_(context) {\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const MpdUtils = shaka.dash.MpdUtils;\n    const SegmentBase = shaka.dash.SegmentBase;\n\n    const representationIndex = MpdUtils.inheritChild(\n        context, SegmentBase.fromInheritance_, 'RepresentationIndex');\n\n    let indexUris = context.representation.baseUris;\n    if (representationIndex) {\n      const representationUri = representationIndex.getAttribute('sourceURL');\n      if (representationUri) {\n        indexUris = ManifestParserUtils.resolveUris(\n            context.representation.baseUris, [representationUri]);\n      }\n    }\n\n    return indexUris;\n  }\n\n  /**\n   * Check if this type of segment index is supported.  This allows for\n   * immediate errors during parsing, as opposed to an async error from\n   * createSegmentIndex().\n   *\n   * Also checks for a valid byte range, which is not required for callers from\n   * SegmentTemplate.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @private\n   */\n  static checkSegmentIndexRangeSupport_(context, initSegmentReference) {\n    const SegmentBase = shaka.dash.SegmentBase;\n\n    SegmentBase.checkSegmentIndexSupport(context, initSegmentReference);\n\n    const indexRange = SegmentBase.computeIndexRange_(context);\n    if (!indexRange) {\n      shaka.log.error(\n          'SegmentBase does not contain sufficient segment information:',\n          'the SegmentBase does not contain @indexRange',\n          'or a RepresentationIndex element.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    }\n  }\n\n  /**\n   * Check if this type of segment index is supported.  This allows for\n   * immediate errors during parsing, as opposed to an async error from\n   * createSegmentIndex().\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   */\n  static checkSegmentIndexSupport(context, initSegmentReference) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const contentType = context.representation.contentType;\n    const containerType = context.representation.mimeType.split('/')[1];\n\n    if (contentType != ContentType.TEXT && containerType != 'mp4' &&\n        containerType != 'webm') {\n      shaka.log.error(\n          'SegmentBase specifies an unsupported container type.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_UNSUPPORTED_CONTAINER);\n    }\n\n    if ((containerType == 'webm') && !initSegmentReference) {\n      shaka.log.error(\n          'SegmentBase does not contain sufficient segment information:',\n          'the SegmentBase uses a WebM container,',\n          'but does not contain an Initialization element.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_WEBM_MISSING_INIT);\n    }\n  }\n\n  /**\n   * Generate a SegmentIndex from a Context object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.DashParser.RequestInitSegmentCallback}\n   *     requestInitSegment\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {number} scaledPresentationTimeOffset\n   * @return {!Promise.<shaka.media.SegmentIndex>}\n   * @private\n   */\n  static generateSegmentIndex_(\n      context, requestInitSegment, initSegmentReference,\n      scaledPresentationTimeOffset) {\n    const SegmentBase = shaka.dash.SegmentBase;\n\n    const indexUris = SegmentBase.computeIndexUris_(context);\n    const indexRange = SegmentBase.computeIndexRange_(context);\n    goog.asserts.assert(indexRange, 'Index range should not be null!');\n\n    return shaka.dash.SegmentBase.generateSegmentIndexFromUris(\n        context, requestInitSegment, initSegmentReference, indexUris,\n        indexRange.start, indexRange.end,\n        scaledPresentationTimeOffset);\n  }\n\n  /**\n   * Create a MediaQualityInfo object from a Context object.\n   *\n   * @param {!shaka.dash.DashParser.Context} context\n   * @return {!shaka.extern.MediaQualityInfo}\n   */\n  static createQualityInfo(context) {\n    const representation = context.representation;\n    return {\n      bandwidth: context.bandwidth,\n      audioSamplingRate: representation.audioSamplingRate,\n      codecs: representation.codecs,\n      contentType: representation.contentType,\n      frameRate: representation.frameRate || null,\n      height: representation.height || null,\n      mimeType: representation.mimeType,\n      channelsCount: representation.numChannels,\n      pixelAspectRatio: representation.pixelAspectRatio || null,\n      width: representation.width || null,\n    };\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.SegmentList');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.dash.SegmentBase');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.XmlUtils');\ngoog.requireType('shaka.dash.DashParser');\n\n\n/**\n * @summary A set of functions for parsing SegmentList elements.\n */\nshaka.dash.SegmentList = class {\n  /**\n   * Creates a new StreamInfo object.\n   * Updates the existing SegmentIndex, if any.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {!Object.<string, !shaka.extern.Stream>} streamMap\n   * @return {shaka.dash.DashParser.StreamInfo}\n   */\n  static createStreamInfo(context, streamMap) {\n    goog.asserts.assert(context.representation.segmentList,\n        'Should only be called with SegmentList');\n    const SegmentList = shaka.dash.SegmentList;\n\n    const initSegmentReference = shaka.dash.SegmentBase.createInitSegment(\n        context, SegmentList.fromInheritance_);\n    const info = SegmentList.parseSegmentListInfo_(context);\n\n    SegmentList.checkSegmentListInfo_(context, info);\n\n    /** @type {shaka.media.SegmentIndex} */\n    let segmentIndex = null;\n    let stream = null;\n    if (context.period.id && context.representation.id) {\n      // Only check/store the index if period and representation IDs are set.\n      const id = context.period.id + ',' + context.representation.id;\n      stream = streamMap[id];\n      if (stream) {\n        segmentIndex = stream.segmentIndex;\n      }\n    }\n\n    const references = SegmentList.createSegmentReferences_(\n        context.periodInfo.start, context.periodInfo.duration,\n        info.startNumber, context.representation.baseUris, info,\n        initSegmentReference);\n\n    const isNew = !segmentIndex;\n    if (segmentIndex) {\n      const start = context.presentationTimeline.getSegmentAvailabilityStart();\n      segmentIndex.mergeAndEvict(references, start);\n    } else {\n      segmentIndex = new shaka.media.SegmentIndex(references);\n    }\n    context.presentationTimeline.notifySegments(references);\n\n    if (!context.dynamic || !context.periodInfo.isLastPeriod) {\n      const periodStart = context.periodInfo.start;\n      const periodEnd = context.periodInfo.duration ?\n          context.periodInfo.start + context.periodInfo.duration : Infinity;\n      segmentIndex.fit(periodStart, periodEnd, isNew);\n    }\n\n    if (stream) {\n      stream.segmentIndex = segmentIndex;\n    }\n\n    return {\n      generateSegmentIndex: () => {\n        if (!segmentIndex || segmentIndex.isEmpty()) {\n          segmentIndex.merge(references);\n        }\n        return Promise.resolve(segmentIndex);\n      },\n    };\n  }\n\n  /**\n   * @param {?shaka.dash.DashParser.InheritanceFrame} frame\n   * @return {Element}\n   * @private\n   */\n  static fromInheritance_(frame) {\n    return frame.segmentList;\n  }\n\n  /**\n   * Parses the SegmentList items to create an info object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {shaka.dash.SegmentList.SegmentListInfo}\n   * @private\n   */\n  static parseSegmentListInfo_(context) {\n    const SegmentList = shaka.dash.SegmentList;\n    const MpdUtils = shaka.dash.MpdUtils;\n\n    const mediaSegments = SegmentList.parseMediaSegments_(context);\n    const segmentInfo =\n        MpdUtils.parseSegmentInfo(context, SegmentList.fromInheritance_);\n\n    let startNumber = segmentInfo.startNumber;\n    if (startNumber == 0) {\n      shaka.log.warning('SegmentList@startNumber must be > 0');\n      startNumber = 1;\n    }\n\n    let startTime = 0;\n    if (segmentInfo.segmentDuration) {\n      // See DASH sec. 5.3.9.5.3\n      // Don't use presentationTimeOffset for @duration.\n      startTime = segmentInfo.segmentDuration * (startNumber - 1);\n    } else if (segmentInfo.timeline && segmentInfo.timeline.length > 0) {\n      // The presentationTimeOffset was considered in timeline creation.\n      startTime = segmentInfo.timeline[0].start;\n    }\n\n    return {\n      segmentDuration: segmentInfo.segmentDuration,\n      startTime: startTime,\n      startNumber: startNumber,\n      scaledPresentationTimeOffset: segmentInfo.scaledPresentationTimeOffset,\n      timeline: segmentInfo.timeline,\n      mediaSegments: mediaSegments,\n    };\n  }\n\n  /**\n   * Checks whether a SegmentListInfo object is valid.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.SegmentList.SegmentListInfo} info\n   * @private\n   */\n  static checkSegmentListInfo_(context, info) {\n    if (!info.segmentDuration && !info.timeline &&\n        info.mediaSegments.length > 1) {\n      shaka.log.warning(\n          'SegmentList does not contain sufficient segment information:',\n          'the SegmentList specifies multiple segments,',\n          'but does not specify a segment duration or timeline.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    }\n\n    if (!info.segmentDuration && !context.periodInfo.duration &&\n        !info.timeline && info.mediaSegments.length == 1) {\n      shaka.log.warning(\n          'SegmentList does not contain sufficient segment information:',\n          'the SegmentList specifies one segment,',\n          'but does not specify a segment duration, period duration,',\n          'or timeline.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    }\n\n    if (info.timeline && info.timeline.length == 0) {\n      shaka.log.warning(\n          'SegmentList does not contain sufficient segment information:',\n          'the SegmentList has an empty timeline.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    }\n  }\n\n  /**\n   * Creates an array of segment references for the given data.\n   *\n   * @param {number} periodStart in seconds.\n   * @param {?number} periodDuration in seconds.\n   * @param {number} startNumber\n   * @param {!Array.<string>} baseUris\n   * @param {shaka.dash.SegmentList.SegmentListInfo} info\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @private\n   */\n  static createSegmentReferences_(\n      periodStart, periodDuration, startNumber, baseUris, info,\n      initSegmentReference) {\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n    let max = info.mediaSegments.length;\n    if (info.timeline && info.timeline.length != info.mediaSegments.length) {\n      max = Math.min(info.timeline.length, info.mediaSegments.length);\n      shaka.log.warning(\n          'The number of items in the segment timeline and the number of ',\n          'segment URLs do not match, truncating', info.mediaSegments.length,\n          'to', max);\n    }\n\n    const timestampOffset = periodStart - info.scaledPresentationTimeOffset;\n    const appendWindowStart = periodStart;\n    const appendWindowEnd = periodDuration ?\n        periodStart + periodDuration : Infinity;\n\n    /** @type {!Array.<!shaka.media.SegmentReference>} */\n    const references = [];\n    let prevEndTime = info.startTime;\n    for (let i = 0; i < max; i++) {\n      const segment = info.mediaSegments[i];\n      const mediaUri = ManifestParserUtils.resolveUris(\n          baseUris, [segment.mediaUri]);\n\n      const startTime = prevEndTime;\n      let endTime;\n\n      if (info.segmentDuration != null) {\n        endTime = startTime + info.segmentDuration;\n      } else if (info.timeline) {\n        // Ignore the timepoint start since they are continuous.\n        endTime = info.timeline[i].end;\n      } else {\n        // If segmentDuration and timeline are null then there must\n        // be exactly one segment.\n        goog.asserts.assert(\n            info.mediaSegments.length == 1 && periodDuration,\n            'There should be exactly one segment with a Period duration.');\n        endTime = startTime + periodDuration;\n      }\n\n      const getUris = () => mediaUri;\n      references.push(\n          new shaka.media.SegmentReference(\n              periodStart + startTime,\n              periodStart + endTime,\n              getUris,\n              segment.start,\n              segment.end,\n              initSegmentReference,\n              timestampOffset,\n              appendWindowStart, appendWindowEnd));\n      prevEndTime = endTime;\n    }\n\n    return references;\n  }\n\n  /**\n   * Parses the media URIs from the context.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {!Array.<shaka.dash.SegmentList.MediaSegment>}\n   * @private\n   */\n  static parseMediaSegments_(context) {\n    const Functional = shaka.util.Functional;\n    /** @type {!Array.<!Element>} */\n    const segmentLists = [\n      context.representation.segmentList,\n      context.adaptationSet.segmentList,\n      context.period.segmentList,\n    ].filter(Functional.isNotNull);\n\n    const XmlUtils = shaka.util.XmlUtils;\n    // Search each SegmentList for one with at least one SegmentURL element,\n    // select the first one, and convert each SegmentURL element to a tuple.\n    return segmentLists\n        .map((node) => { return XmlUtils.findChildren(node, 'SegmentURL'); })\n        .reduce((all, part) => { return all.length > 0 ? all : part; })\n        .map((urlNode) => {\n          if (urlNode.getAttribute('indexRange') &&\n              !context.indexRangeWarningGiven) {\n            context.indexRangeWarningGiven = true;\n            shaka.log.warning(\n                'We do not support the SegmentURL@indexRange attribute on ' +\n                'SegmentList.  We only use the SegmentList@duration ' +\n                'attribute or SegmentTimeline, which must be accurate.');\n          }\n\n          const uri = urlNode.getAttribute('media');\n          const range = XmlUtils.parseAttr(\n              urlNode, 'mediaRange', XmlUtils.parseRange,\n              {start: 0, end: null});\n          return {mediaUri: uri, start: range.start, end: range.end};\n        });\n  }\n};\n\n/**\n * @typedef {{\n *   mediaUri: string,\n *   start: number,\n *   end: ?number\n * }}\n *\n * @property {string} mediaUri\n *   The URI of the segment.\n * @property {number} start\n *   The start byte of the segment.\n * @property {?number} end\n *   The end byte of the segment, or null.\n */\nshaka.dash.SegmentList.MediaSegment;\n\n/**\n * @typedef {{\n *   segmentDuration: ?number,\n *   startTime: number,\n *   startNumber: number,\n *   scaledPresentationTimeOffset: number,\n *   timeline: Array.<shaka.dash.MpdUtils.TimeRange>,\n *   mediaSegments: !Array.<shaka.dash.SegmentList.MediaSegment>\n * }}\n * @private\n *\n * @description\n * Contains information about a SegmentList.\n *\n * @property {?number} segmentDuration\n *   The duration of the segments, if given.\n * @property {number} startTime\n *   The start time of the first segment, in seconds.\n * @property {number} startNumber\n *   The start number of the segments; 1 or greater.\n * @property {number} scaledPresentationTimeOffset\n *   The scaledPresentationTimeOffset of the representation, in seconds.\n * @property {Array.<shaka.dash.MpdUtils.TimeRange>} timeline\n *   The timeline of the representation, if given.  Times in seconds.\n * @property {!Array.<shaka.dash.SegmentList.MediaSegment>} mediaSegments\n *   The URI and byte-ranges of the media segments.\n */\nshaka.dash.SegmentList.SegmentListInfo;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.SegmentTemplate');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.dash.SegmentBase');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.ObjectUtils');\ngoog.requireType('shaka.dash.DashParser');\n\n\n/**\n * @summary A set of functions for parsing SegmentTemplate elements.\n */\nshaka.dash.SegmentTemplate = class {\n  /**\n   * Creates a new StreamInfo object.\n   * Updates the existing SegmentIndex, if any.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.DashParser.RequestInitSegmentCallback}\n   *   requestInitSegment\n   * @param {!Object.<string, !shaka.extern.Stream>} streamMap\n   * @param {boolean} isUpdate True if the manifest is being updated.\n   * @param {number} segmentLimit The maximum number of segments to generate for\n   *   a SegmentTemplate with fixed duration.\n   * @param {!Object.<string, number>} periodDurationMap\n   * @return {shaka.dash.DashParser.StreamInfo}\n   */\n  static createStreamInfo(\n      context, requestInitSegment, streamMap, isUpdate, segmentLimit,\n      periodDurationMap) {\n    goog.asserts.assert(context.representation.segmentTemplate,\n        'Should only be called with SegmentTemplate');\n    const SegmentTemplate = shaka.dash.SegmentTemplate;\n\n    const initSegmentReference = SegmentTemplate.createInitSegment_(context);\n    const info = SegmentTemplate.parseSegmentTemplateInfo_(context);\n\n    SegmentTemplate.checkSegmentTemplateInfo_(context, info);\n\n    // Direct fields of context will be reassigned by the parser before\n    // generateSegmentIndex is called.  So we must make a shallow copy first,\n    // and use that in the generateSegmentIndex callbacks.\n    const shallowCopyOfContext =\n        shaka.util.ObjectUtils.shallowCloneObject(context);\n\n    if (info.indexTemplate) {\n      shaka.dash.SegmentBase.checkSegmentIndexSupport(\n          context, initSegmentReference);\n\n      return {\n        generateSegmentIndex: () => {\n          return SegmentTemplate.generateSegmentIndexFromIndexTemplate_(\n              shallowCopyOfContext, requestInitSegment, initSegmentReference,\n              info);\n        },\n      };\n    } else if (info.segmentDuration) {\n      if (!isUpdate && context.adaptationSet.contentType !== 'image') {\n        context.presentationTimeline.notifyMaxSegmentDuration(\n            info.segmentDuration);\n        context.presentationTimeline.notifyMinSegmentStartTime(\n            context.periodInfo.start);\n      }\n\n      return {\n        generateSegmentIndex: () => {\n          return SegmentTemplate.generateSegmentIndexFromDuration_(\n              shallowCopyOfContext, info, segmentLimit, initSegmentReference,\n              periodDurationMap);\n        },\n      };\n    } else {\n      /** @type {shaka.media.SegmentIndex} */\n      let segmentIndex = null;\n      let id = null;\n      let stream = null;\n      if (context.period.id && context.representation.id) {\n        // Only check/store the index if period and representation IDs are set.\n        id = context.period.id + ',' + context.representation.id;\n        stream = streamMap[id];\n        if (stream) {\n          segmentIndex = stream.segmentIndex;\n        }\n      }\n\n      const references = SegmentTemplate.createFromTimeline_(\n          shallowCopyOfContext, info, initSegmentReference);\n\n      const periodStart = context.periodInfo.start;\n      const periodEnd = context.periodInfo.duration ?\n          context.periodInfo.start + context.periodInfo.duration : Infinity;\n\n      /* When to fit segments.  All refactors should honor/update this table:\n       *\n       * | dynamic | infinite | last   | should | notes                     |\n       * |         | period   | period | fit    |                           |\n       * | ------- | -------- | ------ | ------ | ------------------------- |\n       * |     F   |     F    |    X   |    T   | typical VOD               |\n       * |     F   |     T    |    X   |    X   | impossible: infinite VOD  |\n       * |     T   |     F    |    F   |    T   | typical live, old period  |\n       * |     T   |     F    |    T   |    F   | typical IPR               |\n       * |     T   |     T    |    F   |    X   | impossible: old, infinite |\n       * |     T   |     T    |    T   |    F   | typical live, new period  |\n       */\n\n      // We never fit the final period of dynamic content, which could be\n      // infinite live (with no limit to fit to) or IPR (which would expand the\n      // most recent segment to the end of the presentation).\n      const shouldFit = !(context.dynamic && context.periodInfo.isLastPeriod);\n\n      if (segmentIndex) {\n        if (shouldFit) {\n          // Fit the new references before merging them, so that the merge\n          // algorithm has a more accurate view of their start and end times.\n          const wrapper = new shaka.media.SegmentIndex(references);\n          wrapper.fit(periodStart, periodEnd, /* isNew= */ true);\n        }\n\n        segmentIndex.mergeAndEvict(references,\n            context.presentationTimeline.getSegmentAvailabilityStart());\n      } else {\n        segmentIndex = new shaka.media.SegmentIndex(references);\n      }\n      context.presentationTimeline.notifySegments(references);\n\n      if (shouldFit) {\n        segmentIndex.fit(periodStart, periodEnd);\n      }\n\n      if (stream && context.dynamic) {\n        stream.segmentIndex = segmentIndex;\n      }\n\n      return {\n        generateSegmentIndex: () => {\n          // If segmentIndex is deleted, or segmentIndex's references are\n          // released by closeSegmentIndex(), we should set the value of\n          // segmentIndex again.\n          if (!segmentIndex || segmentIndex.isEmpty()) {\n            segmentIndex.merge(references);\n          }\n          return Promise.resolve(segmentIndex);\n        },\n      };\n    }\n  }\n\n  /**\n   * @param {?shaka.dash.DashParser.InheritanceFrame} frame\n   * @return {Element}\n   * @private\n   */\n  static fromInheritance_(frame) {\n    return frame.segmentTemplate;\n  }\n\n  /**\n   * Parses a SegmentTemplate element into an info object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {shaka.dash.SegmentTemplate.SegmentTemplateInfo}\n   * @private\n   */\n  static parseSegmentTemplateInfo_(context) {\n    const SegmentTemplate = shaka.dash.SegmentTemplate;\n    const MpdUtils = shaka.dash.MpdUtils;\n    const segmentInfo =\n        MpdUtils.parseSegmentInfo(context, SegmentTemplate.fromInheritance_);\n\n    const media = MpdUtils.inheritAttribute(\n        context, SegmentTemplate.fromInheritance_, 'media');\n    const index = MpdUtils.inheritAttribute(\n        context, SegmentTemplate.fromInheritance_, 'index');\n\n    return {\n      segmentDuration: segmentInfo.segmentDuration,\n      timescale: segmentInfo.timescale,\n      startNumber: segmentInfo.startNumber,\n      scaledPresentationTimeOffset: segmentInfo.scaledPresentationTimeOffset,\n      unscaledPresentationTimeOffset:\n          segmentInfo.unscaledPresentationTimeOffset,\n      timeline: segmentInfo.timeline,\n      mediaTemplate: media,\n      indexTemplate: index,\n    };\n  }\n\n  /**\n   * Verifies a SegmentTemplate info object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n   * @private\n   */\n  static checkSegmentTemplateInfo_(context, info) {\n    let n = 0;\n    n += info.indexTemplate ? 1 : 0;\n    n += info.timeline ? 1 : 0;\n    n += info.segmentDuration ? 1 : 0;\n\n    if (n == 0) {\n      shaka.log.error(\n          'SegmentTemplate does not contain any segment information:',\n          'the SegmentTemplate must contain either an index URL template',\n          'a SegmentTimeline, or a segment duration.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    } else if (n != 1) {\n      shaka.log.warning(\n          'SegmentTemplate containes multiple segment information sources:',\n          'the SegmentTemplate should only contain an index URL template,',\n          'a SegmentTimeline or a segment duration.',\n          context.representation);\n      if (info.indexTemplate) {\n        shaka.log.info('Using the index URL template by default.');\n        info.timeline = null;\n        info.segmentDuration = null;\n      } else {\n        goog.asserts.assert(info.timeline, 'There should be a timeline');\n        shaka.log.info('Using the SegmentTimeline by default.');\n        info.segmentDuration = null;\n      }\n    }\n\n    if (!info.indexTemplate && !info.mediaTemplate) {\n      shaka.log.error(\n          'SegmentTemplate does not contain sufficient segment information:',\n          'the SegmentTemplate\\'s media URL template is missing.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    }\n  }\n\n  /**\n   * Generates a SegmentIndex from an index URL template.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.DashParser.RequestInitSegmentCallback}\n   *     requestInitSegment\n   * @param {shaka.media.InitSegmentReference} init\n   * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n   * @return {!Promise.<shaka.media.SegmentIndex>}\n   * @private\n   */\n  static generateSegmentIndexFromIndexTemplate_(\n      context, requestInitSegment, init, info) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n    goog.asserts.assert(info.indexTemplate, 'must be using index template');\n    const filledTemplate = MpdUtils.fillUriTemplate(\n        info.indexTemplate, context.representation.id,\n        null, context.bandwidth || null, null);\n\n    const resolvedUris = ManifestParserUtils.resolveUris(\n        context.representation.baseUris, [filledTemplate]);\n\n    return shaka.dash.SegmentBase.generateSegmentIndexFromUris(\n        context, requestInitSegment, init, resolvedUris, 0, null,\n        info.scaledPresentationTimeOffset);\n  }\n\n  /**\n   * Generates a SegmentIndex from fixed-duration segments.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n   * @param {number} segmentLimit The maximum number of segments to generate.\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {!Object.<string, number>} periodDurationMap\n   * @return {!Promise.<shaka.media.SegmentIndex>}\n   * @private\n   */\n  static generateSegmentIndexFromDuration_(\n      context, info, segmentLimit, initSegmentReference, periodDurationMap) {\n    goog.asserts.assert(info.mediaTemplate,\n        'There should be a media template with duration');\n\n    const MpdUtils = shaka.dash.MpdUtils;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n    const presentationTimeline = context.presentationTimeline;\n\n    // Capture values that could change as the parsing context moves on to\n    // other parts of the manifest.\n    const periodStart = context.periodInfo.start;\n    const periodId = context.period.id;\n    const initialPeriodDuration = context.periodInfo.duration;\n\n    // For multi-period live streams the period duration may not be known until\n    // the following period appears in an updated manifest. periodDurationMap\n    // provides the updated period duration.\n    const getPeriodEnd = () => {\n      const periodDuration =\n        (periodId != null && periodDurationMap[periodId]) ||\n        initialPeriodDuration;\n      const periodEnd = periodDuration ?\n        (periodStart + periodDuration) : Infinity;\n      return periodEnd;\n    };\n\n    const segmentDuration = info.segmentDuration;\n    goog.asserts.assert(\n        segmentDuration != null, 'Segment duration must not be null!');\n\n    const startNumber = info.startNumber;\n    const timescale = info.timescale;\n\n    const template = info.mediaTemplate;\n    const bandwidth = context.bandwidth || null;\n    const id = context.representation.id;\n    const baseUris = context.representation.baseUris;\n\n    const timestampOffset = periodStart - info.scaledPresentationTimeOffset;\n\n    // Computes the range of presentation timestamps both within the period and\n    // available.  This is an intersection of the period range and the\n    // availability window.\n    const computeAvailablePeriodRange = () => {\n      return [\n        Math.max(\n            presentationTimeline.getSegmentAvailabilityStart(),\n            periodStart),\n\n        Math.min(\n            presentationTimeline.getSegmentAvailabilityEnd(),\n            getPeriodEnd()),\n      ];\n    };\n\n    // Computes the range of absolute positions both within the period and\n    // available.  The range is inclusive.  These are the positions for which we\n    // will generate segment references.\n    const computeAvailablePositionRange = () => {\n      // In presentation timestamps.\n      const availablePresentationTimes = computeAvailablePeriodRange();\n      goog.asserts.assert(availablePresentationTimes.every(isFinite),\n          'Available presentation times must be finite!');\n      goog.asserts.assert(availablePresentationTimes.every((x) => x >= 0),\n          'Available presentation times must be positive!');\n      goog.asserts.assert(segmentDuration != null,\n          'Segment duration must not be null!');\n\n      // In period-relative timestamps.\n      const availablePeriodTimes =\n          availablePresentationTimes.map((x) => x - periodStart);\n      // These may sometimes be reversed ([1] <= [0]) if the period is\n      // completely unavailable.  The logic will still work if this happens,\n      // because we will simply generate no references.\n\n      // In period-relative positions (0-based).\n      const availablePeriodPositions = [\n        Math.ceil(availablePeriodTimes[0] / segmentDuration),\n        Math.ceil(availablePeriodTimes[1] / segmentDuration) - 1,\n      ];\n\n      // In absolute positions.\n      const availablePresentationPositions =\n          availablePeriodPositions.map((x) => x + startNumber);\n      return availablePresentationPositions;\n    };\n\n    // For Live, we must limit the initial SegmentIndex in size, to avoid\n    // consuming too much CPU or memory for content with gigantic\n    // timeShiftBufferDepth (which can have values up to and including\n    // Infinity).\n    const range = computeAvailablePositionRange();\n    const minPosition = context.dynamic ?\n        Math.max(range[0], range[1] - segmentLimit + 1) :\n        range[0];\n    const maxPosition = range[1];\n\n    const references = [];\n    const createReference = (position) => {\n      // These inner variables are all scoped to the inner loop, and can be used\n      // safely in the callback below.\n\n      goog.asserts.assert(segmentDuration != null,\n          'Segment duration must not be null!');\n\n      // Relative to the period start.\n      const positionWithinPeriod = position - startNumber;\n      const segmentPeriodTime = positionWithinPeriod * segmentDuration;\n\n      // What will appear in the actual segment files.  The media timestamp is\n      // what is expected in the $Time$ template.\n      const segmentMediaTime = segmentPeriodTime +\n          info.scaledPresentationTimeOffset;\n\n      const getUris = () => {\n        const mediaUri = MpdUtils.fillUriTemplate(\n            template, id, position, bandwidth,\n            segmentMediaTime * timescale);\n        return ManifestParserUtils.resolveUris(baseUris, [mediaUri]);\n      };\n\n      // Relative to the presentation.\n      const segmentStart = segmentPeriodTime + periodStart;\n      const trueSegmentEnd = segmentStart + segmentDuration;\n      // Cap the segment end at the period end so that references from the\n      // next period will fit neatly after it.\n      const segmentEnd = Math.min(trueSegmentEnd, getPeriodEnd());\n\n      // This condition will be true unless the segmentStart was >= periodEnd.\n      // If we've done the position calculations correctly, this won't happen.\n      goog.asserts.assert(segmentStart < segmentEnd,\n          'Generated a segment outside of the period!');\n\n      const ref = new shaka.media.SegmentReference(\n          segmentStart,\n          segmentEnd,\n          getUris,\n          /* startByte= */ 0,\n          /* endByte= */ null,\n          initSegmentReference,\n          timestampOffset,\n          /* appendWindowStart= */ periodStart,\n          /* appendWindowEnd= */ getPeriodEnd());\n      // This is necessary information for thumbnail streams:\n      ref.trueEndTime = trueSegmentEnd;\n      return ref;\n    };\n\n    for (let position = minPosition; position <= maxPosition; ++position) {\n      const reference = createReference(position);\n      references.push(reference);\n    }\n\n    /** @type {shaka.media.SegmentIndex} */\n    const segmentIndex = new shaka.media.SegmentIndex(references);\n\n    // If the availability timeline currently ends before the period, we will\n    // need to add references over time.\n    const willNeedToAddReferences =\n        presentationTimeline.getSegmentAvailabilityEnd() < getPeriodEnd();\n\n    // When we start a live stream with a period that ends within the\n    // availability window we will not need to add more references, but we will\n    // need to evict old references.\n    const willNeedToEvictReferences = presentationTimeline.isLive();\n\n    if (willNeedToAddReferences || willNeedToEvictReferences) {\n      // The period continues to get longer over time, so check for new\n      // references once every |segmentDuration| seconds.\n      // We clamp to |minPosition| in case the initial range was reversed and no\n      // references were generated.  Otherwise, the update would start creating\n      // negative positions for segments in periods which begin in the future.\n      let nextPosition = Math.max(minPosition, maxPosition + 1);\n      segmentIndex.updateEvery(segmentDuration, () => {\n        // Evict any references outside the window.\n        const availabilityStartTime =\n          presentationTimeline.getSegmentAvailabilityStart();\n        segmentIndex.evict(availabilityStartTime);\n\n        // Compute any new references that need to be added.\n        const [_, maxPosition] = computeAvailablePositionRange();\n        const references = [];\n        while (nextPosition <= maxPosition) {\n          const reference = createReference(nextPosition);\n          references.push(reference);\n          nextPosition++;\n        }\n\n        // The timer must continue firing until the entire period is\n        // unavailable, so that all references will be evicted.\n        if (availabilityStartTime > getPeriodEnd() && !references.length) {\n          // Signal stop.\n          return null;\n        }\n        return references;\n      });\n    }\n\n    return Promise.resolve(segmentIndex);\n  }\n\n  /**\n   * Creates segment references from a timeline.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @private\n   */\n  static createFromTimeline_(context, info, initSegmentReference) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n    const periodStart = context.periodInfo.start;\n    const periodDuration = context.periodInfo.duration;\n\n    const timestampOffset = periodStart - info.scaledPresentationTimeOffset;\n    const appendWindowStart = periodStart;\n    const appendWindowEnd = periodDuration ?\n        periodStart + periodDuration : Infinity;\n\n    /** @type {!Array.<!shaka.media.SegmentReference>} */\n    const references = [];\n    for (let i = 0; i < info.timeline.length; i++) {\n      const {start, unscaledStart, end} = info.timeline[i];\n\n      // Note: i = k - 1, where k indicates the k'th segment listed in the MPD.\n      // (See section 5.3.9.5.3 of the DASH spec.)\n      const segmentReplacement = i + info.startNumber;\n\n      // Consider the presentation time offset in segment uri computation\n      const timeReplacement = unscaledStart +\n          info.unscaledPresentationTimeOffset;\n      const repId = context.representation.id;\n      const bandwidth = context.bandwidth || null;\n      const mediaTemplate = info.mediaTemplate;\n      const baseUris = context.representation.baseUris;\n\n      // This callback must not capture any non-local\n      // variables, such as info, context, etc.  Make\n      // sure any values you reference here have\n      // been assigned to local variables within the\n      // loop, or else we will end up with a leak.\n      const createUris =\n          () => {\n            goog.asserts.assert(\n                mediaTemplate,\n                'There should be a media template with a timeline');\n            const mediaUri = MpdUtils.fillUriTemplate(\n                mediaTemplate, repId,\n                segmentReplacement, bandwidth || null, timeReplacement);\n            return ManifestParserUtils\n                .resolveUris(baseUris, [mediaUri])\n                .map((g) => {\n                  return g.toString();\n                });\n          };\n\n      references.push(new shaka.media.SegmentReference(\n          periodStart + start,\n          periodStart + end,\n          createUris,\n          /* startByte= */ 0,\n          /* endByte= */ null,\n          initSegmentReference,\n          timestampOffset,\n          appendWindowStart,\n          appendWindowEnd));\n    }\n\n    return references;\n  }\n\n  /**\n   * Creates an init segment reference from a context object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {shaka.media.InitSegmentReference}\n   * @private\n   */\n  static createInitSegment_(context) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const SegmentTemplate = shaka.dash.SegmentTemplate;\n\n    const initialization = MpdUtils.inheritAttribute(\n        context, SegmentTemplate.fromInheritance_, 'initialization');\n    if (!initialization) {\n      return null;\n    }\n\n    const repId = context.representation.id;\n    const bandwidth = context.bandwidth || null;\n    const baseUris = context.representation.baseUris;\n    const getUris = () => {\n      goog.asserts.assert(initialization, 'Should have returned earler');\n      const filledTemplate = MpdUtils.fillUriTemplate(\n          initialization, repId, null, bandwidth, null);\n      const resolvedUris = ManifestParserUtils.resolveUris(\n          baseUris, [filledTemplate]);\n      return resolvedUris;\n    };\n    const qualityInfo = shaka.dash.SegmentBase.createQualityInfo(context);\n    return new shaka.media.InitSegmentReference(getUris, 0, null, qualityInfo);\n  }\n};\n\n/**\n * @typedef {{\n *   timescale: number,\n *   segmentDuration: ?number,\n *   startNumber: number,\n *   scaledPresentationTimeOffset: number,\n *   unscaledPresentationTimeOffset: number,\n *   timeline: Array.<shaka.dash.MpdUtils.TimeRange>,\n *   mediaTemplate: ?string,\n *   indexTemplate: ?string\n * }}\n * @private\n *\n * @description\n * Contains information about a SegmentTemplate.\n *\n * @property {number} timescale\n *   The time-scale of the representation.\n * @property {?number} segmentDuration\n *   The duration of the segments in seconds, if given.\n * @property {number} startNumber\n *   The start number of the segments; 1 or greater.\n * @property {number} scaledPresentationTimeOffset\n *   The presentation time offset of the representation, in seconds.\n * @property {number} unscaledPresentationTimeOffset\n *   The presentation time offset of the representation, in timescale units.\n * @property {Array.<shaka.dash.MpdUtils.TimeRange>} timeline\n *   The timeline of the representation, if given.  Times in seconds.\n * @property {?string} mediaTemplate\n *   The media URI template, if given.\n * @property {?string} indexTemplate\n *   The index URI template, if given.\n */\nshaka.dash.SegmentTemplate.SegmentTemplateInfo;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.PeriodCombiner');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.MetaSegmentIndex');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.MimeUtils');\n\n/**\n * A utility to combine streams across periods.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.util.PeriodCombiner = class {\n  /** */\n  constructor() {\n    /** @private {!Array.<shaka.extern.Variant>} */\n    this.variants_ = [];\n\n    /** @private {!Array.<shaka.extern.Stream>} */\n    this.audioStreams_ = [];\n\n    /** @private {!Array.<shaka.extern.Stream>} */\n    this.videoStreams_ = [];\n\n    /** @private {!Array.<shaka.extern.Stream>} */\n    this.textStreams_ = [];\n\n    /** @private {!Array.<shaka.extern.Stream>} */\n    this.imageStreams_ = [];\n\n    /**\n     * The IDs of the periods we have already used to generate streams.\n     * This helps us identify the periods which have been added when a live\n     * stream is updated.\n     *\n     * @private {!Set.<string>}\n     */\n    this.usedPeriodIds_ = new Set();\n  }\n\n  /** @override */\n  release() {\n    const allStreams =\n        this.audioStreams_.concat(this.videoStreams_, this.textStreams_,\n            this.imageStreams_);\n\n    for (const stream of allStreams) {\n      if (stream.segmentIndex) {\n        stream.segmentIndex.release();\n      }\n    }\n\n    this.audioStreams_ = [];\n    this.videoStreams_ = [];\n    this.textStreams_ = [];\n    this.imageStreams_ = [];\n    this.variants_ = [];\n  }\n\n  /** @return {!Array.<shaka.extern.Variant>} */\n  getVariants() {\n    return this.variants_;\n  }\n\n  /** @return {!Array.<shaka.extern.Stream>} */\n  getTextStreams() {\n    // Return a copy of the array because makeTextStreamsForClosedCaptions\n    // may make changes to the contents of the array. Those changes should not\n    // propagate back to the PeriodCombiner.\n    return this.textStreams_.slice();\n  }\n\n  /** @return {!Array.<shaka.extern.Stream>} */\n  getImageStreams() {\n    return this.imageStreams_;\n  }\n\n  /**\n   * @param {!Array.<shaka.util.PeriodCombiner.Period>} periods\n   * @param {boolean} isDynamic\n   * @return {!Promise}\n   */\n  async combinePeriods(periods, isDynamic) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    shaka.util.PeriodCombiner.filterOutAudioStreamDuplicates_(periods);\n    shaka.util.PeriodCombiner.filterOutVideoStreamDuplicates_(periods);\n    shaka.util.PeriodCombiner.filterOutTextStreamDuplicates_(periods);\n    shaka.util.PeriodCombiner.filterOutImageStreamDuplicates_(periods);\n\n    // Optimization: for single-period VOD, do nothing.  This makes sure\n    // single-period DASH content will be 100% accurately represented in the\n    // output.\n    if (!isDynamic && periods.length == 1) {\n      const firstPeriod = periods[0];\n      this.audioStreams_ = firstPeriod.audioStreams;\n      this.videoStreams_ = firstPeriod.videoStreams;\n      this.textStreams_ = firstPeriod.textStreams;\n      this.imageStreams_ = firstPeriod.imageStreams;\n    } else {\n      // Find the first period we haven't seen before.  Tag all the periods we\n      // see now as \"used\".\n      let firstNewPeriodIndex = -1;\n      for (let i = 0; i < periods.length; i++) {\n        const period = periods[i];\n        if (this.usedPeriodIds_.has(period.id)) {\n          // This isn't new.\n        } else {\n          // This one _is_ new.\n          this.usedPeriodIds_.add(period.id);\n\n          if (firstNewPeriodIndex == -1) {\n            // And it's the _first_ new one.\n            firstNewPeriodIndex = i;\n          }\n        }\n      }\n\n      if (firstNewPeriodIndex == -1) {\n        // Nothing new? Nothing to do.\n        return;\n      }\n\n      const audioStreamsPerPeriod = periods.map(\n          (period) => period.audioStreams);\n      const videoStreamsPerPeriod = periods.map(\n          (period) => period.videoStreams);\n      const textStreamsPerPeriod = periods.map(\n          (period) => period.textStreams);\n      const imageStreamsPerPeriod = periods.map(\n          (period) => period.imageStreams);\n\n      // It's okay to have a period with no text or images, but our algorithm\n      // fails on any period without matching streams.  So we add dummy streams\n      // to each period.  Since we combine text streams by language and image\n      // streams by resolution, we might need a dummy even in periods with these\n      // streams already.\n      for (const textStreams of textStreamsPerPeriod) {\n        textStreams.push(shaka.util.PeriodCombiner.dummyStream_(\n            ContentType.TEXT));\n      }\n      for (const imageStreams of imageStreamsPerPeriod) {\n        imageStreams.push(shaka.util.PeriodCombiner.dummyStream_(\n            ContentType.IMAGE));\n      }\n\n      await shaka.util.PeriodCombiner.combine_(\n          this.audioStreams_,\n          audioStreamsPerPeriod,\n          firstNewPeriodIndex,\n          shaka.util.PeriodCombiner.cloneStream_,\n          shaka.util.PeriodCombiner.concatenateStreams_);\n\n      await shaka.util.PeriodCombiner.combine_(\n          this.videoStreams_,\n          videoStreamsPerPeriod,\n          firstNewPeriodIndex,\n          shaka.util.PeriodCombiner.cloneStream_,\n          shaka.util.PeriodCombiner.concatenateStreams_);\n\n      await shaka.util.PeriodCombiner.combine_(\n          this.textStreams_,\n          textStreamsPerPeriod,\n          firstNewPeriodIndex,\n          shaka.util.PeriodCombiner.cloneStream_,\n          shaka.util.PeriodCombiner.concatenateStreams_);\n\n      await shaka.util.PeriodCombiner.combine_(\n          this.imageStreams_,\n          imageStreamsPerPeriod,\n          firstNewPeriodIndex,\n          shaka.util.PeriodCombiner.cloneStream_,\n          shaka.util.PeriodCombiner.concatenateStreams_);\n    }\n\n    // Create variants for all audio/video combinations.\n    let nextVariantId = 0;\n    const variants = [];\n    if (!this.videoStreams_.length || !this.audioStreams_.length) {\n      // For audio-only or video-only content, just give each stream its own\n      // variant.\n      const streams = this.videoStreams_.concat(this.audioStreams_);\n      for (const stream of streams) {\n        const id = nextVariantId++;\n        variants.push({\n          id,\n          language: stream.language,\n          primary: stream.primary,\n          audio: stream.type == ContentType.AUDIO ? stream : null,\n          video: stream.type == ContentType.VIDEO ? stream : null,\n          bandwidth: stream.bandwidth || 0,\n          drmInfos: stream.drmInfos,\n          allowedByApplication: true,\n          allowedByKeySystem: true,\n          decodingInfos: [],\n        });\n      }\n    } else {\n      for (const audio of this.audioStreams_) {\n        for (const video of this.videoStreams_) {\n          const commonDrmInfos = shaka.media.DrmEngine.getCommonDrmInfos(\n              audio.drmInfos, video.drmInfos);\n\n          if (audio.drmInfos.length && video.drmInfos.length &&\n              !commonDrmInfos.length) {\n            shaka.log.warning(\n                'Incompatible DRM in audio & video, skipping variant creation.',\n                audio, video);\n            continue;\n          }\n\n          const id = nextVariantId++;\n          variants.push({\n            id,\n            language: audio.language,\n            primary: audio.primary,\n            audio,\n            video,\n            bandwidth: (audio.bandwidth || 0) + (video.bandwidth || 0),\n            drmInfos: commonDrmInfos,\n            allowedByApplication: true,\n            allowedByKeySystem: true,\n            decodingInfos: [],\n          });\n        }\n      }\n    }\n\n    this.variants_ = variants;\n  }\n\n  /**\n   * @param {!Array.<shaka.util.PeriodCombiner.Period>} periods\n   * @private\n   */\n  static filterOutAudioStreamDuplicates_(periods) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n    // Two audio streams are considered to be duplicates of\n    // one another if their ids are different, but all the other\n    // information is the same.\n    for (const period of periods) {\n      const filteredAudios = [];\n      for (const a1 of period.audioStreams) {\n        let duplicate = false;\n        for (const a2 of filteredAudios) {\n          if (a1.id != a2.id &&\n              a1.channelsCount == a2.channelsCount &&\n              a1.language == a2.language &&\n              a1.bandwidth == a2.bandwidth &&\n              a1.label == a2.label &&\n              a1.codecs == a2.codecs &&\n              a1.mimeType == a2.mimeType &&\n              ArrayUtils.hasSameElements(a1.roles, a2.roles) &&\n              a1.audioSamplingRate == a2.audioSamplingRate &&\n              a1.primary == a2.primary) {\n            duplicate = true;\n          }\n        }\n\n        if (!duplicate) {\n          filteredAudios.push(a1);\n        }\n      }\n\n      period.audioStreams = filteredAudios;\n    }\n  }\n\n  /**\n   * @param {!Array.<shaka.util.PeriodCombiner.Period>} periods\n   * @private\n   */\n  static filterOutTextStreamDuplicates_(periods) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n    // Two text streams are considered to be duplicates of\n    // one another if their ids are different, but all the other\n    // information is the same.\n    for (const period of periods) {\n      const filteredTexts = [];\n      for (const t1 of period.textStreams) {\n        let duplicate = false;\n        for (const t2 of filteredTexts) {\n          if (t1.id != t2.id &&\n            t1.language == t2.language &&\n            t1.label == t2.label &&\n            t1.codecs == t2.codecs &&\n            t1.mimeType == t2.mimeType &&\n            t1.bandwidth == t2.bandwidth &&\n            ArrayUtils.hasSameElements(t1.roles, t2.roles)) {\n            duplicate = true;\n          }\n        }\n\n        if (!duplicate) {\n          filteredTexts.push(t1);\n        }\n      }\n\n      period.textStreams = filteredTexts;\n    }\n  }\n\n  /**\n   * @param {!Array.<shaka.util.PeriodCombiner.Period>} periods\n   * @private\n   */\n  static filterOutVideoStreamDuplicates_(periods) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n    const MapUtils = shaka.util.MapUtils;\n    // Two video streams are considered to be duplicates of\n    // one another if their ids are different, but all the other\n    // information is the same.\n    for (const period of periods) {\n      const filteredVideos = [];\n      for (const v1 of period.videoStreams) {\n        let duplicate = false;\n        for (const v2 of filteredVideos) {\n          if (v1.id != v2.id &&\n              v1.width == v2.width &&\n              v1.frameRate == v2.frameRate &&\n              v1.codecs == v2.codecs &&\n              v1.mimeType == v2.mimeType &&\n              v1.label == v2.label &&\n              ArrayUtils.hasSameElements(v1.roles, v2.roles) &&\n              MapUtils.hasSameElements(v1.closedCaptions, v2.closedCaptions) &&\n              v1.bandwidth == v2.bandwidth) {\n            duplicate = true;\n          }\n        }\n\n        if (!duplicate) {\n          filteredVideos.push(v1);\n        }\n      }\n\n      period.videoStreams = filteredVideos;\n    }\n  }\n\n  /**\n   * @param {!Array.<shaka.util.PeriodCombiner.Period>} periods\n   * @private\n   */\n  static filterOutImageStreamDuplicates_(periods) {\n    // Two image streams are considered to be duplicates of\n    // one another if their ids are different, but all the other\n    // information is the same.\n    for (const period of periods) {\n      const filteredImages = [];\n      for (const i1 of period.imageStreams) {\n        let duplicate = false;\n        for (const i2 of filteredImages) {\n          if (i1.id != i2.id &&\n              i1.width == i2.width &&\n              i1.codecs == i2.codecs &&\n              i1.mimeType == i2.mimeType) {\n            duplicate = true;\n          }\n        }\n\n        if (!duplicate) {\n          filteredImages.push(i1);\n        }\n      }\n\n      period.imageStreams = filteredImages;\n    }\n  }\n\n  /**\n   * Stitch together DB streams across periods, taking a mix of stream types.\n   * The offline database does not separate these by type.\n   *\n   * Unlike the DASH case, this does not need to maintain any state for manifest\n   * updates.\n   *\n   * @param {!Array.<!Array.<shaka.extern.StreamDB>>} streamDbsPerPeriod\n   * @return {!Promise.<!Array.<shaka.extern.StreamDB>>}\n   */\n  static async combineDbStreams(streamDbsPerPeriod) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    // Optimization: for single-period content, do nothing.  This makes sure\n    // single-period DASH or any HLS content stored offline will be 100%\n    // accurately represented in the output.\n    if (streamDbsPerPeriod.length == 1) {\n      return streamDbsPerPeriod[0];\n    }\n\n    const audioStreamDbsPerPeriod = streamDbsPerPeriod.map(\n        (streams) => streams.filter((s) => s.type == ContentType.AUDIO));\n    const videoStreamDbsPerPeriod = streamDbsPerPeriod.map(\n        (streams) => streams.filter((s) => s.type == ContentType.VIDEO));\n    const textStreamDbsPerPeriod = streamDbsPerPeriod.map(\n        (streams) => streams.filter((s) => s.type == ContentType.TEXT));\n    const imageStreamDbsPerPeriod = streamDbsPerPeriod.map(\n        (streams) => streams.filter((s) => s.type == ContentType.IMAGE));\n\n    // It's okay to have a period with no text or images, but our algorithm\n    // fails on any period without matching streams.  So we add dummy streams to\n    // each period.  Since we combine text streams by language and image streams\n    // by resolution, we might need a dummy even in periods with these streams\n    // already.\n    for (const textStreams of textStreamDbsPerPeriod) {\n      textStreams.push(shaka.util.PeriodCombiner.dummyStreamDB_(\n          ContentType.TEXT));\n    }\n    for (const imageStreams of imageStreamDbsPerPeriod) {\n      imageStreams.push(shaka.util.PeriodCombiner.dummyStreamDB_(\n          ContentType.IMAGE));\n    }\n\n    const combinedAudioStreamDbs = await shaka.util.PeriodCombiner.combine_(\n        /* outputStreams= */ [],\n        audioStreamDbsPerPeriod,\n        /* firstNewPeriodIndex= */ 0,\n        shaka.util.PeriodCombiner.cloneStreamDB_,\n        shaka.util.PeriodCombiner.concatenateStreamDBs_);\n\n    const combinedVideoStreamDbs = await shaka.util.PeriodCombiner.combine_(\n        /* outputStreams= */ [],\n        videoStreamDbsPerPeriod,\n        /* firstNewPeriodIndex= */ 0,\n        shaka.util.PeriodCombiner.cloneStreamDB_,\n        shaka.util.PeriodCombiner.concatenateStreamDBs_);\n\n    const combinedTextStreamDbs = await shaka.util.PeriodCombiner.combine_(\n        /* outputStreams= */ [],\n        textStreamDbsPerPeriod,\n        /* firstNewPeriodIndex= */ 0,\n        shaka.util.PeriodCombiner.cloneStreamDB_,\n        shaka.util.PeriodCombiner.concatenateStreamDBs_);\n\n    const combinedImageStreamDbs = await shaka.util.PeriodCombiner.combine_(\n        /* outputStreams= */ [],\n        imageStreamDbsPerPeriod,\n        /* firstNewPeriodIndex= */ 0,\n        shaka.util.PeriodCombiner.cloneStreamDB_,\n        shaka.util.PeriodCombiner.concatenateStreamDBs_);\n\n    // Recreate variantIds from scratch in the output.\n    // HLS content is always single-period, so the early return at the top of\n    // this method would catch all HLS content.  DASH content stored with v3.0\n    // will already be flattened before storage.  Therefore the only content\n    // that reaches this point is multi-period DASH content stored before v3.0.\n    // Such content always had variants generated from all combinations of audio\n    // and video, so we can simply do that now without loss of correctness.\n    let nextVariantId = 0;\n    if (!combinedVideoStreamDbs.length || !combinedAudioStreamDbs.length) {\n      // For audio-only or video-only content, just give each stream its own\n      // variant ID.\n      const combinedStreamDbs =\n          combinedVideoStreamDbs.concat(combinedAudioStreamDbs);\n      for (const stream of combinedStreamDbs) {\n        stream.variantIds = [nextVariantId++];\n      }\n    } else {\n      for (const audio of combinedAudioStreamDbs) {\n        for (const video of combinedVideoStreamDbs) {\n          const id = nextVariantId++;\n          video.variantIds.push(id);\n          audio.variantIds.push(id);\n        }\n      }\n    }\n\n    return combinedVideoStreamDbs\n        .concat(combinedAudioStreamDbs)\n        .concat(combinedTextStreamDbs)\n        .concat(combinedImageStreamDbs);\n  }\n\n  /**\n   * Combine input Streams per period into flat output Streams.\n   * Templatized to handle both DASH Streams and offline StreamDBs.\n   *\n   * @param {!Array.<T>} outputStreams A list of existing output streams, to\n   *   facilitate updates for live DASH content.  Will be modified and returned.\n   * @param {!Array.<!Array.<T>>} streamsPerPeriod A list of lists of Streams\n   *   from each period.\n   * @param {number} firstNewPeriodIndex An index into streamsPerPeriod which\n   *   represents the first new period that hasn't been processed yet.\n   * @param {function(T):T} clone Make a clone of an input stream.\n   * @param {function(T, T)} concat Concatenate the second stream onto the end\n   *   of the first.\n   *\n   * @return {!Promise.<!Array.<T>>} The same array passed to outputStreams,\n   *   modified to include any newly-created streams.\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static async combine_(\n      outputStreams, streamsPerPeriod, firstNewPeriodIndex, clone, concat) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const unusedStreamsPerPeriod = [];\n    for (let i = 0; i < streamsPerPeriod.length; i++) {\n      if (i >= firstNewPeriodIndex) {\n        // This periods streams are all new.\n        unusedStreamsPerPeriod.push(new Set(streamsPerPeriod[i]));\n      } else {\n        // This period's streams have all been used already.\n        unusedStreamsPerPeriod.push(new Set());\n      }\n    }\n\n    // First, extend all existing output Streams into the new periods.\n    for (const outputStream of outputStreams) {\n      // eslint-disable-next-line no-await-in-loop\n      const ok = await shaka.util.PeriodCombiner.extendExistingOutputStream_(\n          outputStream, streamsPerPeriod, firstNewPeriodIndex, concat,\n          unusedStreamsPerPeriod);\n      if (!ok) {\n        // This output Stream was not properly extended to include streams from\n        // the new period.  This is likely a bug in our algorithm, so throw an\n        // error.\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.PERIOD_FLATTENING_FAILED);\n      }\n\n      // This output stream is now complete with content from all known\n      // periods.\n    }  // for (const outputStream of outputStreams)\n\n    for (const unusedStreams of unusedStreamsPerPeriod) {\n      for (const stream of unusedStreams) {\n        // Create a new output stream which includes this input stream.\n        const outputStream =\n            shaka.util.PeriodCombiner.createNewOutputStream_(\n                stream, streamsPerPeriod, clone, concat,\n                unusedStreamsPerPeriod);\n        if (outputStream) {\n          outputStreams.push(outputStream);\n        } else {\n          // This is not a stream we can build output from, but it may become\n          // part of another output based on another period's stream.\n        }\n      }  // for (const stream of unusedStreams)\n    }  // for (const unusedStreams of unusedStreamsPerPeriod)\n\n    for (const unusedStreams of unusedStreamsPerPeriod) {\n      for (const stream of unusedStreams) {\n        const isDummyText = stream.type == ContentType.TEXT && !stream.language;\n        const isDummyImage = stream.type == ContentType.IMAGE &&\n            !stream.tilesLayout;\n        if (isDummyText || isDummyImage) {\n          // This is one of our dummy streams, so ignore it.  We may not use\n          // them all, and that's fine.\n          continue;\n        }\n        // If this stream has a different codec/MIME than any other stream,\n        // then we can't play it.\n        // TODO(#1528): Consider changing this when we support codec switching.\n        const hasCodec = outputStreams.some((s) => {\n          return s.mimeType == stream.mimeType &&\n                shaka.util.MimeUtils.getNormalizedCodec(s.codecs) ==\n                    shaka.util.MimeUtils.getNormalizedCodec(stream.codecs);\n        });\n        if (!hasCodec) {\n          continue;\n        }\n\n        // Any other unused stream is likely a bug in our algorithm, so throw\n        // an error.\n        shaka.log.error('Unused stream in period-flattening!',\n            stream, outputStreams);\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.PERIOD_FLATTENING_FAILED);\n      }\n    }\n\n    return outputStreams;\n  }\n\n  /**\n   * @param {T} outputStream An existing output stream which needs to be\n   *   extended into new periods.\n   * @param {!Array.<!Array.<T>>} streamsPerPeriod A list of lists of Streams\n   *   from each period.\n   * @param {number} firstNewPeriodIndex An index into streamsPerPeriod which\n   *   represents the first new period that hasn't been processed yet.\n   * @param {function(T, T)} concat Concatenate the second stream onto the end\n   *   of the first.\n   * @param {!Array.<!Set.<T>>} unusedStreamsPerPeriod An array of sets of\n   *   unused streams from each period.\n   *\n   * @return {!Promise.<boolean>}\n   *\n   * @template T\n   * Should only be called with a Stream type in practice, but has call sites\n   * from other templated functions that also accept a StreamDB.\n   *\n   * @private\n   */\n  static async extendExistingOutputStream_(\n      outputStream, streamsPerPeriod, firstNewPeriodIndex, concat,\n      unusedStreamsPerPeriod) {\n    shaka.util.PeriodCombiner.findMatchesInAllPeriods_(streamsPerPeriod,\n        outputStream);\n\n    // This only exists where T == Stream, and this should only ever be called\n    // on Stream types.  StreamDB should not have pre-existing output streams.\n    goog.asserts.assert(outputStream.createSegmentIndex,\n        'outputStream should be a Stream type!');\n\n    if (!outputStream.matchedStreams) {\n      // We were unable to extend this output stream.\n      shaka.log.error('No matches extending output stream!',\n          outputStream, streamsPerPeriod);\n      return false;\n    }\n    // We need to create all the per-period segment indexes and append them to\n    // the output's MetaSegmentIndex.\n    if (outputStream.segmentIndex) {\n      await shaka.util.PeriodCombiner.extendOutputSegmentIndex_(outputStream,\n          firstNewPeriodIndex);\n    }\n\n    shaka.util.PeriodCombiner.extendOutputStream_(outputStream,\n        firstNewPeriodIndex, concat, unusedStreamsPerPeriod);\n    return true;\n  }\n\n  /**\n   * Creates the segment indexes for an array of input streams, and append them\n   * to the output stream's segment index.\n   *\n   * @param {shaka.extern.Stream} outputStream\n   * @param {number} firstNewPeriodIndex An index into streamsPerPeriod which\n   *   represents the first new period that hasn't been processed yet.\n   * @private\n   */\n  static async extendOutputSegmentIndex_(outputStream, firstNewPeriodIndex) {\n    const operations = [];\n    const streams = outputStream.matchedStreams;\n    goog.asserts.assert(streams, 'matched streams should be valid');\n\n    for (const stream of streams) {\n      operations.push(stream.createSegmentIndex());\n      if (stream.trickModeVideo && !stream.trickModeVideo.segmentIndex) {\n        operations.push(stream.trickModeVideo.createSegmentIndex());\n      }\n    }\n    await Promise.all(operations);\n\n    // Concatenate the new matches onto the stream, starting at the first new\n    // period.\n    // Satisfy the compiler about the type.\n    // Also checks if the segmentIndex is still valid after the async\n    // operations, to make sure we stop if the active stream has changed.\n    if (outputStream.segmentIndex instanceof shaka.media.MetaSegmentIndex) {\n      for (let i = firstNewPeriodIndex; i < streams.length; i++) {\n        const match = streams[i];\n        goog.asserts.assert(match.segmentIndex,\n            'stream should have a segmentIndex.');\n        if (match.segmentIndex) {\n          outputStream.segmentIndex.appendSegmentIndex(match.segmentIndex);\n        }\n      }\n    }\n  }\n\n  /**\n   * Create a new output Stream based on a particular input Stream.  Locates\n   * matching Streams in all other periods and combines them into an output\n   * Stream.\n   * Templatized to handle both DASH Streams and offline StreamDBs.\n   *\n   * @param {T} stream An input stream on which to base the output stream.\n   * @param {!Array.<!Array.<T>>} streamsPerPeriod A list of lists of Streams\n   *   from each period.\n   * @param {function(T):T} clone Make a clone of an input stream.\n   * @param {function(T, T)} concat Concatenate the second stream onto the end\n   *   of the first.\n   * @param {!Array.<!Set.<T>>} unusedStreamsPerPeriod An array of sets of\n   *   unused streams from each period.\n   *\n   * @return {?T} A newly-created output Stream, or null if matches\n   *   could not be found.`\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static createNewOutputStream_(\n      stream, streamsPerPeriod, clone, concat, unusedStreamsPerPeriod) {\n    // Start by cloning the stream without segments, key IDs, etc.\n    const outputStream = clone(stream);\n\n    // Find best-matching streams in all periods.\n    shaka.util.PeriodCombiner.findMatchesInAllPeriods_(streamsPerPeriod,\n        outputStream);\n\n    // This only exists where T == Stream.\n    if (outputStream.createSegmentIndex) {\n      // Override the createSegmentIndex function of the outputStream.\n      outputStream.createSegmentIndex = async () => {\n        if (!outputStream.segmentIndex) {\n          outputStream.segmentIndex = new shaka.media.MetaSegmentIndex();\n          await shaka.util.PeriodCombiner.extendOutputSegmentIndex_(\n              outputStream, /* firstNewPeriodIndex= */ 0);\n        }\n      };\n      // For T == Stream, we need to create all the per-period segment indexes\n      // in advance.  concat() will add them to the output's MetaSegmentIndex.\n    }\n\n    if (!outputStream.matchedStreams || !outputStream.matchedStreams.length) {\n      // This is not a stream we can build output from, but it may become part\n      // of another output based on another period's stream.\n      return null;\n    }\n    shaka.util.PeriodCombiner.extendOutputStream_(outputStream,\n        /* firstNewPeriodIndex= */ 0, concat, unusedStreamsPerPeriod);\n\n    return outputStream;\n  }\n\n  /**\n   * @param {T} outputStream An existing output stream which needs to be\n   *   extended into new periods.\n   * @param {number} firstNewPeriodIndex An index into streamsPerPeriod which\n   *   represents the first new period that hasn't been processed yet.\n   * @param {function(T, T)} concat Concatenate the second stream onto the end\n   *   of the first.\n   * @param {!Array.<!Set.<T>>} unusedStreamsPerPeriod An array of sets of\n   *   unused streams from each period.\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static extendOutputStream_(\n      outputStream, firstNewPeriodIndex, concat, unusedStreamsPerPeriod) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const LanguageUtils = shaka.util.LanguageUtils;\n    const matches = outputStream.matchedStreams;\n\n    // Assure the compiler that matches didn't become null during the async\n    // operation before.\n    goog.asserts.assert(outputStream.matchedStreams,\n        'matchedStreams should be non-null');\n\n    // Concatenate the new matches onto the stream, starting at the first new\n    // period.\n    for (let i = 0; i < matches.length; i++) {\n      if (i >= firstNewPeriodIndex) {\n        const match = matches[i];\n        concat(outputStream, match);\n\n        // We only consider an audio stream \"used\" if its language is related to\n        // the output language.  There are scenarios where we want to generate\n        // separate tracks for each language, even when we are forced to connect\n        // unrelated languages across periods.\n        let used = true;\n        if (outputStream.type == ContentType.AUDIO) {\n          const relatedness = LanguageUtils.relatedness(\n              outputStream.language, match.language);\n          if (relatedness == 0) {\n            used = false;\n          }\n        }\n\n        if (used) {\n          unusedStreamsPerPeriod[i].delete(match);\n        }\n      }\n    }\n  }\n\n  /**\n   * Clone a Stream to make an output Stream for combining others across\n   * periods.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {shaka.extern.Stream}\n   * @private\n   */\n  static cloneStream_(stream) {\n    const clone = /** @type {shaka.extern.Stream} */(Object.assign({}, stream));\n\n    // These are wiped out now and rebuilt later from the various per-period\n    // streams that match this output.\n    clone.originalId = null;\n    clone.createSegmentIndex = () => Promise.resolve();\n    clone.closeSegmentIndex = () => {\n      if (clone.segmentIndex) {\n        clone.segmentIndex.release();\n        clone.segmentIndex = null;\n      }\n      // Close the segment index of the matched streams.\n      if (clone.matchedStreams) {\n        for (const match of clone.matchedStreams) {\n          if (match.segmentIndex) {\n            match.segmentIndex.release();\n            match.segmentIndex = null;\n          }\n        }\n      }\n    };\n\n    clone.segmentIndex = null;\n    clone.emsgSchemeIdUris = [];\n    clone.keyIds = new Set();\n    clone.closedCaptions = null;\n    clone.trickModeVideo = null;\n\n    return clone;\n  }\n\n  /**\n   * Clone a StreamDB to make an output stream for combining others across\n   * periods.\n   *\n   * @param {shaka.extern.StreamDB} streamDb\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  static cloneStreamDB_(streamDb) {\n    const clone = /** @type {shaka.extern.StreamDB} */(Object.assign(\n        {}, streamDb));\n\n    // These are wiped out now and rebuilt later from the various per-period\n    // streams that match this output.\n    clone.keyIds = new Set();\n    clone.segments = [];\n    clone.variantIds = [];\n    clone.closedCaptions = null;\n\n    return clone;\n  }\n\n  /**\n   * Combine the various fields of the input Stream into the output.\n   *\n   * @param {shaka.extern.Stream} output\n   * @param {shaka.extern.Stream} input\n   * @private\n   */\n  static concatenateStreams_(output, input) {\n    // We keep the original stream's bandwidth, resolution, frame rate,\n    // sample rate, and channel count to ensure that it's properly\n    // matched with similar content in other periods further down\n    // the line.\n\n    // Combine arrays, keeping only the unique elements\n    const combineArrays = (a, b) => Array.from(new Set(a.concat(b)));\n    output.roles = combineArrays(output.roles, input.roles);\n\n    if (input.emsgSchemeIdUris) {\n      output.emsgSchemeIdUris = combineArrays(\n          output.emsgSchemeIdUris, input.emsgSchemeIdUris);\n    }\n\n    const combineSets = (a, b) => new Set([...a, ...b]);\n    output.keyIds = combineSets(output.keyIds, input.keyIds);\n\n    if (output.originalId == null) {\n      output.originalId = input.originalId;\n    } else {\n      output.originalId += ',' + (input.originalId || '');\n    }\n\n    const commonDrmInfos = shaka.media.DrmEngine.getCommonDrmInfos(\n        output.drmInfos, input.drmInfos);\n    if (input.drmInfos.length && output.drmInfos.length &&\n        !commonDrmInfos.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.INCONSISTENT_DRM_ACROSS_PERIODS);\n    }\n    output.drmInfos = commonDrmInfos;\n\n    // The output is encrypted if any input was encrypted.\n    output.encrypted = output.encrypted || input.encrypted;\n\n    // Combine the closed captions maps.\n    if (input.closedCaptions) {\n      if (!output.closedCaptions) {\n        output.closedCaptions = new Map();\n      }\n      for (const [key, value] of input.closedCaptions) {\n        output.closedCaptions.set(key, value);\n      }\n    }\n\n    // Combine trick-play video streams, if present.\n    if (input.trickModeVideo) {\n      if (!output.trickModeVideo) {\n        // Create a fresh output stream for trick-mode playback.\n        output.trickModeVideo = shaka.util.PeriodCombiner.cloneStream_(\n            input.trickModeVideo);\n        // TODO: fix the createSegmentIndex function for trickModeVideo.\n        // The trick-mode tracks in multi-period content should have trick-mode\n        // segment indexes whenever available, rather than only regular-mode\n        // segment indexes.\n        output.trickModeVideo.createSegmentIndex = () => {\n          // Satisfy the compiler about the type.\n          goog.asserts.assert(\n              output.segmentIndex instanceof shaka.media.MetaSegmentIndex,\n              'The stream should have a MetaSegmentIndex.');\n          output.trickModeVideo.segmentIndex = output.segmentIndex.clone();\n          return Promise.resolve();\n        };\n      }\n\n      // Concatenate the trick mode input onto the trick mode output.\n      shaka.util.PeriodCombiner.concatenateStreams_(\n          output.trickModeVideo, input.trickModeVideo);\n    } else if (output.trickModeVideo) {\n      // We have a trick mode output, but no input from this Period.  Fill it in\n      // from the standard input Stream.\n      shaka.util.PeriodCombiner.concatenateStreams_(\n          output.trickModeVideo, input);\n    }\n  }\n\n  /**\n   * Combine the various fields of the input StreamDB into the output.\n   *\n   * @param {shaka.extern.StreamDB} output\n   * @param {shaka.extern.StreamDB} input\n   * @private\n   */\n  static concatenateStreamDBs_(output, input) {\n    // Combine arrays, keeping only the unique elements\n    const combineArrays = (a, b) => Array.from(new Set(a.concat(b)));\n    output.roles = combineArrays(output.roles, input.roles);\n\n    const combineSets = (a, b) => new Set([...a, ...b]);\n    output.keyIds = combineSets(output.keyIds, input.keyIds);\n\n    // The output is encrypted if any input was encrypted.\n    output.encrypted = output.encrypted && input.encrypted;\n\n    // Concatenate segments without de-duping.\n    output.segments.push(...input.segments);\n\n    // Combine the closed captions maps.\n    if (input.closedCaptions) {\n      if (!output.closedCaptions) {\n        output.closedCaptions = new Map();\n      }\n      for (const [key, value] of input.closedCaptions) {\n        output.closedCaptions.set(key, value);\n      }\n    }\n  }\n\n  /**\n   * Finds streams in all periods which match the output stream.\n   *\n   * @param {!Array.<!Array.<T>>} streamsPerPeriod\n   * @param {T} outputStream\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static findMatchesInAllPeriods_(streamsPerPeriod, outputStream) {\n    const matches = [];\n    for (const streams of streamsPerPeriod) {\n      const match = shaka.util.PeriodCombiner.findBestMatchInPeriod_(\n          streams, outputStream);\n      if (!match) {\n        return;\n      }\n      matches.push(match);\n    }\n    outputStream.matchedStreams = matches;\n  }\n\n  /**\n   * Find the best match for the output stream.\n   *\n   * @param {!Array.<T>} streams\n   * @param {T} outputStream\n   * @return {?T}  Returns null if no match can be found.\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static findBestMatchInPeriod_(streams, outputStream) {\n    const areCompatible = {\n      'audio': shaka.util.PeriodCombiner.areAVStreamsCompatible_,\n      'video': shaka.util.PeriodCombiner.areAVStreamsCompatible_,\n      'text': shaka.util.PeriodCombiner.areTextStreamsCompatible_,\n      'image': shaka.util.PeriodCombiner.areImageStreamsCompatible_,\n    }[outputStream.type];\n\n    const isBetterMatch = {\n      'audio': shaka.util.PeriodCombiner.isAudioStreamBetterMatch_,\n      'video': shaka.util.PeriodCombiner.isVideoStreamBetterMatch_,\n      'text': shaka.util.PeriodCombiner.isTextStreamBetterMatch_,\n      'image': shaka.util.PeriodCombiner.isImageStreamBetterMatch_,\n    }[outputStream.type];\n\n    let best = null;\n\n    for (const stream of streams) {\n      if (!areCompatible(outputStream, stream)) {\n        continue;\n      }\n\n      if (!best || isBetterMatch(outputStream, best, stream)) {\n        best = stream;\n      }\n    }\n\n    return best;\n  }\n\n  /**\n   * @param {T} outputStream An audio or video output stream\n   * @param {T} candidate A candidate stream to be combined with the output\n   * @return {boolean} True if the candidate could be combined with the\n   *   output stream\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static areAVStreamsCompatible_(outputStream, candidate) {\n    const getCodec = (codecs) =>\n      shaka.util.MimeUtils.getNormalizedCodec(codecs);\n    // Check MIME type and codecs, which should always be the same.\n    if (candidate.mimeType != outputStream.mimeType ||\n        getCodec(candidate.codecs) != getCodec(outputStream.codecs)) {\n      return false;\n    }\n\n    // This field is only available on Stream, not StreamDB.\n    if (outputStream.drmInfos) {\n      // Check for compatible DRM systems.  Note that clear streams are\n      // implicitly compatible with any DRM and with each other.\n      if (!shaka.media.DrmEngine.areDrmCompatible(outputStream.drmInfos,\n          candidate.drmInfos)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {T} outputStream A text output stream\n   * @param {T} candidate A candidate stream to be combined with the output\n   * @return {boolean} True if the candidate could be combined with the\n   *   output\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static areTextStreamsCompatible_(outputStream, candidate) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // For text, we don't care about MIME type or codec.  We can always switch\n    // between text types.\n\n    // The output stream should not be a dummy stream inserted to fill a period\n    // gap.  So reject any candidate if the output has no language.  This would\n    // cause findMatchesInAllPeriods_ to return null and this output stream to\n    // be skipped (meaning no output streams based on it).\n    if (!outputStream.language) {\n      return false;\n    }\n\n    // If the candidate is a dummy, then it is compatible, and we could use it\n    // if nothing else matches.\n    if (!candidate.language) {\n      return true;\n    }\n\n    const languageRelatedness = LanguageUtils.relatedness(\n        outputStream.language, candidate.language);\n\n    // We will strictly avoid combining text across languages or \"kinds\"\n    // (caption vs subtitle).\n    if (languageRelatedness == 0 ||\n        candidate.kind != outputStream.kind) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {T} outputStream A image output stream\n   * @param {T} candidate A candidate stream to be combined with the output\n   * @return {boolean} True if the candidate could be combined with the\n   *   output\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static areImageStreamsCompatible_(outputStream, candidate) {\n    // For image, we don't care about MIME type.  We can always switch\n    // between image types.\n\n    // The output stream should not be a dummy stream inserted to fill a period\n    // gap.  So reject any candidate if the output has no tilesLayout.  This\n    // would cause findMatchesInAllPeriods_ to return null and this output\n    // stream to be skipped (meaning no output streams based on it).\n    if (!outputStream.tilesLayout) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {T} outputStream An audio output stream\n   * @param {T} best The best match so far for this period\n   * @param {T} candidate A candidate stream which might be better\n   * @return {boolean} True if the candidate is a better match\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static isAudioStreamBetterMatch_(outputStream, best, candidate) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n    const {BETTER, EQUAL, WORSE} = shaka.util.PeriodCombiner.BetterOrWorse;\n\n    // If the output stream was based on the candidate stream, the candidate\n    // stream should be considered a better match. We can check this by\n    // comparing their ids.\n    if (outputStream.id == candidate.id) {\n      return true;\n    }\n\n    // Otherwise, compare the streams' characteristics to determine the best\n    // match.\n\n    // The most important thing is language.  In some cases, we will accept a\n    // different language across periods when we must.\n    const bestRelatedness = LanguageUtils.relatedness(\n        outputStream.language, best.language);\n    const candidateRelatedness = LanguageUtils.relatedness(\n        outputStream.language, candidate.language);\n\n    if (candidateRelatedness > bestRelatedness) {\n      return true;\n    }\n    if (candidateRelatedness < bestRelatedness) {\n      return false;\n    }\n\n    // If language-based differences haven't decided this, look at roles.  If\n    // the candidate has more roles in common with the output, upgrade to the\n    // candidate.\n    if (outputStream.roles.length) {\n      const bestRoleMatches =\n          best.roles.filter((role) => outputStream.roles.includes(role));\n      const candidateRoleMatches =\n          candidate.roles.filter((role) => outputStream.roles.includes(role));\n      if (candidateRoleMatches.length > bestRoleMatches.length) {\n        return true;\n      } else if (candidateRoleMatches.length < bestRoleMatches.length) {\n        return false;\n      } else {\n        // Both streams have the same role overlap with the outputStream\n        // If this is the case, choose the stream with the fewer roles overall.\n        // Streams that match best together tend to be streams with the same\n        // roles, e g stream1 with roles [r1, r2] is likely a better match\n        // for stream2 with roles [r1, r2] vs stream3 with roles\n        // [r1, r2, r3, r4].\n        // If we match stream1 with stream3 due to the same role overlap,\n        // stream2 is likely to be left unmatched and error out later.\n        // See https://github.com/shaka-project/shaka-player/issues/2542 for\n        // more details.\n        return candidate.roles.length < best.roles.length;\n      }\n    } else if (!candidate.roles.length && best.roles.length) {\n      // If outputStream has no roles, and only one of the streams has no roles,\n      // choose the one with no roles.\n      return true;\n    } else if (candidate.roles.length && !best.roles.length) {\n      return false;\n    }\n\n    // If the language doesn't match, but the candidate is the \"primary\"\n    // language, then that should be preferred as a fallback.\n    if (!best.primary && candidate.primary) {\n      return true;\n    }\n    if (best.primary && !candidate.primary) {\n      return false;\n    }\n\n    // If language-based and role-based features are equivalent, take the audio\n    // with the closes channel count to the output.\n    const channelsBetterOrWorse =\n        shaka.util.PeriodCombiner.compareClosestPreferLower(\n            outputStream.channelsCount,\n            best.channelsCount,\n            candidate.channelsCount);\n    if (channelsBetterOrWorse == BETTER) {\n      return true;\n    } else if (channelsBetterOrWorse == WORSE) {\n      return false;\n    }\n\n    // If channels are equal, take the closest sample rate to the output.\n    const sampleRateBetterOrWorse =\n        shaka.util.PeriodCombiner.compareClosestPreferLower(\n            outputStream.audioSamplingRate,\n            best.audioSamplingRate,\n            candidate.audioSamplingRate);\n    if (sampleRateBetterOrWorse == BETTER) {\n      return true;\n    } else if (sampleRateBetterOrWorse == WORSE) {\n      return false;\n    }\n\n    if (outputStream.bandwidth) {\n      // Take the audio with the closest bandwidth to the output.\n      const bandwidthBetterOrWorse =\n          shaka.util.PeriodCombiner.compareClosestPreferMinimalAbsDiff_(\n              outputStream.bandwidth,\n              best.bandwidth,\n              candidate.bandwidth);\n      if (bandwidthBetterOrWorse == BETTER) {\n        return true;\n      } else if (bandwidthBetterOrWorse == WORSE) {\n        return false;\n      }\n    }\n\n    // If the result of each comparison was inconclusive, default to false.\n    return false;\n  }\n\n  /**\n   * @param {T} outputStream A video output stream\n   * @param {T} best The best match so far for this period\n   * @param {T} candidate A candidate stream which might be better\n   * @return {boolean} True if the candidate is a better match\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static isVideoStreamBetterMatch_(outputStream, best, candidate) {\n    const {BETTER, EQUAL, WORSE} = shaka.util.PeriodCombiner.BetterOrWorse;\n\n    // If the output stream was based on the candidate stream, the candidate\n    // stream should be considered a better match. We can check this by\n    // comparing their ids.\n    if (outputStream.id == candidate.id) {\n      return true;\n    }\n\n    // Otherwise, compare the streams' characteristics to determine the best\n    // match.\n\n    // Take the video with the closest resolution to the output.\n    const resolutionBetterOrWorse =\n        shaka.util.PeriodCombiner.compareClosestPreferLower(\n            outputStream.width * outputStream.height,\n            best.width * best.height,\n            candidate.width * candidate.height);\n    if (resolutionBetterOrWorse == BETTER) {\n      return true;\n    } else if (resolutionBetterOrWorse == WORSE) {\n      return false;\n    }\n\n    // We may not know the frame rate for the content, in which case this gets\n    // skipped.\n    if (outputStream.frameRate) {\n      // Take the video with the closest frame rate to the output.\n      const frameRateBetterOrWorse =\n          shaka.util.PeriodCombiner.compareClosestPreferLower(\n              outputStream.frameRate,\n              best.frameRate,\n              candidate.frameRate);\n      if (frameRateBetterOrWorse == BETTER) {\n        return true;\n      } else if (frameRateBetterOrWorse == WORSE) {\n        return false;\n      }\n    }\n\n\n    if (outputStream.bandwidth) {\n      // Take the video with the closest bandwidth to the output.\n      const bandwidthBetterOrWorse =\n          shaka.util.PeriodCombiner.compareClosestPreferMinimalAbsDiff_(\n              outputStream.bandwidth,\n              best.bandwidth,\n              candidate.bandwidth);\n      if (bandwidthBetterOrWorse == BETTER) {\n        return true;\n      } else if (bandwidthBetterOrWorse == WORSE) {\n        return false;\n      }\n    }\n\n    // If the result of each comparison was inconclusive, default to false.\n    return false;\n  }\n\n  /**\n   * @param {T} outputStream A text output stream\n   * @param {T} best The best match so far for this period\n   * @param {T} candidate A candidate stream which might be better\n   * @return {boolean} True if the candidate is a better match\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static isTextStreamBetterMatch_(outputStream, best, candidate) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // If the output stream was based on the candidate stream, the candidate\n    // stream should be considered a better match. We can check this by\n    // comparing their ids.\n    if (outputStream.id == candidate.id) {\n      return true;\n    }\n\n    // Otherwise, compare the streams' characteristics to determine the best\n    // match.\n\n    // The most important thing is language.  In some cases, we will accept a\n    // different language across periods when we must.\n    const bestRelatedness = LanguageUtils.relatedness(\n        outputStream.language, best.language);\n    const candidateRelatedness = LanguageUtils.relatedness(\n        outputStream.language, candidate.language);\n\n    if (candidateRelatedness > bestRelatedness) {\n      return true;\n    }\n    if (candidateRelatedness < bestRelatedness) {\n      return false;\n    }\n\n    // If the language doesn't match, but the candidate is the \"primary\"\n    // language, then that should be preferred as a fallback.\n    if (!best.primary && candidate.primary) {\n      return true;\n    }\n    if (best.primary && !candidate.primary) {\n      return false;\n    }\n\n    // If the candidate has more roles in common with the output, upgrade to the\n    // candidate.\n    if (outputStream.roles.length) {\n      const bestRoleMatches =\n          best.roles.filter((role) => outputStream.roles.includes(role));\n      const candidateRoleMatches =\n          candidate.roles.filter((role) => outputStream.roles.includes(role));\n      if (candidateRoleMatches.length > bestRoleMatches.length) {\n        return true;\n      }\n      if (candidateRoleMatches.length < bestRoleMatches.length) {\n        return false;\n      }\n    } else if (!candidate.roles.length && best.roles.length) {\n      // If outputStream has no roles, and only one of the streams has no roles,\n      // choose the one with no roles.\n      return true;\n    } else if (candidate.roles.length && !best.roles.length) {\n      return false;\n    }\n\n    // If the candidate has the same MIME type and codec, upgrade to the\n    // candidate.  It's not required that text streams use the same format\n    // across periods, but it's a helpful signal.  Some content in our demo app\n    // contains the same languages repeated with two different text formats in\n    // each period.  This condition ensures that all text streams are used.\n    // Otherwise, we wind up with some one stream of each language left unused,\n    // triggering a failure.\n    if (candidate.mimeType == outputStream.mimeType &&\n        candidate.codecs == outputStream.codecs &&\n        (best.mimeType != outputStream.mimeType ||\n         best.codecs != outputStream.codecs)) {\n      return true;\n    }\n\n    // If the result of each comparison was inconclusive, default to false.\n    return false;\n  }\n\n  /**\n   * @param {T} outputStream A image output stream\n   * @param {T} best The best match so far for this period\n   * @param {T} candidate A candidate stream which might be better\n   * @return {boolean} True if the candidate is a better match\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static isImageStreamBetterMatch_(outputStream, best, candidate) {\n    const {BETTER, EQUAL, WORSE} = shaka.util.PeriodCombiner.BetterOrWorse;\n\n    // If the output stream was based on the candidate stream, the candidate\n    // stream should be considered a better match. We can check this by\n    // comparing their ids.\n    if (outputStream.id == candidate.id) {\n      return true;\n    }\n\n    // Take the image with the closest resolution to the output.\n    const resolutionBetterOrWorse =\n        shaka.util.PeriodCombiner.compareClosestPreferLower(\n            outputStream.width * outputStream.height,\n            best.width * best.height,\n            candidate.width * candidate.height);\n    if (resolutionBetterOrWorse == BETTER) {\n      return true;\n    } else if (resolutionBetterOrWorse == WORSE) {\n      return false;\n    }\n\n    // If the result of each comparison was inconclusive, default to false.\n    return false;\n  }\n\n  /**\n   * Create a dummy StreamDB to fill in periods that are missing a certain type,\n   * to avoid failing the general flattening algorithm.  This won't be used for\n   * audio or video, since those are strictly required in all periods if they\n   * exist in any period.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} type\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  static dummyStreamDB_(type) {\n    return {\n      id: 0,\n      originalId: '',\n      primary: false,\n      type,\n      mimeType: '',\n      codecs: '',\n      language: '',\n      label: null,\n      width: null,\n      height: null,\n      encrypted: false,\n      keyIds: new Set(),\n      segments: [],\n      variantIds: [],\n      roles: [],\n      forced: false,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      closedCaptions: null,\n    };\n  }\n\n  /**\n   * Create a dummy Stream to fill in periods that are missing a certain type,\n   * to avoid failing the general flattening algorithm.  This won't be used for\n   * audio or video, since those are strictly required in all periods if they\n   * exist in any period.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} type\n   * @return {shaka.extern.Stream}\n   * @private\n   */\n  static dummyStream_(type) {\n    return {\n      id: 0,\n      originalId: '',\n      createSegmentIndex: () => Promise.resolve(),\n      segmentIndex: new shaka.media.SegmentIndex([]),\n      mimeType: '',\n      codecs: '',\n      encrypted: false,\n      drmInfos: [],\n      keyIds: new Set(),\n      language: '',\n      label: null,\n      type,\n      primary: false,\n      trickModeVideo: null,\n      emsgSchemeIdUris: null,\n      roles: [],\n      forced: false,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      closedCaptions: null,\n    };\n  }\n\n  /**\n   * Compare the best value so far with the candidate value and the output\n   * value.  Decide if the candidate is better, equal, or worse than the best\n   * so far.  Any value less than or equal to the output is preferred over a\n   * larger value, and closer to the output is better than farther.\n   *\n   * This provides us a generic way to choose things that should match as\n   * closely as possible, like resolution, frame rate, audio channels, or\n   * sample rate.  If we have to go higher to make a match, we will.  But if\n   * the user selects 480p, for example, we don't want to surprise them with\n   * 720p and waste bandwidth if there's another choice available to us.\n   *\n   * @param {number} outputValue\n   * @param {number} bestValue\n   * @param {number} candidateValue\n   * @return {shaka.util.PeriodCombiner.BetterOrWorse}\n   */\n  static compareClosestPreferLower(outputValue, bestValue, candidateValue) {\n    const {BETTER, EQUAL, WORSE} = shaka.util.PeriodCombiner.BetterOrWorse;\n\n    // If one is the exact match for the output value, and the other isn't,\n    // prefer the one that is the exact match.\n    if (bestValue == outputValue && outputValue != candidateValue) {\n      return WORSE;\n    } else if (candidateValue == outputValue && outputValue != bestValue) {\n      return BETTER;\n    }\n\n    if (bestValue > outputValue) {\n      if (candidateValue <= outputValue) {\n        // Any smaller-or-equal-to-output value is preferable to a\n        // bigger-than-output value.\n        return BETTER;\n      }\n\n      // Both \"best\" and \"candidate\" are greater than the output.  Take\n      // whichever is closer.\n      if (candidateValue - outputValue < bestValue - outputValue) {\n        return BETTER;\n      } else if (candidateValue - outputValue > bestValue - outputValue) {\n        return WORSE;\n      }\n    } else {\n      // The \"best\" so far is less than or equal to the output.  If the\n      // candidate is bigger than the output, we don't want it.\n      if (candidateValue > outputValue) {\n        return WORSE;\n      }\n\n      // Both \"best\" and \"candidate\" are less than or equal to the output.\n      // Take whichever is closer.\n      if (outputValue - candidateValue < outputValue - bestValue) {\n        return BETTER;\n      } else if (outputValue - candidateValue > outputValue - bestValue) {\n        return WORSE;\n      }\n    }\n\n    return EQUAL;\n  }\n\n  /**\n   * @param {number} outputValue\n   * @param {number} bestValue\n   * @param {number} candidateValue\n   * @return {shaka.util.PeriodCombiner.BetterOrWorse}\n   * @private\n   */\n  static compareClosestPreferMinimalAbsDiff_(\n      outputValue, bestValue, candidateValue) {\n    const {BETTER, EQUAL, WORSE} = shaka.util.PeriodCombiner.BetterOrWorse;\n\n    const absDiffBest = Math.abs(outputValue - bestValue);\n    const absDiffCandidate = Math.abs(outputValue - candidateValue);\n    if (absDiffCandidate < absDiffBest) {\n      return BETTER;\n    } else if (absDiffBest < absDiffCandidate) {\n      return WORSE;\n    }\n\n    return EQUAL;\n  }\n};\n\n/**\n * @typedef {{\n *   id: string,\n *   audioStreams: !Array.<shaka.extern.Stream>,\n *   videoStreams: !Array.<shaka.extern.Stream>,\n *   textStreams: !Array.<shaka.extern.Stream>,\n *   imageStreams: !Array.<shaka.extern.Stream>\n * }}\n *\n * @description Contains the streams from one DASH period.\n *\n * @property {string} id\n *   The Period ID.\n * @property {!Array.<shaka.extern.Stream>} audioStreams\n *   The audio streams from one Period.\n * @property {!Array.<shaka.extern.Stream>} videoStreams\n *   The video streams from one Period.\n * @property {!Array.<shaka.extern.Stream>} textStreams\n *   The text streams from one Period.\n * @property {!Array.<shaka.extern.Stream>} imageStreams\n *   The image streams from one Period.\n */\nshaka.util.PeriodCombiner.Period;\n\n/**\n * @enum {number}\n */\nshaka.util.PeriodCombiner.BetterOrWorse = {\n  BETTER: 1,\n  EQUAL: 0,\n  WORSE: -1,\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.DashParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.abr.Ewma');\ngoog.require('shaka.dash.ContentProtection');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.dash.SegmentBase');\ngoog.require('shaka.dash.SegmentList');\ngoog.require('shaka.dash.SegmentTemplate');\ngoog.require('shaka.log');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.CmcdManager');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Networking');\ngoog.require('shaka.util.OperationManager');\ngoog.require('shaka.util.PeriodCombiner');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Timer');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * Creates a new DASH parser.\n *\n * @implements {shaka.extern.ManifestParser}\n * @export\n */\nshaka.dash.DashParser = class {\n  /** Creates a new DASH parser. */\n  constructor() {\n    /** @private {?shaka.extern.ManifestConfiguration} */\n    this.config_ = null;\n\n    /** @private {?shaka.extern.ManifestParser.PlayerInterface} */\n    this.playerInterface_ = null;\n\n    /** @private {!Array.<string>} */\n    this.manifestUris_ = [];\n\n    /** @private {?shaka.extern.Manifest} */\n    this.manifest_ = null;\n\n    /** @private {number} */\n    this.globalId_ = 1;\n\n    /**\n     * A map of IDs to Stream objects.\n     * ID: Period@id,AdaptationSet@id,@Representation@id\n     * e.g.: '1,5,23'\n     * @private {!Object.<string, !shaka.extern.Stream>}\n     */\n    this.streamMap_ = {};\n\n    /**\n     * A map of period ids to their durations\n     * @private {!Object.<string, number>}\n     */\n    this.periodDurations_ = {};\n\n    /** @private {shaka.util.PeriodCombiner} */\n    this.periodCombiner_ = new shaka.util.PeriodCombiner();\n\n    /**\n     * The update period in seconds, or 0 for no updates.\n     * @private {number}\n     */\n    this.updatePeriod_ = 0;\n\n    /**\n     * An ewma that tracks how long updates take.\n     * This is to mitigate issues caused by slow parsing on embedded devices.\n     * @private {!shaka.abr.Ewma}\n     */\n    this.averageUpdateDuration_ = new shaka.abr.Ewma(5);\n\n    /** @private {shaka.util.Timer} */\n    this.updateTimer_ = new shaka.util.Timer(() => {\n      this.onUpdate_();\n    });\n\n    /** @private {!shaka.util.OperationManager} */\n    this.operationManager_ = new shaka.util.OperationManager();\n\n    /**\n     * Largest period start time seen.\n     * @private {?number}\n     */\n    this.largestPeriodStartTime_ = null;\n\n    /**\n     * Period IDs seen in previous manifest.\n     * @private {!Array.<string>}\n     */\n    this.lastManifestUpdatePeriodIds_ = [];\n\n    /**\n     * The minimum of the availabilityTimeOffset values among the adaptation\n     * sets.\n     * @private {number}\n     */\n    this.minTotalAvailabilityTimeOffset_ = Infinity;\n\n    /** @private {boolean} */\n    this.lowLatencyMode_ = false;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  configure(config) {\n    goog.asserts.assert(config.dash != null,\n        'DashManifestConfiguration should not be null!');\n\n    this.config_ = config;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  async start(uri, playerInterface) {\n    goog.asserts.assert(this.config_, 'Must call configure() before start()!');\n    this.lowLatencyMode_ = playerInterface.isLowLatencyMode();\n    this.manifestUris_ = [uri];\n    this.playerInterface_ = playerInterface;\n\n    const updateDelay = await this.requestManifest_();\n\n    if (this.playerInterface_) {\n      this.setUpdateTimer_(updateDelay);\n    }\n\n    // Make sure that the parser has not been destroyed.\n    if (!this.playerInterface_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED);\n    }\n\n    goog.asserts.assert(this.manifest_, 'Manifest should be non-null!');\n    return this.manifest_;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  stop() {\n    // When the parser stops, release all segment indexes, which stops their\n    // timers, as well.\n    for (const stream of Object.values(this.streamMap_)) {\n      if (stream.segmentIndex) {\n        stream.segmentIndex.release();\n      }\n    }\n\n    if (this.periodCombiner_) {\n      this.periodCombiner_.release();\n    }\n\n    this.playerInterface_ = null;\n    this.config_ = null;\n    this.manifestUris_ = [];\n    this.manifest_ = null;\n    this.streamMap_ = {};\n    this.periodCombiner_ = null;\n\n    if (this.updateTimer_ != null) {\n      this.updateTimer_.stop();\n      this.updateTimer_ = null;\n    }\n\n    return this.operationManager_.destroy();\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  async update() {\n    try {\n      await this.requestManifest_();\n    } catch (error) {\n      if (!this.playerInterface_ || !error) {\n        return;\n      }\n      goog.asserts.assert(error instanceof shaka.util.Error, 'Bad error type');\n      this.playerInterface_.onError(error);\n    }\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  onExpirationUpdated(sessionId, expiration) {\n    // No-op\n  }\n\n  /**\n   * Makes a network request for the manifest and parses the resulting data.\n   *\n   * @return {!Promise.<number>} Resolves with the time it took, in seconds, to\n   *   fulfill the request and parse the data.\n   * @private\n   */\n  async requestManifest_() {\n    const requestType = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        this.manifestUris_, this.config_.retryParameters);\n    const networkingEngine = this.playerInterface_.networkingEngine;\n\n    const format = shaka.util.CmcdManager.StreamingFormat.DASH;\n    this.playerInterface_.modifyManifestRequest(request, {format: format});\n\n    const startTime = Date.now();\n    const operation = networkingEngine.request(requestType, request);\n    this.operationManager_.manage(operation);\n\n    const response = await operation.promise;\n\n    // Detect calls to stop().\n    if (!this.playerInterface_) {\n      return 0;\n    }\n\n    // For redirections add the response uri to the first entry in the\n    // Manifest Uris array.\n    if (response.uri && !this.manifestUris_.includes(response.uri)) {\n      this.manifestUris_.unshift(response.uri);\n    }\n\n    // This may throw, but it will result in a failed promise.\n    await this.parseManifest_(response.data, response.uri);\n    // Keep track of how long the longest manifest update took.\n    const endTime = Date.now();\n    const updateDuration = (endTime - startTime) / 1000.0;\n    this.averageUpdateDuration_.sample(1, updateDuration);\n\n    // Let the caller know how long this update took.\n    return updateDuration;\n  }\n\n  /**\n   * Parses the manifest XML.  This also handles updates and will update the\n   * stored manifest.\n   *\n   * @param {BufferSource} data\n   * @param {string} finalManifestUri The final manifest URI, which may\n   *   differ from this.manifestUri_ if there has been a redirect.\n   * @return {!Promise}\n   * @private\n   */\n  async parseManifest_(data, finalManifestUri) {\n    const Error = shaka.util.Error;\n    const MpdUtils = shaka.dash.MpdUtils;\n\n    const mpd = shaka.util.XmlUtils.parseXml(data, 'MPD');\n    if (!mpd) {\n      throw new Error(\n          Error.Severity.CRITICAL, Error.Category.MANIFEST,\n          Error.Code.DASH_INVALID_XML, finalManifestUri);\n    }\n    const disableXlinkProcessing = this.config_.dash.disableXlinkProcessing;\n    if (disableXlinkProcessing) {\n      return this.processManifest_(mpd, finalManifestUri);\n    }\n\n    // Process the mpd to account for xlink connections.\n    const failGracefully = this.config_.dash.xlinkFailGracefully;\n    const xlinkOperation = MpdUtils.processXlinks(\n        mpd, this.config_.retryParameters, failGracefully, finalManifestUri,\n        this.playerInterface_.networkingEngine);\n    this.operationManager_.manage(xlinkOperation);\n    const finalMpd = await xlinkOperation.promise;\n    return this.processManifest_(finalMpd, finalManifestUri);\n  }\n\n\n  /**\n   * Takes a formatted MPD and converts it into a manifest.\n   *\n   * @param {!Element} mpd\n   * @param {string} finalManifestUri The final manifest URI, which may\n   *   differ from this.manifestUri_ if there has been a redirect.\n   * @return {!Promise}\n   * @private\n   */\n  async processManifest_(mpd, finalManifestUri) {\n    const Functional = shaka.util.Functional;\n    const XmlUtils = shaka.util.XmlUtils;\n\n    const manifestPreprocessor = this.config_.dash.manifestPreprocessor;\n    if (manifestPreprocessor) {\n      manifestPreprocessor(mpd);\n    }\n\n    // Get any Location elements.  This will update the manifest location and\n    // the base URI.\n    /** @type {!Array.<string>} */\n    let manifestBaseUris = [finalManifestUri];\n    /** @type {!Array.<string>} */\n    const locations = XmlUtils.findChildren(mpd, 'Location')\n        .map(XmlUtils.getContents)\n        .filter(Functional.isNotNull);\n    if (locations.length > 0) {\n      const absoluteLocations = shaka.util.ManifestParserUtils.resolveUris(\n          manifestBaseUris, locations);\n      this.manifestUris_ = absoluteLocations;\n      manifestBaseUris = absoluteLocations;\n    }\n\n    const uriObjs = XmlUtils.findChildren(mpd, 'BaseURL');\n    const uris = uriObjs.map(XmlUtils.getContents);\n    const baseUris = shaka.util.ManifestParserUtils.resolveUris(\n        manifestBaseUris, uris);\n\n    let availabilityTimeOffset = 0;\n    if (uriObjs && uriObjs.length) {\n      availabilityTimeOffset = XmlUtils.parseAttr(\n          uriObjs[0], 'availabilityTimeOffset', XmlUtils.parseFloat) || 0;\n    }\n\n    const ignoreMinBufferTime = this.config_.dash.ignoreMinBufferTime;\n    let minBufferTime = 0;\n    if (!ignoreMinBufferTime) {\n      minBufferTime =\n          XmlUtils.parseAttr(mpd, 'minBufferTime', XmlUtils.parseDuration) || 0;\n    }\n\n    this.updatePeriod_ = /** @type {number} */ (XmlUtils.parseAttr(\n        mpd, 'minimumUpdatePeriod', XmlUtils.parseDuration, -1));\n\n    const presentationStartTime = XmlUtils.parseAttr(\n        mpd, 'availabilityStartTime', XmlUtils.parseDate);\n    let segmentAvailabilityDuration = XmlUtils.parseAttr(\n        mpd, 'timeShiftBufferDepth', XmlUtils.parseDuration);\n\n    const ignoreSuggestedPresentationDelay =\n      this.config_.dash.ignoreSuggestedPresentationDelay;\n    let suggestedPresentationDelay = null;\n    if (!ignoreSuggestedPresentationDelay) {\n      suggestedPresentationDelay = XmlUtils.parseAttr(\n          mpd, 'suggestedPresentationDelay', XmlUtils.parseDuration);\n    }\n\n    const ignoreMaxSegmentDuration =\n        this.config_.dash.ignoreMaxSegmentDuration;\n    let maxSegmentDuration = null;\n    if (!ignoreMaxSegmentDuration) {\n      maxSegmentDuration = XmlUtils.parseAttr(\n          mpd, 'maxSegmentDuration', XmlUtils.parseDuration);\n    }\n    const mpdType = mpd.getAttribute('type') || 'static';\n\n    /** @type {!shaka.media.PresentationTimeline} */\n    let presentationTimeline;\n    if (this.manifest_) {\n      presentationTimeline = this.manifest_.presentationTimeline;\n\n      // Before processing an update, evict from all segment indexes.  Some of\n      // them may not get updated otherwise if their corresponding Period\n      // element has been dropped from the manifest since the last update.\n      // Without this, playback will still work, but this is necessary to\n      // maintain conditions that we assert on for multi-Period content.\n      // This gives us confidence that our state is maintained correctly, and\n      // that the complex logic of multi-Period eviction and period-flattening\n      // is correct.  See also:\n      // https://github.com/shaka-project/shaka-player/issues/3169#issuecomment-823580634\n      for (const stream of Object.values(this.streamMap_)) {\n        if (stream.segmentIndex) {\n          stream.segmentIndex.evict(\n              presentationTimeline.getSegmentAvailabilityStart());\n        }\n      }\n    } else {\n      // DASH IOP v3.0 suggests using a default delay between minBufferTime\n      // and timeShiftBufferDepth.  This is literally the range of all\n      // feasible choices for the value.  Nothing older than\n      // timeShiftBufferDepth is still available, and anything less than\n      // minBufferTime will cause buffering issues.\n      //\n      // We have decided that our default will be the configured value, or\n      // 1.5 * minBufferTime if not configured. This is fairly conservative.\n      // Content providers should provide a suggestedPresentationDelay whenever\n      // possible to optimize the live streaming experience.\n      const defaultPresentationDelay =\n          this.config_.defaultPresentationDelay || minBufferTime * 1.5;\n      const presentationDelay = suggestedPresentationDelay != null ?\n          suggestedPresentationDelay : defaultPresentationDelay;\n      presentationTimeline = new shaka.media.PresentationTimeline(\n          presentationStartTime, presentationDelay,\n          this.config_.dash.autoCorrectDrift);\n    }\n\n    presentationTimeline.setStatic(mpdType == 'static');\n\n    const isLive = presentationTimeline.isLive();\n\n    // If it's live, we check for an override.\n    if (isLive && !isNaN(this.config_.availabilityWindowOverride)) {\n      segmentAvailabilityDuration = this.config_.availabilityWindowOverride;\n    }\n\n    // If it's null, that means segments are always available.  This is always\n    // the case for VOD, and sometimes the case for live.\n    if (segmentAvailabilityDuration == null) {\n      segmentAvailabilityDuration = Infinity;\n    }\n\n    presentationTimeline.setSegmentAvailabilityDuration(\n        segmentAvailabilityDuration);\n\n    const profiles = mpd.getAttribute('profiles') || '';\n\n    /** @type {shaka.dash.DashParser.Context} */\n    const context = {\n      // Don't base on updatePeriod_ since emsg boxes can cause manifest\n      // updates.\n      dynamic: mpdType != 'static',\n      presentationTimeline: presentationTimeline,\n      period: null,\n      periodInfo: null,\n      adaptationSet: null,\n      representation: null,\n      bandwidth: 0,\n      indexRangeWarningGiven: false,\n      availabilityTimeOffset: availabilityTimeOffset,\n      profiles: profiles.split(','),\n    };\n\n    const periodsAndDuration = this.parsePeriods_(context, baseUris, mpd);\n    const duration = periodsAndDuration.duration;\n    const periods = periodsAndDuration.periods;\n\n    if (mpdType == 'static' ||\n        !periodsAndDuration.durationDerivedFromPeriods) {\n      // Ignore duration calculated from Period lengths if this is dynamic.\n      presentationTimeline.setDuration(duration || Infinity);\n    }\n\n    // The segments are available earlier than the availability start time.\n    // If the stream is low latency and the user has not configured the\n    // lowLatencyMode, but if it has been configured to activate the\n    // lowLatencyMode if a stream of this type is detected, we automatically\n    // activate the lowLatencyMode.\n    if (this.minTotalAvailabilityTimeOffset_ && !this.lowLatencyMode_) {\n      const autoLowLatencyMode = this.playerInterface_.isAutoLowLatencyMode();\n      if (autoLowLatencyMode) {\n        this.playerInterface_.enableLowLatencyMode();\n        this.lowLatencyMode_ = this.playerInterface_.isLowLatencyMode();\n      }\n    }\n\n    if (this.lowLatencyMode_) {\n      presentationTimeline.setAvailabilityTimeOffset(\n          this.minTotalAvailabilityTimeOffset_);\n    } else if (this.minTotalAvailabilityTimeOffset_) {\n      // If the playlist contains AvailabilityTimeOffset value, the\n      // streaming.lowLatencyMode value should be set to true to stream with low\n      // latency mode.\n      shaka.log.alwaysWarn('Low-latency DASH live stream detected, but ' +\n        'low-latency streaming mode is not enabled in Shaka Player. ' +\n        'Set streaming.lowLatencyMode configuration to true, and see ' +\n        'https://bit.ly/3clctcj for details.');\n    }\n\n    // Use @maxSegmentDuration to override smaller, derived values.\n    presentationTimeline.notifyMaxSegmentDuration(maxSegmentDuration || 1);\n    if (goog.DEBUG) {\n      presentationTimeline.assertIsValid();\n    }\n\n    await this.periodCombiner_.combinePeriods(periods, context.dynamic);\n\n    // These steps are not done on manifest update.\n    if (!this.manifest_) {\n      this.manifest_ = {\n        presentationTimeline: presentationTimeline,\n        variants: this.periodCombiner_.getVariants(),\n        textStreams: this.periodCombiner_.getTextStreams(),\n        imageStreams: this.periodCombiner_.getImageStreams(),\n        offlineSessionIds: [],\n        minBufferTime: minBufferTime || 0,\n      };\n\n      // We only need to do clock sync when we're using presentation start\n      // time. This condition also excludes VOD streams.\n      if (presentationTimeline.usingPresentationStartTime()) {\n        const XmlUtils = shaka.util.XmlUtils;\n        const timingElements = XmlUtils.findChildren(mpd, 'UTCTiming');\n        const offset = await this.parseUtcTiming_(baseUris, timingElements);\n        // Detect calls to stop().\n        if (!this.playerInterface_) {\n          return;\n        }\n        presentationTimeline.setClockOffset(offset);\n      }\n\n      // This is the first point where we have a meaningful presentation start\n      // time, and we need to tell PresentationTimeline that so that it can\n      // maintain consistency from here on.\n      presentationTimeline.lockStartTime();\n    } else {\n      // Just update the variants and text streams, which may change as periods\n      // are added or removed.\n      this.manifest_.variants = this.periodCombiner_.getVariants();\n      this.manifest_.textStreams = this.periodCombiner_.getTextStreams();\n      this.manifest_.imageStreams = this.periodCombiner_.getImageStreams();\n\n      // Re-filter the manifest.  This will check any configured restrictions on\n      // new variants, and will pass any new init data to DrmEngine to ensure\n      // that key rotation works correctly.\n      this.playerInterface_.filter(this.manifest_);\n    }\n\n    // Add text streams to correspond to closed captions.  This happens right\n    // after period combining, while we still have a direct reference, so that\n    // any new streams will appear in the period combiner.\n    this.playerInterface_.makeTextStreamsForClosedCaptions(this.manifest_);\n  }\n\n  /**\n   * Reads and parses the periods from the manifest.  This first does some\n   * partial parsing so the start and duration is available when parsing\n   * children.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {!Array.<string>} baseUris\n   * @param {!Element} mpd\n   * @return {{\n   *   periods: !Array.<shaka.util.PeriodCombiner.Period>,\n   *   duration: ?number,\n   *   durationDerivedFromPeriods: boolean\n   * }}\n   * @private\n   */\n  parsePeriods_(context, baseUris, mpd) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const presentationDuration = XmlUtils.parseAttr(\n        mpd, 'mediaPresentationDuration', XmlUtils.parseDuration);\n\n    const periods = [];\n    let prevEnd = 0;\n    const periodNodes = XmlUtils.findChildren(mpd, 'Period');\n    for (let i = 0; i < periodNodes.length; i++) {\n      const elem = periodNodes[i];\n      const next = periodNodes[i + 1];\n      const start = /** @type {number} */ (\n        XmlUtils.parseAttr(elem, 'start', XmlUtils.parseDuration, prevEnd));\n      const periodId = elem.id;\n      const givenDuration =\n          XmlUtils.parseAttr(elem, 'duration', XmlUtils.parseDuration);\n\n      let periodDuration = null;\n      if (next) {\n        // \"The difference between the start time of a Period and the start time\n        // of the following Period is the duration of the media content\n        // represented by this Period.\"\n        const nextStart =\n            XmlUtils.parseAttr(next, 'start', XmlUtils.parseDuration);\n        if (nextStart != null) {\n          periodDuration = nextStart - start;\n        }\n      } else if (presentationDuration != null) {\n        // \"The Period extends until the Period.start of the next Period, or\n        // until the end of the Media Presentation in the case of the last\n        // Period.\"\n        periodDuration = presentationDuration - start;\n      }\n\n      const threshold =\n          shaka.util.ManifestParserUtils.GAP_OVERLAP_TOLERANCE_SECONDS;\n      if (periodDuration && givenDuration &&\n          Math.abs(periodDuration - givenDuration) > threshold) {\n        shaka.log.warning('There is a gap/overlap between Periods', elem);\n      }\n      // Only use the @duration in the MPD if we can't calculate it.  We should\n      // favor the @start of the following Period.  This ensures that there\n      // aren't gaps between Periods.\n      if (periodDuration == null) {\n        periodDuration = givenDuration;\n      }\n\n      /**\n       * This is to improve robustness when the player observes manifest with\n       * past periods that are inconsistent to previous ones.\n       *\n       * This may happen when a CDN or proxy server switches its upstream from\n       * one encoder to another redundant encoder.\n       *\n       * Skip periods that match all of the following criteria:\n       * - Start time is earlier than latest period start time ever seen\n       * - Period ID is never seen in the previous manifest\n       * - Not the last period in the manifest\n       *\n       * Periods that meet the aforementioned criteria are considered invalid\n       * and should be safe to discard.\n       */\n\n      if (this.largestPeriodStartTime_ !== null &&\n        periodId !== null && start !== null &&\n        start < this.largestPeriodStartTime_ &&\n        !this.lastManifestUpdatePeriodIds_.includes(periodId) &&\n        i + 1 != periodNodes.length) {\n        shaka.log.debug(\n            `Skipping Period with ID ${periodId} as its start time is smaller` +\n            ' than the largest period start time that has been seen, and ID ' +\n            'is unseen before');\n        continue;\n      }\n\n\n      // Save maximum period start time if it is the last period\n      if (start !== null &&\n        (this.largestPeriodStartTime_ === null ||\n          start > this.largestPeriodStartTime_)) {\n        this.largestPeriodStartTime_ = start;\n      }\n\n      // Parse child nodes.\n      const info = {\n        start: start,\n        duration: periodDuration,\n        node: elem,\n        isLastPeriod: periodDuration == null || !next,\n      };\n      const period = this.parsePeriod_(context, baseUris, info);\n      periods.push(period);\n\n      if (context.period.id && periodDuration) {\n        this.periodDurations_[context.period.id] = periodDuration;\n      }\n\n      if (periodDuration == null) {\n        if (next) {\n          // If the duration is still null and we aren't at the end, then we\n          // will skip any remaining periods.\n          shaka.log.warning(\n              'Skipping Period', i + 1, 'and any subsequent Periods:', 'Period',\n              i + 1, 'does not have a valid start time.', next);\n        }\n\n        // The duration is unknown, so the end is unknown.\n        prevEnd = null;\n        break;\n      }\n\n      prevEnd = start + periodDuration;\n    } // end of period parsing loop\n\n    // Replace previous seen periods with the current one.\n    this.lastManifestUpdatePeriodIds_ = periods.map((el) => el.id);\n\n    if (presentationDuration != null) {\n      if (prevEnd != presentationDuration) {\n        shaka.log.warning(\n            '@mediaPresentationDuration does not match the total duration of ',\n            'all Periods.');\n        // Assume @mediaPresentationDuration is correct.\n      }\n      return {\n        periods: periods,\n        duration: presentationDuration,\n        durationDerivedFromPeriods: false,\n      };\n    } else {\n      return {\n        periods: periods,\n        duration: prevEnd,\n        durationDerivedFromPeriods: true,\n      };\n    }\n  }\n\n  /**\n   * Parses a Period XML element.  Unlike the other parse methods, this is not\n   * given the Node; it is given a PeriodInfo structure.  Also, partial parsing\n   * was done before this was called so start and duration are valid.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {!Array.<string>} baseUris\n   * @param {shaka.dash.DashParser.PeriodInfo} periodInfo\n   * @return {shaka.util.PeriodCombiner.Period}\n   * @private\n   */\n  parsePeriod_(context, baseUris, periodInfo) {\n    const Functional = shaka.util.Functional;\n    const XmlUtils = shaka.util.XmlUtils;\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    context.period = this.createFrame_(periodInfo.node, null, baseUris);\n    context.periodInfo = periodInfo;\n    context.period.availabilityTimeOffset = context.availabilityTimeOffset;\n\n    // If the period doesn't have an ID, give it one based on its start time.\n    if (!context.period.id) {\n      shaka.log.info(\n          'No Period ID given for Period with start time ' + periodInfo.start +\n          ',  Assigning a default');\n      context.period.id = '__shaka_period_' + periodInfo.start;\n    }\n\n    const eventStreamNodes =\n        XmlUtils.findChildren(periodInfo.node, 'EventStream');\n    const availabilityStart =\n        context.presentationTimeline.getSegmentAvailabilityStart();\n\n    for (const node of eventStreamNodes) {\n      this.parseEventStream_(\n          periodInfo.start, periodInfo.duration, node, availabilityStart);\n    }\n\n    const adaptationSetNodes =\n        XmlUtils.findChildren(periodInfo.node, 'AdaptationSet');\n    const adaptationSets = adaptationSetNodes\n        .map((node) => this.parseAdaptationSet_(context, node))\n        .filter(Functional.isNotNull);\n\n    // For dynamic manifests, we use rep IDs internally, and they must be\n    // unique.\n    if (context.dynamic) {\n      const ids = [];\n      for (const set of adaptationSets) {\n        for (const id of set.representationIds) {\n          ids.push(id);\n        }\n      }\n\n      const uniqueIds = new Set(ids);\n\n      if (ids.length != uniqueIds.size) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.DASH_DUPLICATE_REPRESENTATION_ID);\n      }\n    }\n\n    const normalAdaptationSets = adaptationSets\n        .filter((as) => { return !as.trickModeFor; });\n\n    const trickModeAdaptationSets = adaptationSets\n        .filter((as) => { return as.trickModeFor; });\n\n    // Attach trick mode tracks to normal tracks.\n    for (const trickModeSet of trickModeAdaptationSets) {\n      const targetIds = trickModeSet.trickModeFor.split(' ');\n      for (const normalSet of normalAdaptationSets) {\n        if (targetIds.includes(normalSet.id)) {\n          for (const stream of normalSet.streams) {\n            // There may be multiple trick mode streams, but we do not\n            // currently support that.  Just choose one.\n            // TODO: https://github.com/shaka-project/shaka-player/issues/1528\n            stream.trickModeVideo = trickModeSet.streams.find((trickStream) =>\n              shaka.util.MimeUtils.getNormalizedCodec(stream.codecs) ==\n              shaka.util.MimeUtils.getNormalizedCodec(trickStream.codecs));\n          }\n        }\n      }\n    }\n\n    const audioSets = this.config_.disableAudio ? [] :\n        this.getSetsOfType_(normalAdaptationSets, ContentType.AUDIO);\n    const videoSets = this.config_.disableVideo ? [] :\n        this.getSetsOfType_(normalAdaptationSets, ContentType.VIDEO);\n    const textSets = this.config_.disableText ? [] :\n        this.getSetsOfType_(normalAdaptationSets, ContentType.TEXT);\n    const imageSets = this.config_.disableThumbnails ? [] :\n        this.getSetsOfType_(normalAdaptationSets, ContentType.IMAGE);\n\n    if (!videoSets.length && !audioSets.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_EMPTY_PERIOD);\n    }\n\n    const audioStreams = [];\n    for (const audioSet of audioSets) {\n      audioStreams.push(...audioSet.streams);\n    }\n\n    const videoStreams = [];\n    for (const videoSet of videoSets) {\n      videoStreams.push(...videoSet.streams);\n    }\n\n    const textStreams = [];\n    for (const textSet of textSets) {\n      textStreams.push(...textSet.streams);\n    }\n\n    const imageStreams = [];\n    for (const imageSet of imageSets) {\n      imageStreams.push(...imageSet.streams);\n    }\n\n    return {\n      id: context.period.id,\n      audioStreams,\n      videoStreams,\n      textStreams,\n      imageStreams,\n    };\n  }\n\n  /**\n   * @param {!Array.<!shaka.dash.DashParser.AdaptationInfo>} adaptationSets\n   * @param {string} type\n   * @return {!Array.<!shaka.dash.DashParser.AdaptationInfo>}\n   * @private\n   */\n  getSetsOfType_(adaptationSets, type) {\n    return adaptationSets.filter((as) => {\n      return as.contentType == type;\n    });\n  }\n\n  /**\n   * Parses an AdaptationSet XML element.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {!Element} elem The AdaptationSet element.\n   * @return {?shaka.dash.DashParser.AdaptationInfo}\n   * @private\n   */\n  parseAdaptationSet_(context, elem) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const Functional = shaka.util.Functional;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const ContentType = ManifestParserUtils.ContentType;\n    const ContentProtection = shaka.dash.ContentProtection;\n\n    context.adaptationSet = this.createFrame_(elem, context.period, null);\n\n    let main = false;\n    const roleElements = XmlUtils.findChildren(elem, 'Role');\n    const roleValues = roleElements.map((role) => {\n      return role.getAttribute('value');\n    }).filter(Functional.isNotNull);\n\n    // Default kind for text streams is 'subtitle' if unspecified in the\n    // manifest.\n    let kind = undefined;\n    const isText = context.adaptationSet.contentType == ContentType.TEXT;\n    if (isText) {\n      kind = ManifestParserUtils.TextStreamKind.SUBTITLE;\n    }\n\n    for (const roleElement of roleElements) {\n      const scheme = roleElement.getAttribute('schemeIdUri');\n      if (scheme == null || scheme == 'urn:mpeg:dash:role:2011') {\n        // These only apply for the given scheme, but allow them to be specified\n        // if there is no scheme specified.\n        // See: DASH section 5.8.5.5\n        const value = roleElement.getAttribute('value');\n        switch (value) {\n          case 'main':\n            main = true;\n            break;\n          case 'caption':\n          case 'subtitle':\n            kind = value;\n            break;\n        }\n      }\n    }\n\n    // Parallel for HLS VIDEO-RANGE as defined in DASH-IF IOP v4.3 6.2.5.1.\n    let videoRange;\n    const videoRangeScheme = 'urn:mpeg:mpegB:cicp:TransferCharacteristics';\n    const getVideoRangeFromTransferCharacteristicCICP = (cicp) => {\n      switch (cicp) {\n        case 1:\n        case 6:\n        case 13:\n        case 14:\n        case 15:\n          return 'SDR';\n        case 16:\n          return 'PQ';\n        case 18:\n          return 'HLG';\n      }\n      return undefined;\n    };\n\n    const essentialProperties =\n        XmlUtils.findChildren(elem, 'EssentialProperty');\n    // ID of real AdaptationSet if this is a trick mode set:\n    let trickModeFor = null;\n    let unrecognizedEssentialProperty = false;\n    for (const prop of essentialProperties) {\n      const schemeId = prop.getAttribute('schemeIdUri');\n      if (schemeId == 'http://dashif.org/guidelines/trickmode') {\n        trickModeFor = prop.getAttribute('value');\n      } else if (schemeId == videoRangeScheme) {\n        videoRange = getVideoRangeFromTransferCharacteristicCICP(\n            parseInt(prop.getAttribute('value'), 10),\n        );\n      } else {\n        unrecognizedEssentialProperty = true;\n      }\n    }\n\n    const supplementalProperties =\n        XmlUtils.findChildren(elem, 'SupplementalProperty');\n    for (const prop of supplementalProperties) {\n      const schemeId = prop.getAttribute('schemeIdUri');\n      if (schemeId == videoRangeScheme) {\n        videoRange = getVideoRangeFromTransferCharacteristicCICP(\n            parseInt(prop.getAttribute('value'), 10),\n        );\n      }\n    }\n\n    const accessibilities = XmlUtils.findChildren(elem, 'Accessibility');\n    const LanguageUtils = shaka.util.LanguageUtils;\n    const closedCaptions = new Map();\n    for (const prop of accessibilities) {\n      const schemeId = prop.getAttribute('schemeIdUri');\n      const value = prop.getAttribute('value');\n      if (schemeId == 'urn:scte:dash:cc:cea-608:2015' ) {\n        let channelId = 1;\n        if (value != null) {\n          const channelAssignments = value.split(';');\n          for (const captionStr of channelAssignments) {\n            let channel;\n            let language;\n            // Some closed caption descriptions have channel number and\n            // language (\"CC1=eng\") others may only have language (\"eng,spa\").\n            if (!captionStr.includes('=')) {\n              // When the channel assignemnts are not explicitly provided and\n              // there are only 2 values provided, it is highly likely that the\n              // assignments are CC1 and CC3 (most commonly used CC streams).\n              // Otherwise, cycle through all channels arbitrarily (CC1 - CC4)\n              // in order of provided langs.\n              channel = `CC${channelId}`;\n              if (channelAssignments.length == 2) {\n                channelId += 2;\n              } else {\n                channelId ++;\n              }\n              language = captionStr;\n            } else {\n              const channelAndLanguage = captionStr.split('=');\n              // The channel info can be '1' or 'CC1'.\n              // If the channel info only has channel number(like '1'), add 'CC'\n              // as prefix so that it can be a full channel id (like 'CC1').\n              channel = channelAndLanguage[0].startsWith('CC') ?\n                  channelAndLanguage[0] : `CC${channelAndLanguage[0]}`;\n\n              // 3 letters (ISO 639-2).  In b/187442669, we saw a blank string\n              // (CC2=;CC3=), so default to \"und\" (the code for \"undetermined\").\n              language = channelAndLanguage[1] || 'und';\n            }\n            closedCaptions.set(channel, LanguageUtils.normalize(language));\n          }\n        } else {\n          // If channel and language information has not been provided, assign\n          // 'CC1' as channel id and 'und' as language info.\n          closedCaptions.set('CC1', 'und');\n        }\n      } else if (schemeId == 'urn:scte:dash:cc:cea-708:2015') {\n        let serviceNumber = 1;\n        if (value != null) {\n          for (const captionStr of value.split(';')) {\n            let service;\n            let language;\n            // Similar to CEA-608, it is possible that service # assignments\n            // are not explicitly provided e.g. \"eng;deu;swe\" In this case,\n            // we just cycle through the services for each language one by one.\n            if (!captionStr.includes('=')) {\n              service = `svc${serviceNumber}`;\n              serviceNumber ++;\n              language = captionStr;\n            } else {\n            // Otherwise, CEA-708 caption values take the form \"\n            // 1=lang:eng;2=lang:deu\" i.e. serviceNumber=lang:threelettercode.\n              const serviceAndLanguage = captionStr.split('=');\n              service = `svc${serviceAndLanguage[0]}`;\n\n              // The language info can be different formats, lang:eng',\n              // or 'lang:eng,war:1,er:1'. Extract the language info.\n              language = serviceAndLanguage[1].split(',')[0].split(':').pop();\n            }\n            closedCaptions.set(service, LanguageUtils.normalize(language));\n          }\n        } else {\n          // If service and language information has not been provided, assign\n          // 'svc1' as service number and 'und' as language info.\n          closedCaptions.set('svc1', 'und');\n        }\n      } else if (schemeId == 'urn:mpeg:dash:role:2011') {\n        // See DASH IOP 3.9.2 Table 4.\n        if (value != null) {\n          roleValues.push(value);\n          if (value == 'captions') {\n            kind = ManifestParserUtils.TextStreamKind.CLOSED_CAPTION;\n          }\n        }\n      }\n    }\n\n    // According to DASH spec (2014) section 5.8.4.8, \"the successful processing\n    // of the descriptor is essential to properly use the information in the\n    // parent element\".  According to DASH IOP v3.3, section 3.3.4, \"if the\n    // scheme or the value\" for EssentialProperty is not recognized, \"the DASH\n    // client shall ignore the parent element.\"\n    if (unrecognizedEssentialProperty) {\n      // Stop parsing this AdaptationSet and let the caller filter out the\n      // nulls.\n      return null;\n    }\n\n    const contentProtectionElems =\n        XmlUtils.findChildren(elem, 'ContentProtection');\n    const contentProtection = ContentProtection.parseFromAdaptationSet(\n        contentProtectionElems,\n        this.config_.dash.ignoreDrmInfo,\n        this.config_.dash.keySystemsByURI);\n\n    const language =\n        shaka.util.LanguageUtils.normalize(elem.getAttribute('lang') || 'und');\n\n    // This attribute is currently non-standard, but it is supported by Kaltura.\n    let label = elem.getAttribute('label');\n\n    // See DASH IOP 4.3 here https://dashif.org/docs/DASH-IF-IOP-v4.3.pdf (page 35)\n    const labelElements = XmlUtils.findChildren(elem, 'Label');\n    if (labelElements && labelElements.length) {\n      // NOTE: Right now only one label field is supported.\n      const firstLabelElement = labelElements[0];\n      if (firstLabelElement.textContent) {\n        label = firstLabelElement.textContent;\n      }\n    }\n\n    // Parse Representations into Streams.\n    const representations = XmlUtils.findChildren(elem, 'Representation');\n    const streams = representations.map((representation) => {\n      const parsedRepresentation = this.parseRepresentation_(context,\n          contentProtection, kind, language, label, main, roleValues,\n          closedCaptions, representation);\n      if (parsedRepresentation) {\n        parsedRepresentation.hdr = parsedRepresentation.hdr || videoRange;\n      }\n      return parsedRepresentation;\n    }).filter((s) => !!s);\n\n    if (streams.length == 0) {\n      const isImage = context.adaptationSet.contentType == ContentType.IMAGE;\n      // Ignore empty AdaptationSets if ignoreEmptyAdaptationSet is true\n      // or they are for text/image content.\n      if (this.config_.dash.ignoreEmptyAdaptationSet || isText || isImage) {\n        return null;\n      }\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_EMPTY_ADAPTATION_SET);\n    }\n\n    // If AdaptationSet's type is unknown or is ambiguously \"application\",\n    // guess based on the information in the first stream.  If the attributes\n    // mimeType and codecs are split across levels, they will both be inherited\n    // down to the stream level by this point, so the stream will have all the\n    // necessary information.\n    if (!context.adaptationSet.contentType ||\n        context.adaptationSet.contentType == ContentType.APPLICATION) {\n      const mimeType = streams[0].mimeType;\n      const codecs = streams[0].codecs;\n      context.adaptationSet.contentType =\n          shaka.dash.DashParser.guessContentType_(mimeType, codecs);\n\n      for (const stream of streams) {\n        stream.type = context.adaptationSet.contentType;\n      }\n    }\n\n    for (const stream of streams) {\n      // Some DRM license providers require that we have a default\n      // key ID from the manifest in the wrapped license request.\n      // Thus, it should be put in drmInfo to be accessible to request filters.\n      for (const drmInfo of contentProtection.drmInfos) {\n        drmInfo.keyIds = drmInfo.keyIds && stream.keyIds ?\n            new Set([...drmInfo.keyIds, ...stream.keyIds]) :\n            drmInfo.keyIds || stream.keyIds;\n      }\n    }\n\n    const repIds = representations\n        .map((node) => { return node.getAttribute('id'); })\n        .filter(shaka.util.Functional.isNotNull);\n\n    return {\n      id: context.adaptationSet.id || ('__fake__' + this.globalId_++),\n      contentType: context.adaptationSet.contentType,\n      language: language,\n      main: main,\n      streams: streams,\n      drmInfos: contentProtection.drmInfos,\n      trickModeFor: trickModeFor,\n      representationIds: repIds,\n    };\n  }\n\n  /**\n   * Parses a Representation XML element.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.ContentProtection.Context} contentProtection\n   * @param {(string|undefined)} kind\n   * @param {string} language\n   * @param {string} label\n   * @param {boolean} isPrimary\n   * @param {!Array.<string>} roles\n   * @param {Map.<string, string>} closedCaptions\n   * @param {!Element} node\n   * @return {?shaka.extern.Stream} The Stream, or null when there is a\n   *   non-critical parsing error.\n   * @private\n   */\n  parseRepresentation_(context, contentProtection, kind, language, label,\n      isPrimary, roles, closedCaptions, node) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    context.representation =\n        this.createFrame_(node, context.adaptationSet, null);\n\n    this.minTotalAvailabilityTimeOffset_ =\n        Math.min(this.minTotalAvailabilityTimeOffset_,\n            context.representation.availabilityTimeOffset);\n\n    if (!this.verifyRepresentation_(context.representation)) {\n      shaka.log.warning('Skipping Representation', context.representation);\n      return null;\n    }\n    const periodStart = context.periodInfo.start;\n\n    // NOTE: bandwidth is a mandatory attribute according to the spec, and zero\n    // does not make sense in the DASH spec's bandwidth formulas.\n    // In some content, however, the attribute is missing or zero.\n    // To avoid NaN at the variant level on broken content, fall back to zero.\n    // https://github.com/shaka-project/shaka-player/issues/938#issuecomment-317278180\n    context.bandwidth =\n        XmlUtils.parseAttr(node, 'bandwidth', XmlUtils.parsePositiveInt) || 0;\n\n    /** @type {?shaka.dash.DashParser.StreamInfo} */\n    let streamInfo;\n\n    const contentType = context.representation.contentType;\n    const isText = contentType == ContentType.TEXT ||\n                   contentType == ContentType.APPLICATION;\n    const isImage = contentType == ContentType.IMAGE;\n\n    try {\n      const requestInitSegment = (uris, startByte, endByte) => {\n        return this.requestInitSegment_(uris, startByte, endByte);\n      };\n      if (context.representation.segmentBase) {\n        streamInfo = shaka.dash.SegmentBase.createStreamInfo(\n            context, requestInitSegment);\n      } else if (context.representation.segmentList) {\n        streamInfo = shaka.dash.SegmentList.createStreamInfo(\n            context, this.streamMap_);\n      } else if (context.representation.segmentTemplate) {\n        const hasManifest = !!this.manifest_;\n\n        streamInfo = shaka.dash.SegmentTemplate.createStreamInfo(\n            context, requestInitSegment, this.streamMap_, hasManifest,\n            this.config_.dash.initialSegmentLimit, this.periodDurations_);\n      } else {\n        goog.asserts.assert(isText,\n            'Must have Segment* with non-text streams.');\n\n        const baseUris = context.representation.baseUris;\n        const duration = context.periodInfo.duration || 0;\n        streamInfo = {\n          generateSegmentIndex: () => {\n            return Promise.resolve(shaka.media.SegmentIndex.forSingleSegment(\n                periodStart, duration, baseUris));\n          },\n        };\n      }\n    } catch (error) {\n      if ((isText || isImage) &&\n          error.code == shaka.util.Error.Code.DASH_NO_SEGMENT_INFO) {\n        // We will ignore any DASH_NO_SEGMENT_INFO errors for text/image\n        // streams.\n        return null;\n      }\n\n      // For anything else, re-throw.\n      throw error;\n    }\n\n    const contentProtectionElems =\n        XmlUtils.findChildren(node, 'ContentProtection');\n    const keyId = shaka.dash.ContentProtection.parseFromRepresentation(\n        contentProtectionElems, contentProtection,\n        this.config_.dash.ignoreDrmInfo,\n        this.config_.dash.keySystemsByURI);\n    const keyIds = new Set(keyId ? [keyId] : []);\n\n    // Detect the presence of E-AC3 JOC audio content, using DD+JOC signaling.\n    // See: ETSI TS 103 420 V1.2.1 (2018-10)\n    const supplementalPropertyElems =\n        XmlUtils.findChildren(node, 'SupplementalProperty');\n    const hasJoc = supplementalPropertyElems.some((element) => {\n      const expectedUri = 'tag:dolby.com,2018:dash:EC3_ExtensionType:2018';\n      const expectedValue = 'JOC';\n      return element.getAttribute('schemeIdUri') == expectedUri &&\n          element.getAttribute('value') == expectedValue;\n    });\n    let spatialAudio = false;\n    if (hasJoc) {\n      spatialAudio = true;\n    }\n\n    let forced = false;\n    if (isText) {\n      // See: https://github.com/shaka-project/shaka-player/issues/2122 and\n      // https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/165\n      forced = roles.includes('forced_subtitle') ||\n          roles.includes('forced-subtitle');\n    }\n\n    let tilesLayout;\n    if (isImage) {\n      const essentialPropertyElems =\n          XmlUtils.findChildren(node, 'EssentialProperty');\n      const thumbnailTileElem = essentialPropertyElems.find((element) => {\n        const expectedUris = [\n          'http://dashif.org/thumbnail_tile',\n          'http://dashif.org/guidelines/thumbnail_tile',\n        ];\n        return expectedUris.includes(element.getAttribute('schemeIdUri'));\n      });\n      if (thumbnailTileElem) {\n        tilesLayout = thumbnailTileElem.getAttribute('value');\n      }\n      // Filter image adaptation sets that has no tilesLayout.\n      if (!tilesLayout) {\n        return null;\n      }\n    }\n\n    let hdr;\n    const profiles = context.profiles;\n    const codecs = context.representation.codecs;\n\n    const hevcHDR = 'http://dashif.org/guidelines/dash-if-uhd#hevc-hdr-pq10';\n    if (profiles.includes(hevcHDR) && (codecs.includes('hvc1.2.4.L153.B0') ||\n        codecs.includes('hev1.2.4.L153.B0'))) {\n      hdr = 'PQ';\n    }\n\n    const contextId = context.representation.id ?\n        context.period.id + ',' + context.representation.id : '';\n\n    /** @type {shaka.extern.Stream} */\n    let stream;\n\n    if (contextId && this.streamMap_[contextId]) {\n      stream = this.streamMap_[contextId];\n    } else {\n      stream = {\n        id: this.globalId_++,\n        originalId: context.representation.id,\n        createSegmentIndex: () => Promise.resolve(),\n        closeSegmentIndex: () => {\n          if (stream.segmentIndex) {\n            stream.segmentIndex.release();\n            stream.segmentIndex = null;\n          }\n        },\n        segmentIndex: null,\n        mimeType: context.representation.mimeType,\n        codecs: context.representation.codecs,\n        frameRate: context.representation.frameRate,\n        pixelAspectRatio: context.representation.pixelAspectRatio,\n        bandwidth: context.bandwidth,\n        width: context.representation.width,\n        height: context.representation.height,\n        kind,\n        encrypted: contentProtection.drmInfos.length > 0,\n        drmInfos: contentProtection.drmInfos,\n        keyIds,\n        language,\n        label,\n        type: context.adaptationSet.contentType,\n        primary: isPrimary,\n        trickModeVideo: null,\n        emsgSchemeIdUris:\n            context.representation.emsgSchemeIdUris,\n        roles,\n        forced,\n        channelsCount: context.representation.numChannels,\n        audioSamplingRate: context.representation.audioSamplingRate,\n        spatialAudio,\n        closedCaptions,\n        hdr,\n        tilesLayout,\n        matchedStreams: [],\n      };\n    }\n\n    stream.createSegmentIndex = async () => {\n      if (!stream.segmentIndex) {\n        stream.segmentIndex = await streamInfo.generateSegmentIndex();\n      }\n    };\n\n    if (contextId && context.dynamic && !this.streamMap_[contextId]) {\n      this.streamMap_[contextId] = stream;\n    }\n\n    return stream;\n  }\n\n  /**\n   * Called when the update timer ticks.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async onUpdate_() {\n    goog.asserts.assert(this.updatePeriod_ >= 0,\n        'There should be an update period');\n\n    shaka.log.info('Updating manifest...');\n\n    // Default the update delay to 0 seconds so that if there is an error we can\n    // try again right away.\n    let updateDelay = 0;\n\n    try {\n      updateDelay = await this.requestManifest_();\n    } catch (error) {\n      goog.asserts.assert(error instanceof shaka.util.Error,\n          'Should only receive a Shaka error');\n\n      // Try updating again, but ensure we haven't been destroyed.\n      if (this.playerInterface_) {\n        // We will retry updating, so override the severity of the error.\n        error.severity = shaka.util.Error.Severity.RECOVERABLE;\n        this.playerInterface_.onError(error);\n      }\n    }\n\n    // Detect a call to stop()\n    if (!this.playerInterface_) {\n      return;\n    }\n\n    this.setUpdateTimer_(updateDelay);\n  }\n\n  /**\n   * Sets the update timer.  Does nothing if the manifest does not specify an\n   * update period.\n   *\n   * @param {number} offset An offset, in seconds, to apply to the manifest's\n   *   update period.\n   * @private\n   */\n  setUpdateTimer_(offset) {\n    // NOTE: An updatePeriod_ of -1 means the attribute was missing.\n    // An attribute which is present and set to 0 should still result in\n    // periodic updates.  For more, see:\n    // https://github.com/shaka-project/shaka-player/issues/331\n    if (this.updatePeriod_ < 0) {\n      return;\n    }\n\n    const finalDelay = Math.max(\n        shaka.dash.DashParser.MIN_UPDATE_PERIOD_,\n        this.updatePeriod_ - offset,\n        this.averageUpdateDuration_.getEstimate());\n\n    // We do not run the timer as repeating because part of update is async and\n    // we need schedule the update after it finished.\n    this.updateTimer_.tickAfter(/* seconds= */ finalDelay);\n  }\n\n  /**\n   * Creates a new inheritance frame for the given element.\n   *\n   * @param {!Element} elem\n   * @param {?shaka.dash.DashParser.InheritanceFrame} parent\n   * @param {Array.<string>} baseUris\n   * @return {shaka.dash.DashParser.InheritanceFrame}\n   * @private\n   */\n  createFrame_(elem, parent, baseUris) {\n    goog.asserts.assert(parent || baseUris,\n        'Must provide either parent or baseUris');\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const XmlUtils = shaka.util.XmlUtils;\n    parent = parent || /** @type {shaka.dash.DashParser.InheritanceFrame} */ ({\n      contentType: '',\n      mimeType: '',\n      codecs: '',\n      emsgSchemeIdUris: [],\n      frameRate: undefined,\n      pixelAspectRatio: undefined,\n      numChannels: null,\n      audioSamplingRate: null,\n      availabilityTimeOffset: 0,\n    });\n    baseUris = baseUris || parent.baseUris;\n\n    const parseNumber = XmlUtils.parseNonNegativeInt;\n    const evalDivision = XmlUtils.evalDivision;\n\n    const uriObjs = XmlUtils.findChildren(elem, 'BaseURL');\n    const uris = uriObjs.map(XmlUtils.getContents);\n\n    let contentType = elem.getAttribute('contentType') || parent.contentType;\n    const mimeType = elem.getAttribute('mimeType') || parent.mimeType;\n    const codecs = elem.getAttribute('codecs') || parent.codecs;\n    const frameRate =\n        XmlUtils.parseAttr(elem, 'frameRate', evalDivision) || parent.frameRate;\n    const pixelAspectRatio =\n        elem.getAttribute('sar') || parent.pixelAspectRatio;\n    const emsgSchemeIdUris = this.emsgSchemeIdUris_(\n        XmlUtils.findChildren(elem, 'InbandEventStream'),\n        parent.emsgSchemeIdUris);\n    const audioChannelConfigs =\n        XmlUtils.findChildren(elem, 'AudioChannelConfiguration');\n    const numChannels =\n        this.parseAudioChannels_(audioChannelConfigs) || parent.numChannels;\n    const audioSamplingRate =\n        XmlUtils.parseAttr(elem, 'audioSamplingRate', parseNumber) ||\n        parent.audioSamplingRate;\n\n    if (!contentType) {\n      contentType = shaka.dash.DashParser.guessContentType_(mimeType, codecs);\n    }\n\n    const segmentBase = XmlUtils.findChild(elem, 'SegmentBase');\n    const segmentTemplate = XmlUtils.findChild(elem, 'SegmentTemplate');\n\n    // The availabilityTimeOffset is the sum of all @availabilityTimeOffset\n    // values that apply to the adaptation set, via BaseURL, SegmentBase,\n    // or SegmentTemplate elements.\n    const segmentBaseAto = segmentBase ?\n        (XmlUtils.parseAttr(segmentBase, 'availabilityTimeOffset',\n            XmlUtils.parseFloat) || 0) : 0;\n    const segmentTemplateAto = segmentTemplate ?\n        (XmlUtils.parseAttr(segmentTemplate, 'availabilityTimeOffset',\n            XmlUtils.parseFloat) || 0) : 0;\n    const baseUriAto = uriObjs && uriObjs.length ?\n        (XmlUtils.parseAttr(uriObjs[0], 'availabilityTimeOffset',\n            XmlUtils.parseFloat) || 0) : 0;\n\n    const availabilityTimeOffset = parent.availabilityTimeOffset + baseUriAto +\n        segmentBaseAto + segmentTemplateAto;\n\n    return {\n      baseUris: ManifestParserUtils.resolveUris(baseUris, uris),\n      segmentBase: segmentBase || parent.segmentBase,\n      segmentList:\n          XmlUtils.findChild(elem, 'SegmentList') || parent.segmentList,\n      segmentTemplate: segmentTemplate || parent.segmentTemplate,\n      width: XmlUtils.parseAttr(elem, 'width', parseNumber) || parent.width,\n      height: XmlUtils.parseAttr(elem, 'height', parseNumber) || parent.height,\n      contentType: contentType,\n      mimeType: mimeType,\n      codecs: codecs,\n      frameRate: frameRate,\n      pixelAspectRatio: pixelAspectRatio,\n      emsgSchemeIdUris: emsgSchemeIdUris,\n      id: elem.getAttribute('id'),\n      numChannels: numChannels,\n      audioSamplingRate: audioSamplingRate,\n      availabilityTimeOffset: availabilityTimeOffset,\n    };\n  }\n\n  /**\n   * Returns a new array of InbandEventStream schemeIdUri containing the union\n   * of the ones parsed from inBandEventStreams and the ones provided in\n   * emsgSchemeIdUris.\n   *\n   * @param {!Array.<!Element>} inBandEventStreams Array of InbandEventStream\n   *     elements to parse and add to the returned array.\n   * @param {!Array.<string>} emsgSchemeIdUris Array of parsed\n   *     InbandEventStream schemeIdUri attributes to add to the returned array.\n   * @return {!Array.<string>} schemeIdUris Array of parsed\n   *     InbandEventStream schemeIdUri attributes.\n   * @private\n   */\n  emsgSchemeIdUris_(inBandEventStreams, emsgSchemeIdUris) {\n    const schemeIdUris = emsgSchemeIdUris.slice();\n    for (const event of inBandEventStreams) {\n      const schemeIdUri = event.getAttribute('schemeIdUri');\n      if (!schemeIdUris.includes(schemeIdUri)) {\n        schemeIdUris.push(schemeIdUri);\n      }\n    }\n    return schemeIdUris;\n  }\n\n  /**\n   * @param {!Array.<!Element>} audioChannelConfigs An array of\n   *   AudioChannelConfiguration elements.\n   * @return {?number} The number of audio channels, or null if unknown.\n   * @private\n   */\n  parseAudioChannels_(audioChannelConfigs) {\n    for (const elem of audioChannelConfigs) {\n      const scheme = elem.getAttribute('schemeIdUri');\n      if (!scheme) {\n        continue;\n      }\n\n      const value = elem.getAttribute('value');\n      if (!value) {\n        continue;\n      }\n\n      switch (scheme) {\n        case 'urn:mpeg:dash:outputChannelPositionList:2012':\n          // A space-separated list of speaker positions, so the number of\n          // channels is the length of this list.\n          return value.trim().split(/ +/).length;\n\n        case 'urn:mpeg:dash:23003:3:audio_channel_configuration:2011':\n        case 'urn:dts:dash:audio_channel_configuration:2012': {\n          // As far as we can tell, this is a number of channels.\n          const intValue = parseInt(value, 10);\n          if (!intValue) {  // 0 or NaN\n            shaka.log.warning('Channel parsing failure! ' +\n                          'Ignoring scheme and value', scheme, value);\n            continue;\n          }\n          return intValue;\n        }\n\n        case 'tag:dolby.com,2014:dash:audio_channel_configuration:2011':\n        case 'urn:dolby:dash:audio_channel_configuration:2011': {\n          // A hex-encoded 16-bit integer, in which each bit represents a\n          // channel.\n          let hexValue = parseInt(value, 16);\n          if (!hexValue) {  // 0 or NaN\n            shaka.log.warning('Channel parsing failure! ' +\n                          'Ignoring scheme and value', scheme, value);\n            continue;\n          }\n          // Count the 1-bits in hexValue.\n          let numBits = 0;\n          while (hexValue) {\n            if (hexValue & 1) {\n              ++numBits;\n            }\n            hexValue >>= 1;\n          }\n          return numBits;\n        }\n\n        // Defined by https://dashif.org/identifiers/audio_source_metadata/ and clause 8.2, in ISO/IEC 23001-8.\n        case 'urn:mpeg:mpegB:cicp:ChannelConfiguration': {\n          const noValue = 0;\n          const channelCountMapping = [\n            noValue, 1, 2, 3, 4, 5, 6, 8, 2, 3, /* 0--9 */\n            4, 7, 8, 24, 8, 12, 10, 12, 14, 12, /* 10--19 */\n            14, /* 20 */\n          ];\n          const intValue = parseInt(value, 10);\n          if (!intValue) {  // 0 or NaN\n            shaka.log.warning('Channel parsing failure! ' +\n                          'Ignoring scheme and value', scheme, value);\n            continue;\n          }\n          if (intValue > noValue && intValue < channelCountMapping.length) {\n            return channelCountMapping[intValue];\n          }\n          continue;\n        }\n\n        default:\n          shaka.log.warning(\n              'Unrecognized audio channel scheme:', scheme, value);\n          continue;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Verifies that a Representation has exactly one Segment* element.  Prints\n   * warnings if there is a problem.\n   *\n   * @param {shaka.dash.DashParser.InheritanceFrame} frame\n   * @return {boolean} True if the Representation is usable; otherwise return\n   *   false.\n   * @private\n   */\n  verifyRepresentation_(frame) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    let n = 0;\n    n += frame.segmentBase ? 1 : 0;\n    n += frame.segmentList ? 1 : 0;\n    n += frame.segmentTemplate ? 1 : 0;\n\n    if (n == 0) {\n      // TODO: Extend with the list of MIME types registered to TextEngine.\n      if (frame.contentType == ContentType.TEXT ||\n          frame.contentType == ContentType.APPLICATION) {\n        return true;\n      } else {\n        shaka.log.warning(\n            'Representation does not contain a segment information source:',\n            'the Representation must contain one of SegmentBase, SegmentList,',\n            'SegmentTemplate, or explicitly indicate that it is \"text\".',\n            frame);\n        return false;\n      }\n    }\n\n    if (n != 1) {\n      shaka.log.warning(\n          'Representation contains multiple segment information sources:',\n          'the Representation should only contain one of SegmentBase,',\n          'SegmentList, or SegmentTemplate.',\n          frame);\n      if (frame.segmentBase) {\n        shaka.log.info('Using SegmentBase by default.');\n        frame.segmentList = null;\n        frame.segmentTemplate = null;\n      } else {\n        goog.asserts.assert(frame.segmentList, 'There should be a SegmentList');\n        shaka.log.info('Using SegmentList by default.');\n        frame.segmentTemplate = null;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Makes a request to the given URI and calculates the clock offset.\n   *\n   * @param {!Array.<string>} baseUris\n   * @param {string} uri\n   * @param {string} method\n   * @return {!Promise.<number>}\n   * @private\n   */\n  async requestForTiming_(baseUris, uri, method) {\n    const requestUris =\n        shaka.util.ManifestParserUtils.resolveUris(baseUris, [uri]);\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        requestUris, this.config_.retryParameters);\n    request.method = method;\n    const type = shaka.net.NetworkingEngine.RequestType.TIMING;\n\n    const operation =\n    this.playerInterface_.networkingEngine.request(type, request);\n    this.operationManager_.manage(operation);\n\n    const response = await operation.promise;\n    let text;\n    if (method == 'HEAD') {\n      if (!response.headers || !response.headers['date']) {\n        shaka.log.warning('UTC timing response is missing',\n            'expected date header');\n        return 0;\n      }\n      text = response.headers['date'];\n    } else {\n      text = shaka.util.StringUtils.fromUTF8(response.data);\n    }\n    const date = Date.parse(text);\n    if (isNaN(date)) {\n      shaka.log.warning('Unable to parse date from UTC timing response');\n      return 0;\n    }\n    return (date - Date.now());\n  }\n\n  /**\n   * Parses an array of UTCTiming elements.\n   *\n   * @param {!Array.<string>} baseUris\n   * @param {!Array.<!Element>} elems\n   * @return {!Promise.<number>}\n   * @private\n   */\n  async parseUtcTiming_(baseUris, elems) {\n    const schemesAndValues = elems.map((elem) => {\n      return {\n        scheme: elem.getAttribute('schemeIdUri'),\n        value: elem.getAttribute('value'),\n      };\n    });\n\n    // If there's nothing specified in the manifest, but we have a default from\n    // the config, use that.\n    const clockSyncUri = this.config_.dash.clockSyncUri;\n    if (!schemesAndValues.length && clockSyncUri) {\n      schemesAndValues.push({\n        scheme: 'urn:mpeg:dash:utc:http-head:2014',\n        value: clockSyncUri,\n      });\n    }\n\n    for (const sv of schemesAndValues) {\n      try {\n        const scheme = sv.scheme;\n        const value = sv.value;\n        switch (scheme) {\n          // See DASH IOP Guidelines Section 4.7\n          // https://bit.ly/DashIop3-2\n          // Some old ISO23009-1 drafts used 2012.\n          case 'urn:mpeg:dash:utc:http-head:2014':\n          case 'urn:mpeg:dash:utc:http-head:2012':\n            // eslint-disable-next-line no-await-in-loop\n            return await this.requestForTiming_(baseUris, value, 'HEAD');\n          case 'urn:mpeg:dash:utc:http-xsdate:2014':\n          case 'urn:mpeg:dash:utc:http-iso:2014':\n          case 'urn:mpeg:dash:utc:http-xsdate:2012':\n          case 'urn:mpeg:dash:utc:http-iso:2012':\n            // eslint-disable-next-line no-await-in-loop\n            return await this.requestForTiming_(baseUris, value, 'GET');\n          case 'urn:mpeg:dash:utc:direct:2014':\n          case 'urn:mpeg:dash:utc:direct:2012': {\n            const date = Date.parse(value);\n            return isNaN(date) ? 0 : (date - Date.now());\n          }\n\n          case 'urn:mpeg:dash:utc:http-ntp:2014':\n          case 'urn:mpeg:dash:utc:ntp:2014':\n          case 'urn:mpeg:dash:utc:sntp:2014':\n            shaka.log.alwaysWarn('NTP UTCTiming scheme is not supported');\n            break;\n          default:\n            shaka.log.alwaysWarn(\n                'Unrecognized scheme in UTCTiming element', scheme);\n            break;\n        }\n      } catch (e) {\n        shaka.log.warning('Error fetching time from UTCTiming elem', e.message);\n      }\n    }\n\n    shaka.log.alwaysWarn(\n        'A UTCTiming element should always be given in live manifests! ' +\n        'This content may not play on clients with bad clocks!');\n    return 0;\n  }\n\n  /**\n   * Parses an EventStream element.\n   *\n   * @param {number} periodStart\n   * @param {?number} periodDuration\n   * @param {!Element} elem\n   * @param {number} availabilityStart\n   * @private\n   */\n  parseEventStream_(periodStart, periodDuration, elem, availabilityStart) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const parseNumber = XmlUtils.parseNonNegativeInt;\n\n    const schemeIdUri = elem.getAttribute('schemeIdUri') || '';\n    const value = elem.getAttribute('value') || '';\n    const timescale = XmlUtils.parseAttr(elem, 'timescale', parseNumber) || 1;\n\n    for (const eventNode of XmlUtils.findChildren(elem, 'Event')) {\n      const presentationTime =\n          XmlUtils.parseAttr(eventNode, 'presentationTime', parseNumber) || 0;\n      const duration =\n          XmlUtils.parseAttr(eventNode, 'duration', parseNumber) || 0;\n\n      let startTime = presentationTime / timescale + periodStart;\n      let endTime = startTime + (duration / timescale);\n      if (periodDuration != null) {\n        // An event should not go past the Period, even if the manifest says so.\n        // See: Dash sec. 5.10.2.1\n        startTime = Math.min(startTime, periodStart + periodDuration);\n        endTime = Math.min(endTime, periodStart + periodDuration);\n      }\n\n      // Don't add unavailable regions to the timeline.\n      if (endTime < availabilityStart) {\n        continue;\n      }\n\n      /** @type {shaka.extern.TimelineRegionInfo} */\n      const region = {\n        schemeIdUri: schemeIdUri,\n        value: value,\n        startTime: startTime,\n        endTime: endTime,\n        id: eventNode.getAttribute('id') || '',\n        eventElement: eventNode,\n      };\n\n      this.playerInterface_.onTimelineRegionAdded(region);\n    }\n  }\n\n  /**\n   * Makes a network request on behalf of SegmentBase.createStreamInfo.\n   *\n   * @param {!Array.<string>} uris\n   * @param {?number} startByte\n   * @param {?number} endByte\n   * @return {!Promise.<BufferSource>}\n   * @private\n   */\n  async requestInitSegment_(uris, startByte, endByte) {\n    const requestType = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n    const request = shaka.util.Networking.createSegmentRequest(\n        uris,\n        startByte,\n        endByte,\n        this.config_.retryParameters);\n\n    const networkingEngine = this.playerInterface_.networkingEngine;\n    const operation = networkingEngine.request(requestType, request);\n    this.operationManager_.manage(operation);\n    const response = await operation.promise;\n    return response.data;\n  }\n\n  /**\n   * Guess the content type based on MIME type and codecs.\n   *\n   * @param {string} mimeType\n   * @param {string} codecs\n   * @return {string}\n   * @private\n   */\n  static guessContentType_(mimeType, codecs) {\n    const fullMimeType = shaka.util.MimeUtils.getFullType(mimeType, codecs);\n\n    if (shaka.text.TextEngine.isTypeSupported(fullMimeType)) {\n      // If it's supported by TextEngine, it's definitely text.\n      // We don't check MediaSourceEngine, because that would report support\n      // for platform-supported video and audio types as well.\n      return shaka.util.ManifestParserUtils.ContentType.TEXT;\n    }\n\n    // Otherwise, just split the MIME type.  This handles video and audio\n    // types well.\n    return mimeType.split('/')[0];\n  }\n};\n\n\n/**\n * Contains the minimum amount of time, in seconds, between manifest update\n * requests.\n *\n * @private\n * @const {number}\n */\nshaka.dash.DashParser.MIN_UPDATE_PERIOD_ = 3;\n\n\n/**\n * @typedef {\n *   function(!Array.<string>, ?number, ?number):!Promise.<BufferSource>\n * }\n */\nshaka.dash.DashParser.RequestInitSegmentCallback;\n\n\n/**\n * @typedef {{\n *   segmentBase: Element,\n *   segmentList: Element,\n *   segmentTemplate: Element,\n *   baseUris: !Array.<string>,\n *   width: (number|undefined),\n *   height: (number|undefined),\n *   contentType: string,\n *   mimeType: string,\n *   codecs: string,\n *   frameRate: (number|undefined),\n *   pixelAspectRatio: (string|undefined),\n *   emsgSchemeIdUris: !Array.<string>,\n *   id: ?string,\n *   numChannels: ?number,\n *   audioSamplingRate: ?number,\n *   availabilityTimeOffset: number\n * }}\n *\n * @description\n * A collection of elements and properties which are inherited across levels\n * of a DASH manifest.\n *\n * @property {Element} segmentBase\n *   The XML node for SegmentBase.\n * @property {Element} segmentList\n *   The XML node for SegmentList.\n * @property {Element} segmentTemplate\n *   The XML node for SegmentTemplate.\n * @property {!Array.<string>} baseUris\n *   An array of absolute base URIs for the frame.\n * @property {(number|undefined)} width\n *   The inherited width value.\n * @property {(number|undefined)} height\n *   The inherited height value.\n * @property {string} contentType\n *   The inherited media type.\n * @property {string} mimeType\n *   The inherited MIME type value.\n * @property {string} codecs\n *   The inherited codecs value.\n * @property {(number|undefined)} frameRate\n *   The inherited framerate value.\n * @property {(string|undefined)} pixelAspectRatio\n *   The inherited pixel aspect ratio value.\n * @property {!Array.<string>} emsgSchemeIdUris\n *   emsg registered schemeIdUris.\n * @property {?string} id\n *   The ID of the element.\n * @property {?number} numChannels\n *   The number of audio channels, or null if unknown.\n * @property {?number} audioSamplingRate\n *   Specifies the maximum sampling rate of the content, or null if unknown.\n * @property {number} availabilityTimeOffset\n *   Specifies the total availabilityTimeOffset of the segment, or 0 if unknown.\n */\nshaka.dash.DashParser.InheritanceFrame;\n\n\n/**\n * @typedef {{\n *   dynamic: boolean,\n *   presentationTimeline: !shaka.media.PresentationTimeline,\n *   period: ?shaka.dash.DashParser.InheritanceFrame,\n *   periodInfo: ?shaka.dash.DashParser.PeriodInfo,\n *   adaptationSet: ?shaka.dash.DashParser.InheritanceFrame,\n *   representation: ?shaka.dash.DashParser.InheritanceFrame,\n *   bandwidth: number,\n *   indexRangeWarningGiven: boolean,\n *   availabilityTimeOffset: number,\n *   profiles: !Array.<string>\n * }}\n *\n * @description\n * Contains context data for the streams.  This is designed to be\n * shallow-copyable, so the parser must overwrite (not modify) each key as the\n * parser moves through the manifest and the parsing context changes.\n *\n * @property {boolean} dynamic\n *   True if the MPD is dynamic (not all segments available at once)\n * @property {!shaka.media.PresentationTimeline} presentationTimeline\n *   The PresentationTimeline.\n * @property {?shaka.dash.DashParser.InheritanceFrame} period\n *   The inheritance from the Period element.\n * @property {?shaka.dash.DashParser.PeriodInfo} periodInfo\n *   The Period info for the current Period.\n * @property {?shaka.dash.DashParser.InheritanceFrame} adaptationSet\n *   The inheritance from the AdaptationSet element.\n * @property {?shaka.dash.DashParser.InheritanceFrame} representation\n *   The inheritance from the Representation element.\n * @property {number} bandwidth\n *   The bandwidth of the Representation, or zero if missing.\n * @property {boolean} indexRangeWarningGiven\n *   True if the warning about SegmentURL@indexRange has been printed.\n * @property {number} availabilityTimeOffset\n *   The sum of the availabilityTimeOffset values that apply to the element.\n * @property {!Array.<string>} profiles\n *   Profiles of DASH are defined to enable interoperability and the signaling\n *   of the use of features.\n */\nshaka.dash.DashParser.Context;\n\n\n/**\n * @typedef {{\n *   start: number,\n *   duration: ?number,\n *   node: !Element,\n *   isLastPeriod: boolean\n * }}\n *\n * @description\n * Contains information about a Period element.\n *\n * @property {number} start\n *   The start time of the period.\n * @property {?number} duration\n *   The duration of the period; or null if the duration is not given.  This\n *   will be non-null for all periods except the last.\n * @property {!Element} node\n *   The XML Node for the Period.\n * @property {boolean} isLastPeriod\n *   Whether this Period is the last one in the manifest.\n */\nshaka.dash.DashParser.PeriodInfo;\n\n\n/**\n * @typedef {{\n *   id: string,\n *   contentType: ?string,\n *   language: string,\n *   main: boolean,\n *   streams: !Array.<shaka.extern.Stream>,\n *   drmInfos: !Array.<shaka.extern.DrmInfo>,\n *   trickModeFor: ?string,\n *   representationIds: !Array.<string>\n * }}\n *\n * @description\n * Contains information about an AdaptationSet element.\n *\n * @property {string} id\n *   The unique ID of the adaptation set.\n * @property {?string} contentType\n *   The content type of the AdaptationSet.\n * @property {string} language\n *   The language of the AdaptationSet.\n * @property {boolean} main\n *   Whether the AdaptationSet has the 'main' type.\n * @property {!Array.<shaka.extern.Stream>} streams\n *   The streams this AdaptationSet contains.\n * @property {!Array.<shaka.extern.DrmInfo>} drmInfos\n *   The DRM info for the AdaptationSet.\n * @property {?string} trickModeFor\n *   If non-null, this AdaptationInfo represents trick mode tracks.  This\n *   property is the ID of the normal AdaptationSet these tracks should be\n *   associated with.\n * @property {!Array.<string>} representationIds\n *   An array of the IDs of the Representations this AdaptationSet contains.\n */\nshaka.dash.DashParser.AdaptationInfo;\n\n\n/**\n * @typedef {function():!Promise.<shaka.media.SegmentIndex>}\n * @description\n * An async function which generates and returns a SegmentIndex.\n */\nshaka.dash.DashParser.GenerateSegmentIndexFunction;\n\n\n/**\n * @typedef {{\n *   generateSegmentIndex: shaka.dash.DashParser.GenerateSegmentIndexFunction\n * }}\n *\n * @description\n * Contains information about a Stream. This is passed from the createStreamInfo\n * methods.\n *\n * @property {shaka.dash.DashParser.GenerateSegmentIndexFunction}\n *     generateSegmentIndex\n *   An async function to create the SegmentIndex for the stream.\n */\nshaka.dash.DashParser.StreamInfo;\n\n\nshaka.media.ManifestParser.registerParserByExtension(\n    'mpd', () => new shaka.dash.DashParser());\nshaka.media.ManifestParser.registerParserByMime(\n    'application/dash+xml', () => new shaka.dash.DashParser());\nshaka.media.ManifestParser.registerParserByMime(\n    'video/vnd.mpeg.dash.mpd', () => new shaka.dash.DashParser());\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.hls.Attribute');\ngoog.provide('shaka.hls.Playlist');\ngoog.provide('shaka.hls.PlaylistType');\ngoog.provide('shaka.hls.Segment');\ngoog.provide('shaka.hls.Tag');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.Error');\n\n\n/**\n * HLS playlist class.\n */\nshaka.hls.Playlist = class {\n  /**\n   * @param {string} absoluteUri An absolute, final URI after redirects.\n   * @param {!shaka.hls.PlaylistType} type\n   * @param {!Array.<shaka.hls.Tag>} tags\n   * @param {!Array.<shaka.hls.Segment>=} segments\n   */\n  constructor(absoluteUri, type, tags, segments) {\n    /**\n     * An absolute, final URI after redirects.\n     *\n     * @const {string}\n     */\n    this.absoluteUri = absoluteUri;\n\n    /** @const {shaka.hls.PlaylistType} */\n    this.type = type;\n\n    /** @const {!Array.<!shaka.hls.Tag>} */\n    this.tags = tags;\n\n    /** @const {Array.<!shaka.hls.Segment>} */\n    this.segments = segments || null;\n  }\n};\n\n\n/**\n * @enum {number}\n */\nshaka.hls.PlaylistType = {\n  MASTER: 0,\n  MEDIA: 1,\n};\n\n\n/**\n * HLS tag class.\n */\nshaka.hls.Tag = class {\n  /**\n   * @param {number} id\n   * @param {string} name\n   * @param {!Array.<shaka.hls.Attribute>} attributes\n   * @param {?string=} value\n   */\n  constructor(id, name, attributes, value = null) {\n    /** @const {number} */\n    this.id = id;\n\n    /** @type {string} */\n    this.name = name;\n\n    /** @const {!Array.<shaka.hls.Attribute>} */\n    this.attributes = attributes;\n\n    /** @const {?string} */\n    this.value = value;\n  }\n\n  /**\n   * Create the string representation of the tag.\n   *\n   * For the DRM system - the full tag needs to be passed down to the CDM.\n   * There are two ways of doing this (1) save the original tag or (2) recreate\n   * the tag.\n   * As in some cases (like in tests) the tag never existed in string form, it\n   * is far easier to recreate the tag from the parsed form.\n   *\n   * @return {string}\n   * @override\n   */\n  toString() {\n    /**\n     * @param {shaka.hls.Attribute} attr\n     * @return {string}\n     */\n    const attrToStr = (attr) => {\n      const isNumericAttr = !isNaN(Number(attr.value));\n      const value = (isNumericAttr ? attr.value : '\"' + attr.value + '\"');\n      return attr.name + '=' + value;\n    };\n    // A valid tag can only follow 1 of 4 patterns.\n    //  1) <NAME>:<VALUE>\n    //  2) <NAME>:<ATTRIBUTE LIST>\n    //  3) <NAME>\n    //  4) <NAME>:<VALUE>,<ATTRIBUTE_LIST>\n\n    let tagStr = '#' + this.name;\n    const appendages = this.attributes ? this.attributes.map(attrToStr) : [];\n\n    if (this.value) {\n      appendages.unshift(this.value);\n    }\n\n    if (appendages.length > 0) {\n      tagStr += ':' + appendages.join(',');\n    }\n\n    return tagStr;\n  }\n\n  /**\n   * Adds an attribute to an HLS Tag.\n   *\n   * @param {!shaka.hls.Attribute} attribute\n   */\n  addAttribute(attribute) {\n    this.attributes.push(attribute);\n  }\n\n\n  /**\n   * Gets the first attribute of the tag with a specified name.\n   *\n   * @param {string} name\n   * @return {?shaka.hls.Attribute} attribute\n   */\n  getAttribute(name) {\n    const attributes = this.attributes.filter((attr) => {\n      return attr.name == name;\n    });\n\n    goog.asserts.assert(attributes.length < 2,\n        'A tag should not have multiple attributes ' +\n                        'with the same name!');\n\n    if (attributes.length) {\n      return attributes[0];\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Gets the value of the first attribute of the tag with a specified name.\n   * If not found, returns an optional default value.\n   *\n   * @param {string} name\n   * @param {string=} defaultValue\n   * @return {?string}\n   */\n  getAttributeValue(name, defaultValue) {\n    const attribute = this.getAttribute(name);\n    return attribute ? attribute.value : (defaultValue || null);\n  }\n\n\n  /**\n   * Finds the attribute and returns its value.\n   * Throws an error if attribute was not found.\n   *\n   * @param {string} name\n   * @return {string}\n   */\n  getRequiredAttrValue(name) {\n    const attribute = this.getAttribute(name);\n    if (!attribute) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_REQUIRED_ATTRIBUTE_MISSING,\n          name);\n    }\n\n    return attribute.value;\n  }\n\n  /**\n   * Set the name of the tag. Used only for Preload hinted MAP tag.\n   * @param {string} name\n   */\n  setName(name) {\n    this.name = name;\n  }\n};\n\n\n/**\n * HLS segment class.\n */\nshaka.hls.Segment = class {\n  /**\n   * Creates an HLS segment object.\n   *\n   * @param {string} absoluteUri An absolute URI.\n   * @param {!Array.<shaka.hls.Tag>} tags\n   * @param {!Array.<shaka.hls.Tag>=} partialSegments\n   */\n  constructor(absoluteUri, tags, partialSegments=[]) {\n    /** @const {!Array.<shaka.hls.Tag>} */\n    this.tags = tags;\n\n    /**\n     * An absolute URI.\n     *\n     * @const {string}\n     */\n    this.absoluteUri = absoluteUri;\n\n    /** @type {!Array.<shaka.hls.Tag>} */\n    this.partialSegments = partialSegments;\n  }\n};\n\n\n/**\n * HLS Attribute class.\n */\nshaka.hls.Attribute = class {\n  /**\n   * Creates an HLS attribute object.\n   *\n   * @param {string} name\n   * @param {string} value\n   */\n  constructor(name, value) {\n    /** @const {string} */\n    this.name = name;\n\n    /** @const {string} */\n    this.value = value;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.hls.Utils');\n\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.requireType('shaka.hls.Tag');\n\n\nshaka.hls.Utils = class {\n  /**\n   *\n   * @param {!Array.<!shaka.hls.Tag>} tags\n   * @param {string} name\n   * @return {!Array.<!shaka.hls.Tag>}\n   */\n  static filterTagsByName(tags, name) {\n    return tags.filter((tag) => {\n      return tag.name == name;\n    });\n  }\n\n\n  /**\n   *\n   * @param {!Array.<!shaka.hls.Tag>} tags\n   * @param {string} type\n   * @return {!Array.<!shaka.hls.Tag>}\n   */\n  static filterTagsByType(tags, type) {\n    return tags.filter((tag) => {\n      const tagType = tag.getRequiredAttrValue('TYPE');\n      return tagType == type;\n    });\n  }\n\n\n  /**\n   *\n   * @param {!Array.<!shaka.hls.Tag>} tags\n   * @param {string} name\n   * @return {?shaka.hls.Tag}\n   */\n  static getFirstTagWithName(tags, name) {\n    const tagsWithName = shaka.hls.Utils.filterTagsByName(tags, name);\n    if (!tagsWithName.length) {\n      return null;\n    }\n\n    return tagsWithName[0];\n  }\n\n  /**\n   * Get the numerical value of the first tag with given name if available.\n   * Return the default value if the tag is not present.\n   *\n   * @param {!Array.<!shaka.hls.Tag>} tags\n   * @param {string} name\n   * @param {number=} defaultValue\n   * @return {number}\n   */\n  static getFirstTagWithNameAsNumber(tags, name, defaultValue = 0) {\n    const tag = shaka.hls.Utils.getFirstTagWithName(tags, name);\n    const value = tag ? Number(tag.value) : defaultValue;\n    return value;\n  }\n\n\n  /**\n   * @param {string} parentAbsoluteUri\n   * @param {string} uri\n   * @return {string}\n   */\n  static constructAbsoluteUri(parentAbsoluteUri, uri) {\n    const uris = shaka.util.ManifestParserUtils.resolveUris(\n        [parentAbsoluteUri], [uri]);\n\n    return uris[0];\n  }\n\n\n  /**\n   * Matches a string to an HLS comment format and returns the result.\n   *\n   * @param {string} line\n   * @return {boolean}\n   */\n  static isComment(line) {\n    return /^#(?!EXT)/m.test(line);\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.TextParser');\n\ngoog.require('goog.asserts');\n\n\n/**\n * Reads elements from strings.\n */\nshaka.util.TextParser = class {\n  /**\n   * @param {string} data\n   */\n  constructor(data) {\n    /**\n     * @const\n     * @private {string}\n     */\n    this.data_ = data;\n\n    /** @private {number} */\n    this.position_ = 0;\n  }\n\n\n  /** @return {boolean} Whether it is at the end of the string. */\n  atEnd() {\n    return this.position_ == this.data_.length;\n  }\n\n\n  /**\n   * Reads a line from the parser.  This will read but not return the newline.\n   * Returns null at the end.\n   *\n   * @return {?string}\n   */\n  readLine() {\n    return this.readRegexReturnCapture_(/(.*?)(\\n|$)/gm, 1);\n  }\n\n\n  /**\n   * Reads a word from the parser.  This will not read or return any whitespace\n   * before or after the word (including newlines).  Returns null at the end.\n   *\n   * @return {?string}\n   */\n  readWord() {\n    return this.readRegexReturnCapture_(/[^ \\t\\n]*/gm, 0);\n  }\n\n\n  /**\n   * Skips any continuous whitespace from the parser.  Returns null at the end.\n   */\n  skipWhitespace() {\n    this.readRegex(/[ \\t]+/gm);\n  }\n\n\n  /**\n   * Reads the given regular expression from the parser.  This requires the\n   * match to be at the current position; there is no need to include a head\n   * anchor.\n   * This requires that the regex have the global flag to be set so that it can\n   * set lastIndex to start the search at the current position.  Returns null at\n   * the end or if the regex does not match the current position.\n   *\n   * @param {!RegExp} regex\n   * @return {Array.<string>}\n   */\n  readRegex(regex) {\n    const index = this.indexOf_(regex);\n    if (this.atEnd() || index == null || index.position != this.position_) {\n      return null;\n    }\n\n    this.position_ += index.length;\n    return index.results;\n  }\n\n\n  /**\n   * Reads a regex from the parser and returns the given capture.\n   *\n   * @param {!RegExp} regex\n   * @param {number} index\n   * @return {?string}\n   * @private\n   */\n  readRegexReturnCapture_(regex, index) {\n    if (this.atEnd()) {\n      return null;\n    }\n\n    const ret = this.readRegex(regex);\n    if (!ret) {\n      return null;\n    } else {\n      return ret[index];\n    }\n  }\n\n\n  /**\n   * Returns the index info about a regular expression match.\n   *\n   * @param {!RegExp} regex\n   * @return {?{position: number, length: number, results: !Array.<string>}}\n   * @private\n   */\n  indexOf_(regex) {\n    // The global flag is required to use lastIndex.\n    goog.asserts.assert(regex.global, 'global flag should be set');\n\n    regex.lastIndex = this.position_;\n    const results = regex.exec(this.data_);\n    if (results == null) {\n      return null;\n    } else {\n      return {\n        position: results.index,\n        length: results[0].length,\n        results: results,\n      };\n    }\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.hls.ManifestTextParser');\n\ngoog.require('shaka.hls.Attribute');\ngoog.require('shaka.hls.Playlist');\ngoog.require('shaka.hls.PlaylistType');\ngoog.require('shaka.hls.Segment');\ngoog.require('shaka.hls.Tag');\ngoog.require('shaka.hls.Utils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\n\n\n/**\n * HlS manifest text parser.\n */\nshaka.hls.ManifestTextParser = class {\n  /** */\n  constructor() {\n    /** @private {number} */\n    this.globalId_ = 0;\n  }\n\n  /**\n   * @param {BufferSource} data\n   * @param {string} absolutePlaylistUri An absolute, final URI after redirects.\n   * @return {!shaka.hls.Playlist}\n   */\n  parsePlaylist(data, absolutePlaylistUri) {\n    const MEDIA_PLAYLIST_TAGS =\n        shaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS;\n    const SEGMENT_TAGS = shaka.hls.ManifestTextParser.SEGMENT_TAGS;\n\n    // Get the input as a string.  Normalize newlines to \\n.\n    let str = shaka.util.StringUtils.fromUTF8(data);\n    str = str.replace(/\\r\\n|\\r(?=[^\\n]|$)/gm, '\\n').trim();\n\n    const lines = str.split(/\\n+/m);\n\n    if (!/^#EXTM3U($|[ \\t\\n])/m.test(lines[0])) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_PLAYLIST_HEADER_MISSING);\n    }\n\n    /** shaka.hls.PlaylistType */\n    let playlistType = shaka.hls.PlaylistType.MASTER;\n\n    // First, look for media playlist tags, so that we know what the playlist\n    // type really is before we start parsing.\n    // TODO: refactor the for loop for better readability.\n    // Whether to skip the next element; initialize to true to skip first elem.\n    let skip = true;\n    for (const line of lines) {\n      // Ignore comments.\n      if (shaka.hls.Utils.isComment(line) || skip) {\n        skip = false;\n        continue;\n      }\n      const tag = this.parseTag_(line);\n      // These tags won't actually be used, so don't increment the global\n      // id.\n      this.globalId_ -= 1;\n\n      if (MEDIA_PLAYLIST_TAGS.includes(tag.name)) {\n        playlistType = shaka.hls.PlaylistType.MEDIA;\n        break;\n      } else if (tag.name == 'EXT-X-STREAM-INF') {\n        skip = true;\n      }\n    }\n\n    /** {Array.<shaka.hls.Tag>} */\n    const tags = [];\n    // Initialize to \"true\" to skip the first element.\n    skip = true;\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      const next = lines[i + 1];\n      // Skip comments\n      if (shaka.hls.Utils.isComment(line) || skip) {\n        skip = false;\n        continue;\n      }\n\n      const tag = this.parseTag_(line);\n      if (SEGMENT_TAGS.includes(tag.name)) {\n        if (playlistType != shaka.hls.PlaylistType.MEDIA) {\n          // Only media playlists should contain segment tags\n          throw new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.MANIFEST,\n              shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY);\n        }\n\n        const segmentsData = lines.splice(i, lines.length - i);\n        const segments = this.parseSegments_(\n            absolutePlaylistUri, segmentsData, tags);\n        return new shaka.hls.Playlist(\n            absolutePlaylistUri, playlistType, tags, segments);\n      }\n\n      tags.push(tag);\n\n      // An EXT-X-STREAM-INF tag is followed by a URI of a media playlist.\n      // Add the URI to the tag object.\n      if (tag.name == 'EXT-X-STREAM-INF') {\n        const tagUri = new shaka.hls.Attribute('URI', next);\n        tag.addAttribute(tagUri);\n        skip = true;\n      }\n    }\n\n    return new shaka.hls.Playlist(absolutePlaylistUri, playlistType, tags);\n  }\n\n  /**\n   * Parses an array of strings into an array of HLS Segment objects.\n   *\n   * @param {string} absoluteMediaPlaylistUri\n   * @param {!Array.<string>} lines\n   * @param {!Array.<!shaka.hls.Tag>} playlistTags\n   * @return {!Array.<shaka.hls.Segment>}\n   * @private\n   */\n  parseSegments_(absoluteMediaPlaylistUri, lines, playlistTags) {\n    /** @type {!Array.<shaka.hls.Segment>} */\n    const segments = [];\n    /** @type {!Array.<shaka.hls.Tag>} */\n    let segmentTags = [];\n\n    /** @type {!Array.<shaka.hls.Tag>} */\n    let partialSegmentTags = [];\n\n    // The last parsed EXT-X-MAP tag.\n    /** @type {?shaka.hls.Tag} */\n    let currentMapTag = null;\n\n    for (const line of lines) {\n      if (/^(#EXT)/.test(line)) {\n        const tag = this.parseTag_(line);\n        if (shaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS.includes(\n            tag.name)) {\n          playlistTags.push(tag);\n        } else {\n          // Mark the the EXT-X-MAP tag, and add it to the segment tags\n          // following it later.\n          if (tag.name == 'EXT-X-MAP') {\n            currentMapTag = tag;\n          } else if (tag.name == 'EXT-X-PART') {\n            partialSegmentTags.push(tag);\n          } else if (tag.name == 'EXT-X-PRELOAD-HINT') {\n            if (tag.getAttributeValue('TYPE') == 'PART') {\n              partialSegmentTags.push(tag);\n            } else if (tag.getAttributeValue('TYPE') == 'MAP') {\n              // Rename the Preload Hint tag to be a Map tag.\n              tag.setName('EXT-X-MAP');\n              currentMapTag = tag;\n            }\n          } else {\n            segmentTags.push(tag);\n          }\n        }\n      } else if (shaka.hls.Utils.isComment(line)) {\n        // Skip comments.\n      } else {\n        const verbatimSegmentUri = line.trim();\n        const absoluteSegmentUri = shaka.hls.Utils.constructAbsoluteUri(\n            absoluteMediaPlaylistUri, verbatimSegmentUri);\n        // Attach the last parsed EXT-X-MAP tag to the segment.\n        if (currentMapTag) {\n          segmentTags.push(currentMapTag);\n        }\n        // The URI appears after all of the tags describing the segment.\n        const segment =\n            new shaka.hls.Segment(absoluteSegmentUri, segmentTags,\n                partialSegmentTags);\n        segments.push(segment);\n        segmentTags = [];\n        partialSegmentTags = [];\n      }\n    }\n    // After all the partial segments of a regular segment is published,\n    // a EXTINF tag and Uri for a regular segment containing the same media\n    // content will get published at last.\n    // If no EXTINF tag follows the list of partial segment tags at the end,\n    // create a segment to wrap the partial segment tags.\n    if (partialSegmentTags.length) {\n      if (currentMapTag) {\n        segmentTags.push(currentMapTag);\n      }\n      const segment = new shaka.hls.Segment('', segmentTags,\n          partialSegmentTags);\n      segments.push(segment);\n    }\n\n    return segments;\n  }\n\n  /**\n   * Parses a string into an HLS Tag object while tracking what id to use next.\n   *\n   * @param {string} word\n   * @return {!shaka.hls.Tag}\n   * @private\n   */\n  parseTag_(word) {\n    return shaka.hls.ManifestTextParser.parseTag(this.globalId_++, word);\n  }\n\n  /**\n   * Parses a string into an HLS Tag object.\n   *\n   * @param {number} id\n   * @param {string} word\n   * @return {!shaka.hls.Tag}\n   */\n  static parseTag(id, word) {\n    /* HLS tags start with '#EXT'. A tag can have a set of attributes\n      (#EXT-<tagname>:<attribute list>) and/or a value (#EXT-<tagname>:<value>).\n      An attribute's format is 'AttributeName=AttributeValue'.\n      The parsing logic goes like this:\n       1. Everything before ':' is a name (we ignore '#').\n       2. Everything after ':' is a list of comma-seprated items,\n            2a. The first item might be a value, if it does not contain '='.\n            2b. Otherwise, items are attributes.\n       3. If there is no \":\", it's a simple tag with no attributes and no value.\n    */\n    const blocks = word.match(/^#(EXT[^:]*)(?::(.*))?$/);\n    if (!blocks) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.INVALID_HLS_TAG,\n          word);\n    }\n    const name = blocks[1];\n    const data = blocks[2];\n    const attributes = [];\n    let value;\n\n    if (data) {\n      const parser = new shaka.util.TextParser(data);\n      let blockAttrs;\n\n      // Regex: any number of non-equals-sign characters at the beginning\n      // terminated by comma or end of line\n      const valueRegex = /^([^,=]+)(?:,|$)/g;\n\n      const blockValue = parser.readRegex(valueRegex);\n\n      if (blockValue) {\n        value = blockValue[1];\n      }\n\n      // Regex:\n      // 1. Key name ([1])\n      // 2. Equals sign\n      // 3. Either:\n      //   a. A quoted string (everything up to the next quote, [2])\n      //   b. An unquoted string\n      //    (everything up to the next comma or end of line, [3])\n      // 4. Either:\n      //   a. A comma\n      //   b. End of line\n      const attributeRegex = /([^=]+)=(?:\"([^\"]*)\"|([^\",]*))(?:,|$)/g;\n\n      while ((blockAttrs = parser.readRegex(attributeRegex))) {\n        const attrName = blockAttrs[1];\n        const attrValue = blockAttrs[2] || blockAttrs[3];\n        const attribute = new shaka.hls.Attribute(attrName, attrValue);\n        attributes.push(attribute);\n        parser.skipWhitespace();\n      }\n    }\n\n    return new shaka.hls.Tag(id, name, attributes, value);\n  }\n};\n\n\n/**\n * HLS tags that only appear on Media Playlists.\n * Used to determine a playlist type.\n *\n * @const {!Array.<string>}\n */\nshaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS = [\n  'EXT-X-TARGETDURATION',\n  'EXT-X-MEDIA-SEQUENCE',\n  'EXT-X-DISCONTINUITY-SEQUENCE',\n  'EXT-X-PLAYLIST-TYPE',\n  'EXT-X-I-FRAMES-ONLY',\n  'EXT-X-ENDLIST',\n  'EXT-X-SERVER-CONTROL',\n  'EXT-X-SKIP',\n];\n\n\n/**\n * HLS tags that only appear on Segments in a Media Playlists.\n * Used to determine the start of the segments info.\n *\n * @const {!Array.<string>}\n */\nshaka.hls.ManifestTextParser.SEGMENT_TAGS = [\n  'EXTINF',\n  'EXT-X-BYTERANGE',\n  'EXT-X-DISCONTINUITY',\n  'EXT-X-PROGRAM-DATE-TIME',\n  'EXT-X-KEY',\n  'EXT-X-DATERANGE',\n  'EXT-X-MAP',\n];\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.DataUriPlugin');\n\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @summary A networking plugin to handle data URIs.\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs\n * @export\n */\nshaka.net.DataUriPlugin = class {\n  /**\n   * @param {string} uri\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a\n   *   progress event happened.\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @export\n   */\n  static parse(uri, request, requestType, progressUpdated) {\n    try {\n      const parsed = shaka.net.DataUriPlugin.parseRaw(uri);\n\n      /** @type {shaka.extern.Response} */\n      const response = {\n        uri: uri,\n        originalUri: uri,\n        data: parsed.data,\n        headers: {\n          'content-type': parsed.contentType,\n        },\n      };\n\n      return shaka.util.AbortableOperation.completed(response);\n    } catch (error) {\n      return shaka.util.AbortableOperation.failed(error);\n    }\n  }\n\n  /**\n   * @param {string} uri\n   * @return {{data: BufferSource, contentType: string}}\n   */\n  static parseRaw(uri) {\n    // Extract the scheme.\n    const parts = uri.split(':');\n    if (parts.length < 2 || parts[0] != 'data') {\n      shaka.log.error('Bad data URI, failed to parse scheme');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.MALFORMED_DATA_URI,\n          uri);\n    }\n    const path = parts.slice(1).join(':');\n\n    // Extract the encoding and MIME type (required but can be empty).\n    const infoAndData = path.split(',');\n    if (infoAndData.length < 2) {\n      shaka.log.error('Bad data URI, failed to extract encoding and MIME type');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.MALFORMED_DATA_URI,\n          uri);\n    }\n    const info = infoAndData[0];\n    const dataStr = window.decodeURIComponent(infoAndData.slice(1).join(','));\n\n    // The MIME type is always the first thing in the semicolon-separated list\n    // of type parameters.  It may be blank.\n    const typeInfoList = info.split(';');\n    const contentType = typeInfoList[0];\n\n    // Check for base64 encoding, which is always the last in the\n    // semicolon-separated list if present.\n    let base64Encoded = false;\n    if (typeInfoList.length > 1 &&\n        typeInfoList[typeInfoList.length - 1] == 'base64') {\n      base64Encoded = true;\n      typeInfoList.pop();\n    }\n\n    // Convert the data.\n    /** @type {BufferSource} */\n    let data;\n    if (base64Encoded) {\n      data = shaka.util.Uint8ArrayUtils.fromBase64(dataStr);\n    } else {\n      data = shaka.util.StringUtils.toUTF8(dataStr);\n    }\n\n    return {data: data, contentType};\n  }\n};\n\n\nshaka.net.NetworkingEngine.registerScheme(\n    'data', shaka.net.DataUriPlugin.parse);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.hls.HlsParser');\n\ngoog.require('goog.Uri');\ngoog.require('goog.asserts');\ngoog.require('shaka.hls.ManifestTextParser');\ngoog.require('shaka.hls.Playlist');\ngoog.require('shaka.hls.PlaylistType');\ngoog.require('shaka.hls.Tag');\ngoog.require('shaka.hls.Utils');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.net.DataUriPlugin');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.CmcdManager');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Mp4BoxParsers');\ngoog.require('shaka.util.Networking');\ngoog.require('shaka.util.OperationManager');\ngoog.require('shaka.util.Pssh');\ngoog.require('shaka.util.Timer');\ngoog.requireType('shaka.hls.Segment');\n\n\n/**\n * HLS parser.\n *\n * @implements {shaka.extern.ManifestParser}\n * @export\n */\nshaka.hls.HlsParser = class {\n  /**\n   * Creates an Hls Parser object.\n   */\n  constructor() {\n    /** @private {?shaka.extern.ManifestParser.PlayerInterface} */\n    this.playerInterface_ = null;\n\n    /** @private {?shaka.extern.ManifestConfiguration} */\n    this.config_ = null;\n\n    /** @private {number} */\n    this.globalId_ = 1;\n\n    /** @private {!Map.<string, string>} */\n    this.globalVariables_ = new Map();\n\n    /**\n     * A map from group id to stream infos created from the media tags.\n     * @private {!Map.<string, !Array.<?shaka.hls.HlsParser.StreamInfo>>}\n     */\n    this.groupIdToStreamInfosMap_ = new Map();\n\n    /**\n     * The values are strings of the form \"<VIDEO URI> - <AUDIO URI>\",\n     * where the URIs are the verbatim media playlist URIs as they appeared in\n     * the master playlist.\n     *\n     * Used to avoid duplicates that vary only in their text stream.\n     *\n     * @private {!Set.<string>}\n     */\n    this.variantUriSet_ = new Set();\n\n    /**\n     * A map from (verbatim) media playlist URI to stream infos representing the\n     * playlists.\n     *\n     * On update, used to iterate through and update from media playlists.\n     *\n     * On initial parse, used to iterate through and determine minimum\n     * timestamps, offsets, and to handle TS rollover.\n     *\n     * During parsing, used to avoid duplicates in the async methods\n     * createStreamInfoFromMediaTag_, createStreamInfoFromImageTag_ and\n     * createStreamInfoFromVariantTag_.\n     *\n     * During parsing of updates, used by getStartTime_ to determine the start\n     * time of the first segment from existing segment references.\n     *\n     * @private {!Map.<string, shaka.hls.HlsParser.StreamInfo>}\n     */\n    this.uriToStreamInfosMap_ = new Map();\n\n    /** @private {?shaka.media.PresentationTimeline} */\n    this.presentationTimeline_ = null;\n\n    /**\n     * The master playlist URI, after redirects.\n     *\n     * @private {string}\n     */\n    this.masterPlaylistUri_ = '';\n\n    /** @private {shaka.hls.ManifestTextParser} */\n    this.manifestTextParser_ = new shaka.hls.ManifestTextParser();\n\n    /**\n     * This is the number of seconds we want to wait between finishing a\n     * manifest update and starting the next one. This will be set when we parse\n     * the manifest.\n     *\n     * @private {number}\n     */\n    this.updatePlaylistDelay_ = 0;\n\n    /**\n     * This timer is used to trigger the start of a manifest update. A manifest\n     * update is async. Once the update is finished, the timer will be restarted\n     * to trigger the next update. The timer will only be started if the content\n     * is live content.\n     *\n     * @private {shaka.util.Timer}\n     */\n    this.updatePlaylistTimer_ = new shaka.util.Timer(() => {\n      this.onUpdate_();\n    });\n\n    /** @private {shaka.hls.HlsParser.PresentationType_} */\n    this.presentationType_ = shaka.hls.HlsParser.PresentationType_.VOD;\n\n    /** @private {?shaka.extern.Manifest} */\n    this.manifest_ = null;\n\n    /** @private {number} */\n    this.maxTargetDuration_ = 0;\n\n    /** @private {number} */\n    this.minTargetDuration_ = Infinity;\n\n    /** Partial segments target duration.\n     * @private {number}\n     */\n    this.partialTargetDuration_ = 0;\n\n    /** @private {number} */\n    this.lowLatencyPresentationDelay_ = 0;\n\n    /** @private {shaka.util.OperationManager} */\n    this.operationManager_ = new shaka.util.OperationManager();\n\n    /** @private {!Array.<!Array.<!shaka.media.SegmentReference>>} */\n    this.segmentsToNotifyByStream_ = [];\n\n    /** A map from closed captions' group id, to a map of closed captions info.\n     * {group id -> {closed captions channel id -> language}}\n     * @private {Map.<string, Map.<string, string>>}\n     */\n    this.groupIdToClosedCaptionsMap_ = new Map();\n\n    /** True if some of the variants in  the playlist is encrypted with AES-128.\n     * @private {boolean} */\n    this.aesEncrypted_ = false;\n\n    /** @private {Map.<string, string>} */\n    this.groupIdToCodecsMap_ = new Map();\n\n    /** @private {?number} */\n    this.playlistStartTime_ = null;\n\n    /** A cache mapping EXT-X-MAP tag info to the InitSegmentReference created\n     * from the tag.\n     * The key is a string combining the EXT-X-MAP tag's absolute uri, and\n     * its BYTERANGE if available.\n     * {!Map.<string, !shaka.media.InitSegmentReference>} */\n    this.mapTagToInitSegmentRefMap_ = new Map();\n\n    /**\n     * A cache mapping a discontinuity sequence number of a segment with\n     * EXT-X-DISCONTINUITY tag into its timestamp offset.\n     * Key: the discontinuity sequence number of a segment\n     * Value: the segment reference's timestamp offset.\n     * {!Map.<number, number>}\n     */\n    this.discontinuityToTso_ = new Map();\n\n    /** @private {boolean} */\n    this.lowLatencyMode_ = false;\n  }\n\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  configure(config) {\n    this.config_ = config;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  async start(uri, playerInterface) {\n    goog.asserts.assert(this.config_, 'Must call configure() before start()!');\n    this.playerInterface_ = playerInterface;\n    this.lowLatencyMode_ = playerInterface.isLowLatencyMode();\n\n    const response = await this.requestManifest_(uri);\n\n    // Record the master playlist URI after redirects.\n    this.masterPlaylistUri_ = response.uri;\n\n    goog.asserts.assert(response.data, 'Response data should be non-null!');\n    await this.parseManifest_(response.data);\n\n    // Start the update timer if we want updates.\n    const delay = this.updatePlaylistDelay_;\n    if (delay > 0) {\n      this.updatePlaylistTimer_.tickAfter(/* seconds= */ delay);\n    }\n\n    goog.asserts.assert(this.manifest_, 'Manifest should be non-null');\n    return this.manifest_;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  stop() {\n    // Make sure we don't update the manifest again. Even if the timer is not\n    // running, this is safe to call.\n    if (this.updatePlaylistTimer_) {\n      this.updatePlaylistTimer_.stop();\n      this.updatePlaylistTimer_ = null;\n    }\n\n    /** @type {!Array.<!Promise>} */\n    const pending = [];\n\n    if (this.operationManager_) {\n      pending.push(this.operationManager_.destroy());\n      this.operationManager_ = null;\n    }\n\n    this.playerInterface_ = null;\n    this.config_ = null;\n    this.variantUriSet_.clear();\n    this.manifest_ = null;\n    this.uriToStreamInfosMap_.clear();\n    this.groupIdToStreamInfosMap_.clear();\n    this.groupIdToCodecsMap_.clear();\n    this.globalVariables_.clear();\n\n    return Promise.all(pending);\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  async update() {\n    if (!this.isLive_()) {\n      return;\n    }\n\n    /** @type {!Array.<!Promise>} */\n    const updates = [];\n    // Reset the start time for the new media playlist.\n    this.playlistStartTime_ = null;\n    const streamInfos = Array.from(this.uriToStreamInfosMap_.values());\n    // Wait for the first stream info created, so that the start time is fetched\n    // and can be reused.\n    if (streamInfos.length) {\n      await this.updateStream_(streamInfos[0]);\n    }\n    for (let i = 1; i < streamInfos.length; i++) {\n      updates.push(this.updateStream_(streamInfos[i]));\n    }\n\n    await Promise.all(updates);\n  }\n\n  /**\n   * Updates a stream.\n   *\n   * @param {!shaka.hls.HlsParser.StreamInfo} streamInfo\n   * @return {!Promise}\n   * @private\n   */\n  async updateStream_(streamInfo) {\n    const PresentationType = shaka.hls.HlsParser.PresentationType_;\n    const manifestUri = streamInfo.absoluteMediaPlaylistUri;\n    const uriObj = new goog.Uri(manifestUri);\n    if (this.lowLatencyMode_ && streamInfo.canSkipSegments) {\n      // Enable delta updates. This will replace older segments with\n      // 'EXT-X-SKIP' tag in the media playlist.\n      uriObj.setQueryData(new goog.Uri.QueryData('_HLS_skip=YES'));\n    }\n    const response = await this.requestManifest_(uriObj.toString());\n\n    /** @type {shaka.hls.Playlist} */\n    const playlist = this.manifestTextParser_.parsePlaylist(\n        response.data, response.uri);\n\n    if (playlist.type != shaka.hls.PlaylistType.MEDIA) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY);\n    }\n\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const variablesTags = shaka.hls.Utils.filterTagsByName(playlist.tags,\n        'EXT-X-DEFINE');\n\n    const mediaVariables = this.parseMediaVariables_(variablesTags);\n\n    const stream = streamInfo.stream;\n\n    const segments = await this.createSegments_(\n        streamInfo.verbatimMediaPlaylistUri, playlist, stream.type,\n        stream.mimeType, streamInfo.mediaSequenceToStartTime, mediaVariables,\n        streamInfo.discontinuityToMediaSequence, stream.codecs,\n        stream.bandwidth);\n\n    stream.segmentIndex.mergeAndEvict(\n        segments, this.presentationTimeline_.getSegmentAvailabilityStart());\n    if (segments.length) {\n      const mediaSequenceNumber = shaka.hls.Utils.getFirstTagWithNameAsNumber(\n          playlist.tags, 'EXT-X-MEDIA-SEQUENCE', 0);\n      const playlistStartTime = streamInfo.mediaSequenceToStartTime.get(\n          mediaSequenceNumber);\n      stream.segmentIndex.evict(playlistStartTime);\n    }\n    const newestSegment = segments[segments.length - 1];\n    goog.asserts.assert(newestSegment, 'Should have segments!');\n\n    // Once the last segment has been added to the playlist,\n    // #EXT-X-ENDLIST tag will be appended.\n    // If that happened, treat the rest of the EVENT presentation as VOD.\n    const endListTag =\n        shaka.hls.Utils.getFirstTagWithName(playlist.tags, 'EXT-X-ENDLIST');\n\n    if (endListTag) {\n      // Convert the presentation to VOD and set the duration to the last\n      // segment's end time.\n      this.setPresentationType_(PresentationType.VOD);\n      this.presentationTimeline_.setDuration(newestSegment.endTime);\n    }\n  }\n\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  onExpirationUpdated(sessionId, expiration) {\n    // No-op\n  }\n\n  /**\n   * Parses the manifest.\n   *\n   * @param {BufferSource} data\n   * @return {!Promise}\n   * @private\n   */\n  async parseManifest_(data) {\n    const Utils = shaka.hls.Utils;\n\n    goog.asserts.assert(this.masterPlaylistUri_,\n        'Master playlist URI must be set before calling parseManifest_!');\n\n    const playlist = this.manifestTextParser_.parsePlaylist(\n        data, this.masterPlaylistUri_);\n\n    // We don't support directly providing a Media Playlist.\n    // See the error code for details.\n    if (playlist.type != shaka.hls.PlaylistType.MASTER) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_MASTER_PLAYLIST_NOT_PROVIDED);\n    }\n\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const variablesTags = Utils.filterTagsByName(playlist.tags, 'EXT-X-DEFINE');\n\n    this.parseMasterVariables_(variablesTags);\n\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const mediaTags = Utils.filterTagsByName(playlist.tags, 'EXT-X-MEDIA');\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const variantTags = Utils.filterTagsByName(\n        playlist.tags, 'EXT-X-STREAM-INF');\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const imageTags = Utils.filterTagsByName(\n        playlist.tags, 'EXT-X-IMAGE-STREAM-INF');\n\n    this.parseCodecs_(variantTags);\n\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const sesionDataTags =\n        Utils.filterTagsByName(playlist.tags, 'EXT-X-SESSION-DATA');\n    for (const tag of sesionDataTags) {\n      const id = tag.getAttributeValue('DATA-ID');\n      const uri = tag.getAttributeValue('URI');\n      const language = tag.getAttributeValue('LANGUAGE');\n      const value = tag.getAttributeValue('VALUE');\n      const data = (new Map()).set('id', id);\n      if (uri) {\n        data.set('uri',\n            shaka.hls.Utils.constructAbsoluteUri(this.masterPlaylistUri_, uri));\n      }\n      if (language) {\n        data.set('language', language);\n      }\n      if (value) {\n        data.set('value', value);\n      }\n      const event = new shaka.util.FakeEvent('sessiondata', data);\n      if (this.playerInterface_) {\n        this.playerInterface_.onEvent(event);\n      }\n    }\n\n    // Parse audio and video media tags first, so that we can extract segment\n    // start time from audio/video streams and reuse for text streams.\n    await this.createStreamInfosFromMediaTags_(mediaTags);\n    this.parseClosedCaptions_(mediaTags);\n    const variants = await this.createVariantsForTags_(variantTags);\n    const textStreams = await this.parseTexts_(mediaTags);\n    const imageStreams = await this.parseImages_(imageTags);\n\n    // Make sure that the parser has not been destroyed.\n    if (!this.playerInterface_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED);\n    }\n\n    if (this.aesEncrypted_ && variants.length == 0) {\n      // We do not support AES-128 encryption with HLS yet. Variants is null\n      // when the playlist is encrypted with AES-128.\n      shaka.log.info('No stream is created, because we don\\'t support AES-128',\n          'encryption yet');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_AES_128_ENCRYPTION_NOT_SUPPORTED);\n    }\n\n    // Find the min and max timestamp of the earliest segment in all streams.\n    // Find the minimum duration of all streams as well.\n    let minFirstTimestamp = Infinity;\n    let minDuration = Infinity;\n\n    for (const streamInfo of this.uriToStreamInfosMap_.values()) {\n      minFirstTimestamp =\n          Math.min(minFirstTimestamp, streamInfo.minTimestamp);\n      if (streamInfo.stream.type != 'text') {\n        minDuration = Math.min(minDuration,\n            streamInfo.maxTimestamp - streamInfo.minTimestamp);\n      }\n    }\n\n    // This assert is our own sanity check.\n    goog.asserts.assert(this.presentationTimeline_ == null,\n        'Presentation timeline created early!');\n    this.createPresentationTimeline_();\n\n    // This assert satisfies the compiler that it is not null for the rest of\n    // the method.\n    goog.asserts.assert(this.presentationTimeline_,\n        'Presentation timeline not created!');\n\n    if (this.isLive_()) {\n      // The HLS spec (RFC 8216) states in 6.3.4:\n      // \"the client MUST wait for at least the target duration before\n      // attempting to reload the Playlist file again\".\n      // For LL-HLS, the server must add a new partial segment to the Playlist\n      // every part target duration.\n      this.updatePlaylistDelay_ = this.minTargetDuration_;\n\n      // The spec says nothing much about seeking in live content, but Safari's\n      // built-in HLS implementation does not allow it.  Therefore we will set\n      // the availability window equal to the presentation delay.  The player\n      // will be able to buffer ahead three segments, but the seek window will\n      // be zero-sized.\n      const PresentationType = shaka.hls.HlsParser.PresentationType_;\n\n      if (this.presentationType_ == PresentationType.LIVE) {\n        // This defaults to the presentation delay, which has the effect of\n        // making the live stream unseekable.  This is consistent with Apple's\n        // HLS implementation.\n        let segmentAvailabilityDuration = this.presentationTimeline_.getDelay();\n\n        // The app can override that with a longer duration, to allow seeking.\n        if (!isNaN(this.config_.availabilityWindowOverride)) {\n          segmentAvailabilityDuration = this.config_.availabilityWindowOverride;\n        }\n\n        this.presentationTimeline_.setSegmentAvailabilityDuration(\n            segmentAvailabilityDuration);\n      }\n    } else {\n      // For VOD/EVENT content, offset everything back to 0.\n      // Use the minimum timestamp as the offset for all streams.\n      // Use the minimum duration as the presentation duration.\n      this.presentationTimeline_.setDuration(minDuration);\n      // Use a negative offset to adjust towards 0.\n      this.presentationTimeline_.offset(-minFirstTimestamp);\n\n      for (const streamInfo of this.uriToStreamInfosMap_.values()) {\n        // The segments were created with actual media times, rather than\n        // presentation-aligned times, so offset them all now.\n        streamInfo.stream.segmentIndex.offset(-minFirstTimestamp);\n        // Finally, fit the segments to the playlist duration.\n        streamInfo.stream.segmentIndex.fit(/* periodStart= */ 0, minDuration);\n      }\n    }\n\n    // Now that the content has been fit, notify segments.\n    this.segmentsToNotifyByStream_ = [];\n    const streamsToNotify = [];\n    for (const variant of variants) {\n      for (const stream of [variant.video, variant.audio]) {\n        if (stream) {\n          streamsToNotify.push(stream);\n        }\n      }\n    }\n    await Promise.all(streamsToNotify.map(async (stream) => {\n      await stream.createSegmentIndex();\n    }));\n    for (const stream of streamsToNotify) {\n      this.segmentsToNotifyByStream_.push(stream.segmentIndex.references);\n    }\n\n    this.notifySegments_();\n\n    // This is the first point where we have a meaningful presentation start\n    // time, and we need to tell PresentationTimeline that so that it can\n    // maintain consistency from here on.\n    this.presentationTimeline_.lockStartTime();\n\n    // This asserts that the live edge is being calculated from segment times.\n    // For VOD and event streams, this check should still pass.\n    goog.asserts.assert(\n        !this.presentationTimeline_.usingPresentationStartTime(),\n        'We should not be using the presentation start time in HLS!');\n\n    this.manifest_ = {\n      presentationTimeline: this.presentationTimeline_,\n      variants,\n      textStreams,\n      imageStreams,\n      offlineSessionIds: [],\n      minBufferTime: 0,\n    };\n    this.playerInterface_.makeTextStreamsForClosedCaptions(this.manifest_);\n  }\n\n  /**\n   * Get the variables of each variant tag, and store in a map.\n   * @param {!Array.<!shaka.hls.Tag>} tags Variant tags from the playlist.\n   * @private\n   */\n  parseMasterVariables_(tags) {\n    for (const variableTag of tags) {\n      const name = variableTag.getAttributeValue('NAME');\n      const value = variableTag.getAttributeValue('VALUE');\n      if (name && value) {\n        if (!this.globalVariables_.has(name)) {\n          this.globalVariables_.set(name, value);\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the variables of each variant tag, and store in a map.\n   * @param {!Array.<!shaka.hls.Tag>} tags Variant tags from the playlist.\n   * @return {!Map.<string, string>}\n   * @private\n   */\n  parseMediaVariables_(tags) {\n    const mediaVariables = new Map();\n    for (const variableTag of tags) {\n      const name = variableTag.getAttributeValue('NAME');\n      const value = variableTag.getAttributeValue('VALUE');\n      const mediaImport = variableTag.getAttributeValue('IMPORT');\n      if (name && value) {\n        mediaVariables.set(name, value);\n      }\n      if (mediaImport) {\n        const globalValue = this.globalVariables_.get(mediaImport);\n        if (globalValue) {\n          mediaVariables.set(mediaImport, globalValue);\n        }\n      }\n    }\n    return mediaVariables;\n  }\n\n  /**\n   * Get the codecs of each variant tag, and store in a map from\n   * audio/video/subtitle group id to the codecs arraylist.\n   * @param {!Array.<!shaka.hls.Tag>} tags Variant tags from the playlist.\n   * @private\n   */\n  parseCodecs_(tags) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    for (const variantTag of tags) {\n      const audioGroupId = variantTag.getAttributeValue('AUDIO');\n      const videoGroupId = variantTag.getAttributeValue('VIDEO');\n      const subGroupId = variantTag.getAttributeValue('SUBTITLES');\n      const allCodecs = this.getCodecsForVariantTag_(variantTag);\n\n      if (subGroupId) {\n        const textCodecs = shaka.util.ManifestParserUtils.guessCodecsSafe(\n            ContentType.TEXT, allCodecs);\n        goog.asserts.assert(textCodecs != null, 'Text codecs should be valid.');\n        this.groupIdToCodecsMap_.set(subGroupId, textCodecs);\n        shaka.util.ArrayUtils.remove(allCodecs, textCodecs);\n      }\n      if (audioGroupId) {\n        let codecs = shaka.util.ManifestParserUtils.guessCodecsSafe(\n            ContentType.AUDIO, allCodecs);\n        if (!codecs) {\n          codecs = this.config_.hls.defaultAudioCodec;\n        }\n        this.groupIdToCodecsMap_.set(audioGroupId, codecs);\n      }\n      if (videoGroupId) {\n        let codecs = shaka.util.ManifestParserUtils.guessCodecsSafe(\n            ContentType.VIDEO, allCodecs);\n        if (!codecs) {\n          codecs = this.config_.hls.defaultVideoCodec;\n        }\n        this.groupIdToCodecsMap_.set(videoGroupId, codecs);\n      }\n    }\n  }\n\n  /**\n   * Parse Subtitles and Closed Captions from 'EXT-X-MEDIA' tags.\n   * Create text streams for Subtitles, but not Closed Captions.\n   *\n   * @param {!Array.<!shaka.hls.Tag>} mediaTags Media tags from the playlist.\n   * @return {!Promise.<!Array.<!shaka.extern.Stream>>}\n   * @private\n   */\n  async parseTexts_(mediaTags) {\n    // Create text stream for each Subtitle media tag.\n    const subtitleTags =\n        shaka.hls.Utils.filterTagsByType(mediaTags, 'SUBTITLES');\n    const textStreamPromises = subtitleTags.map(async (tag) => {\n      const disableText = this.config_.disableText;\n      if (disableText) {\n        return null;\n      }\n      try {\n        const streamInfo = await this.createStreamInfoFromMediaTag_(tag);\n        goog.asserts.assert(\n            streamInfo, 'Should always have a streamInfo for text');\n        return streamInfo.stream;\n      } catch (e) {\n        if (this.config_.hls.ignoreTextStreamFailures) {\n          return null;\n        }\n        throw e;\n      }\n    });\n    const textStreams = await Promise.all(textStreamPromises);\n\n    // Set the codecs for text streams.\n    for (const tag of subtitleTags) {\n      const groupId = tag.getRequiredAttrValue('GROUP-ID');\n      const codecs = this.groupIdToCodecsMap_.get(groupId);\n      if (codecs) {\n        const textStreamInfos = this.groupIdToStreamInfosMap_.get(groupId);\n        if (textStreamInfos) {\n          for (const textStreamInfo of textStreamInfos) {\n            textStreamInfo.stream.codecs = codecs;\n          }\n        }\n      }\n    }\n\n    // Do not create text streams for Closed captions.\n    return textStreams.filter((s) => s);\n  }\n\n  /**\n   * @param {!Array.<!shaka.hls.Tag>} imageTags from the playlist.\n   * @return {!Promise.<!Array.<!shaka.extern.Stream>>}\n   * @private\n   */\n  async parseImages_(imageTags) {\n    // Create image stream for each image tag.\n    const imageStreamPromises = imageTags.map(async (tag) => {\n      const disableThumbnails = this.config_.disableThumbnails;\n      if (disableThumbnails) {\n        return null;\n      }\n      try {\n        const streamInfo = await this.createStreamInfoFromImageTag_(tag);\n        goog.asserts.assert(\n            streamInfo, 'Should always have a streamInfo for image');\n        return streamInfo.stream;\n      } catch (e) {\n        if (this.config_.hls.ignoreImageStreamFailures) {\n          return null;\n        }\n        throw e;\n      }\n    });\n    const imageStreams = await Promise.all(imageStreamPromises);\n    return imageStreams.filter((s) => s);\n  }\n\n  /**\n   * @param {!Array.<!shaka.hls.Tag>} mediaTags Media tags from the playlist.\n   * @private\n   */\n  async createStreamInfosFromMediaTags_(mediaTags) {\n    // Filter out subtitles and  media tags without uri.\n    mediaTags = mediaTags.filter((tag) => {\n      const uri = tag.getAttributeValue('URI') || '';\n      const type = tag.getAttributeValue('TYPE');\n      return type != 'SUBTITLES' && uri != '';\n    });\n\n    // Create stream info for each audio / video media tag.\n    // Wait for the first stream info created, so that the start time is fetched\n    // and can be reused.\n    if (mediaTags.length) {\n      await this.createStreamInfoFromMediaTag_(mediaTags[0]);\n    }\n    const promises = mediaTags.slice(1).map((tag) => {\n      return this.createStreamInfoFromMediaTag_(tag);\n    });\n    await Promise.all(promises);\n  }\n\n  /**\n   * @param {!Array.<!shaka.hls.Tag>} tags Variant tags from the playlist.\n   * @return {!Promise.<!Array.<!shaka.extern.Variant>>}\n   * @private\n   */\n  async createVariantsForTags_(tags) {\n    // Create variants for each variant tag.\n    const variantsPromises = tags.map(async (tag) => {\n      const frameRate = tag.getAttributeValue('FRAME-RATE');\n      const bandwidth = Number(tag.getAttributeValue('AVERAGE-BANDWIDTH')) ||\n        Number(tag.getRequiredAttrValue('BANDWIDTH'));\n\n      const resolution = tag.getAttributeValue('RESOLUTION');\n      const [width, height] = resolution ? resolution.split('x') : [null, null];\n\n      const videoRange = tag.getAttributeValue('VIDEO-RANGE');\n\n      const streamInfos = await this.createStreamInfosForVariantTag_(tag,\n          resolution, frameRate, bandwidth);\n\n      if (streamInfos) {\n        goog.asserts.assert(streamInfos.audio.length ||\n            streamInfos.video.length, 'We should have created a stream!');\n\n        return this.createVariants_(\n            streamInfos.audio,\n            streamInfos.video,\n            bandwidth,\n            width,\n            height,\n            frameRate,\n            videoRange);\n      }\n      // We do not support AES-128 encryption with HLS yet. If the streamInfos\n      // is null because of AES-128 encryption, do not create variants for that.\n      return [];\n    });\n\n    const allVariants = await Promise.all(variantsPromises);\n    let variants = allVariants.reduce(shaka.util.Functional.collapseArrays, []);\n    // Filter out null variants.\n    variants = variants.filter((variant) => variant != null);\n    return variants;\n  }\n\n  /**\n   * Create audio and video streamInfos from an 'EXT-X-STREAM-INF' tag and its\n   * related media tags.\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @param {?string} resolution\n   * @param {?string} frameRate\n   * @param {number} bandwidth\n   * @return {!Promise.<?shaka.hls.HlsParser.StreamInfos>}\n   * @private\n   */\n  async createStreamInfosForVariantTag_(tag, resolution, frameRate, bandwidth) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    /** @type {!Array.<string>} */\n    let allCodecs = this.getCodecsForVariantTag_(tag);\n    const audioGroupId = tag.getAttributeValue('AUDIO');\n    const videoGroupId = tag.getAttributeValue('VIDEO');\n    goog.asserts.assert(audioGroupId == null || videoGroupId == null,\n        'Unexpected: both video and audio described by media tags!');\n\n    const groupId = audioGroupId || videoGroupId;\n    const streamInfos =\n        (groupId && this.groupIdToStreamInfosMap_.has(groupId)) ?\n        this.groupIdToStreamInfosMap_.get(groupId) : [];\n\n    /** @type {shaka.hls.HlsParser.StreamInfos} */\n    const res = {\n      audio: audioGroupId ? streamInfos : [],\n      video: videoGroupId ? streamInfos : [],\n    };\n\n    // Make an educated guess about the stream type.\n    shaka.log.debug('Guessing stream type for', tag.toString());\n    let type;\n    let ignoreStream = false;\n\n    // The Microsoft HLS manifest generators will make audio-only variants\n    // that link to their URI both directly and through an audio tag.\n    // In that case, ignore the local URI and use the version in the\n    // AUDIO tag, so you inherit its language.\n    // As an example, see the manifest linked in issue #860.\n    const streamURI = tag.getRequiredAttrValue('URI');\n    const hasSameUri = res.audio.find((audio) => {\n      return audio && audio.verbatimMediaPlaylistUri == streamURI;\n    });\n\n    const videoCodecs = shaka.util.ManifestParserUtils.guessCodecsSafe(\n        ContentType.VIDEO, allCodecs);\n    const audioCodecs = shaka.util.ManifestParserUtils.guessCodecsSafe(\n        ContentType.AUDIO, allCodecs);\n\n    if (audioCodecs && !videoCodecs) {\n      // There are no associated media tags, and there's only audio codec,\n      // and no video codec, so it should be audio.\n      type = ContentType.AUDIO;\n      shaka.log.debug('Guessing audio-only.');\n    } else if (!streamInfos.length && audioCodecs && videoCodecs) {\n      // There are both audio and video codecs, so assume multiplexed content.\n      // Note that the default used when CODECS is missing assumes multiple\n      // (and therefore multiplexed).\n      // Recombine the codec strings into one so that MediaSource isn't\n      // lied to later. (That would trigger an error in Chrome.)\n      shaka.log.debug('Guessing multiplexed audio+video.');\n      type = ContentType.VIDEO;\n      allCodecs = [[videoCodecs, audioCodecs].join(',')];\n    } else if (res.audio.length && hasSameUri) {\n      shaka.log.debug('Guessing audio-only.');\n      type = ContentType.AUDIO;\n      ignoreStream = true;\n    } else if (res.video.length && !res.audio.length) {\n      // There are associated video streams.  Assume this is audio.\n      shaka.log.debug('Guessing audio-only.');\n      type = ContentType.AUDIO;\n    } else {\n      shaka.log.debug('Guessing video-only.');\n      type = ContentType.VIDEO;\n    }\n\n    let streamInfo;\n    if (!ignoreStream) {\n      streamInfo =\n          await this.createStreamInfoFromVariantTag_(tag, allCodecs, type,\n              bandwidth);\n    }\n    if (streamInfo) {\n      res[streamInfo.stream.type] = [streamInfo];\n    } else if (streamInfo === null) {\n      // Triple-equals for undefined.\n      shaka.log.debug('streamInfo is null');\n      return null;\n    }\n    this.filterLegacyCodecs_(res);\n    return res;\n  }\n\n\n  /**\n   * Get the codecs from the 'EXT-X-STREAM-INF' tag.\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @return {!Array.<string>} codecs\n   * @private\n   */\n  getCodecsForVariantTag_(tag) {\n    // These are the default codecs to assume if none are specified.\n    const defaultCodecsArray = [];\n    if (!this.config_.disableVideo) {\n      defaultCodecsArray.push(this.config_.hls.defaultVideoCodec);\n    }\n    if (!this.config_.disableAudio) {\n      defaultCodecsArray.push(this.config_.hls.defaultAudioCodec);\n    }\n    const defaultCodecs = defaultCodecsArray.join(',');\n\n    const codecsString = tag.getAttributeValue('CODECS', defaultCodecs);\n    // Strip out internal whitespace while splitting on commas:\n    /** @type {!Array.<string>} */\n    const codecs = codecsString.split(/\\s*,\\s*/);\n\n    // Filter out duplicate codecs.\n    const seen = new Set();\n    const ret = [];\n    for (const codec of codecs) {\n      // HLS says the CODECS field needs to include all codecs that appear in\n      // the content. This means that if the content changes profiles, it should\n      // include both. Since all known browsers support changing profiles\n      // without any other work, just ignore them.  See also:\n      // https://github.com/shaka-project/shaka-player/issues/1817\n      const shortCodec = shaka.util.MimeUtils.getCodecBase(codec);\n      if (!seen.has(shortCodec)) {\n        ret.push(codec);\n        seen.add(shortCodec);\n      } else {\n        shaka.log.debug('Ignoring duplicate codec');\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * Get the channel count information for an HLS audio track.\n   * CHANNELS specifies an ordered, \"/\" separated list of parameters.\n   * If the type is audio, the first parameter will be a decimal integer\n   * specifying the number of independent, simultaneous audio channels.\n   * No other channels parameters are currently defined.\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @return {?number}\n   * @private\n   */\n  getChannelsCount_(tag) {\n    const channels = tag.getAttributeValue('CHANNELS');\n    if (!channels) {\n      return null;\n    }\n    const channelcountstring = channels.split('/')[0];\n    const count = parseInt(channelcountstring, 10);\n    return count;\n  }\n\n  /**\n   * Get the spatial audio information for an HLS audio track.\n   * In HLS the channels field indicates the number of audio channels that the\n   * stream has (eg: 2). In the case of Dolby Atmos, the complexity is\n   * expressed with the number of channels followed by the word JOC\n   * (eg: 16/JOC), so 16 would be the number of channels (eg: 7.3.6 layout),\n   * and JOC indicates that the stream has spatial audio.\n   * @see https://developer.apple.com/documentation/http_live_streaming/hls_authoring_specification_for_apple_devices/hls_authoring_specification_for_apple_devices_appendixes\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @return {boolean}\n   * @private\n   */\n  isSpatialAudio_(tag) {\n    const channels = tag.getAttributeValue('CHANNELS');\n    if (!channels) {\n      return false;\n    }\n    return channels.includes('/JOC');\n  }\n\n  /**\n   * Get the closed captions map information for the EXT-X-STREAM-INF tag, to\n   * create the stream info.\n   * @param {!shaka.hls.Tag} tag\n   * @param {string} type\n   * @return {Map.<string, string>} closedCaptions\n   * @private\n   */\n  getClosedCaptions_(tag, type) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    // The attribute of closed captions is optional, and the value may be\n    // 'NONE'.\n    const closedCaptionsAttr = tag.getAttributeValue('CLOSED-CAPTIONS');\n\n    // EXT-X-STREAM-INF tags may have CLOSED-CAPTIONS attributes.\n    // The value can be either a quoted-string or an enumerated-string with\n    // the value NONE. If the value is a quoted-string, it MUST match the\n    // value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the\n    // Playlist whose TYPE attribute is CLOSED-CAPTIONS.\n    if (type == ContentType.VIDEO && closedCaptionsAttr &&\n    closedCaptionsAttr != 'NONE') {\n      return this.groupIdToClosedCaptionsMap_.get(closedCaptionsAttr);\n    }\n    return null;\n  }\n\n  /**\n   * Get the language value.\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @return {string}\n   * @private\n   */\n  getLanguage_(tag) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n    const languageValue = tag.getAttributeValue('LANGUAGE') || 'und';\n    return LanguageUtils.normalize(languageValue);\n  }\n\n  /**\n   * Get the type value.\n   * Shaka recognizes the content types 'audio', 'video' and 'text'.\n   * The HLS 'subtitles' type needs to be mapped to 'text'.\n   * @param {!shaka.hls.Tag} tag\n   * @return {string}\n   * @private\n   */\n  getType_(tag) {\n    let type = tag.getRequiredAttrValue('TYPE').toLowerCase();\n    if (type == 'subtitles') {\n      type = shaka.util.ManifestParserUtils.ContentType.TEXT;\n    }\n    return type;\n  }\n\n  /**\n   * Filters out unsupported codec strings from an array of stream infos.\n   * @param {shaka.hls.HlsParser.StreamInfos} streamInfos\n   * @private\n   */\n  filterLegacyCodecs_(streamInfos) {\n    for (const streamInfo of streamInfos.audio.concat(streamInfos.video)) {\n      if (!streamInfo) {\n        continue;\n      }\n      let codecs = streamInfo.stream.codecs.split(',');\n      codecs = codecs.filter((codec) => {\n        // mp4a.40.34 is a nonstandard codec string that is sometimes used in\n        // HLS for legacy reasons.  It is not recognized by non-Apple MSE.\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489520\n        // Therefore, ignore this codec string.\n        return codec != 'mp4a.40.34';\n      });\n      streamInfo.stream.codecs = codecs.join(',');\n    }\n  }\n\n  /**\n   * @param {!Array.<shaka.hls.HlsParser.StreamInfo>} audioInfos\n   * @param {!Array.<shaka.hls.HlsParser.StreamInfo>} videoInfos\n   * @param {number} bandwidth\n   * @param {?string} width\n   * @param {?string} height\n   * @param {?string} frameRate\n   * @param {?string} videoRange\n   * @return {!Array.<!shaka.extern.Variant>}\n   * @private\n   */\n  createVariants_(\n      audioInfos, videoInfos, bandwidth, width, height, frameRate, videoRange) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const DrmEngine = shaka.media.DrmEngine;\n\n    for (const info of videoInfos) {\n      this.addVideoAttributes_(\n          info.stream, width, height, frameRate, videoRange);\n    }\n\n    // In case of audio-only or video-only content or the audio/video is\n    // disabled by the config, we create an array of one item containing\n    // a null. This way, the double-loop works for all kinds of content.\n    // NOTE: we currently don't have support for audio-only content.\n    const disableAudio = this.config_.disableAudio;\n    if (!audioInfos.length || disableAudio) {\n      audioInfos = [null];\n    }\n    const disableVideo = this.config_.disableVideo;\n    if (!videoInfos.length || disableVideo) {\n      videoInfos = [null];\n    }\n\n    const variants = [];\n    for (const audioInfo of audioInfos) {\n      for (const videoInfo of videoInfos) {\n        const audioStream = audioInfo ? audioInfo.stream : null;\n        const videoStream = videoInfo ? videoInfo.stream : null;\n        const audioDrmInfos = audioInfo ? audioInfo.stream.drmInfos : null;\n        const videoDrmInfos = videoInfo ? videoInfo.stream.drmInfos : null;\n        const videoStreamUri =\n            videoInfo ? videoInfo.verbatimMediaPlaylistUri : '';\n        const audioStreamUri =\n            audioInfo ? audioInfo.verbatimMediaPlaylistUri : '';\n        const variantUriKey = videoStreamUri + ' - ' + audioStreamUri;\n\n        if (audioStream && videoStream) {\n          if (!DrmEngine.areDrmCompatible(audioDrmInfos, videoDrmInfos)) {\n            shaka.log.warning(\n                'Incompatible DRM info in HLS variant.  Skipping.');\n            continue;\n          }\n        }\n\n        if (this.variantUriSet_.has(variantUriKey)) {\n          // This happens when two variants only differ in their text streams.\n          shaka.log.debug(\n              'Skipping variant which only differs in text streams.');\n          continue;\n        }\n\n        // Since both audio and video are of the same type, this assertion will\n        // catch certain mistakes at runtime that the compiler would miss.\n        goog.asserts.assert(!audioStream ||\n            audioStream.type == ContentType.AUDIO, 'Audio parameter mismatch!');\n        goog.asserts.assert(!videoStream ||\n            videoStream.type == ContentType.VIDEO, 'Video parameter mismatch!');\n\n        const variant = {\n          id: this.globalId_++,\n          language: audioStream ? audioStream.language : 'und',\n          primary: (!!audioStream && audioStream.primary) ||\n              (!!videoStream && videoStream.primary),\n          audio: audioStream,\n          video: videoStream,\n          bandwidth,\n          allowedByApplication: true,\n          allowedByKeySystem: true,\n          decodingInfos: [],\n        };\n\n        variants.push(variant);\n        this.variantUriSet_.add(variantUriKey);\n      }\n    }\n    return variants;\n  }\n\n  /**\n   * Parses an array of EXT-X-MEDIA tags, then stores the values of all tags\n   * with TYPE=\"CLOSED-CAPTIONS\" into a map of group id to closed captions.\n   *\n   * @param {!Array.<!shaka.hls.Tag>} mediaTags\n   * @private\n   */\n  parseClosedCaptions_(mediaTags) {\n    const closedCaptionsTags =\n        shaka.hls.Utils.filterTagsByType(mediaTags, 'CLOSED-CAPTIONS');\n    for (const tag of closedCaptionsTags) {\n      goog.asserts.assert(tag.name == 'EXT-X-MEDIA',\n          'Should only be called on media tags!');\n      const language = this.getLanguage_(tag);\n\n      // The GROUP-ID value is a quoted-string that specifies the group to which\n      // the Rendition belongs.\n      const groupId = tag.getRequiredAttrValue('GROUP-ID');\n\n      // The value of INSTREAM-ID is a quoted-string that specifies a Rendition\n      // within the segments in the Media Playlist. This attribute is REQUIRED\n      // if the TYPE attribute is CLOSED-CAPTIONS.\n      const instreamId = tag.getRequiredAttrValue('INSTREAM-ID');\n      if (!this.groupIdToClosedCaptionsMap_.get(groupId)) {\n        this.groupIdToClosedCaptionsMap_.set(groupId, new Map());\n      }\n      this.groupIdToClosedCaptionsMap_.get(groupId).set(instreamId, language);\n    }\n  }\n\n  /**\n   * Parse EXT-X-MEDIA media tag into a Stream object.\n   *\n   * @param {shaka.hls.Tag} tag\n   * @return {!Promise.<?shaka.hls.HlsParser.StreamInfo>}\n   * @private\n   */\n  async createStreamInfoFromMediaTag_(tag) {\n    goog.asserts.assert(tag.name == 'EXT-X-MEDIA',\n        'Should only be called on media tags!');\n    const groupId = tag.getRequiredAttrValue('GROUP-ID');\n    let codecs = '';\n    /** @type {string} */\n    const type = this.getType_(tag);\n    // Text does not require a codec.\n    if (type != shaka.util.ManifestParserUtils.ContentType.TEXT && groupId &&\n        this.groupIdToCodecsMap_.has(groupId)) {\n      codecs = this.groupIdToCodecsMap_.get(groupId);\n    }\n\n    const verbatimMediaPlaylistUri = this.variableSubstitution_(\n        tag.getRequiredAttrValue('URI'), this.globalVariables_);\n\n    // Check if the stream has already been created as part of another Variant\n    // and return it if it has.\n    if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n    }\n\n    const language = this.getLanguage_(tag);\n    const name = tag.getAttributeValue('NAME');\n\n    // NOTE: According to the HLS spec, \"DEFAULT=YES\" requires \"AUTOSELECT=YES\".\n    // However, we don't bother to validate \"AUTOSELECT\", since we don't\n    // actually use it in our streaming model, and we treat everything as\n    // \"AUTOSELECT=YES\".  A value of \"AUTOSELECT=NO\" would imply that it may\n    // only be selected explicitly by the user, and we don't have a way to\n    // represent that in our model.\n    const defaultAttrValue = tag.getAttributeValue('DEFAULT');\n    const primary = defaultAttrValue == 'YES';\n\n    const channelsCount = type == 'audio' ? this.getChannelsCount_(tag) : null;\n    const spatialAudio = type == 'audio' ? this.isSpatialAudio_(tag) : false;\n    const characteristics = tag.getAttributeValue('CHARACTERISTICS');\n\n    const forcedAttrValue = tag.getAttributeValue('FORCED');\n    const forced = forcedAttrValue == 'YES';\n    // TODO: Should we take into account some of the currently ignored\n    // attributes: INSTREAM-ID, Attribute descriptions: https://bit.ly/2lpjOhj\n    const streamInfo = await this.createStreamInfo_(\n        verbatimMediaPlaylistUri, codecs, type, language, primary, name,\n        channelsCount, /* closedCaptions= */ null, characteristics, forced,\n        spatialAudio);\n    if (this.groupIdToStreamInfosMap_.has(groupId)) {\n      this.groupIdToStreamInfosMap_.get(groupId).push(streamInfo);\n    } else {\n      this.groupIdToStreamInfosMap_.set(groupId, [streamInfo]);\n    }\n    if (streamInfo == null) {\n      return null;\n    }\n\n    // TODO: This check is necessary because of the possibility of multiple\n    // calls to createStreamInfoFromMediaTag_ before either has resolved.\n    if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n    }\n    this.uriToStreamInfosMap_.set(verbatimMediaPlaylistUri, streamInfo);\n    return streamInfo;\n  }\n\n  /**\n   * Parse EXT-X-MEDIA media tag into a Stream object.\n   *\n   * @param {shaka.hls.Tag} tag\n   * @return {!Promise.<?shaka.hls.HlsParser.StreamInfo>}\n   * @private\n   */\n  async createStreamInfoFromImageTag_(tag) {\n    goog.asserts.assert(tag.name == 'EXT-X-IMAGE-STREAM-INF',\n        'Should only be called on image tags!');\n    /** @type {string} */\n    const type = shaka.util.ManifestParserUtils.ContentType.IMAGE;\n\n    const verbatimImagePlaylistUri = this.variableSubstitution_(\n        tag.getRequiredAttrValue('URI'), this.globalVariables_);\n    const codecs = tag.getAttributeValue('CODECS', 'jpeg') || '';\n\n    // Check if the stream has already been created as part of another Variant\n    // and return it if it has.\n    if (this.uriToStreamInfosMap_.has(verbatimImagePlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimImagePlaylistUri);\n    }\n\n    const language = this.getLanguage_(tag);\n    const name = tag.getAttributeValue('NAME');\n\n    const characteristics = tag.getAttributeValue('CHARACTERISTICS');\n\n    const streamInfo = await this.createStreamInfo_(\n        verbatimImagePlaylistUri, codecs, type, language, /* primary= */ false,\n        name, /* channelsCount= */ null, /* closedCaptions= */ null,\n        characteristics, /* forced= */ false, /* spatialAudio= */ false);\n    if (streamInfo == null) {\n      return null;\n    }\n\n    // TODO: This check is necessary because of the possibility of multiple\n    // calls to createStreamInfoFromImageTag_ before either has resolved.\n    if (this.uriToStreamInfosMap_.has(verbatimImagePlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimImagePlaylistUri);\n    }\n\n    // Parse misc attributes.\n    const resolution = tag.getAttributeValue('RESOLUTION');\n    if (resolution) {\n      // The RESOLUTION tag represents the resolution of a single thumbnail, not\n      // of the entire sheet at once (like we expect in the output).\n      // So multiply by the layout size.\n\n      const reference = streamInfo.stream.segmentIndex.get(0);\n      const layout = reference.getTilesLayout();\n      if (layout) {\n        streamInfo.stream.width =\n            Number(resolution.split('x')[0]) * Number(layout.split('x')[0]);\n        streamInfo.stream.height =\n            Number(resolution.split('x')[1]) * Number(layout.split('x')[1]);\n        // TODO: What happens if there are multiple grids, with different\n        // layout sizes, inside this image stream?\n      }\n    }\n    const bandwidth = tag.getAttributeValue('BANDWIDTH');\n    if (bandwidth) {\n      streamInfo.stream.bandwidth = Number(bandwidth);\n    }\n\n    this.uriToStreamInfosMap_.set(verbatimImagePlaylistUri, streamInfo);\n    return streamInfo;\n  }\n\n  /**\n   * Parse an EXT-X-STREAM-INF media tag into a Stream object.\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @param {!Array.<string>} allCodecs\n   * @param {string} type\n   * @param {number} bandwidth\n   * @return {!Promise.<?shaka.hls.HlsParser.StreamInfo>}\n   * @private\n   */\n  async createStreamInfoFromVariantTag_(tag, allCodecs, type, bandwidth) {\n    goog.asserts.assert(tag.name == 'EXT-X-STREAM-INF',\n        'Should only be called on variant tags!');\n    const verbatimMediaPlaylistUri = this.variableSubstitution_(\n        tag.getRequiredAttrValue('URI'), this.globalVariables_);\n\n    if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n    }\n\n    const closedCaptions = this.getClosedCaptions_(tag, type);\n    const codecs = shaka.util.ManifestParserUtils.guessCodecs(type, allCodecs);\n    const streamInfo = await this.createStreamInfo_(verbatimMediaPlaylistUri,\n        codecs, type, /* language= */ 'und', /* primary= */ false,\n        /* name= */ null, /* channelcount= */ null, closedCaptions,\n        /* characteristics= */ null, /* forced= */ false,\n        /* spatialAudio= */ false, bandwidth);\n    if (streamInfo == null) {\n      return null;\n    }\n    // TODO: This check is necessary because of the possibility of multiple\n    // calls to createStreamInfoFromVariantTag_ before either has resolved.\n    if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n    }\n\n    this.uriToStreamInfosMap_.set(verbatimMediaPlaylistUri, streamInfo);\n    return streamInfo;\n  }\n\n\n  /**\n   * @param {string} verbatimMediaPlaylistUri\n   * @param {string} codecs\n   * @param {string} type\n   * @param {string} language\n   * @param {boolean} primary\n   * @param {?string} name\n   * @param {?number} channelsCount\n   * @param {Map.<string, string>} closedCaptions\n   * @param {?string} characteristics\n   * @param {boolean} forced\n   * @param {boolean} spatialAudio\n   * @param {(number|undefined)} bandwidth\n   * @return {!Promise.<?shaka.hls.HlsParser.StreamInfo>}\n   * @private\n   */\n  async createStreamInfo_(verbatimMediaPlaylistUri, codecs, type, language,\n      primary, name, channelsCount, closedCaptions, characteristics, forced,\n      spatialAudio, bandwidth = undefined) {\n    // TODO: Refactor, too many parameters\n    let absoluteMediaPlaylistUri = shaka.hls.Utils.constructAbsoluteUri(\n        this.masterPlaylistUri_, verbatimMediaPlaylistUri);\n\n    const response = await this.requestManifest_(absoluteMediaPlaylistUri);\n    // Record the final URI after redirects.\n    absoluteMediaPlaylistUri = response.uri;\n\n    // Record the redirected, final URI of this media playlist when we parse it.\n    /** @type {!shaka.hls.Playlist} */\n    const playlist = this.manifestTextParser_.parsePlaylist(\n        response.data, absoluteMediaPlaylistUri);\n\n    if (playlist.type != shaka.hls.PlaylistType.MEDIA) {\n      // EXT-X-MEDIA and EXT-X-IMAGE-STREAM-INF tags should point to media\n      // playlists.\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY);\n    }\n\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const drmTags = [];\n    if (playlist.segments) {\n      for (const segment of playlist.segments) {\n        const segmentKeyTags = shaka.hls.Utils.filterTagsByName(segment.tags,\n            'EXT-X-KEY');\n        drmTags.push(...segmentKeyTags);\n      }\n    }\n\n    let encrypted = false;\n    /** @type {!Array.<shaka.extern.DrmInfo>}*/\n    const drmInfos = [];\n    const keyIds = new Set();\n\n    // TODO: May still need changes to support key rotation.\n    for (const drmTag of drmTags) {\n      const method = drmTag.getRequiredAttrValue('METHOD');\n      if (method != 'NONE') {\n        encrypted = true;\n\n        // We do not support AES-128 encryption with HLS yet. So, do not create\n        // StreamInfo for the playlist encrypted with AES-128.\n        // TODO: Remove the error message once we add support for AES-128.\n        if (method == 'AES-128') {\n          shaka.log.warning('Unsupported HLS Encryption', method);\n          this.aesEncrypted_ = true;\n          return null;\n        }\n\n        const keyFormat = drmTag.getRequiredAttrValue('KEYFORMAT');\n        const drmParser =\n            shaka.hls.HlsParser.KEYFORMATS_TO_DRM_PARSERS_[keyFormat];\n\n        const drmInfo = drmParser ? drmParser(drmTag) : null;\n        if (drmInfo) {\n          if (drmInfo.keyIds) {\n            for (const keyId of drmInfo.keyIds) {\n              keyIds.add(keyId);\n            }\n          }\n          drmInfos.push(drmInfo);\n        } else {\n          shaka.log.warning('Unsupported HLS KEYFORMAT', keyFormat);\n        }\n      }\n    }\n\n    if (encrypted && !drmInfos.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_KEYFORMATS_NOT_SUPPORTED);\n    }\n\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const variablesTags = shaka.hls.Utils.filterTagsByName(playlist.tags,\n        'EXT-X-DEFINE');\n\n    const mediaVariables = this.parseMediaVariables_(variablesTags);\n\n    goog.asserts.assert(playlist.segments != null,\n        'Media playlist should have segments!');\n\n    this.determinePresentationType_(playlist);\n\n    /** @type {string} */\n    const mimeType = await this.guessMimeType_(type, codecs, playlist,\n        mediaVariables);\n\n    // MediaSource expects no codec strings combined with raw formats.\n    // TODO(#2337): Instead, create a Stream flag indicating a raw format.\n    if (shaka.hls.HlsParser.RAW_FORMATS_.includes(mimeType)) {\n      codecs = '';\n    }\n\n    /** @type {!Map.<number, number>} */\n    const mediaSequenceToStartTime = new Map();\n\n    /**\n     * A map of a discontinuity sequence number, to the first segment's media\n     * sequence number with the discontinuity sequence number.\n     * Key: the discontinuity sequence number of a few segments\n     * Value: the first segment's media sequence number of the segments with\n     * this discontinuity sequence number.\n     * Used to get the discontinuity sequence number with playlist delta\n     * updates with lowLatencyMode enabled.\n     * {!Map.<number, number>}\n     */\n    const discontinuityToMediaSequence = new Map();\n\n    const prevLowLatencyMode = this.lowLatencyMode_;\n    let segments;\n    try {\n      segments = await this.createSegments_(verbatimMediaPlaylistUri,\n          playlist, type, mimeType, mediaSequenceToStartTime, mediaVariables,\n          discontinuityToMediaSequence, codecs, bandwidth);\n    } catch (error) {\n      if (error.code == shaka.util.Error.Code.HLS_INTERNAL_SKIP_STREAM) {\n        shaka.log.alwaysWarn('Skipping unsupported HLS stream',\n            mimeType, verbatimMediaPlaylistUri);\n        return null;\n      }\n\n      throw error;\n    }\n\n    // This happens when autoLowLatencyMode is true, so we need set the\n    // correct lowLatencyPresentationDelay_\n    if (prevLowLatencyMode != this.lowLatencyMode_) {\n      this.determinePresentationType_(playlist);\n    }\n\n    const minTimestamp = segments[0].startTime;\n    const lastEndTime = segments[segments.length - 1].endTime;\n    /** @type {!shaka.media.SegmentIndex} */\n    const segmentIndex = new shaka.media.SegmentIndex(segments);\n\n    const kind = (type == shaka.util.ManifestParserUtils.ContentType.TEXT) ?\n        shaka.util.ManifestParserUtils.TextStreamKind.SUBTITLE : undefined;\n\n    const roles = [];\n    if (characteristics) {\n      for (const characteristic of characteristics.split(',')) {\n        roles.push(characteristic);\n      }\n    }\n\n    const serverControlTag = shaka.hls.Utils.getFirstTagWithName(\n        playlist.tags, 'EXT-X-SERVER-CONTROL');\n    const canSkipSegments = serverControlTag ?\n          serverControlTag.getAttribute('CAN-SKIP-UNTIL') != null : false;\n\n    /** @type {shaka.extern.Stream} */\n    const stream = {\n      id: this.globalId_++,\n      originalId: name,\n      createSegmentIndex: () => Promise.resolve(),\n      segmentIndex,\n      mimeType,\n      codecs,\n      kind,\n      encrypted,\n      drmInfos,\n      keyIds,\n      language,\n      label: name,  // For historical reasons, since before \"originalId\".\n      type,\n      primary,\n      // TODO: trick mode\n      trickModeVideo: null,\n      emsgSchemeIdUris: null,\n      frameRate: undefined,\n      pixelAspectRatio: undefined,\n      width: undefined,\n      height: undefined,\n      bandwidth: undefined,\n      roles: roles,\n      forced: forced,\n      channelsCount,\n      audioSamplingRate: null,\n      spatialAudio: spatialAudio,\n      closedCaptions,\n      hdr: undefined,\n      tilesLayout: undefined,\n    };\n\n    return {\n      stream,\n      verbatimMediaPlaylistUri,\n      absoluteMediaPlaylistUri,\n      minTimestamp,\n      maxTimestamp: lastEndTime,\n      mediaSequenceToStartTime,\n      discontinuityToMediaSequence,\n      canSkipSegments,\n    };\n  }\n\n\n  /**\n   * @param {!shaka.hls.Playlist} playlist\n   * @private\n   */\n  determinePresentationType_(playlist) {\n    const PresentationType = shaka.hls.HlsParser.PresentationType_;\n    const presentationTypeTag =\n        shaka.hls.Utils.getFirstTagWithName(playlist.tags,\n            'EXT-X-PLAYLIST-TYPE');\n    const endListTag =\n        shaka.hls.Utils.getFirstTagWithName(playlist.tags, 'EXT-X-ENDLIST');\n\n    const isVod = (presentationTypeTag && presentationTypeTag.value == 'VOD') ||\n        endListTag;\n    const isEvent = presentationTypeTag &&\n        presentationTypeTag.value == 'EVENT' && !isVod;\n    const isLive = !isVod && !isEvent;\n\n    if (isVod) {\n      this.setPresentationType_(PresentationType.VOD);\n    } else {\n      // If it's not VOD, it must be presentation type LIVE or an ongoing EVENT.\n      if (isLive) {\n        this.setPresentationType_(PresentationType.LIVE);\n      } else {\n        this.setPresentationType_(PresentationType.EVENT);\n      }\n\n      const targetDurationTag = this.getRequiredTag_(playlist.tags,\n          'EXT-X-TARGETDURATION');\n      const targetDuration = Number(targetDurationTag.value);\n      const partialTargetDurationTag =\n        shaka.hls.Utils.getFirstTagWithName(playlist.tags, 'EXT-X-PART-INF');\n      // According to the HLS spec, updates should not happen more often than\n      // once in targetDuration.  It also requires us to only update the active\n      // variant.  We might implement that later, but for now every variant\n      // will be updated.  To get the update period, choose the smallest\n      // targetDuration value across all playlists.\n      // 1. Update the shortest one to use as update period and segment\n      // availability time (for LIVE).\n      if (this.lowLatencyMode_ && partialTargetDurationTag) {\n        // For low latency streaming, use the partial segment target duration.\n        this.partialTargetDuration_ = Number(\n            partialTargetDurationTag.getRequiredAttrValue('PART-TARGET'));\n        this.minTargetDuration_ = Math.min(\n            this.partialTargetDuration_, this.minTargetDuration_);\n        // Get the server-recommended min distance from the live edge.\n        const serverControlTag = shaka.hls.Utils.getFirstTagWithName(\n            playlist.tags, 'EXT-X-SERVER-CONTROL');\n        // Use 'PART-HOLD-BACK' as the presentation delay for low latency mode.\n        this.lowLatencyPresentationDelay_ = serverControlTag ? Number(\n            serverControlTag.getRequiredAttrValue('PART-HOLD-BACK')) : 0;\n      } else {\n        // For regular HLS, use the target duration of regular segments.\n        this.minTargetDuration_ = Math.min(\n            targetDuration, this.minTargetDuration_);\n      }\n      // 2. Update the longest target duration if need be to use as a\n      // presentation delay later.\n      this.maxTargetDuration_ = Math.max(\n          targetDuration, this.maxTargetDuration_);\n    }\n  }\n\n  /**\n   * @private\n   */\n  createPresentationTimeline_() {\n    if (this.isLive_()) {\n      // The live edge will be calculated from segments, so we don't need to\n      // set a presentation start time.  We will assert later that this is\n      // working as expected.\n\n      // The HLS spec (RFC 8216) states in 6.3.3:\n      //\n      // \"The client SHALL choose which Media Segment to play first ... the\n      // client SHOULD NOT choose a segment that starts less than three target\n      // durations from the end of the Playlist file.  Doing so can trigger\n      // playback stalls.\"\n      //\n      // We accomplish this in our DASH-y model by setting a presentation\n      // delay of configured value, or 3 segments duration if not configured.\n      // This will be the \"live edge\" of the presentation.\n      let presentationDelay;\n      if (this.config_.defaultPresentationDelay) {\n        presentationDelay = this.config_.defaultPresentationDelay;\n      } else if (this.lowLatencyPresentationDelay_) {\n        presentationDelay = this.lowLatencyPresentationDelay_;\n      } else {\n        presentationDelay = this.maxTargetDuration_ * 3;\n      }\n\n      this.presentationTimeline_ = new shaka.media.PresentationTimeline(\n      /* presentationStartTime= */ 0, /* delay= */ presentationDelay);\n      this.presentationTimeline_.setStatic(false);\n    } else {\n      this.presentationTimeline_ = new shaka.media.PresentationTimeline(\n      /* presentationStartTime= */ null, /* delay= */ 0);\n      this.presentationTimeline_.setStatic(true);\n    }\n  }\n\n  /**\n   * Get the InitSegmentReference for a segment if it has a EXT-X-MAP tag.\n   * @param {string} playlistUri The absolute uri of the media playlist.\n   * @param {!Array.<!shaka.hls.Tag>} tags Segment tags\n   * @param {!Map.<string, string>} variables\n   * @return {shaka.media.InitSegmentReference}\n   * @private\n   */\n  getInitSegmentReference_(playlistUri, tags, variables) {\n    /** @type {?shaka.hls.Tag} */\n    const mapTag = shaka.hls.Utils.getFirstTagWithName(tags, 'EXT-X-MAP');\n\n    if (!mapTag) {\n      return null;\n    }\n    // Map tag example: #EXT-X-MAP:URI=\"main.mp4\",BYTERANGE=\"720@0\"\n    const verbatimInitSegmentUri = mapTag.getRequiredAttrValue('URI');\n    const absoluteInitSegmentUri = this.variableSubstitution_(\n        shaka.hls.Utils.constructAbsoluteUri(\n            playlistUri, verbatimInitSegmentUri),\n        variables);\n\n    const mapTagKey = [\n      absoluteInitSegmentUri,\n      mapTag.getAttributeValue('BYTERANGE', ''),\n    ].join('-');\n    if (!this.mapTagToInitSegmentRefMap_.has(mapTagKey)) {\n      const initSegmentRef = this.createInitSegmentReference_(\n          absoluteInitSegmentUri, mapTag);\n      this.mapTagToInitSegmentRefMap_.set(mapTagKey, initSegmentRef);\n    }\n    return this.mapTagToInitSegmentRefMap_.get(mapTagKey);\n  }\n\n  /**\n   * Create an InitSegmentReference object for the EXT-X-MAP tag in the media\n   * playlist.\n   * @param {string} absoluteInitSegmentUri\n   * @param {!shaka.hls.Tag} mapTag EXT-X-MAP\n   * @return {!shaka.media.InitSegmentReference}\n   * @private\n   */\n  createInitSegmentReference_(absoluteInitSegmentUri, mapTag) {\n    let startByte = 0;\n    let endByte = null;\n    const byterange = mapTag.getAttributeValue('BYTERANGE');\n    // If a BYTERANGE attribute is not specified, the segment consists\n    // of the entire resource.\n    if (byterange) {\n      const blocks = byterange.split('@');\n      const byteLength = Number(blocks[0]);\n      startByte = Number(blocks[1]);\n      endByte = startByte + byteLength - 1;\n    }\n\n    const initSegmentRef = new shaka.media.InitSegmentReference(\n        () => [absoluteInitSegmentUri],\n        startByte,\n        endByte);\n    return initSegmentRef;\n  }\n\n  /**\n   * Parses one shaka.hls.Segment object into a shaka.media.SegmentReference.\n   *\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {shaka.media.SegmentReference} previousReference\n   * @param {!shaka.hls.Segment} hlsSegment\n   * @param {number} startTime\n   * @param {number} timestampOffset\n   * @param {!Map.<string, string>} variables\n   * @param {string} absoluteMediaPlaylistUri\n   * @param {string} type\n   * @return {shaka.media.SegmentReference}\n   * @private\n   */\n  createSegmentReference_(\n      initSegmentReference, previousReference, hlsSegment, startTime,\n      timestampOffset, variables, absoluteMediaPlaylistUri, type) {\n    const tags = hlsSegment.tags;\n    const absoluteSegmentUri = this.variableSubstitution_(\n        hlsSegment.absoluteUri, variables);\n    const extinfTag =\n        shaka.hls.Utils.getFirstTagWithName(tags, 'EXTINF');\n\n    let endTime = 0;\n    let startByte = 0;\n    let endByte = null;\n\n    if (!extinfTag) {\n      if (hlsSegment.partialSegments.length == 0) {\n        // EXTINF tag must be available if the segment has no partial segments.\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.HLS_REQUIRED_TAG_MISSING, 'EXTINF');\n      } else if (!this.lowLatencyMode_) {\n        // Without EXTINF and without low-latency mode, partial segments get\n        // ignored.\n        return null;\n      }\n    }\n\n    // Create SegmentReferences for the partial segments.\n    const partialSegmentRefs = [];\n    if (this.lowLatencyMode_) {\n      for (let i = 0; i < hlsSegment.partialSegments.length; i++) {\n        const item = hlsSegment.partialSegments[i];\n        const pPreviousReference = i == 0 ?\n          previousReference : partialSegmentRefs[partialSegmentRefs.length - 1];\n        const pStartTime = (i == 0) ? startTime : pPreviousReference.endTime;\n\n        // If DURATION is missing from this partial segment, use the target\n        // partial duration from the top of the playlist, which is a required\n        // attribute for content with partial segments.\n        const pDuration = Number(item.getAttributeValue('DURATION')) ||\n            this.partialTargetDuration_;\n\n        // If for some reason we have neither an explicit duration, nor a target\n        // partial duration, we should SKIP this partial segment to avoid\n        // duplicating content in the presentation timeline.\n        if (!pDuration) {\n          continue;\n        }\n\n        const pEndTime = pStartTime + pDuration;\n\n        let pStartByte = 0;\n        let pEndByte = null;\n        if (item.name == 'EXT-X-PRELOAD-HINT') {\n          // A preload hinted partial segment may have byterange start info.\n          const pByterangeStart = item.getAttributeValue('BYTERANGE-START');\n          pStartByte = pByterangeStart ? Number(pByterangeStart) : 0;\n        } else {\n          const pByterange = item.getAttributeValue('BYTERANGE');\n          [pStartByte, pEndByte] =\n            this.parseByteRange_(pPreviousReference, pByterange);\n        }\n        const pUri = item.getAttributeValue('URI');\n        if (!pUri) {\n          continue;\n        }\n        const pAbsoluteUri = shaka.hls.Utils.constructAbsoluteUri(\n            absoluteMediaPlaylistUri, pUri);\n\n        const partial = new shaka.media.SegmentReference(\n            pStartTime,\n            pEndTime,\n            () => [pAbsoluteUri],\n            pStartByte,\n            pEndByte,\n            initSegmentReference,\n            timestampOffset,\n            /* appendWindowStart= */ 0,\n            /* appendWindowEnd= */ Infinity);\n        partialSegmentRefs.push(partial);\n      } // for-loop of hlsSegment.partialSegments\n    }\n\n    // If the segment has EXTINF tag, set the segment's end time, start byte\n    // and end byte based on the duration and byterange information.\n    // Otherwise, calculate the end time, start / end byte based on its partial\n    // segments.\n    // Note that the sum of partial segments durations may be slightly different\n    // from the parent segment's duration. In this case, use the duration from\n    // the parent segment tag.\n    if (extinfTag) {\n      // The EXTINF tag format is '#EXTINF:<duration>,[<title>]'.\n      // We're interested in the duration part.\n      const extinfValues = extinfTag.value.split(',');\n      const duration = Number(extinfValues[0]);\n      endTime = startTime + duration;\n    } else {\n      endTime = partialSegmentRefs[partialSegmentRefs.length - 1].endTime;\n    }\n\n    // If the segment has EXT-X-BYTERANGE tag, set the start byte and end byte\n    // base on the byterange information. If segment has no EXT-X-BYTERANGE tag\n    // and has partial segments, set the start byte and end byte base on the\n    // partial segments.\n    const byterangeTag =\n         shaka.hls.Utils.getFirstTagWithName(tags, 'EXT-X-BYTERANGE');\n    if (byterangeTag) {\n      [startByte, endByte] =\n          this.parseByteRange_(previousReference, byterangeTag.value);\n    } else if (partialSegmentRefs.length) {\n      startByte = partialSegmentRefs[0].startByte;\n      endByte = partialSegmentRefs[partialSegmentRefs.length - 1].endByte;\n    }\n\n    let tilesLayout = '';\n    let tileDuration = null;\n    if (type == shaka.util.ManifestParserUtils.ContentType.IMAGE) {\n      // By default in HLS the tilesLayout is 1x1\n      tilesLayout = '1x1';\n      const tilesTag =\n          shaka.hls.Utils.getFirstTagWithName(tags, 'EXT-X-TILES');\n      if (tilesTag) {\n        tilesLayout = tilesTag.getRequiredAttrValue('LAYOUT');\n        const duration = tilesTag.getAttributeValue('DURATION');\n        if (duration) {\n          tileDuration = Number(duration);\n        }\n      }\n    }\n\n    return new shaka.media.SegmentReference(\n        startTime,\n        endTime,\n        () => absoluteSegmentUri.length ? [absoluteSegmentUri] : [],\n        startByte,\n        endByte,\n        initSegmentReference,\n        timestampOffset,\n        /* appendWindowStart= */ 0,\n        /* appendWindowEnd= */ Infinity,\n        partialSegmentRefs,\n        tilesLayout,\n        tileDuration,\n    );\n  }\n\n\n  /**\n   * Parse the startByte and endByte.\n   * @param {shaka.media.SegmentReference} previousReference\n   * @param {?string} byterange\n   * @return {!Array.<number>} An array with the start byte and end byte.\n   * @private\n   */\n  parseByteRange_(previousReference, byterange) {\n    let startByte = 0;\n    let endByte = null;\n    // If BYTERANGE is not specified, the segment consists of the entire\n    // resource.\n    if (byterange) {\n      const blocks = byterange.split('@');\n      const byteLength = Number(blocks[0]);\n      if (blocks[1]) {\n        startByte = Number(blocks[1]);\n      } else {\n        goog.asserts.assert(previousReference,\n            'Cannot refer back to previous HLS segment!');\n        startByte = previousReference.endByte + 1;\n      }\n      endByte = startByte + byteLength - 1;\n    }\n    return [startByte, endByte];\n  }\n\n  /** @private */\n  notifySegments_() {\n    // The presentation timeline may or may not be set yet.\n    // If it does not yet exist, hold onto the segments until it does.\n    if (!this.presentationTimeline_) {\n      return;\n    }\n    for (const segments of this.segmentsToNotifyByStream_) {\n      this.presentationTimeline_.notifySegments(segments);\n    }\n    this.segmentsToNotifyByStream_ = [];\n  }\n\n  /**\n   * Parses shaka.hls.Segment objects into shaka.media.SegmentReferences.\n   *\n   * @param {string} verbatimMediaPlaylistUri\n   * @param {!shaka.hls.Playlist} playlist\n   * @param {string} type\n   * @param {string} mimeType\n   * @param {!Map.<number, number>} mediaSequenceToStartTime\n   * @param {!Map.<string, string>} variables\n   * @param {!Map.<number, number>} discontinuityToMediaSequence\n   * @param {string} codecs\n   * @param {(number|undefined)} bandwidth\n   * @return {!Promise<!Array.<!shaka.media.SegmentReference>>}\n   * @private\n   */\n  async createSegments_(verbatimMediaPlaylistUri, playlist, type, mimeType,\n      mediaSequenceToStartTime, variables, discontinuityToMediaSequence,\n      codecs, bandwidth) {\n    /** @type {Array.<!shaka.hls.Segment>} */\n    const hlsSegments = playlist.segments;\n    goog.asserts.assert(hlsSegments.length, 'Playlist should have segments!');\n\n    /** @type {shaka.media.InitSegmentReference} */\n    let initSegmentRef;\n\n    // We may need to look at the media itself to determine a segment start\n    // time.\n    const mediaSequenceNumber = shaka.hls.Utils.getFirstTagWithNameAsNumber(\n        playlist.tags, 'EXT-X-MEDIA-SEQUENCE', 0);\n    const skipTag = shaka.hls.Utils.getFirstTagWithName(playlist.tags,\n        'EXT-X-SKIP');\n    const skippedSegments =\n        skipTag ? Number(skipTag.getAttributeValue('SKIPPED-SEGMENTS')) : 0;\n    let position = mediaSequenceNumber + skippedSegments;\n    let firstStartTime;\n    // For live stream, use the cached value in the mediaSequenceToStartTime\n    // map if available.\n    // Since createSegments_() is asynchronous and we are updating the streams\n    // in parallel, the global playlistStartTime_ may get updated by other\n    // playlist updates rather than the current one.\n\n    if (this.isLive_() && mediaSequenceToStartTime.has(position)) {\n      firstStartTime = mediaSequenceToStartTime.get(position);\n    } else {\n      if (this.playlistStartTime_ == null) {\n        // For VOD and EVENT playlists, all variants must start at the same\n        // time, so we can fetch the start time once and reuse for the others.\n        // This is not guaranteed when updating a LIVE stream. We assume the\n        // first segment in each live playlist is no more than one segment out\n        // of sync with the other playlists, so we can fetch the start time for\n        // once.\n        initSegmentRef = this.getInitSegmentReference_(\n            playlist.absoluteUri, hlsSegments[0].tags, variables);\n        goog.asserts.assert(\n            type != shaka.util.ManifestParserUtils.ContentType.TEXT &&\n            type != shaka.util.ManifestParserUtils.ContentType.IMAGE,\n            'Should only get start time from audio or video streams');\n        this.playlistStartTime_ = await this.getStartTime_(\n            verbatimMediaPlaylistUri, initSegmentRef, mimeType,\n            position, /* isDiscontinuity= */ false,\n            hlsSegments[0], variables, type, codecs, bandwidth);\n      }\n      firstStartTime = this.playlistStartTime_;\n    }\n\n    const firstSegmentUri = hlsSegments[0].absoluteUri;\n    shaka.log.debug('First segment', firstSegmentUri.split('/').pop(),\n        'starts at', firstStartTime);\n\n    let discontintuitySequenceNum = shaka.hls.Utils.getFirstTagWithNameAsNumber(\n        playlist.tags, 'EXT-X-DISCONTINUITY-SEQUENCE');\n    if (this.lowLatencyMode_) {\n      if (!discontinuityToMediaSequence.has(discontintuitySequenceNum)) {\n        discontinuityToMediaSequence.set(discontintuitySequenceNum, position);\n      }\n      if (skippedSegments) {\n        // With delta updates, the DISCONTINUITY may be skipped. Check if\n        // the discontintuity Sequence Number based on the media sequence\n        // number.\n        const disconMap = discontinuityToMediaSequence;\n        while (disconMap.has(discontintuitySequenceNum + 1) &&\n            disconMap.get(discontintuitySequenceNum + 1) < position) {\n          discontintuitySequenceNum++;\n        }\n      }\n    }\n    let timestampOffset =\n        this.discontinuityToTso_.get(discontintuitySequenceNum) || 0;\n\n    /** @type {!Array.<!shaka.media.SegmentReference>} */\n    const references = [];\n\n    for (let i = 0; i < hlsSegments.length; i++) {\n      const item = hlsSegments[i];\n      const previousReference = references[references.length - 1];\n      const startTime = (i == 0) ? firstStartTime :\n        previousReference.endTime;\n      position = mediaSequenceNumber + skippedSegments + i;\n\n      mediaSequenceToStartTime.set(position, startTime);\n\n      initSegmentRef = this.getInitSegmentReference_(playlist.absoluteUri,\n          item.tags, variables);\n\n      const discontintuityTag = shaka.hls.Utils.getFirstTagWithName(item.tags,\n          'EXT-X-DISCONTINUITY');\n      if (discontintuityTag) {\n        discontintuitySequenceNum++;\n        discontinuityToMediaSequence.set(discontintuitySequenceNum, position);\n\n        // eslint-disable-next-line no-await-in-loop\n        timestampOffset = await this.getTimestampOffset_(\n            discontintuitySequenceNum, verbatimMediaPlaylistUri, initSegmentRef,\n            mimeType, position, item, variables, startTime, type, codecs,\n            bandwidth);\n      }\n\n      // If the stream is low latency and the user has not configured the\n      // lowLatencyMode, but if it has been configured to activate the\n      // lowLatencyMode if a stream of this type is detected, we automatically\n      // activate the lowLatencyMode.\n      if (!this.lowLatencyMode_) {\n        const autoLowLatencyMode = this.playerInterface_.isAutoLowLatencyMode();\n        if (autoLowLatencyMode) {\n          this.playerInterface_.enableLowLatencyMode();\n          this.lowLatencyMode_ = this.playerInterface_.isLowLatencyMode();\n        }\n      }\n\n      const extinfTag =\n          shaka.hls.Utils.getFirstTagWithName(item.tags, 'EXTINF');\n      if (this.lowLatencyMode_ || extinfTag) {\n        const reference = this.createSegmentReference_(\n            initSegmentRef,\n            previousReference,\n            item,\n            startTime,\n            timestampOffset,\n            variables,\n            playlist.absoluteUri,\n            type);\n\n        if (reference) {\n          references.push(reference);\n        }\n      } else if (!this.lowLatencyMode_) {\n        // If a segment has no extinfTag, it must contain partial segments.\n        shaka.log.alwaysWarn('Low-latency HLS live stream detected, but ' +\n          'low-latency streaming mode is not enabled in Shaka Player. ' +\n          'Set streaming.lowLatencyMode configuration to true, and see ' +\n          'https://bit.ly/3clctcj for details.');\n      }\n    }\n\n    return references;\n  }\n\n  /**\n   * Gets the start time of the first segment of the playlist from existing\n   * value (if possible) or by downloading it and parsing it otherwise.\n   *\n   * @param {number} discontintuitySequenceNum\n   * @param {string} verbatimMediaPlaylistUri\n   * @param {shaka.media.InitSegmentReference} initSegmentRef\n   * @param {string} mimeType\n   * @param {number} mediaSequenceNumber\n   * @param {!shaka.hls.Segment} segment\n   * @param {!Map.<string, string>} variables\n   * @param {number} startTime\n   * @param {string} type\n   * @param {string} codecs\n   * @param {number|undefined} bandwidth\n   * @return {!Promise.<number>}\n   * @throws {shaka.util.Error}\n   * @private\n   */\n  async getTimestampOffset_(discontintuitySequenceNum,\n      verbatimMediaPlaylistUri, initSegmentRef,\n      mimeType, mediaSequenceNumber, segment, variables, startTime, type,\n      codecs, bandwidth) {\n    let timestampOffset = 0;\n    if (this.discontinuityToTso_.has(discontintuitySequenceNum)) {\n      timestampOffset =\n          this.discontinuityToTso_.get(discontintuitySequenceNum);\n    } else {\n      const mediaStartTime = await this.getStartTime_(\n          verbatimMediaPlaylistUri, initSegmentRef, mimeType,\n          mediaSequenceNumber, /* isDiscontinuity= */ true, segment,\n          variables, type, codecs, bandwidth);\n      timestampOffset = startTime - mediaStartTime;\n      shaka.log.v1('Segment timestampOffset =', timestampOffset);\n      this.discontinuityToTso_.set(\n          discontintuitySequenceNum, timestampOffset);\n    }\n    return timestampOffset;\n  }\n\n  /**\n   * Try to fetch the starting part of a segment, and fall back to a full\n   * segment if we have to.\n   *\n   * @param {!shaka.media.AnySegmentReference} reference\n   * @param {string} type\n   * @param {string} mimeType\n   * @param {string} codecs\n   * @param {number|undefined} bandwidth\n   * @return {!Promise.<shaka.extern.Response>}\n   * @private\n   */\n  async fetchStartOfSegment_(reference, type, mimeType, codecs, bandwidth) {\n    const requestType = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n    // Create two requests:\n    //  1. A partial request meant to fetch the smallest part of the segment\n    //     required to get the time stamp.\n    //  2. A full request meant as a fallback for when the server does not\n    //     support partial requests.\n    const fullRequest = shaka.util.Networking.createSegmentRequest(\n        reference.getUris(),\n        reference.startByte,\n        reference.endByte,\n        this.config_.retryParameters);\n\n    // We can only add partial CMCD data here because the stream\n    // and manifest objects are still being created\n    this.playerInterface_.modifySegmentRequest(\n        fullRequest,\n        {\n          type: type,\n          init: reference instanceof shaka.media.InitSegmentReference,\n          duration: reference.endTime - reference.startTime,\n          mimeType: mimeType,\n          codecs: codecs,\n          bandwidth: bandwidth,\n        },\n    );\n\n    if (this.config_.hls.useFullSegmentsForStartTime) {\n      return this.makeNetworkRequest_(fullRequest, requestType);\n    }\n\n    const partialRequest = shaka.util.Networking.createSegmentRequest(\n        reference.getUris(),\n        reference.startByte,\n        reference.startByte + shaka.hls.HlsParser.START_OF_SEGMENT_SIZE_ - 1,\n        this.config_.retryParameters);\n\n    this.playerInterface_.modifySegmentRequest(\n        partialRequest,\n        {\n          type: type,\n          init: reference instanceof shaka.media.InitSegmentReference,\n          duration: reference.endTime - reference.startTime,\n          mimeType: mimeType,\n          codecs: codecs,\n          bandwidth: bandwidth,\n        },\n    );\n\n    // TODO(vaage): The need to do fall back requests is not likely to be unique\n    //    to here. It would be nice if the fallback(s) could be included into\n    //    the same abortable operation as the original request.\n    //\n    //    What would need to change with networking engine to support requests\n    //    with fallback(s)?\n    try {\n      const response = await this.makeNetworkRequest_(\n          partialRequest, requestType);\n\n      return response;\n    } catch (e) {\n      // If the networking operation was aborted, we don't want to treat it as\n      // a request failure. We surface the error so that the OPERATION_ABORTED\n      // error will be handled correctly.\n      if (e.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n        throw e;\n      }\n\n      // The partial request may fail for a number of reasons.\n      // Some servers do not support Range requests, and others do not support\n      // the OPTIONS request which must be made before any cross-origin Range\n      // request.  Since this fallback is expensive, warn the app developer.\n      shaka.log.alwaysWarn('Unable to fetch the starting part of HLS ' +\n                           'segment! Falling back to a full segment request, ' +\n                           'which is expensive!  Your server should ' +\n                           'support Range requests and CORS preflights.',\n      partialRequest.uris[0]);\n\n      const response = await this.makeNetworkRequest_(fullRequest, requestType);\n\n      return response;\n    }\n  }\n\n  /**\n   * Gets the start time of a segment from the existing manifest (if possible)\n   * or by downloading it and parsing it otherwise.\n   *\n   * @param {string} verbatimMediaPlaylistUri\n   * @param {shaka.media.InitSegmentReference} initSegmentRef\n   * @param {string} mimeType\n   * @param {number} mediaSequenceNumber\n   * @param {boolean} isDiscontinuity\n   * @param {!shaka.hls.Segment} segment\n   * @param {!Map.<string, string>} variables\n   * @param {string} type\n   * @param {string} codecs\n   * @param {number|undefined} bandwidth\n   * @return {!Promise.<number>}\n   * @private\n   */\n  async getStartTime_(\n      verbatimMediaPlaylistUri, initSegmentRef, mimeType, mediaSequenceNumber,\n      isDiscontinuity, segment, variables, type, codecs, bandwidth) {\n    const segmentRef = this.createSegmentReference_(\n        initSegmentRef,\n        /* previousReference= */ null,\n        segment,\n        /* startTime= */ 0,\n        /* timestampOffset= */ 0,\n        variables,\n        /* absoluteMediaPlaylistUri= */ '',\n        type);\n    goog.asserts.assert(\n        segmentRef != null, 'Segment reference should not be null!');\n\n    // If we are updating the manifest, we can usually skip fetching the segment\n    // by examining the references we already have.  This won't be possible if\n    // there was some kind of lag or delay updating the manifest on the server,\n    // in which extreme case we would fall back to fetching a segment.  This\n    // allows us to both avoid fetching segments when possible, and recover from\n    // certain server-side issues gracefully.\n    // Do not use cached start time for the segments with discontinuity tags.\n    if (this.manifest_ && !isDiscontinuity) {\n      const streamInfo =\n          this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n      const startTime = streamInfo.mediaSequenceToStartTime.get(\n          mediaSequenceNumber);\n      if (startTime != undefined) {\n        // We found it!  Avoid fetching and parsing the segment.\n        shaka.log.v1('Found segment start time in previous manifest',\n            startTime);\n        return startTime;\n      }\n\n      shaka.log.debug(\n          'Unable to find segment start time in previous manifest!');\n    }\n\n    // TODO: Introduce a new tag to extend HLS and provide the first segment's\n    // start time.  This will avoid the need for these fetches in content\n    // packaged with Shaka Packager.  This web-friendly extension to HLS can\n    // then be proposed to Apple for inclusion in a future version of HLS.\n    // See https://github.com/google/shaka-packager/issues/294\n\n    shaka.log.v1('Fetching segment to find start time');\n    mimeType = mimeType.toLowerCase();\n\n    if (shaka.hls.HlsParser.RAW_FORMATS_.includes(mimeType)) {\n      // Raw formats contain no timestamps.  Even if there is an ID3 tag with a\n      // timestamp, that's not going to be honored by MediaSource, which will\n      // use sequence mode for these segments.  We don't yet support sequence\n      // mode, so we must reject these streams.\n      // TODO(#2337): Support sequence mode and align raw format timestamps to\n      // other streams.\n      shaka.log.alwaysWarn(\n          'Raw formats are not yet supported.  Skipping ' + mimeType);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_INTERNAL_SKIP_STREAM);\n    }\n\n    if (mimeType == 'video/webm') {\n      shaka.log.alwaysWarn('WebM in HLS is not yet supported.  Skipping.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_INTERNAL_SKIP_STREAM);\n    }\n\n    if (mimeType == 'video/mp4' || mimeType == 'audio/mp4') {\n      // We also need the init segment to get the correct timescale. But if the\n      // stream is self-initializing, use the same response for both.\n      const fetches = [this.fetchStartOfSegment_(\n          segmentRef,\n          type,\n          mimeType,\n          codecs,\n          bandwidth,\n      )];\n\n      if (initSegmentRef) {\n        fetches.push(this.fetchStartOfSegment_(\n            initSegmentRef,\n            type,\n            mimeType,\n            codecs,\n            bandwidth,\n        ));\n      }\n\n      const responses = await Promise.all(fetches);\n\n      // If the stream is self-initializing, use the main segment in-place of\n      // the init segment.\n      const segmentResponse = responses[0];\n      const initSegmentResponse = responses[1] || responses[0];\n\n      return this.getStartTimeFromMp4Segment_(\n          verbatimMediaPlaylistUri, segmentResponse.uri,\n          segmentResponse.data, initSegmentResponse.data);\n    }\n\n    if (mimeType == 'video/mp2t') {\n      const response = await this.fetchStartOfSegment_(\n          segmentRef,\n          type,\n          mimeType,\n          codecs,\n          bandwidth,\n      );\n      goog.asserts.assert(response.data, 'Should have a response body!');\n      return this.getStartTimeFromTsSegment_(\n          verbatimMediaPlaylistUri, response.uri, response.data);\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_COULD_NOT_PARSE_SEGMENT_START_TIME,\n        verbatimMediaPlaylistUri);\n  }\n\n  /**\n   * Parses an mp4 segment to get its start time.\n   *\n   * @param {string} playlistUri\n   * @param {string} segmentUri\n   * @param {BufferSource} mediaData\n   * @param {BufferSource} initData\n   * @return {number}\n   * @private\n   */\n  getStartTimeFromMp4Segment_(playlistUri, segmentUri, mediaData, initData) {\n    const Mp4Parser = shaka.util.Mp4Parser;\n\n    let timescale = 0;\n    new Mp4Parser()\n        .box('moov', Mp4Parser.children)\n        .box('trak', Mp4Parser.children)\n        .box('mdia', Mp4Parser.children)\n        .fullBox('mdhd', (box) => {\n          goog.asserts.assert(\n              box.version == 0 || box.version == 1,\n              'MDHD version can only be 0 or 1');\n\n          const parsedMDHDBox = shaka.util.Mp4BoxParsers.parseMDHD(\n              box.reader, box.version);\n\n          timescale = parsedMDHDBox.timescale;\n          box.parser.stop();\n        }).parse(initData, /* partialOkay= */ true);\n\n    if (!timescale) {\n      shaka.log.error('Unable to find timescale in init segment!');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_COULD_NOT_PARSE_SEGMENT_START_TIME,\n          playlistUri, segmentUri);\n    }\n\n    let startTime = 0;\n    let parsedMedia = false;\n    new Mp4Parser()\n        .box('moof', Mp4Parser.children)\n        .box('traf', Mp4Parser.children)\n        .fullBox('tfdt', (box) => {\n          goog.asserts.assert(\n              box.version == 0 || box.version == 1,\n              'TFDT version can only be 0 or 1');\n\n          const parsedTFDTBox = shaka.util.Mp4BoxParsers.parseTFDT(\n              box.reader, box.version);\n          const baseTime = parsedTFDTBox.baseMediaDecodeTime;\n          startTime = baseTime / timescale;\n          parsedMedia = true;\n          box.parser.stop();\n        }).parse(mediaData, /* partialOkay= */ true);\n\n    if (!parsedMedia) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_COULD_NOT_PARSE_SEGMENT_START_TIME,\n          playlistUri, segmentUri);\n    }\n    return startTime;\n  }\n\n  /**\n   * Parses a TS segment to get its start time.\n   *\n   * @param {string} playlistUri\n   * @param {string} segmentUri\n   * @param {BufferSource} data\n   * @return {number}\n   * @private\n   */\n  getStartTimeFromTsSegment_(playlistUri, segmentUri, data) {\n    const reader = new shaka.util.DataViewReader(\n        data, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n    const fail = () => {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_COULD_NOT_PARSE_SEGMENT_START_TIME,\n          playlistUri, segmentUri);\n    };\n\n    let packetStart = 0;\n    let syncByte = 0;\n\n    const skipPacket = () => {\n      // 188-byte packets are standard, so assume that.\n      reader.seek(packetStart + 188);\n      syncByte = reader.readUint8();\n      if (syncByte != 0x47) {\n        // We haven't found the sync byte, so try it as a 192-byte packet.\n        reader.seek(packetStart + 192);\n        syncByte = reader.readUint8();\n      }\n      if (syncByte != 0x47) {\n        // We still haven't found the sync byte, so try as a 204-byte packet.\n        reader.seek(packetStart + 204);\n        syncByte = reader.readUint8();\n      }\n      if (syncByte != 0x47) {\n        // We still haven't found the sync byte, so the packet was of a\n        // non-standard size.\n        fail();\n      }\n      // Put the sync byte back so we can read it in the next loop.\n      reader.rewind(1);\n    };\n\n    // We will look a few packet-lengths forward to find the first sync byte.\n    // Note that we are using this method on what is already a subset of the\n    // file (the first |shaka.hls.HlsParser.START_OF_SEGMENT_SIZE_| bytes), so\n    // we can't look too far ahead to begin with.\n    let syncByteScanLength = Math.min(reader.getLength() - 188, 5 * 188);\n\n    // TODO: refactor this while loop for better readability.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Format reference: https://bit.ly/TsPacket\n      packetStart = reader.getPosition();\n\n      syncByte = reader.readUint8();\n      if (syncByte != 0x47) {\n        if (syncByteScanLength > 0) {\n          // This file could have started with a cut-off TS packet. Scan forward\n          // until we find a sync byte.\n          syncByteScanLength -= 1;\n          continue;\n        }\n        fail();\n      }\n      // If we've found a sync byte, stop scanning forward for future packets.\n      syncByteScanLength = 0;\n\n      const flagsAndPacketId = reader.readUint16();\n      const packetId = flagsAndPacketId & 0x1fff;\n      if (packetId == 0x1fff) {\n        // A \"null\" TS packet.  Skip this TS packet and try again.\n        skipPacket();\n        continue;\n      }\n\n      const hasPesPacket = flagsAndPacketId & 0x4000;\n      if (!hasPesPacket) {\n        // Not a PES packet yet.  Skip this TS packet and try again.\n        skipPacket();\n        continue;\n      }\n\n      const flags = reader.readUint8();\n      const adaptationFieldControl = (flags & 0x30) >> 4;\n      if (adaptationFieldControl == 0 /* reserved */ ||\n          adaptationFieldControl == 2 /* adaptation field, no payload */) {\n        fail();\n      }\n\n      if (adaptationFieldControl == 3) {\n        // Skip over adaptation field.\n        const length = reader.readUint8();\n        reader.skip(length);\n      }\n\n      // Now we come to the PES header (hopefully).\n      // Format reference: https://bit.ly/TsPES\n      const startCode = reader.readUint32();\n      const startCodePrefix = startCode >> 8;\n      if (startCodePrefix != 1) {\n        // Not a PES packet yet.  Skip this TS packet and try again.\n        skipPacket();\n        continue;\n      }\n\n      // Skip the 16-bit PES length and the first 8 bits of the optional header.\n      reader.skip(3);\n      // The next 8 bits contain flags about DTS & PTS.\n      const ptsDtsIndicator = reader.readUint8() >> 6;\n      if (ptsDtsIndicator == 0 /* no timestamp */ ||\n          ptsDtsIndicator == 1 /* forbidden */) {\n        fail();\n      }\n\n      const pesHeaderLengthRemaining = reader.readUint8();\n      if (pesHeaderLengthRemaining == 0) {\n        fail();\n      }\n\n      if (ptsDtsIndicator == 2 /* PTS only */) {\n        goog.asserts.assert(pesHeaderLengthRemaining == 5, 'Bad PES header?');\n      } else if (ptsDtsIndicator == 3 /* PTS and DTS */) {\n        goog.asserts.assert(pesHeaderLengthRemaining == 10, 'Bad PES header?');\n      }\n\n      const pts0 = reader.readUint8();\n      const pts1 = reader.readUint16();\n      const pts2 = reader.readUint16();\n      // Reconstruct 33-bit PTS from the 5-byte, padded structure.\n      const ptsHigh3 = (pts0 & 0x0e) >> 1;\n      const ptsLow30 = ((pts1 & 0xfffe) << 14) | ((pts2 & 0xfffe) >> 1);\n      // Reconstruct the PTS as a float.  Avoid bitwise operations to combine\n      // because bitwise ops treat the values as 32-bit ints.\n      const pts = ptsHigh3 * (1 << 30) + ptsLow30;\n      return pts / shaka.hls.HlsParser.TS_TIMESCALE_;\n    }\n  }\n\n  /**\n   * Replaces the variables of a given URI.\n   *\n   * @param {string} uri\n   * @param {!Map.<string, string>} variables\n   * @return {string}\n   * @private\n   */\n  variableSubstitution_(uri, variables) {\n    let newUri = String(uri).replace(/%7B/g, '{').replace(/%7D/g, '}');\n\n    const uriVariables = newUri.match(/{\\$\\w*}/g);\n    if (uriVariables) {\n      for (const variable of uriVariables) {\n        // Note: All variables have the structure {$...}\n        const variableName = variable.slice(2, variable.length - 1);\n        const replaceValue = variables.get(variableName);\n        if (replaceValue) {\n          newUri = newUri.replace(variable, replaceValue);\n        } else {\n          shaka.log.error('A variable has been found that is not declared',\n              variableName);\n          throw new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.MANIFEST,\n              shaka.util.Error.Code.HLS_VARIABLE_NOT_FOUND,\n              variableName);\n        }\n      }\n    }\n    return newUri;\n  }\n\n  /**\n   * Attempts to guess stream's mime type based on content type and URI.\n   *\n   * @param {string} contentType\n   * @param {string} codecs\n   * @param {!shaka.hls.Playlist} playlist\n   * @param {!Map.<string, string>} variables\n   * @return {!Promise.<string>}\n   * @private\n   */\n  async guessMimeType_(contentType, codecs, playlist, variables) {\n    const HlsParser = shaka.hls.HlsParser;\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const requestType = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n    goog.asserts.assert(playlist.segments.length,\n        'Playlist should have segments!');\n    const firstSegmentUri = this.variableSubstitution_(\n        playlist.segments[0].absoluteUri, variables);\n\n    const parsedUri = new goog.Uri(firstSegmentUri);\n    const extension = parsedUri.getPath().split('.').pop();\n    const map = HlsParser.EXTENSION_MAP_BY_CONTENT_TYPE_[contentType];\n\n    const mimeType = map[extension];\n    if (mimeType) {\n      return mimeType;\n    }\n\n    if (contentType == ContentType.TEXT) {\n      // The extension map didn't work.\n      if (!codecs || codecs == 'vtt' || codecs == 'wvtt') {\n        // If codecs is 'vtt', it's WebVTT.\n        // If there was no codecs string, assume HLS text streams are WebVTT.\n        return 'text/vtt';\n      } else {\n        // Otherwise, assume MP4-embedded text, since text-based formats tend\n        // not to have a codecs string at all.\n        return 'application/mp4';\n      }\n    }\n\n    if (contentType == ContentType.IMAGE) {\n      if (!codecs || codecs == 'jpeg') {\n        return 'image/jpeg';\n      }\n    }\n\n    // If unable to guess mime type, request a segment and try getting it\n    // from the response.\n    const headRequest = shaka.net.NetworkingEngine.makeRequest(\n        [firstSegmentUri], this.config_.retryParameters);\n    headRequest.method = 'HEAD';\n\n    const response = await this.makeNetworkRequest_(\n        headRequest, requestType);\n\n    const contentMimeType = response.headers['content-type'];\n\n    if (!contentMimeType) {\n      // If the HLS content is lacking in both MIME type metadata and\n      // segment file extensions, we fall back to assuming it's MP4.\n      const fallbackMimeType = map['mp4'];\n      return fallbackMimeType;\n    }\n\n    // Split the MIME type in case the server sent additional parameters.\n    return contentMimeType.split(';')[0];\n  }\n\n  /**\n   * Returns a tag with a given name.\n   * Throws an error if tag was not found.\n   *\n   * @param {!Array.<shaka.hls.Tag>} tags\n   * @param {string} tagName\n   * @return {!shaka.hls.Tag}\n   * @private\n   */\n  getRequiredTag_(tags, tagName) {\n    const tag = shaka.hls.Utils.getFirstTagWithName(tags, tagName);\n    if (!tag) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_REQUIRED_TAG_MISSING, tagName);\n    }\n\n    return tag;\n  }\n\n  /**\n   * @param {shaka.extern.Stream} stream\n   * @param {?string} width\n   * @param {?string} height\n   * @param {?string} frameRate\n   * @param {?string} videoRange\n   * @private\n   */\n  addVideoAttributes_(stream, width, height, frameRate, videoRange) {\n    if (stream) {\n      stream.width = Number(width) || undefined;\n      stream.height = Number(height) || undefined;\n      stream.frameRate = Number(frameRate) || undefined;\n      stream.hdr = videoRange || undefined;\n    }\n  }\n\n  /**\n   * Makes a network request for the manifest and returns a Promise\n   * with the resulting data.\n   *\n   * @param {string} absoluteUri\n   * @return {!Promise.<!shaka.extern.Response>}\n   * @private\n   */\n  requestManifest_(absoluteUri) {\n    const requestType = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        [absoluteUri], this.config_.retryParameters);\n\n    const format = shaka.util.CmcdManager.StreamingFormat.HLS;\n    this.playerInterface_.modifyManifestRequest(request, {format: format});\n\n    return this.makeNetworkRequest_(request, requestType);\n  }\n\n  /**\n   * Called when the update timer ticks. Because parsing a manifest is async,\n   * this method is async. To work with this, this method will schedule the next\n   * update when it finished instead of using a repeating-start.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async onUpdate_() {\n    shaka.log.info('Updating manifest...');\n\n    goog.asserts.assert(\n        this.updatePlaylistDelay_ > 0,\n        'We should only call |onUpdate_| when we are suppose to be updating.');\n\n    // Detect a call to stop()\n    if (!this.playerInterface_) {\n      return;\n    }\n\n    try {\n      await this.update();\n\n      const delay = this.updatePlaylistDelay_;\n      this.updatePlaylistTimer_.tickAfter(/* seconds= */ delay);\n    } catch (error) {\n      // Detect a call to stop() during this.update()\n      if (!this.playerInterface_) {\n        return;\n      }\n\n      goog.asserts.assert(error instanceof shaka.util.Error,\n          'Should only receive a Shaka error');\n\n      // We will retry updating, so override the severity of the error.\n      error.severity = shaka.util.Error.Severity.RECOVERABLE;\n      this.playerInterface_.onError(error);\n\n      // Try again very soon.\n      this.updatePlaylistTimer_.tickAfter(/* seconds= */ 0.1);\n    }\n  }\n\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  isLive_() {\n    const PresentationType = shaka.hls.HlsParser.PresentationType_;\n    return this.presentationType_ != PresentationType.VOD;\n  }\n\n\n  /**\n   * @param {shaka.hls.HlsParser.PresentationType_} type\n   * @private\n   */\n  setPresentationType_(type) {\n    this.presentationType_ = type;\n\n    if (this.presentationTimeline_) {\n      this.presentationTimeline_.setStatic(!this.isLive_());\n    }\n\n    // If this manifest is not for live content, then we have no reason to\n    // update it.\n    if (!this.isLive_()) {\n      this.updatePlaylistTimer_.stop();\n    }\n  }\n\n\n  /**\n   * Create a networking request. This will manage the request using the\n   * parser's operation manager. If the parser has already been stopped, the\n   * request will not be made.\n   *\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @return {!Promise.<shaka.extern.Response>}\n   * @private\n   */\n  makeNetworkRequest_(request, type) {\n    if (!this.operationManager_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED);\n    }\n\n    const op = this.playerInterface_.networkingEngine.request(type, request);\n    this.operationManager_.manage(op);\n\n    return op.promise;\n  }\n\n  /**\n   * @param {!shaka.hls.Tag} drmTag\n   * @return {?shaka.extern.DrmInfo}\n   * @private\n   */\n  static widevineDrmParser_(drmTag) {\n    const method = drmTag.getRequiredAttrValue('METHOD');\n    const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR'];\n    if (!VALID_METHODS.includes(method)) {\n      shaka.log.error('Widevine in HLS is only supported with [',\n          VALID_METHODS.join(', '), '], not', method);\n      return null;\n    }\n\n    const uri = drmTag.getRequiredAttrValue('URI');\n    const parsedData = shaka.net.DataUriPlugin.parseRaw(uri);\n\n    // The data encoded in the URI is a PSSH box to be used as init data.\n    const pssh = shaka.util.BufferUtils.toUint8(parsedData.data);\n    const drmInfo = shaka.util.ManifestParserUtils.createDrmInfo(\n        'com.widevine.alpha', [\n          {initDataType: 'cenc', initData: pssh},\n        ]);\n\n    const keyId = drmTag.getAttributeValue('KEYID');\n    if (keyId) {\n      const keyIdLowerCase = keyId.toLowerCase();\n      // This value should begin with '0x':\n      goog.asserts.assert(\n          keyIdLowerCase.startsWith('0x'), 'Incorrect KEYID format!');\n      // But the output should not contain the '0x':\n      drmInfo.keyIds = new Set([keyIdLowerCase.substr(2)]);\n    }\n    return drmInfo;\n  }\n\n  /**\n   * See: https://docs.microsoft.com/en-us/playready/packaging/mp4-based-formats-supported-by-playready-clients?tabs=case4\n   *\n   * @param {!shaka.hls.Tag} drmTag\n   * @return {?shaka.extern.DrmInfo}\n   * @private\n   */\n  static playreadyDrmParser_(drmTag) {\n    const method = drmTag.getRequiredAttrValue('METHOD');\n    const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR'];\n    if (!VALID_METHODS.includes(method)) {\n      shaka.log.error('PlayReady in HLS is only supported with [',\n          VALID_METHODS.join(', '), '], not', method);\n      return null;\n    }\n\n    const uri = drmTag.getRequiredAttrValue('URI');\n    const parsedData = shaka.net.DataUriPlugin.parseRaw(uri);\n\n    // The data encoded in the URI is a PlayReady Pro Object, so we need\n    // convert it to pssh.\n    const data = shaka.util.BufferUtils.toUint8(parsedData.data);\n    const systemId = new Uint8Array([\n      0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86,\n      0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95,\n    ]);\n    const pssh = shaka.util.Pssh.createPssh(data, systemId);\n    const drmInfo = shaka.util.ManifestParserUtils.createDrmInfo(\n        'com.microsoft.playready', [\n          {initDataType: 'cenc', initData: pssh},\n        ]);\n\n    return drmInfo;\n  }\n};\n\n\n/**\n * @typedef {{\n *   stream: !shaka.extern.Stream,\n *   verbatimMediaPlaylistUri: string,\n *   absoluteMediaPlaylistUri: string,\n *   minTimestamp: number,\n *   maxTimestamp: number,\n *   mediaSequenceToStartTime: !Map.<number, number>,\n *   discontinuityToMediaSequence: !Map.<number, number>,\n *   canSkipSegments: boolean\n * }}\n *\n * @description\n * Contains a stream and information about it.\n *\n * @property {!shaka.extern.Stream} stream\n *   The Stream itself.\n * @property {string} verbatimMediaPlaylistUri\n *   The verbatim media playlist URI, as it appeared in the master playlist.\n *   This has not been canonicalized into an absolute URI.  This gives us a\n *   consistent key for this playlist, even if redirects cause us to update\n *   from different origins each time.\n * @property {string} absoluteMediaPlaylistUri\n *   The absolute media playlist URI, resolved relative to the master playlist\n *   and updated to reflect any redirects.\n * @property {number} minTimestamp\n *   The minimum timestamp found in the stream.\n * @property {number} maxTimestamp\n *   The maximum timestamp found in the stream.\n * @property {!Map.<number, number>} mediaSequenceToStartTime\n *   A map of media sequence numbers to media start times.\n * @property  {!Map.<number, number>} discontinuityToMediaSequence\n *   A map of discontinuity sequence numbers to the media sequence number of the\n *   segment starting with that discontinuity sequence number.\n * @property {boolean} canSkipSegments\n *  True if the server supports delta playlist updates, and we can send a\n *  request for a playlist that can skip older media segments.\n */\nshaka.hls.HlsParser.StreamInfo;\n\n\n/**\n * @typedef {{\n *   audio: !Array.<shaka.hls.HlsParser.StreamInfo>,\n *   video: !Array.<shaka.hls.HlsParser.StreamInfo>\n * }}\n *\n * @description Audio and video stream infos.\n * @property {!Array.<shaka.hls.HlsParser.StreamInfo>} audio\n * @property {!Array.<shaka.hls.HlsParser.StreamInfo>} video\n */\nshaka.hls.HlsParser.StreamInfos;\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.hls.HlsParser.AUDIO_EXTENSIONS_TO_MIME_TYPES_ = {\n  'mp4': 'audio/mp4',\n  'mp4a': 'audio/mp4',\n  'm4s': 'audio/mp4',\n  'm4i': 'audio/mp4',\n  'm4a': 'audio/mp4',\n  'm4f': 'audio/mp4',\n  'cmfa': 'audio/mp4',\n  // MPEG2-TS also uses video/ for audio: https://bit.ly/TsMse\n  'ts': 'video/mp2t',\n  'tsa': 'video/mp2t',\n\n  // Raw formats:\n  'aac': 'audio/aac',\n  'ac3': 'audio/ac3',\n  'ec3': 'audio/ec3',\n  'mp3': 'audio/mpeg',\n};\n\n\n/**\n * MIME types of raw formats.\n * TODO(#2337): Support raw formats and share this list among parsers.\n *\n * @const {!Array.<string>}\n * @private\n */\nshaka.hls.HlsParser.RAW_FORMATS_ = [\n  'audio/aac',\n  'audio/ac3',\n  'audio/ec3',\n  'audio/mpeg',\n];\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.hls.HlsParser.VIDEO_EXTENSIONS_TO_MIME_TYPES_ = {\n  'mp4': 'video/mp4',\n  'mp4v': 'video/mp4',\n  'm4s': 'video/mp4',\n  'm4i': 'video/mp4',\n  'm4v': 'video/mp4',\n  'm4f': 'video/mp4',\n  'cmfv': 'video/mp4',\n  'ts': 'video/mp2t',\n  'tsv': 'video/mp2t',\n};\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.hls.HlsParser.TEXT_EXTENSIONS_TO_MIME_TYPES_ = {\n  'mp4': 'application/mp4',\n  'm4s': 'application/mp4',\n  'm4i': 'application/mp4',\n  'm4f': 'application/mp4',\n  'cmft': 'application/mp4',\n  'vtt': 'text/vtt',\n  'webvtt': 'text/vtt',\n  'ttml': 'application/ttml+xml',\n};\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.hls.HlsParser.IMAGE_EXTENSIONS_TO_MIME_TYPES_ = {\n  'jpg': 'image/jpeg',\n  'png': 'image/png',\n  'svg': 'image/svg+xml',\n  'webp': 'image/webp',\n  'avif': 'image/avif',\n};\n\n\n/**\n * @const {!Object.<string, !Object.<string, string>>}\n * @private\n */\nshaka.hls.HlsParser.EXTENSION_MAP_BY_CONTENT_TYPE_ = {\n  'audio': shaka.hls.HlsParser.AUDIO_EXTENSIONS_TO_MIME_TYPES_,\n  'video': shaka.hls.HlsParser.VIDEO_EXTENSIONS_TO_MIME_TYPES_,\n  'text': shaka.hls.HlsParser.TEXT_EXTENSIONS_TO_MIME_TYPES_,\n  'image': shaka.hls.HlsParser.IMAGE_EXTENSIONS_TO_MIME_TYPES_,\n};\n\n\n/**\n * @typedef {function(!shaka.hls.Tag):?shaka.extern.DrmInfo}\n * @private\n */\nshaka.hls.HlsParser.DrmParser_;\n\n\n/**\n * @const {!Object.<string, shaka.hls.HlsParser.DrmParser_>}\n * @private\n */\nshaka.hls.HlsParser.KEYFORMATS_TO_DRM_PARSERS_ = {\n  /* TODO: https://github.com/google/shaka-player/issues/382\n  'com.apple.streamingkeydelivery':\n      shaka.hls.HlsParser.fairplayDrmParser_,\n  */\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed':\n      shaka.hls.HlsParser.widevineDrmParser_,\n  'com.microsoft.playready':\n      shaka.hls.HlsParser.playreadyDrmParser_,\n};\n\n\n/**\n * @enum {string}\n * @private\n */\nshaka.hls.HlsParser.PresentationType_ = {\n  VOD: 'VOD',\n  EVENT: 'EVENT',\n  LIVE: 'LIVE',\n};\n\n\n/**\n * @const {number}\n * @private\n */\nshaka.hls.HlsParser.TS_TIMESCALE_ = 90000;\n\n\n/**\n * The amount of data from the start of a segment we will try to fetch when we\n * need to know the segment start time.  This allows us to avoid fetching the\n * entire segment in many cases.\n *\n * @const {number}\n * @private\n */\nshaka.hls.HlsParser.START_OF_SEGMENT_SIZE_ = 2048;\n\n\nshaka.media.ManifestParser.registerParserByExtension(\n    'm3u8', () => new shaka.hls.HlsParser());\nshaka.media.ManifestParser.registerParserByMime(\n    'application/x-mpegurl', () => new shaka.hls.HlsParser());\nshaka.media.ManifestParser.registerParserByMime(\n    'application/vnd.apple.mpegurl', () => new shaka.hls.HlsParser());\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.HttpPluginUtils');\n\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.requireType('shaka.net.NetworkingEngine');\n\n\n/**\n * @summary A set of http networking utility functions.\n * @exportDoc\n */\nshaka.net.HttpPluginUtils = class {\n  /**\n   * @param {!Object.<string,string>} headers\n   * @param {BufferSource} data\n   * @param {number} status\n   * @param {string} uri\n   * @param {string} responseURL\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @return {!shaka.extern.Response}\n   */\n  static makeResponse(headers, data, status, uri, responseURL, requestType) {\n    if (status >= 200 && status <= 299 && status != 202) {\n      // Most 2xx HTTP codes are success cases.\n      /** @type {shaka.extern.Response} */\n      const response = {\n        uri: responseURL || uri,\n        originalUri: uri,\n        data: data,\n        status: status,\n        headers: headers,\n        fromCache: !!headers['x-shaka-from-cache'],\n      };\n      return response;\n    } else {\n      let responseText = null;\n      try {\n        responseText = shaka.util.StringUtils.fromBytesAutoDetect(data);\n      } catch (exception) {}\n      shaka.log.debug('HTTP error text:', responseText);\n\n      const severity = status == 401 || status == 403 ?\n          shaka.util.Error.Severity.CRITICAL :\n          shaka.util.Error.Severity.RECOVERABLE;\n\n      throw new shaka.util.Error(\n          severity,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.BAD_HTTP_STATUS,\n          uri,\n          status,\n          responseText,\n          headers,\n          requestType);\n    }\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.HttpFetchPlugin');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.net.HttpPluginUtils');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * @summary A networking plugin to handle http and https URIs via the Fetch API.\n * @export\n */\nshaka.net.HttpFetchPlugin = class {\n  /**\n   * @param {string} uri\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a\n   *   progress event happened.\n   * @param {shaka.extern.HeadersReceived} headersReceived Called when the\n   *   headers for the download are received, but before the body is.\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @export\n   */\n  static parse(uri, request, requestType, progressUpdated, headersReceived) {\n    const headers = new shaka.net.HttpFetchPlugin.Headers_();\n    shaka.util.MapUtils.asMap(request.headers).forEach((value, key) => {\n      headers.append(key, value);\n    });\n\n    const controller = new shaka.net.HttpFetchPlugin.AbortController_();\n\n    /** @type {!RequestInit} */\n    const init = {\n      // Edge does not treat null as undefined for body; https://bit.ly/2luyE6x\n      body: request.body || undefined,\n      headers: headers,\n      method: request.method,\n      signal: controller.signal,\n      credentials: request.allowCrossSiteCredentials ? 'include' : undefined,\n    };\n\n    /** @type {shaka.net.HttpFetchPlugin.AbortStatus} */\n    const abortStatus = {\n      canceled: false,\n      timedOut: false,\n    };\n\n    const pendingRequest = shaka.net.HttpFetchPlugin.request_(\n        uri, requestType, init, abortStatus, progressUpdated, headersReceived,\n        request.streamDataCallback);\n\n    /** @type {!shaka.util.AbortableOperation} */\n    const op = new shaka.util.AbortableOperation(pendingRequest, () => {\n      abortStatus.canceled = true;\n      controller.abort();\n      return Promise.resolve();\n    });\n\n    // The fetch API does not timeout natively, so do a timeout manually using\n    // the AbortController.\n    const timeoutMs = request.retryParameters.timeout;\n    if (timeoutMs) {\n      const timer = new shaka.util.Timer(() => {\n        abortStatus.timedOut = true;\n        controller.abort();\n      });\n\n      timer.tickAfter(timeoutMs / 1000);\n\n      // To avoid calling |abort| on the network request after it finished, we\n      // will stop the timer when the requests resolves/rejects.\n      op.finally(() => {\n        timer.stop();\n      });\n    }\n\n    return op;\n  }\n\n  /**\n   * @param {string} uri\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @param {!RequestInit} init\n   * @param {shaka.net.HttpFetchPlugin.AbortStatus} abortStatus\n   * @param {shaka.extern.ProgressUpdated} progressUpdated\n   * @param {shaka.extern.HeadersReceived} headersReceived\n   * @param {?function(BufferSource):!Promise} streamDataCallback\n   * @return {!Promise<!shaka.extern.Response>}\n   * @private\n   */\n  static async request_(uri, requestType, init, abortStatus, progressUpdated,\n      headersReceived, streamDataCallback) {\n    const fetch = shaka.net.HttpFetchPlugin.fetch_;\n    const ReadableStream = shaka.net.HttpFetchPlugin.ReadableStream_;\n    let response;\n    let arrayBuffer;\n    let loaded = 0;\n    let lastLoaded = 0;\n\n    // Last time stamp when we got a progress event.\n    let lastTime = Date.now();\n\n    try {\n      // The promise returned by fetch resolves as soon as the HTTP response\n      // headers are available. The download itself isn't done until the promise\n      // for retrieving the data (arrayBuffer, blob, etc) has resolved.\n      response = await fetch(uri, init);\n      // At this point in the process, we have the headers of the response, but\n      // not the body yet.\n      headersReceived(shaka.net.HttpFetchPlugin.headersToGenericObject_(\n          response.headers));\n\n      // In new versions of Chromium, HEAD requests now have a response body\n      // that is null.\n      // So just don't try to download the body at all, if it's a HEAD request,\n      // to avoid null reference errors.\n      // See: https://crbug.com/1297060\n      if (init.method != 'HEAD') {\n        goog.asserts.assert(response.body,\n            'non-HEAD responses should have a body');\n\n        // Getting the reader in this way allows us to observe the process of\n        // downloading the body, instead of just waiting for an opaque promise\n        // to resolve.\n        // We first clone the response because calling getReader locks the body\n        // stream; if we didn't clone it here, we would be unable to get the\n        // response's arrayBuffer later.\n        const reader = response.clone().body.getReader();\n\n        const contentLengthRaw = response.headers.get('Content-Length');\n        const contentLength =\n            contentLengthRaw ? parseInt(contentLengthRaw, 10) : 0;\n\n        const start = (controller) => {\n          const push = async () => {\n            let readObj;\n            try {\n              readObj = await reader.read();\n            } catch (e) {\n              // If we abort the request, we'll get an error here.  Just ignore\n              // it since real errors will be reported when we read the buffer\n              // below.\n              shaka.log.v1('error reading from stream', e.message);\n              return;\n            }\n\n            if (!readObj.done) {\n              loaded += readObj.value.byteLength;\n              if (streamDataCallback) {\n                await streamDataCallback(readObj.value);\n              }\n            }\n\n            const currentTime = Date.now();\n            // If the time between last time and this time we got progress event\n            // is long enough, or if a whole segment is downloaded, call\n            // progressUpdated().\n            if (currentTime - lastTime > 100 || readObj.done) {\n              progressUpdated(currentTime - lastTime, loaded - lastLoaded,\n                  contentLength - loaded);\n              lastLoaded = loaded;\n              lastTime = currentTime;\n            }\n\n            if (readObj.done) {\n              goog.asserts.assert(!readObj.value,\n                  'readObj should be unset when \"done\" is true.');\n              controller.close();\n            } else {\n              controller.enqueue(readObj.value);\n              push();\n            }\n          };\n          push();\n        };\n        // Create a ReadableStream to use the reader. We don't need to use the\n        // actual stream for anything, though, as we are using the response's\n        // arrayBuffer method to get the body, so we don't store the\n        // ReadableStream.\n        new ReadableStream({start}); // eslint-disable-line no-new\n        arrayBuffer = await response.arrayBuffer();\n      }\n    } catch (error) {\n      if (abortStatus.canceled) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.OPERATION_ABORTED,\n            uri, requestType);\n      } else if (abortStatus.timedOut) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.TIMEOUT,\n            uri, requestType);\n      } else {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.HTTP_ERROR,\n            uri, error, requestType);\n      }\n    }\n\n    const headers = shaka.net.HttpFetchPlugin.headersToGenericObject_(\n        response.headers);\n\n    return shaka.net.HttpPluginUtils.makeResponse(\n        headers, arrayBuffer, response.status, uri, response.url, requestType);\n  }\n\n  /**\n   * @param {!Headers} headers\n   * @return {!Object.<string, string>}\n   * @private\n   */\n  static headersToGenericObject_(headers) {\n    const headersObj = {};\n    headers.forEach((value, key) => {\n      // Since Edge incorrectly return the header with a leading new line\n      // character ('\\n'), we trim the header here.\n      headersObj[key.trim()] = value;\n    });\n    return headersObj;\n  }\n\n  /**\n   * Determine if the Fetch API is supported in the browser. Note: this is\n   * deliberately exposed as a method to allow the client app to use the same\n   * logic as Shaka when determining support.\n   * @return {boolean}\n   * @export\n   */\n  static isSupported() {\n    // On Edge, ReadableStream exists, but attempting to construct it results in\n    // an error. See https://bit.ly/2zwaFLL\n    // So this has to check that ReadableStream is present AND usable.\n    if (window.ReadableStream) {\n      try {\n        new ReadableStream({}); // eslint-disable-line no-new\n      } catch (e) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n    // Old fetch implementations hasn't body and ReadableStream implementation\n    // See: https://github.com/shaka-project/shaka-player/issues/5088\n    if (window.Response) {\n      const response = new Response('');\n      if (!response.body) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n    return !!(window.fetch && window.AbortController);\n  }\n};\n\n\n/**\n * @typedef {{\n *   canceled: boolean,\n *   timedOut: boolean\n * }}\n * @property {boolean} canceled\n *   Indicates if the request was canceled.\n * @property {boolean} timedOut\n *   Indicates if the request timed out.\n */\nshaka.net.HttpFetchPlugin.AbortStatus;\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(string, !RequestInit)}\n * @private\n */\nshaka.net.HttpFetchPlugin.fetch_ = window.fetch;\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: AbortController)}\n * @private\n */\nshaka.net.HttpFetchPlugin.AbortController_ = window.AbortController;\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: ReadableStream, !Object)}\n * @private\n */\nshaka.net.HttpFetchPlugin.ReadableStream_ = window.ReadableStream;\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: Headers)}\n * @private\n */\nshaka.net.HttpFetchPlugin.Headers_ = window.Headers;\n\n\nif (shaka.net.HttpFetchPlugin.isSupported()) {\n  shaka.net.NetworkingEngine.registerScheme(\n      'http', shaka.net.HttpFetchPlugin.parse,\n      shaka.net.NetworkingEngine.PluginPriority.PREFERRED,\n      /* progressSupport= */ true);\n  shaka.net.NetworkingEngine.registerScheme(\n      'https', shaka.net.HttpFetchPlugin.parse,\n      shaka.net.NetworkingEngine.PluginPriority.PREFERRED,\n      /* progressSupport= */ true);\n  shaka.net.NetworkingEngine.registerScheme(\n      'blob', shaka.net.HttpFetchPlugin.parse,\n      shaka.net.NetworkingEngine.PluginPriority.PREFERRED,\n      /* progressSupport= */ true);\n}\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.HttpXHRPlugin');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.net.HttpPluginUtils');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @summary A networking plugin to handle http and https URIs via XHR.\n * @export\n */\nshaka.net.HttpXHRPlugin = class {\n  /**\n   * @param {string} uri\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a\n   *   progress event happened.\n   * @param {shaka.extern.HeadersReceived} headersReceived Called when the\n   *   headers for the download are received, but before the body is.\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @export\n   */\n  static parse(uri, request, requestType, progressUpdated, headersReceived) {\n    const xhr = new shaka.net.HttpXHRPlugin.Xhr_();\n\n    // Last time stamp when we got a progress event.\n    let lastTime = Date.now();\n    // Last number of bytes loaded, from progress event.\n    let lastLoaded = 0;\n\n    const promise = new Promise(((resolve, reject) => {\n      xhr.open(request.method, uri, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.timeout = request.retryParameters.timeout;\n      xhr.withCredentials = request.allowCrossSiteCredentials;\n\n      xhr.onabort = () => {\n        reject(new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.OPERATION_ABORTED,\n            uri, requestType));\n      };\n      let calledHeadersReceived = false;\n      xhr.onreadystatechange = (event) => {\n        // See if the readyState is 2 (\"HEADERS_RECEIVED\").\n        if (xhr.readyState == 2 && !calledHeadersReceived) {\n          const headers = shaka.net.HttpXHRPlugin.headersToGenericObject_(xhr);\n          headersReceived(headers);\n          // Don't send out this event twice.\n          calledHeadersReceived = true;\n        }\n      };\n      xhr.onload = (event) => {\n        const headers = shaka.net.HttpXHRPlugin.headersToGenericObject_(xhr);\n        goog.asserts.assert(xhr.response instanceof ArrayBuffer,\n            'XHR should have a response by now!');\n        const xhrResponse = xhr.response;\n\n        try {\n          const response = shaka.net.HttpPluginUtils.makeResponse(headers,\n              xhrResponse, xhr.status, uri, xhr.responseURL, requestType);\n          resolve(response);\n        } catch (error) {\n          goog.asserts.assert(error instanceof shaka.util.Error,\n              'Wrong error type!');\n          reject(error);\n        }\n      };\n      xhr.onerror = (event) => {\n        reject(new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.HTTP_ERROR,\n            uri, event, requestType));\n      };\n      xhr.ontimeout = (event) => {\n        reject(new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.TIMEOUT,\n            uri, requestType));\n      };\n      xhr.onprogress = (event) => {\n        const currentTime = Date.now();\n        // If the time between last time and this time we got progress event\n        // is long enough, or if a whole segment is downloaded, call\n        // progressUpdated().\n        if (currentTime - lastTime > 100 ||\n            (event.lengthComputable && event.loaded == event.total)) {\n          progressUpdated(currentTime - lastTime, event.loaded - lastLoaded,\n              event.total - event.loaded);\n          lastLoaded = event.loaded;\n          lastTime = currentTime;\n        }\n      };\n\n      for (const key in request.headers) {\n        // The Fetch API automatically normalizes outgoing header keys to\n        // lowercase. For consistency's sake, do it here too.\n        const lowercasedKey = key.toLowerCase();\n        xhr.setRequestHeader(lowercasedKey, request.headers[key]);\n      }\n      xhr.send(request.body);\n    }));\n\n    return new shaka.util.AbortableOperation(\n        promise,\n        () => {\n          xhr.abort();\n          return Promise.resolve();\n        });\n  }\n\n  /**\n   * @param {!XMLHttpRequest} xhr\n   * @return {!Object.<string, string>}\n   * @private\n   */\n  static headersToGenericObject_(xhr) {\n    // Since Edge incorrectly return the header with a leading new\n    // line character ('\\n'), we trim the header here.\n    const headerLines = xhr.getAllResponseHeaders().trim().split('\\r\\n');\n    const headers = {};\n    for (const header of headerLines) {\n      /** @type {!Array.<string>} */\n      const parts = header.split(': ');\n      headers[parts[0].toLowerCase()] = parts.slice(1).join(': ');\n    }\n    return headers;\n  }\n};\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: XMLHttpRequest)}\n * @private\n */\nshaka.net.HttpXHRPlugin.Xhr_ = window.XMLHttpRequest;\n\n\nshaka.net.NetworkingEngine.registerScheme(\n    'http', shaka.net.HttpXHRPlugin.parse,\n    shaka.net.NetworkingEngine.PluginPriority.FALLBACK,\n    /* progressSupport= */ true);\nshaka.net.NetworkingEngine.registerScheme(\n    'https', shaka.net.HttpXHRPlugin.parse,\n    shaka.net.NetworkingEngine.PluginPriority.FALLBACK,\n    /* progressSupport= */ true);\nshaka.net.NetworkingEngine.registerScheme(\n    'blob', shaka.net.HttpXHRPlugin.parse,\n    shaka.net.NetworkingEngine.PluginPriority.FALLBACK,\n    /* progressSupport= */ true);\n\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.DownloadInfo');\n\ngoog.require('shaka.util.Networking');\ngoog.requireType('shaka.media.InitSegmentReference');\ngoog.requireType('shaka.media.SegmentReference');\n\n\n/**\n * An object that represents a single segment, that the storage system will soon\n * download, but has not yet started downloading.\n */\nshaka.offline.DownloadInfo = class {\n  /**\n   * @param {shaka.media.SegmentReference|shaka.media.InitSegmentReference} ref\n   * @param {number} estimateId\n   * @param {number} groupId\n   * @param {boolean} isInitSegment\n   */\n  constructor(ref, estimateId, groupId, isInitSegment) {\n    /** @type {shaka.media.SegmentReference|shaka.media.InitSegmentReference} */\n    this.ref = ref;\n\n    /** @type {number} */\n    this.estimateId = estimateId;\n\n    /** @type {number} */\n    this.groupId = groupId;\n\n    /** @type {boolean} */\n    this.isInitSegment = isInitSegment;\n  }\n\n  /**\n   * Creates an ID that encapsulates all important information in the ref, which\n   * can then be used to check for equality.\n   * @param {shaka.media.SegmentReference|shaka.media.InitSegmentReference} ref\n   * @return {string}\n   */\n  static idForSegmentRef(ref) {\n    // Escape the URIs using encodeURI, to make sure that a weirdly formed URI\n    // cannot cause two unrelated refs to be considered equivalent.\n    return ref.getUris().map((uri) => '{' + encodeURI(uri) + '}').join('') +\n        ':' + ref.startByte + ':' + ref.endByte;\n  }\n\n  /** @return {string} */\n  getRefId() {\n    return shaka.offline.DownloadInfo.idForSegmentRef(this.ref);\n  }\n\n  /**\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {!shaka.extern.Request}\n   */\n  makeSegmentRequest(config) {\n    return shaka.util.Networking.createSegmentRequest(\n        this.ref.getUris(),\n        this.ref.startByte,\n        this.ref.endByte,\n        config.streaming.retryParameters);\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.DownloadProgressEstimator');\n\n\n/**\n * The download progress estimator class encapsulates all the logic for tracking\n * how much content has been downloaded and estimating its progress.\n *\n * @final\n */\nshaka.offline.DownloadProgressEstimator = class {\n  /** */\n  constructor() {\n    /**\n     * This is the sum of all estimates passed to |open|. This is used as the\n     * denominator when measuring progress.\n     *\n     * @private {number}\n     */\n    this.estimatedTotal_ = 0;\n\n    /**\n     * This is the sum of all estimates pass to |open| but only after |close|\n     * has been called. This is used as the numerator when measuring progress so\n     * that |estimatedTotal_ == estimatedDownloaded_| after everything is\n     * downloaded.\n     *\n     * @private {number}\n     */\n    this.estimatedDownloaded_ = 0;\n\n    /**\n     * This is the total number of bytes actually downloaded. This will most\n     * likely differ from |estimatedTotal_| after everything is downloaded since\n     * our estimates will be off.\n     *\n     * @private {number}\n     */\n    this.actualDownloaded_ = 0;\n\n    /**\n     * This is a map of all pending downloads. This maps their download id (an\n     * internal id) to the estimate. This will allow us to update\n     * |estimatedDownloaded_| when |close| is called.\n     *\n     * @private {!Map.<number, number>}\n     */\n    this.pending_ = new Map();\n\n    /**\n     * This number is used to provide unique (to estimator) ids for each\n     * download. This allows us to track each download in |pending_|.\n     *\n     * @private {number}\n     */\n    this.nextId_ = 0;\n  }\n\n  /**\n   * Open a new download in the progress estimator. This will create an entry so\n   * that we can track the download progress.\n   *\n   * This will return an id for the download. This id must be passed to |close|\n   * in order for the |close| to be paired with this call to |open|.\n   *\n   * @param {number} estimate\n   * @return {number}\n   */\n  open(estimate) {\n    this.estimatedTotal_ += estimate;\n\n    const id = this.nextId_;\n    this.nextId_++;\n\n    this.pending_.set(id, estimate);\n    return id;\n  }\n\n  /**\n   * Close a download in the estimator. This will signal that we have finished\n   * downloading a segment and we can update the progress estimate.\n   *\n   * @param {number} id\n   * @param {number} actual\n   */\n  close(id, actual) {\n    if (!this.pending_.has(id)) {\n      return;\n    }\n\n    const estimate = this.pending_.get(id);\n    this.pending_.delete(id);\n\n    this.estimatedDownloaded_ += estimate;\n    this.actualDownloaded_ += actual;\n  }\n\n  /**\n   * Get the current estimate for how much progress we've made downloading the\n   * content. Progress will be between 0 and 1.\n   *\n   * Depending on the order of calls to |open| and |close|,\n   * |getEstimatedProgress| will fluctuate and is not guaranteed to always be\n   * increasing.\n   *\n   * @return {number}\n   */\n  getEstimatedProgress() {\n    return this.estimatedTotal_ == 0 ?\n           0 :\n           this.estimatedDownloaded_ / this.estimatedTotal_;\n  }\n\n  /**\n   * Get the total number of bytes that were actually downloaded.\n   *\n   * @return {number}\n   */\n  getTotalDownloaded() {\n    return this.actualDownloaded_;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.DownloadManager');\n\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.offline.DownloadProgressEstimator');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Pssh');\n\n\n/**\n * This manages downloading segments.\n *\n * @implements {shaka.util.IDestroyable}\n * @final\n */\nshaka.offline.DownloadManager = class {\n  /**\n   * Create a new download manager. It will use (but not own) |networkingEngine|\n   * and call |onProgress| after each download.\n   *\n   * @param {!shaka.net.NetworkingEngine} networkingEngine\n   */\n  constructor(networkingEngine) {\n    /** @private {shaka.net.NetworkingEngine} */\n    this.networkingEngine_ = networkingEngine;\n\n    /**\n     * We group downloads. Within each group, the requests are executed in\n     * series. Between groups, the requests are executed in parallel. We store\n     * the promise chain that is doing the work.\n     *\n     * @private {!Map.<number, !Promise>}\n     */\n    this.groups_ = new Map();\n\n    /** @private {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(() => {\n      // Add a \"catch\" block to stop errors from being returned.\n      return this.abortAll().catch(() => {});\n    });\n\n    /**\n     * A list of callback functions to cancel any in-progress downloads.\n     *\n     * @private {!Array.<function():!Promise>}\n     */\n    this.abortCallbacks_ = [];\n\n    /**\n     * A callback for when a segment has been downloaded. The first parameter\n     * is the progress of all segments, a number between 0.0 (0% complete) and\n     * 1.0 (100% complete). The second parameter is the total number of bytes\n     * that have been downloaded.\n     *\n     * @private {function(number, number)}\n     */\n    this.onProgress_ = (progress, size) => {};\n\n    /**\n     * A callback for when a segment has new PSSH data and we pass\n     * on the initData to storage\n     *\n     * @private {function(!Uint8Array, string)}\n     */\n    this.onInitData_ = (initData, systemId) => {};\n\n    /** @private {shaka.offline.DownloadProgressEstimator} */\n    this.estimator_ = new shaka.offline.DownloadProgressEstimator();\n  }\n\n  /** @override */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /**\n   * @param {function(number, number)} onProgress\n   * @param {function(!Uint8Array, string)} onInitData\n   */\n  setCallbacks(onProgress, onInitData) {\n    this.onProgress_ = onProgress;\n    this.onInitData_ = onInitData;\n  }\n\n  /**\n   * Aborts all in-progress downloads.\n   * @return {!Promise} A promise that will resolve once the downloads are fully\n   *   aborted.\n   */\n  abortAll() {\n    const promises = this.abortCallbacks_.map((callback) => callback());\n    this.abortCallbacks_ = [];\n    return Promise.all(promises);\n  }\n\n  /**\n   * Adds a byte length to the download estimate.\n   *\n   * @param {number} estimatedByteLength\n   * @return {number} estimateId\n   */\n  addDownloadEstimate(estimatedByteLength) {\n    return this.estimator_.open(estimatedByteLength);\n  }\n\n  /**\n   * Add a request to be downloaded as part of a group.\n   *\n   * @param {number} groupId\n   *    The group to add this segment to. If the group does not exist, a new\n   *    group will be created.\n   * @param {shaka.extern.Request} request\n   * @param {number} estimateId\n   * @param {boolean} isInitSegment\n   * @param {function(BufferSource):!Promise} onDownloaded\n   *   The callback for when this request has been downloaded. Downloading for\n   *   |group| will pause until the promise returned by |onDownloaded| resolves.\n   * @return {!Promise} Resolved when this request is complete.\n   */\n  queue(groupId, request, estimateId, isInitSegment, onDownloaded) {\n    this.destroyer_.ensureNotDestroyed();\n\n    const group = this.groups_.get(groupId) || Promise.resolve();\n\n    // Add another download to the group.\n    const newPromise = group.then(async () => {\n      const response = await this.fetchSegment_(request);\n\n      // Make sure we stop downloading if we have been destroyed.\n      if (this.destroyer_.destroyed()) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.OPERATION_ABORTED);\n      }\n\n      // Update initData\n      if (isInitSegment) {\n        const segmentBytes = shaka.util.BufferUtils.toUint8(response);\n        const pssh = new shaka.util.Pssh(segmentBytes);\n        for (const key in pssh.data) {\n          const index = Number(key);\n          const data = pssh.data[index];\n          const systemId = pssh.systemIds[index];\n          this.onInitData_(data, systemId);\n        }\n      }\n\n      // Update all our internal stats.\n      this.estimator_.close(estimateId, response.byteLength);\n      this.onProgress_(\n          this.estimator_.getEstimatedProgress(),\n          this.estimator_.getTotalDownloaded());\n\n      return onDownloaded(response);\n    });\n\n    this.groups_.set(groupId, newPromise);\n    return newPromise;\n  }\n\n  /**\n   * Add additional async work to the group work queue.\n   *\n   * @param {number} groupId\n   *    The group to add this group to. If the group does not exist, a new\n   *    group will be created.\n   * @param {function():!Promise} callback\n   *   The callback for the async work.  Downloading for this group will be\n   *   blocked until the Promise returned by |callback| resolves.\n   * @return {!Promise} Resolved when this work is complete.\n   */\n  queueWork(groupId, callback) {\n    this.destroyer_.ensureNotDestroyed();\n    const group = this.groups_.get(groupId) || Promise.resolve();\n    const newPromise = group.then(async () => {\n      await callback();\n    });\n    this.groups_.set(groupId, newPromise);\n    return newPromise;\n  }\n\n  /**\n   * Get a promise that will resolve when all currently queued downloads have\n   * finished.\n   *\n   * @return {!Promise.<number>}\n   */\n  async waitToFinish() {\n    await Promise.all(this.groups_.values());\n    return this.estimator_.getTotalDownloaded();\n  }\n\n  /**\n   * Download a segment and return the data in the response.\n   *\n   * @param {shaka.extern.Request} request\n   * @return {!Promise.<BufferSource>}\n   * @private\n   */\n  async fetchSegment_(request) {\n    const type = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n    /** @type {!shaka.net.NetworkingEngine.PendingRequest} */\n    const action = this.networkingEngine_.request(type, request);\n    const abortCallback = () => {\n      return action.abort();\n    };\n    this.abortCallbacks_.push(abortCallback);\n    const response = await action.promise;\n    shaka.util.ArrayUtils.remove(this.abortCallbacks_, abortCallback);\n    return response.data;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.DBOperation');\n\n\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * A DBOperation wraps an IndexedDB transaction in a promise.\n */\nshaka.offline.indexeddb.DBOperation = class {\n  /**\n   * @param {IDBTransaction} transaction\n   * @param {string} storeName\n   */\n  constructor(transaction, storeName) {\n    /** @private {IDBTransaction} */\n    this.transaction_ = transaction;\n    /** @private {IDBObjectStore} */\n    this.store_ = transaction.objectStore(storeName);\n    /** @private {!shaka.util.PublicPromise} */\n    this.promise_ = new shaka.util.PublicPromise();\n\n    // Connect the transaction and the promise together.\n    // |event.preventDefault()| is used on all non-successful callbacks to\n    // prevent Firefox from surfacing the error on the main thread.\n    transaction.onabort = (event) => {\n      event.preventDefault();\n      this.promise_.reject();\n    };\n    transaction.onerror = (event) => {\n      event.preventDefault();\n      this.promise_.reject();\n    };\n    transaction.oncomplete = (event) => {\n      this.promise_.resolve();\n    };\n  }\n\n  /**\n   * @return {!Promise}\n   */\n  async abort() {\n    try {\n      this.transaction_.abort();\n    } catch (e) {\n      // Ignore any exceptions that may be thrown as a result of aborting\n      // the transaction.\n    }\n\n    try {\n      // Wait for the promise to be rejected, but ignore the rejection error.\n      await this.promise_;\n    } catch (e) {}\n  }\n\n  /**\n   * Calls the given callback for each entry in the database.\n   *\n   * @param {function(!IDBKeyType, T, !IDBCursorWithValue=):(Promise|undefined)}\n   *   callback\n   * @return {!Promise}\n   * @template T\n   */\n  forEachEntry(callback) {\n    return new Promise((resolve, reject) => {\n      const req = this.store_.openCursor();\n      req.onerror = reject;\n      req.onsuccess = async (event) => {\n        // When we reach the end of the data that the cursor is iterating over,\n        // |req.result| will be null to signal the end of the iteration.\n        // https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/continue\n        if (req.result == null) {\n          resolve();\n          return;\n        }\n\n        /** @type {!IDBCursorWithValue} */\n        const cursor = req.result;\n        await callback(cursor.key, cursor.value, cursor);\n        cursor.continue();\n      };\n    });\n  }\n\n  /**\n   * Get the store that the operation can interact with. Requests can be made\n   * on the store. All requests made on the store will complete successfully\n   * before the operation's promise will resolve. If any request fails, the\n   * operation's promise will be rejected.\n   *\n   * @return {IDBObjectStore}\n   */\n  store() { return this.store_; }\n\n  /**\n   * Get the promise that wraps the transaction. This promise will resolve when\n   * all requests on the object store complete successfully and the transaction\n   * completes. If any request fails or the operation is aborted, the promise\n   * will be rejected.\n   *\n   * @return {!Promise}\n   */\n  promise() { return this.promise_; }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.DBConnection');\n\ngoog.require('shaka.offline.indexeddb.DBOperation');\ngoog.require('shaka.util.ArrayUtils');\n\n\n/**\n * DBConnection is used to manage an IndexedDB connection. It can create new\n * operations. If the connection is killed (via |destroy|) all pending\n * operations will be cancelled.\n */\nshaka.offline.indexeddb.DBConnection = class {\n  /**\n   * @param {IDBDatabase} connection A connection to an IndexedDB instance.\n   */\n  constructor(connection) {\n    /** @private {IDBDatabase} */\n    this.connection_ = connection;\n    /** @private {!Array.<shaka.offline.indexeddb.DBOperation>} */\n    this.pending_ = [];\n  }\n\n  /**\n   * @return {!Promise}\n   */\n  destroy() {\n    return Promise.all(this.pending_.map((op) => {\n      return op.abort();\n    }));\n  }\n\n  /**\n   * @param {string} store The name of the store that the operation should\n   *                       occur on.\n   * @return {!shaka.offline.indexeddb.DBOperation}\n   */\n  startReadOnlyOperation(store) {\n    return this.startOperation_(store, 'readonly');\n  }\n\n  /**\n   * @param {string} store The name of the store that the operation should\n   *                       occur on.\n   * @return {!shaka.offline.indexeddb.DBOperation}\n   */\n  startReadWriteOperation(store) {\n    return this.startOperation_(store, 'readwrite');\n  }\n\n  /**\n   * @param {string} store The name of the store that the operation should\n   *                       occur on.\n   * @param {string} type The type of operation being performed on the store.\n   *                      This determines what commands may be performed. This\n   *                      can either be \"readonly\" or \"readwrite\".\n   * @return {!shaka.offline.indexeddb.DBOperation}\n   * @private\n   */\n  startOperation_(store, type) {\n    const transaction = this.connection_.transaction([store], type);\n    const operation =\n        new shaka.offline.indexeddb.DBOperation(transaction, store);\n\n    this.pending_.push(operation);\n\n    // Once the operation is done (regardless of outcome) stop tracking it.\n    operation.promise().then(\n        () => this.stopTracking_(operation),\n        () => this.stopTracking_(operation));\n\n    return operation;\n  }\n\n  /**\n   * @param {!shaka.offline.indexeddb.DBOperation} operation\n   * @private\n   */\n  stopTracking_(operation) {\n    shaka.util.ArrayUtils.remove(this.pending_, operation);\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.BaseStorageCell');\n\ngoog.require('shaka.offline.indexeddb.DBConnection');\ngoog.require('shaka.util.Error');\ngoog.requireType('shaka.offline.indexeddb.DBOperation');\n\n\n/**\n * indexeddb.StorageCellBase is a base class for all stores that use IndexedDB.\n *\n * @implements {shaka.extern.StorageCell}\n */\nshaka.offline.indexeddb.BaseStorageCell = class {\n  /**\n   * @param {IDBDatabase} connection\n   * @param {string} segmentStore\n   * @param {string} manifestStore\n   */\n  constructor(connection, segmentStore, manifestStore) {\n    /** @protected {!shaka.offline.indexeddb.DBConnection} */\n    this.connection_ = new shaka.offline.indexeddb.DBConnection(connection);\n\n    /** @protected {string} */\n    this.segmentStore_ = segmentStore;\n\n    /** @protected {string} */\n    this.manifestStore_ = manifestStore;\n  }\n\n  /** @override */\n  destroy() {\n    return this.connection_.destroy();\n  }\n\n  /** @override */\n  hasFixedKeySpace() {\n    // By default, all IDB stores are read-only.  The latest one will need to\n    // override this default to be read-write.\n    return true;\n  }\n\n  /** @override */\n  addSegments(segments) {\n    // By default, reject all additions.\n    return this.rejectAdd(this.segmentStore_);\n  }\n\n  /** @override */\n  removeSegments(keys, onRemove) {\n    return this.remove_(this.segmentStore_, keys, onRemove);\n  }\n\n  /** @override */\n  async getSegments(keys) {\n    const rawSegments = await this.get_(this.segmentStore_, keys);\n    return rawSegments.map((s) => this.convertSegmentData(s));\n  }\n\n  /** @override */\n  addManifests(manifests) {\n    // By default, reject all additions.\n    return this.rejectAdd(this.manifestStore_);\n  }\n\n  /** @override */\n  updateManifest(key, manifest) {\n    // By default, reject all updates.\n    return this.rejectUpdate(this.manifestStore_);\n  }\n\n  /**\n   * @param {number} key\n   * @param {!shaka.extern.ManifestDB} manifest\n   * @return {!Promise}\n   * @protected\n   */\n  updateManifestImplementation(key, manifest) {\n    const op = this.connection_.startReadWriteOperation(this.manifestStore_);\n    const store = op.store();\n    store.get(key).onsuccess = (e) => {\n      store.put(manifest, key);\n    };\n\n    return op.promise();\n  }\n\n  /** @override */\n  updateManifestExpiration(key, newExpiration) {\n    const op = this.connection_.startReadWriteOperation(this.manifestStore_);\n    const store = op.store();\n    store.get(key).onsuccess = (e) => {\n      const manifest = e.target.result;\n      // If we can't find the value, then there is nothing for us to update.\n      if (manifest) {\n        manifest.expiration = newExpiration;\n        store.put(manifest, key);\n      }\n    };\n\n    return op.promise();\n  }\n\n  /** @override */\n  removeManifests(keys, onRemove) {\n    return this.remove_(this.manifestStore_, keys, onRemove);\n  }\n\n  /** @override */\n  async getManifests(keys) {\n    const rawManifests = await this.get_(this.manifestStore_, keys);\n    return Promise.all(rawManifests.map((m) => this.convertManifest(m)));\n  }\n\n  /** @override */\n  async getAllManifests() {\n    /** @type {!shaka.offline.indexeddb.DBOperation} */\n    const op = this.connection_.startReadOnlyOperation(this.manifestStore_);\n\n    /** @type {!Map.<number, shaka.extern.ManifestDB>} */\n    const values = new Map();\n\n    await op.forEachEntry(async (key, value) => {\n      const manifest = await this.convertManifest(value);\n      values.set(/** @type {number} */(key), manifest);\n    });\n\n    await op.promise();\n    return values;\n  }\n\n  /**\n   * @param {?} old\n   * @return {shaka.extern.SegmentDataDB}\n   * @protected\n   */\n  convertSegmentData(old) {\n    // Conversion is specific to each subclass.  By default, do nothing.\n    return /** @type {shaka.extern.SegmentDataDB} */(old);\n  }\n\n  /**\n   * @param {?} old\n   * @return {!Promise.<shaka.extern.ManifestDB>}\n   * @protected\n   */\n  convertManifest(old) {\n    // Conversion is specific to each subclass.  By default, do nothing.\n    return Promise.resolve(/** @type {shaka.extern.ManifestDB} */(old));\n  }\n\n  /**\n   * @param {string} storeName\n   * @return {!Promise}\n   * @protected\n   */\n  rejectAdd(storeName) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.NEW_KEY_OPERATION_NOT_SUPPORTED,\n        'Cannot add new value to ' + storeName));\n  }\n\n  /**\n   * @param {string} storeName\n   * @return {!Promise}\n   * @protected\n   */\n  rejectUpdate(storeName) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.MODIFY_OPERATION_NOT_SUPPORTED,\n        'Cannot modify values in ' + storeName));\n  }\n\n  /**\n   * @param {string} storeName\n   * @param {!Array.<T>} values\n   * @return {!Promise.<!Array.<number>>}\n   * @template T\n   * @protected\n   */\n  async add(storeName, values) {\n    const op = this.connection_.startReadWriteOperation(storeName);\n    const store = op.store();\n\n    /** @type {!Array.<number>} */\n    const keys = [];\n\n    // Write each segment out. When each request completes, the key will\n    // be in |request.result| as can be seen in\n    // https://w3c.github.io/IndexedDB/#key-generator-construct.\n    for (const value of values) {\n      const request = store.add(value);\n      request.onsuccess = (event) => {\n        const key = request.result;\n        keys.push(key);\n      };\n    }\n\n    // Wait until the operation completes or else |keys| will not be fully\n    // populated.\n    await op.promise();\n    return keys;\n  }\n\n  /**\n   * @param {string} storeName\n   * @param {!Array.<number>} keys\n   * @param {function(number)} onRemove\n   * @return {!Promise}\n   * @private\n   */\n  remove_(storeName, keys, onRemove) {\n    const op = this.connection_.startReadWriteOperation(storeName);\n    const store = op.store();\n\n    for (const key of keys) {\n      store.delete(key).onsuccess = () => onRemove(key);\n    }\n\n    return op.promise();\n  }\n\n  /**\n   * @param {string} storeName\n   * @param {!Array.<number>} keys\n   * @return {!Promise.<!Array.<T>>}\n   * @template T\n   * @private\n   */\n  async get_(storeName, keys) {\n    const op = this.connection_.startReadOnlyOperation(storeName);\n    const store = op.store();\n\n    const values = {};\n    /** @type {!Array.<number>} */\n    const missing = [];\n\n    // Use a map to store the objects so that we can reorder the results to\n    // match the order of |keys|.\n    for (const key of keys) {\n      const request = store.get(key);\n      request.onsuccess = () => {\n        // Make sure a defined value was found. Indexeddb treats no-value found\n        // as a success with an undefined result.\n        if (request.result == undefined) {\n          missing.push(key);\n        }\n\n        values[key] = request.result;\n      };\n    }\n\n    // Wait until the operation completes or else values may be missing from\n    // |values|. Use the original key list to convert the map to a list so that\n    // the order will match.\n    await op.promise();\n    if (missing.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.KEY_NOT_FOUND,\n          'Could not find values for ' + missing);\n    }\n\n    return keys.map((key) => values[key]);\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.EmeSessionStorageCell');\n\ngoog.require('shaka.offline.indexeddb.DBConnection');\ngoog.requireType('shaka.offline.indexeddb.DBOperation');\n\n\n/**\n * The implementation of the EME session storage cell.\n *\n * @implements {shaka.extern.EmeSessionStorageCell}\n */\nshaka.offline.indexeddb.EmeSessionStorageCell = class {\n  /**\n   * @param {IDBDatabase} connection\n   * @param {string} store\n   */\n  constructor(connection, store) {\n    /** @private {!shaka.offline.indexeddb.DBConnection} */\n    this.connection_ = new shaka.offline.indexeddb.DBConnection(connection);\n\n    /** @private {string} */\n    this.store_ = store;\n  }\n\n  /** @override */\n  destroy() { return this.connection_.destroy(); }\n\n  /** @override */\n  async getAll() {\n    /** @type {!shaka.offline.indexeddb.DBOperation} */\n    const op = this.connection_.startReadOnlyOperation(this.store_);\n    /** @type {!Array.<shaka.extern.EmeSessionDB>} */\n    const values = [];\n\n    await op.forEachEntry((key, value) => {\n      values.push(value);\n    });\n\n    await op.promise();\n    return values;\n  }\n\n  /** @override */\n  add(sessions) {\n    const op = this.connection_.startReadWriteOperation(this.store_);\n    const store = op.store();\n\n    for (const session of sessions) {\n      store.add(session);\n    }\n\n    return op.promise();\n  }\n\n  /** @override */\n  async remove(sessionIds) {\n    /** @type {!shaka.offline.indexeddb.DBOperation} */\n    const op = this.connection_.startReadWriteOperation(this.store_);\n\n    await op.forEachEntry((key, value, cursor) => {\n      if (sessionIds.includes(value.sessionId)) {\n        cursor.delete();\n      }\n    });\n\n    await op.promise();\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.StorageMechanism');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.offline.indexeddb.EmeSessionStorageCell');\ngoog.require('shaka.offline.indexeddb.V1StorageCell');\ngoog.require('shaka.offline.indexeddb.V2StorageCell');\ngoog.require('shaka.offline.indexeddb.V5StorageCell');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * A storage mechanism to manage storage cells for an indexed db instance.\n * The cells are just for interacting with the stores that are found in the\n * database instance. The mechanism is responsible for creating new stores\n * when opening the database. If the database is too old of a version, a\n * cell will be added for the old stores but the cell won't support add\n * operations. The mechanism will create the new versions of the stores and\n * will allow add operations for those stores.\n *\n * @implements {shaka.extern.StorageMechanism}\n */\nshaka.offline.indexeddb.StorageMechanism = class {\n  /** */\n  constructor() {\n    /** @private {IDBDatabase} */\n    this.db_ = null;\n\n    /** @private {shaka.extern.StorageCell} */\n    this.v1_ = null;\n    /** @private {shaka.extern.StorageCell} */\n    this.v2_ = null;\n    /** @private {shaka.extern.StorageCell} */\n    this.v3_ = null;\n    /** @private {shaka.extern.StorageCell} */\n    this.v5_ = null;\n    /** @private {shaka.extern.EmeSessionStorageCell} */\n    this.sessions_ = null;\n  }\n\n  /**\n   * @override\n   */\n  init() {\n    const name = shaka.offline.indexeddb.StorageMechanism.DB_NAME;\n    const version = shaka.offline.indexeddb.StorageMechanism.VERSION;\n\n    const p = new shaka.util.PublicPromise();\n\n    // Add a timeout mechanism, for the (rare?) case where no callbacks are\n    // called at all, so that this method doesn't hang forever.\n    let timedOut = false;\n    const timeOutTimer = new shaka.util.Timer(() => {\n      timedOut = true;\n      p.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.INDEXED_DB_INIT_TIMED_OUT));\n    });\n    timeOutTimer.tickAfter(5);\n\n    const open = window.indexedDB.open(name, version);\n    open.onsuccess = (event) => {\n      if (timedOut) {\n        // Too late, we have already given up on opening the storage mechanism.\n        return;\n      }\n      const db = open.result;\n      this.db_ = db;\n      this.v1_ = shaka.offline.indexeddb.StorageMechanism.createV1_(db);\n      this.v2_ = shaka.offline.indexeddb.StorageMechanism.createV2_(db);\n      this.v3_ = shaka.offline.indexeddb.StorageMechanism.createV3_(db);\n      // NOTE: V4 of the database was when we introduced a special table to\n      // store EME session IDs.  It has no separate storage cell, so we skip to\n      // V5.\n      this.v5_ = shaka.offline.indexeddb.StorageMechanism.createV5_(db);\n      this.sessions_ =\n          shaka.offline.indexeddb.StorageMechanism.createEmeSessionCell_(db);\n      timeOutTimer.stop();\n      p.resolve();\n    };\n    open.onupgradeneeded = (event) => {\n      // Add object stores for the latest version only.\n      this.createStores_(open.result);\n    };\n    open.onerror = (event) => {\n      if (timedOut) {\n        // Too late, we have already given up on opening the storage mechanism.\n        return;\n      }\n      p.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.INDEXED_DB_ERROR,\n          open.error));\n      timeOutTimer.stop();\n\n      // Firefox will raise an error on the main thread unless we stop it here.\n      event.preventDefault();\n    };\n\n    return p;\n  }\n\n  /**\n   * @override\n   */\n  async destroy() {\n    if (this.v1_) {\n      await this.v1_.destroy();\n    }\n    if (this.v2_) {\n      await this.v2_.destroy();\n    }\n    if (this.v3_) {\n      await this.v3_.destroy();\n    }\n    if (this.v5_) {\n      await this.v5_.destroy();\n    }\n    if (this.sessions_) {\n      await this.sessions_.destroy();\n    }\n\n    // If we were never initialized, then |db_| will still be null.\n    if (this.db_) {\n      this.db_.close();\n    }\n  }\n\n  /**\n   * @override\n   */\n  getCells() {\n    const map = new Map();\n\n    if (this.v1_) {\n      map.set('v1', this.v1_);\n    }\n    if (this.v2_) {\n      map.set('v2', this.v2_);\n    }\n    if (this.v3_) {\n      map.set('v3', this.v3_);\n    }\n    if (this.v5_) {\n      map.set('v5', this.v5_);\n    }\n\n    return map;\n  }\n\n  /**\n   * @override\n   */\n  getEmeSessionCell() {\n    goog.asserts.assert(this.sessions_, 'Cannot be destroyed.');\n    return this.sessions_;\n  }\n\n  /**\n   * @override\n   */\n  async erase() {\n    // Not all cells may have been created, so only destroy the ones that\n    // were created.\n    if (this.v1_) {\n      await this.v1_.destroy();\n    }\n    if (this.v2_) {\n      await this.v2_.destroy();\n    }\n    if (this.v3_) {\n      await this.v3_.destroy();\n    }\n    if (this.v5_) {\n      await this.v5_.destroy();\n    }\n\n    // |db_| will only be null if the muxer was not initialized. We need to\n    // close the connection in order delete the database without it being\n    // blocked.\n    if (this.db_) {\n      this.db_.close();\n    }\n\n    await shaka.offline.indexeddb.StorageMechanism.deleteAll_();\n\n    // Reset before initializing.\n    this.db_ = null;\n    this.v1_ = null;\n    this.v2_ = null;\n    this.v3_ = null;\n    this.v5_ = null;\n\n    await this.init();\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.StorageCell}\n   * @private\n   */\n  static createV1_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const segmentStore = StorageMechanism.V1_SEGMENT_STORE;\n    const manifestStore = StorageMechanism.V1_MANIFEST_STORE;\n    const stores = db.objectStoreNames;\n    if (stores.contains(manifestStore) && stores.contains(segmentStore)) {\n      shaka.log.debug('Mounting v1 idb storage cell');\n\n      return new shaka.offline.indexeddb.V1StorageCell(\n          db,\n          segmentStore,\n          manifestStore);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.StorageCell}\n   * @private\n   */\n  static createV2_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const segmentStore = StorageMechanism.V2_SEGMENT_STORE;\n    const manifestStore = StorageMechanism.V2_MANIFEST_STORE;\n    const stores = db.objectStoreNames;\n    if (stores.contains(manifestStore) && stores.contains(segmentStore)) {\n      shaka.log.debug('Mounting v2 idb storage cell');\n\n      return new shaka.offline.indexeddb.V2StorageCell(\n          db,\n          segmentStore,\n          manifestStore);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.StorageCell}\n   * @private\n   */\n  static createV3_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const segmentStore = StorageMechanism.V3_SEGMENT_STORE;\n    const manifestStore = StorageMechanism.V3_MANIFEST_STORE;\n    const stores = db.objectStoreNames;\n    if (stores.contains(manifestStore) && stores.contains(segmentStore)) {\n      shaka.log.debug('Mounting v3 idb storage cell');\n\n      // Version 3 uses the same structure as version 2, so we can use the same\n      // cells but it can support new entries.\n      return new shaka.offline.indexeddb.V2StorageCell(\n          db,\n          segmentStore,\n          manifestStore);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.StorageCell}\n   * @private\n   */\n  static createV5_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const segmentStore = StorageMechanism.V5_SEGMENT_STORE;\n    const manifestStore = StorageMechanism.V5_MANIFEST_STORE;\n    const stores = db.objectStoreNames;\n    if (stores.contains(manifestStore) && stores.contains(segmentStore)) {\n      shaka.log.debug('Mounting v5 idb storage cell');\n\n      return new shaka.offline.indexeddb.V5StorageCell(\n          db,\n          segmentStore,\n          manifestStore);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.EmeSessionStorageCell}\n   * @private\n   */\n  static createEmeSessionCell_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const store = StorageMechanism.SESSION_ID_STORE;\n    if (db.objectStoreNames.contains(store)) {\n      shaka.log.debug('Mounting session ID idb storage cell');\n      return new shaka.offline.indexeddb.EmeSessionStorageCell(db, store);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @private\n   */\n  createStores_(db) {\n    const storeNames = [\n      shaka.offline.indexeddb.StorageMechanism.V5_SEGMENT_STORE,\n      shaka.offline.indexeddb.StorageMechanism.V5_MANIFEST_STORE,\n      shaka.offline.indexeddb.StorageMechanism.SESSION_ID_STORE,\n    ];\n\n    for (const name of storeNames) {\n      if (!db.objectStoreNames.contains(name)) {\n        db.createObjectStore(name, {autoIncrement: true});\n      }\n    }\n  }\n\n  /**\n   * Delete the indexed db instance so that all stores are deleted and cleared.\n   * This will force the database to a like-new state next time it opens.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  static deleteAll_() {\n    const name = shaka.offline.indexeddb.StorageMechanism.DB_NAME;\n\n    const p = new shaka.util.PublicPromise();\n\n    const del = window.indexedDB.deleteDatabase(name);\n    del.onblocked = (event) => {\n      shaka.log.warning('Deleting', name, 'is being blocked', event);\n    };\n    del.onsuccess = (event) => {\n      p.resolve();\n    };\n    del.onerror = (event) => {\n      p.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.INDEXED_DB_ERROR,\n          del.error));\n\n      // Firefox will raise an error on the main thread unless we stop it here.\n      event.preventDefault();\n    };\n\n    return p;\n  }\n};\n\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.DB_NAME = 'shaka_offline_db';\n/** @const {number} */\nshaka.offline.indexeddb.StorageMechanism.VERSION = 5;\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V1_SEGMENT_STORE = 'segment';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V2_SEGMENT_STORE = 'segment-v2';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V3_SEGMENT_STORE = 'segment-v3';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V5_SEGMENT_STORE = 'segment-v5';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V1_MANIFEST_STORE = 'manifest';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V2_MANIFEST_STORE = 'manifest-v2';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V3_MANIFEST_STORE = 'manifest-v3';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V5_MANIFEST_STORE = 'manifest-v5';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.SESSION_ID_STORE = 'session-ids';\n\n\n// Since this may be called before the polyfills remove indexeddb support from\n// some platforms (looking at you Chromecast), we need to check for support\n// when we create the mechanism.\n//\n// Thankfully the storage muxer api allows us to return a null mechanism\n// to indicate that the mechanism is not supported on this platform.\nshaka.offline.StorageMuxer.register(\n    'idb',\n    () => {\n      // Offline storage is not supported on the Chromecast or Xbox One\n      // platforms.\n      if (shaka.util.Platform.isChromecast() ||\n          shaka.util.Platform.isXboxOne()) {\n        return null;\n      }\n      // Offline storage requires the IndexedDB API.\n      if (!window.indexedDB) {\n        return null;\n      }\n      return new shaka.offline.indexeddb.StorageMechanism();\n    });\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.StorageCellHandle');\ngoog.provide('shaka.offline.StorageCellPath');\ngoog.provide('shaka.offline.StorageMuxer');\n\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\n\n/**\n * @typedef {{\n *  mechanism: string,\n *  cell: string\n * }}\n *\n * @property {string} mechanism\n *  The name of the mechanism that holds the cell.\n * @property {string} cell\n *  The name of the cell in the mechanism.\n */\nshaka.offline.StorageCellPath;\n\n\n/**\n * @typedef {{\n *   path: shaka.offline.StorageCellPath,\n *   cell: !shaka.extern.StorageCell\n * }}\n *\n * @property {shaka.offline.StorageCellPath} path\n *   The path that maps to the cell.\n * @property {shaka.extern.StorageCell} cell\n *   The storage cell that the path points to within the storage muxer.\n */\nshaka.offline.StorageCellHandle;\n\n\n// TODO: revisit this when Closure Compiler supports partially-exported classes.\n/**\n * StorageMuxer is responsible for managing StorageMechanisms and addressing\n * cells. The primary purpose of the muxer is to give the caller the correct\n * cell for the operations they want to perform.\n *\n * |findActive| will be used when the caller wants a cell that supports\n * add-operations. This will be used when saving new content to storage.\n *\n * |findAll| will be used when the caller want to look at all the content\n * in storage.\n *\n * |resolvePath| will be used to convert a path (from |findActive| and\n * |findAll|) into a cell, which it then returns.\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.offline.StorageMuxer = class {\n  /** */\n  constructor() {\n    /**\n     * A key in this map is the name given when registering a StorageMechanism.\n     *\n     * @private {!Map.<string, !shaka.extern.StorageMechanism>}\n     */\n    this.mechanisms_ = new Map();\n  }\n\n  // TODO: revisit this when the compiler supports partially-exported classes.\n  /**\n   * Free all resources used by the muxer, mechanisms, and cells. This should\n   * not affect the stored content.\n   *\n   * @override\n   * @export\n   */\n  destroy() {\n    /** @type {!Array.<!Promise>} */\n    const destroys = [];\n    for (const mechanism of this.mechanisms_.values()) {\n      destroys.push(mechanism.destroy());\n    }\n\n    // Empty the map so that subsequent calls will be no-ops.\n    this.mechanisms_.clear();\n\n    return Promise.all(destroys);\n  }\n\n  /**\n   * Initialize the storage muxer. This must be called before any other calls.\n   * This will initialize the muxer to use all mechanisms that have been\n   * registered with |StorageMuxer.register|.\n   *\n   * @return {!Promise}\n   */\n  init() {\n    // Add the new instance of each mechanism to the muxer.\n    const registry = shaka.offline.StorageMuxer.getRegistry_();\n    registry.forEach((factory, name) => {\n      const mech = factory();\n      if (mech) {\n        this.mechanisms_.set(name, mech);\n      } else {\n        shaka.log.info(\n            'Skipping ' + name + ' as it is not supported on this platform');\n      }\n    });\n\n    /** @type {!Array.<!Promise>} */\n    const initPromises = [];\n    for (const mechanism of this.mechanisms_.values()) {\n      initPromises.push(mechanism.init());\n    }\n\n    return Promise.all(initPromises);\n  }\n\n  /**\n   * Get a promise that will resolve with a storage cell that supports\n   * add-operations. If no cell can be found, the promise will be rejected.\n   *\n   * @return {shaka.offline.StorageCellHandle}\n   */\n  getActive() {\n    /** @type {?shaka.offline.StorageCellHandle} */\n    let handle = null;\n\n    this.mechanisms_.forEach((mechanism, mechanismName) => {\n      mechanism.getCells().forEach((cell, cellName) => {\n        // If this cell is not useful to us or we already have a handle, then\n        // we don't need to make a new handle.\n        if (cell.hasFixedKeySpace() || handle) {\n          return;\n        }\n\n        const path = {\n          mechanism: mechanismName,\n          cell: cellName,\n        };\n\n        handle = {\n          path: path,\n          cell: cell,\n        };\n      });\n    });\n\n    if (handle) {\n      return /** @type {shaka.offline.StorageCellHandle} */(handle);\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.MISSING_STORAGE_CELL,\n        'Could not find a cell that supports add-operations');\n  }\n\n  /**\n   * @param {function(!shaka.offline.StorageCellPath,\n   *                  !shaka.extern.StorageCell)} callback\n   */\n  forEachCell(callback) {\n    this.mechanisms_.forEach((mechanism, mechanismName) => {\n      mechanism.getCells().forEach((cell, cellName) => {\n        const path = {\n          mechanism: mechanismName,\n          cell: cellName,\n        };\n\n        callback(path, cell);\n      });\n    });\n  }\n\n  /**\n   * Get a specific storage cell. The promise will resolve with the storage\n   * cell if it is found. If the storage cell is not found, the promise will\n   * be rejected.\n   *\n   * @param {string} mechanismName\n   * @param {string} cellName\n   * @return {!shaka.extern.StorageCell}\n   */\n  getCell(mechanismName, cellName) {\n    const mechanism = this.mechanisms_.get(mechanismName);\n    if (!mechanism) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.MISSING_STORAGE_CELL,\n          'Could not find mechanism with name ' + mechanismName);\n    }\n\n    const cell = mechanism.getCells().get(cellName);\n    if (!cell) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.MISSING_STORAGE_CELL,\n          'Could not find cell with name ' + cellName);\n    }\n\n    return cell;\n  }\n\n  /**\n   * @param {function(!shaka.extern.EmeSessionStorageCell)} callback\n   */\n  forEachEmeSessionCell(callback) {\n    this.mechanisms_.forEach((mechanism, name) => {\n      callback(mechanism.getEmeSessionCell());\n    });\n  }\n\n  /**\n   * Gets an arbitrary EME session cell that can be used for storing new session\n   * info.\n   *\n   * @return {!shaka.extern.EmeSessionStorageCell}\n   */\n  getEmeSessionCell() {\n    const mechanisms = Array.from(this.mechanisms_.keys());\n    if (!mechanisms.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.STORAGE_NOT_SUPPORTED,\n          'No supported storage mechanisms found');\n    }\n\n    return this.mechanisms_.get(mechanisms[0]).getEmeSessionCell();\n  }\n\n  /**\n   * Find the cell that the path points to. A path is made up of a mount point\n   * and a cell id. If a cell can be found, the cell will be returned. If no\n   * cell is found, null will be returned.\n   *\n   * @param {shaka.offline.StorageCellPath} path\n   * @return {shaka.extern.StorageCell}\n   */\n  resolvePath(path) {\n    const mechanism = this.mechanisms_.get(path.mechanism);\n\n    if (!mechanism) {\n      return null;\n    }\n\n    return mechanism.getCells().get(path.cell);\n  }\n\n  /**\n   * This will erase all previous content from storage. Using paths obtained\n   * before calling |erase| is discouraged, as cells may have changed during a\n   * erase.\n   *\n   * @return {!Promise}\n   */\n  async erase() {\n    // If we have initialized, we will use the existing mechanism instances.\n    /** @type {!Array.<!shaka.extern.StorageMechanism>} */\n    const mechanisms = Array.from(this.mechanisms_.values());\n    const alreadyInitialized = mechanisms.length > 0;\n\n    // If we have not initialized, we should still be able to erase.  This is\n    // critical to our ability to wipe the DB in case of a version mismatch.\n    // If there are no instances, create temporary ones and destroy them later.\n    if (!alreadyInitialized) {\n      const registry = shaka.offline.StorageMuxer.getRegistry_();\n      registry.forEach((factory, name) => {\n        const mech = factory();\n        if (mech) {\n          mechanisms.push(mech);\n        }\n      });\n    }\n\n    // Erase all storage mechanisms.\n    await Promise.all(mechanisms.map((m) => m.erase()));\n\n    // If we were erasing temporary instances, destroy them, too.\n    if (!alreadyInitialized) {\n      await Promise.all(mechanisms.map((m) => m.destroy()));\n    }\n  }\n\n  /**\n   * Register a storage mechanism for use with the default storage muxer. This\n   * will have no effect on any storage muxer already in main memory.\n   *\n   * @param {string} name\n   * @param {function():shaka.extern.StorageMechanism} factory\n   * @export\n   */\n  static register(name, factory) {\n    shaka.offline.StorageMuxer.registry_.set(name, factory);\n  }\n\n\n  /**\n   * Unregister a storage mechanism for use with the default storage muxer. This\n   * will have no effect on any storage muxer already in main memory.\n   *\n   * @param {string} name The name that the storage mechanism was registered\n   *                      under.\n   * @export\n   */\n  static unregister(name) {\n    shaka.offline.StorageMuxer.registry_.delete(name);\n  }\n\n  /**\n   * Check if there is support for storage on this platform. It is assumed that\n   * if there are any mechanisms registered, it means that storage is supported\n   * on this platform. We do not check if the mechanisms have any cells.\n   *\n   * @return {boolean}\n   */\n  static support() {\n    const registry = shaka.offline.StorageMuxer.getRegistry_();\n    // Make sure that we will have SOME mechanisms created by creating a\n    // mechanism and immediately destroying it.\n    for (const create of registry.values()) {\n      const instance = create();\n\n      if (instance) {\n        instance.destroy();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Replace the mechanism map used by the muxer. This should only be used\n   * in testing.\n   *\n   * @param {Map.<string, function():shaka.extern.StorageMechanism>} map\n   */\n  static overrideSupport(map) {\n    shaka.offline.StorageMuxer.override_ = map;\n  }\n\n  /**\n   * Undo a previous call to |overrideSupport|.\n   */\n  static clearOverride() {\n    shaka.offline.StorageMuxer.override_ = null;\n  }\n\n  /**\n   * Get the registry. If the support has been disabled, this will always\n   * an empty registry. Reading should always be done via |getRegistry_|.\n   *\n   * @return {!Map.<string, function():shaka.extern.StorageMechanism>}\n   * @private\n   */\n  static getRegistry_() {\n    const override = shaka.offline.StorageMuxer.override_;\n    const registry = shaka.offline.StorageMuxer.registry_;\n\n    if (COMPILED) {\n      return registry;\n    } else {\n      return override || registry;\n    }\n  }\n};\n\n\n/**\n * @private {Map.<string, function():shaka.extern.StorageMechanism>}\n */\nshaka.offline.StorageMuxer.override_ = null;\n\n\n/**\n * @private {!Map.<string, function():shaka.extern.StorageMechanism>}\n */\nshaka.offline.StorageMuxer.registry_ = new Map();\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.V1StorageCell');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.offline.indexeddb.BaseStorageCell');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.PeriodCombiner');\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * The V1StorageCell is for all stores that follow the shaka.externs V1 offline\n * types, introduced in Shaka Player v2.0 and deprecated in v2.3.\n *\n * @implements {shaka.extern.StorageCell}\n */\nshaka.offline.indexeddb.V1StorageCell = class\n  extends shaka.offline.indexeddb.BaseStorageCell {\n  /** @override */\n  async updateManifestExpiration(key, newExpiration) {\n    const op = this.connection_.startReadWriteOperation(this.manifestStore_);\n\n    /** @type {IDBObjectStore} */\n    const store = op.store();\n\n    /** @type {!shaka.util.PublicPromise} */\n    const p = new shaka.util.PublicPromise();\n\n    store.get(key).onsuccess = (event) => {\n      // Make sure a defined value was found. Indexeddb treats \"no value found\"\n      // as a success with an undefined result.\n      const manifest = /** @type {shaka.extern.ManifestDBV1} */(\n        event.target.result);\n\n      // Indexeddb does not fail when you get a value that is not in the\n      // database. It will return an undefined value. However, we expect\n      // the value to never be null, so something is wrong if we get a\n      // falsey value.\n      if (manifest) {\n        // Since this store's scheme uses in-line keys, we don't specify the key\n        // with |put|.  This difference is why we must override the base class.\n        goog.asserts.assert(\n            manifest.key == key,\n            'With in-line keys, the keys should match');\n\n        manifest.expiration = newExpiration;\n        store.put(manifest);\n\n        p.resolve();\n      } else {\n        p.reject(new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.KEY_NOT_FOUND,\n            'Could not find values for ' + key));\n      }\n    };\n\n    await Promise.all([op.promise(), p]);\n  }\n\n  /**\n   * @override\n   * @param {shaka.extern.ManifestDBV1} old\n   * @return {!Promise.<shaka.extern.ManifestDB>}\n   */\n  async convertManifest(old) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    const streamsPerPeriod = [];\n\n    for (let i = 0; i < old.periods.length; ++i) {\n      // The last period ends at the end of the presentation.\n      const periodEnd = i == old.periods.length - 1 ?\n          old.duration : old.periods[i + 1].startTime;\n      const duration = periodEnd - old.periods[i].startTime;\n      const streams = V1StorageCell.convertPeriod_(old.periods[i], duration);\n\n      streamsPerPeriod.push(streams);\n    }\n\n    const streams = await shaka.util.PeriodCombiner.combineDbStreams(\n        streamsPerPeriod);\n\n    return {\n      creationTime: 0,\n      originalManifestUri: old.originalManifestUri,\n      duration: old.duration,\n      size: old.size,\n      expiration: old.expiration == null ? Infinity : old.expiration,\n      streams,\n      sessionIds: old.sessionIds,\n      drmInfo: old.drmInfo,\n      appMetadata: old.appMetadata,\n    };\n  }\n\n  /**\n   * @param {shaka.extern.PeriodDBV1} old\n   * @param {number} periodDuration\n   * @return {!Array.<shaka.extern.StreamDB>}\n   * @private\n   */\n  static convertPeriod_(old, periodDuration) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    // In the case that this is really old (like really old, like dinosaurs\n    // roaming the Earth old) there may be no variants, so we need to add those.\n    V1StorageCell.fillMissingVariants_(old);\n\n    for (const stream of old.streams) {\n      const message = 'After filling in missing variants, ' +\n                      'each stream should have variant ids';\n      goog.asserts.assert(stream.variantIds, message);\n    }\n\n    return old.streams.map((stream) => V1StorageCell.convertStream_(\n        stream, old.startTime, periodDuration));\n  }\n\n  /**\n   * @param {shaka.extern.StreamDBV1} old\n   * @param {number} periodStart\n   * @param {number} periodDuration\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  static convertStream_(old, periodStart, periodDuration) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    const initSegmentKey = old.initSegmentUri ?\n        V1StorageCell.getKeyFromSegmentUri_(old.initSegmentUri) : null;\n\n    // timestampOffset in the new format is the inverse of\n    // presentationTimeOffset in the old format.  Also, PTO did not include the\n    // period start, while TO does.\n    const timestampOffset = periodStart + old.presentationTimeOffset;\n\n    const appendWindowStart = periodStart;\n    const appendWindowEnd = periodStart + periodDuration;\n\n    return {\n      id: old.id,\n      originalId: null,\n      primary: old.primary,\n      type: old.contentType,\n      mimeType: old.mimeType,\n      codecs: old.codecs,\n      frameRate: old.frameRate,\n      pixelAspectRatio: undefined,\n      hdr: undefined,\n      kind: old.kind,\n      language: old.language,\n      label: old.label,\n      width: old.width,\n      height: old.height,\n      initSegmentKey: initSegmentKey,\n      encrypted: old.encrypted,\n      keyIds: new Set([old.keyId]),\n      segments: old.segments.map((segment) => V1StorageCell.convertSegment_(\n          segment, initSegmentKey, appendWindowStart, appendWindowEnd,\n          timestampOffset)),\n      variantIds: old.variantIds,\n      roles: [],\n      forced: false,\n      audioSamplingRate: null,\n      channelsCount: null,\n      spatialAudio: false,\n      closedCaptions: null,\n      tilesLayout: undefined,\n    };\n  }\n\n  /**\n   * @param {shaka.extern.SegmentDBV1} old\n   * @param {?number} initSegmentKey\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @param {number} timestampOffset\n   * @return {shaka.extern.SegmentDB}\n   * @private\n   */\n  static convertSegment_(\n      old, initSegmentKey, appendWindowStart, appendWindowEnd,\n      timestampOffset) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    // Since we don't want to use the uri anymore, we need to parse the key\n    // from it.\n    const dataKey = V1StorageCell.getKeyFromSegmentUri_(old.uri);\n\n    return {\n      startTime: appendWindowStart + old.startTime,\n      endTime: appendWindowStart + old.endTime,\n      dataKey,\n      initSegmentKey,\n      appendWindowStart,\n      appendWindowEnd,\n      timestampOffset,\n      tilesLayout: '',\n    };\n  }\n\n  /**\n   * @override\n   * @param {shaka.extern.SegmentDataDBV1} old\n   * @return {shaka.extern.SegmentDataDB}\n   */\n  convertSegmentData(old) {\n    return {data: old.data};\n  }\n\n  /**\n   * @param {string} uri\n   * @return {number}\n   * @private\n   */\n  static getKeyFromSegmentUri_(uri) {\n    let parts = null;\n\n    // Try parsing the uri as the original Shaka Player 2.0 uri.\n    parts = /^offline:[0-9]+\\/[0-9]+\\/([0-9]+)$/.exec(uri);\n    if (parts) {\n      return Number(parts[1]);\n    }\n\n    // Just before Shaka Player 2.3 the uri format was changed to remove some\n    // of the un-used information from the uri and make the segment uri and\n    // manifest uri follow a similar format. However the old storage system\n    // was still in place, so it is possible for Storage V1 Cells to have\n    // Storage V2 uris.\n    parts = /^offline:segment\\/([0-9]+)$/.exec(uri);\n    if (parts) {\n      return Number(parts[1]);\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n        'Could not parse uri ' + uri);\n  }\n\n  /**\n   * Take a period and check if the streams need to have variants generated.\n   * Before Shaka Player moved to its variants model, there were no variants.\n   * This will fill missing variants into the given object.\n   *\n   * @param {shaka.extern.PeriodDBV1} period\n   * @private\n   */\n  static fillMissingVariants_(period) {\n    const AUDIO = shaka.util.ManifestParserUtils.ContentType.AUDIO;\n    const VIDEO = shaka.util.ManifestParserUtils.ContentType.VIDEO;\n\n    // There are three cases:\n    //  1. All streams' variant ids are null\n    //  2. All streams' variant ids are non-null\n    //  3. Some streams' variant ids are null and other are non-null\n    // Case 3 is invalid and should never happen in production.\n\n    const audio = period.streams.filter((s) => s.contentType == AUDIO);\n    const video = period.streams.filter((s) => s.contentType == VIDEO);\n\n    // Case 2 - There is nothing we need to do, so let's just get out of here.\n    if (audio.every((s) => s.variantIds) && video.every((s) => s.variantIds)) {\n      return;\n    }\n\n    // Case 3... We don't want to be in case three.\n    goog.asserts.assert(\n        audio.every((s) => !s.variantIds),\n        'Some audio streams have variant ids and some do not.');\n    goog.asserts.assert(\n        video.every((s) => !s.variantIds),\n        'Some video streams have variant ids and some do not.');\n\n    // Case 1 - Populate all the variant ids (putting us back to case 2).\n    // Since all the variant ids are null, we need to first make them into\n    // valid arrays.\n    for (const s of audio) {\n      s.variantIds = [];\n    }\n    for (const s of video) {\n      s.variantIds = [];\n    }\n\n    let nextId = 0;\n\n    // It is not possible in Shaka Player's pre-variant world to have audio-only\n    // and video-only content mixed in with audio-video content. So we can\n    // assume that there is only audio-only or video-only if one group is empty.\n\n    // Everything is video-only content - so each video stream gets to be its\n    // own variant.\n    if (video.length && !audio.length) {\n      shaka.log.debug('Found video-only content. Creating variants for video.');\n      const variantId = nextId++;\n      for (const s of video) {\n        s.variantIds.push(variantId);\n      }\n    }\n\n    // Everything is audio-only content - so each audio stream gets to be its\n    // own variant.\n    if (!video.length && audio.length) {\n      shaka.log.debug('Found audio-only content. Creating variants for audio.');\n      const variantId = nextId++;\n      for (const s of audio) {\n        s.variantIds.push(variantId);\n      }\n    }\n\n    // Everything is audio-video content.\n    if (video.length && audio.length) {\n      shaka.log.debug('Found audio-video content. Creating variants.');\n      for (const a of audio) {\n        for (const v of video) {\n          const variantId = nextId++;\n          a.variantIds.push(variantId);\n          v.variantIds.push(variantId);\n        }\n      }\n    }\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.V2StorageCell');\n\ngoog.require('shaka.offline.indexeddb.BaseStorageCell');\ngoog.require('shaka.util.PeriodCombiner');\n\n\n/**\n * The V2StorageCell is for all stores that follow the shaka.externs V2 and V3\n * offline types.  V2 was introduced in Shaka Player v2.3.0 and quickly\n * replaced with V3 in Shaka Player v2.3.2.  V3 was then deprecated in v3.0.\n *\n * Upgrading from V1 to V2 initially broke the database in a way that prevented\n * adding new records.  The problem was with the upgrade process, not with the\n * database format.  Once database upgrades were removed, we increased the\n * database version to V3 and marked V2 as read-only.  Therefore, V2 and V3\n * databases can both be read by this cell.\n *\n * The manifest and segment stores didn't change in database V4, but a separate\n * table for session IDs was added.  So this cell also covers DB V4.\n *\n * @implements {shaka.extern.StorageCell}\n */\nshaka.offline.indexeddb.V2StorageCell = class\n  extends shaka.offline.indexeddb.BaseStorageCell {\n  /**\n   * @override\n   * @param {shaka.extern.ManifestDBV2} old\n   * @return {!Promise.<shaka.extern.ManifestDB>}\n   */\n  async convertManifest(old) {\n    const streamsPerPeriod = [];\n\n    for (let i = 0; i < old.periods.length; ++i) {\n      // The last period ends at the end of the presentation.\n      const periodEnd = i == old.periods.length - 1 ?\n          old.duration : old.periods[i + 1].startTime;\n      const duration = periodEnd - old.periods[i].startTime;\n      const streams = this.convertPeriod_(old.periods[i], duration);\n\n      streamsPerPeriod.push(streams);\n    }\n\n    const streams = await shaka.util.PeriodCombiner.combineDbStreams(\n        streamsPerPeriod);\n\n    return {\n      appMetadata: old.appMetadata,\n      creationTime: 0,\n      drmInfo: old.drmInfo,\n      duration: old.duration,\n      // JSON serialization turns Infinity into null, so turn it back now.\n      expiration: old.expiration == null ? Infinity : old.expiration,\n      originalManifestUri: old.originalManifestUri,\n      sessionIds: old.sessionIds,\n      size: old.size,\n      streams,\n    };\n  }\n\n  /**\n   * @param {shaka.extern.PeriodDBV2} period\n   * @param {number} periodDuration\n   * @return {!Array.<shaka.extern.StreamDB>}\n   * @private\n   */\n  convertPeriod_(period, periodDuration) {\n    const streams = [];\n    for (const stream of period.streams) {\n      // The v4 version of the database as written by v2.5.0 - v2.5.9 might have\n      // been corrupted slightly.  A bug caused the stream metadata from all\n      // periods to be written to each period.  This was corrected in v2.5.10.\n      // To fix this, we can identify the extra streams by their lack of\n      // variantIds and skip them.\n      if (stream.variantIds.length == 0) {\n        continue;\n      }\n\n      streams.push(this.convertStream_(\n          stream, period.startTime, period.startTime + periodDuration));\n    }\n    return streams;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDBV2} old\n   * @param {number} periodStart\n   * @param {number} periodEnd\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  convertStream_(old, periodStart, periodEnd) {\n    return {\n      id: old.id,\n      originalId: old.originalId,\n      primary: old.primary,\n      type: old.contentType,\n      mimeType: old.mimeType,\n      codecs: old.codecs,\n      frameRate: old.frameRate,\n      pixelAspectRatio: old.pixelAspectRatio,\n      hdr: undefined,\n      kind: old.kind,\n      language: old.language,\n      label: old.label,\n      width: old.width,\n      height: old.height,\n      encrypted: old.encrypted,\n      keyIds: new Set([old.keyId]),\n      segments: old.segments.map((segment) =>\n        this.convertSegment_(\n            segment, old.initSegmentKey, periodStart, periodEnd,\n            old.presentationTimeOffset)),\n      variantIds: old.variantIds,\n      roles: [],\n      forced: false,\n      audioSamplingRate: null,\n      channelsCount: null,\n      spatialAudio: false,\n      closedCaptions: null,\n      tilesLayout: undefined,\n    };\n  }\n\n  /**\n   * @param {shaka.extern.SegmentDBV2} old\n   * @param {?number} initSegmentKey\n   * @param {number} periodStart\n   * @param {number} periodEnd\n   * @param {number} presentationTimeOffset\n   * @return {shaka.extern.SegmentDB}\n   * @private\n   */\n  convertSegment_(\n      old, initSegmentKey, periodStart, periodEnd, presentationTimeOffset) {\n    const timestampOffset = periodStart - presentationTimeOffset;\n\n    return {\n      startTime: periodStart + old.startTime,\n      endTime: periodStart + old.endTime,\n      initSegmentKey,\n      appendWindowStart: periodStart,\n      appendWindowEnd: periodEnd,\n      timestampOffset,\n      dataKey: old.dataKey,\n      tilesLayout: '',\n    };\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.V5StorageCell');\n\ngoog.require('shaka.offline.indexeddb.BaseStorageCell');\n\n\n/**\n * The V5StorageCell is for all stores that follow the shaka.externs V5 offline\n * types introduced in v3.0.\n *\n * @implements {shaka.extern.StorageCell}\n */\nshaka.offline.indexeddb.V5StorageCell = class\n  extends shaka.offline.indexeddb.BaseStorageCell {\n  /** @override */\n  hasFixedKeySpace() {\n    // This makes the cell read-write.\n    return false;\n  }\n\n  /** @override */\n  addSegments(segments) {\n    return this.add(this.segmentStore_, segments);\n  }\n\n  /** @override */\n  addManifests(manifests) {\n    return this.add(this.manifestStore_, manifests);\n  }\n\n  /** @override */\n  updateManifest(key, manifest) {\n    return this.updateManifestImplementation(key, manifest);\n  }\n\n  /** @override */\n  convertManifest(old) {\n    // JSON serialization turns Infinity into null, so turn it back now.\n    if (old.expiration == null) {\n      old.expiration = Infinity;\n    }\n    return Promise.resolve(/** @type {shaka.extern.ManifestDB} */(old));\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.OfflineUri');\n\n\n/**\n * The OfflineUri class contains all the components that make up the offline\n * uri. The components are:\n *    TYPE: Used to know what type of data the uri points to. It can either\n *          be \"manifest\" or \"segment\".\n *    MECHANISM: The name of the mechanism that manages the storage cell that\n *               holds the data.\n *    CELL: The name of the cell that holds the data.\n *    KEY: The key that the data is stored under in the cell.\n */\nshaka.offline.OfflineUri = class {\n  /**\n   * @param {string} type\n   * @param {string} mechanism\n   * @param {string} cell\n   * @param {number} key\n   */\n  constructor(type, mechanism, cell, key) {\n    /**\n     * @private {string}\n     * @const\n     */\n    this.type_ = type;\n    /**\n     * @private {string}\n     * @const\n     */\n    this.mechanism_ = mechanism;\n    /**\n     * @private {string}\n     * @const\n     */\n    this.cell_ = cell;\n    /**\n     * @private {number}\n     * @const\n     */\n    this.key_ = key;\n\n    /**\n     * @private {string}\n     * @const\n     */\n    this.asString_ = [\n      'offline:', type, '/', mechanism, '/', cell, '/', key,\n    ].join('');\n  }\n\n  /** @return {boolean} */\n  isManifest() { return this.type_ == 'manifest'; }\n\n  /** @return {boolean} */\n  isSegment() { return this.type_ == 'segment'; }\n\n  /** @return {string} */\n  mechanism() { return this.mechanism_; }\n\n  /** @return {string} */\n  cell() { return this.cell_; }\n\n  /** @return {number} */\n  key() { return this.key_; }\n\n  /** @override */\n  toString() { return this.asString_; }\n\n  /**\n   * @param {string} uri\n   * @return {?shaka.offline.OfflineUri}\n   */\n  static parse(uri) {\n    const parts = /^offline:([a-z]+)\\/([^/]+)\\/([^/]+)\\/([0-9]+)$/.exec(uri);\n    if (parts == null) {\n      return null;\n    }\n\n    const type = parts[1];\n    if (type != 'manifest' && type != 'segment') {\n      return null;\n    }\n\n    const mechanism = parts[2];\n    if (!mechanism) {\n      return null;\n    }\n\n    const cell = parts[3];\n    if (!cell) {\n      return null;\n    }\n\n    const key = Number(parts[4]);\n    if (type == null) {\n      return null;\n    }\n\n    return new shaka.offline.OfflineUri(type, mechanism, cell, key);\n  }\n\n  /**\n   * @param {string} mechanism\n   * @param {string} cell\n   * @param {number} key\n   * @return {!shaka.offline.OfflineUri}\n   */\n  static manifest(mechanism, cell, key) {\n    return new shaka.offline.OfflineUri('manifest', mechanism, cell, key);\n  }\n\n  /**\n   * @param {string} mechanism\n   * @param {string} cell\n   * @param {number} key\n   * @return {!shaka.offline.OfflineUri}\n   */\n  static segment(mechanism, cell, key) {\n    return new shaka.offline.OfflineUri('segment', mechanism, cell, key);\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.ManifestConverter');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.util.ManifestParserUtils');\n\n\n/**\n * Utility class for converting database manifest objects back to normal\n * player-ready objects. Used by the offline system to convert on-disk\n * objects back to the in-memory objects.\n */\nshaka.offline.ManifestConverter = class {\n  /**\n   * Create a new manifest converter. Need to know the mechanism and cell that\n   * the manifest is from so that all segments paths can be created.\n   *\n   * @param {string} mechanism\n   * @param {string} cell\n   */\n  constructor(mechanism, cell) {\n    /** @private {string} */\n    this.mechanism_ = mechanism;\n\n    /** @private {string} */\n    this.cell_ = cell;\n  }\n\n  /**\n   * Convert a |shaka.extern.ManifestDB| object to a |shaka.extern.Manifest|\n   * object.\n   *\n   * @param {shaka.extern.ManifestDB} manifestDB\n   * @return {shaka.extern.Manifest}\n   */\n  fromManifestDB(manifestDB) {\n    const timeline = new shaka.media.PresentationTimeline(null, 0);\n    timeline.setDuration(manifestDB.duration);\n\n    /** @type {!Array.<shaka.extern.StreamDB>} */\n    const audioStreams =\n        manifestDB.streams.filter((streamDB) => this.isAudio_(streamDB));\n\n    /** @type {!Array.<shaka.extern.StreamDB>} */\n    const videoStreams =\n        manifestDB.streams.filter((streamDB) => this.isVideo_(streamDB));\n\n    /** @type {!Map.<number, shaka.extern.Variant>} */\n    const variants = this.createVariants(audioStreams, videoStreams, timeline);\n\n    /** @type {!Array.<shaka.extern.Stream>} */\n    const textStreams =\n        manifestDB.streams.filter((streamDB) => this.isText_(streamDB))\n            .map((streamDB) => this.fromStreamDB_(streamDB, timeline));\n\n    /** @type {!Array.<shaka.extern.Stream>} */\n    const imageStreams =\n        manifestDB.streams.filter((streamDB) => this.isImage_(streamDB))\n            .map((streamDB) => this.fromStreamDB_(streamDB, timeline));\n\n    const drmInfos = manifestDB.drmInfo ? [manifestDB.drmInfo] : [];\n    if (manifestDB.drmInfo) {\n      for (const variant of variants.values()) {\n        if (variant.audio && variant.audio.encrypted) {\n          variant.audio.drmInfos = drmInfos;\n        }\n        if (variant.video && variant.video.encrypted) {\n          variant.video.drmInfos = drmInfos;\n        }\n      }\n    }\n\n    return {\n      presentationTimeline: timeline,\n      minBufferTime: 2,\n      offlineSessionIds: manifestDB.sessionIds,\n      variants: Array.from(variants.values()),\n      textStreams: textStreams,\n      imageStreams: imageStreams,\n    };\n  }\n\n  /**\n   * Recreates Variants from audio and video StreamDB collections.\n   *\n   * @param {!Array.<!shaka.extern.StreamDB>} audios\n   * @param {!Array.<!shaka.extern.StreamDB>} videos\n   * @param {shaka.media.PresentationTimeline} timeline\n   * @return {!Map.<number, !shaka.extern.Variant>}\n   */\n  createVariants(audios, videos, timeline) {\n    // Get all the variant ids from all audio and video streams.\n    /** @type {!Set.<number>} */\n    const variantIds = new Set();\n    for (const streamDB of audios) {\n      for (const id of streamDB.variantIds) {\n        variantIds.add(id);\n      }\n    }\n    for (const streamDB of videos) {\n      for (const id of streamDB.variantIds) {\n        variantIds.add(id);\n      }\n    }\n\n    /** @type {!Map.<number, shaka.extern.Variant>} */\n    const variantMap = new Map();\n    for (const id of variantIds) {\n      variantMap.set(id, this.createEmptyVariant_(id));\n    }\n\n    // Assign each audio stream to its variants.\n    for (const audio of audios) {\n      /** @type {shaka.extern.Stream} */\n      const stream = this.fromStreamDB_(audio, timeline);\n\n      for (const variantId of audio.variantIds) {\n        const variant = variantMap.get(variantId);\n\n        goog.asserts.assert(\n            !variant.audio, 'A variant should only have one audio stream');\n\n        variant.language = stream.language;\n        variant.primary = variant.primary || stream.primary;\n        variant.audio = stream;\n      }\n    }\n\n    // Assign each video stream to its variants.\n    for (const video of videos) {\n      /** @type {shaka.extern.Stream} */\n      const stream = this.fromStreamDB_(video, timeline);\n\n      for (const variantId of video.variantIds) {\n        const variant = variantMap.get(variantId);\n\n        goog.asserts.assert(\n            !variant.video, 'A variant should only have one video stream');\n\n        variant.primary = variant.primary || stream.primary;\n        variant.video = stream;\n      }\n    }\n\n    return variantMap;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} streamDB\n   * @param {shaka.media.PresentationTimeline} timeline\n   * @return {shaka.extern.Stream}\n   * @private\n   */\n  fromStreamDB_(streamDB, timeline) {\n    /** @type {!Array.<!shaka.media.SegmentReference>} */\n    const segments = streamDB.segments.map(\n        (segment, index) => this.fromSegmentDB_(index, segment));\n\n    timeline.notifySegments(segments);\n\n    /** @type {!shaka.media.SegmentIndex} */\n    const segmentIndex = new shaka.media.SegmentIndex(segments);\n\n    /** @type {shaka.extern.Stream} */\n    const stream = {\n      id: streamDB.id,\n      originalId: streamDB.originalId,\n      createSegmentIndex: () => Promise.resolve(),\n      segmentIndex,\n      mimeType: streamDB.mimeType,\n      codecs: streamDB.codecs,\n      width: streamDB.width || undefined,\n      height: streamDB.height || undefined,\n      frameRate: streamDB.frameRate,\n      pixelAspectRatio: streamDB.pixelAspectRatio,\n      hdr: streamDB.hdr,\n      kind: streamDB.kind,\n      encrypted: streamDB.encrypted,\n      drmInfos: [],\n      keyIds: streamDB.keyIds,\n      language: streamDB.language,\n      label: streamDB.label,\n      type: streamDB.type,\n      primary: streamDB.primary,\n      trickModeVideo: null,\n      emsgSchemeIdUris: null,\n      roles: streamDB.roles,\n      forced: streamDB.forced,\n      channelsCount: streamDB.channelsCount,\n      audioSamplingRate: streamDB.audioSamplingRate,\n      spatialAudio: streamDB.spatialAudio,\n      closedCaptions: streamDB.closedCaptions,\n      tilesLayout: streamDB.tilesLayout,\n    };\n\n    return stream;\n  }\n\n  /**\n   * @param {number} index\n   * @param {shaka.extern.SegmentDB} segmentDB\n   * @return {!shaka.media.SegmentReference}\n   * @private\n   */\n  fromSegmentDB_(index, segmentDB) {\n    /** @type {!shaka.offline.OfflineUri} */\n    const uri = shaka.offline.OfflineUri.segment(\n        this.mechanism_, this.cell_, segmentDB.dataKey);\n\n    const initSegmentReference = segmentDB.initSegmentKey != null ?\n        this.fromInitSegmentDB_(segmentDB.initSegmentKey) : null;\n\n    return new shaka.media.SegmentReference(\n        segmentDB.startTime,\n        segmentDB.endTime,\n        () => [uri.toString()],\n        /* startByte= */ 0,\n        /* endByte= */ null,\n        initSegmentReference,\n        segmentDB.timestampOffset,\n        segmentDB.appendWindowStart,\n        segmentDB.appendWindowEnd,\n        /* partialReferences= */ [],\n        segmentDB.tilesLayout || '');\n  }\n\n  /**\n   * @param {number} key\n   * @return {!shaka.media.InitSegmentReference}\n   * @private\n   */\n  fromInitSegmentDB_(key) {\n    /** @type {!shaka.offline.OfflineUri} */\n    const uri = shaka.offline.OfflineUri.segment(\n        this.mechanism_, this.cell_, key);\n\n    return new shaka.media.InitSegmentReference(\n        () => [uri.toString()],\n        /* startBytes= */ 0,\n        /* endBytes= */ null );\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} streamDB\n   * @return {boolean}\n   * @private\n   */\n  isAudio_(streamDB) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return streamDB.type == ContentType.AUDIO;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} streamDB\n   * @return {boolean}\n   * @private\n   */\n  isVideo_(streamDB) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return streamDB.type == ContentType.VIDEO;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} streamDB\n   * @return {boolean}\n   * @private\n   */\n  isText_(streamDB) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return streamDB.type == ContentType.TEXT;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} streamDB\n   * @return {boolean}\n   * @private\n   */\n  isImage_(streamDB) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return streamDB.type == ContentType.IMAGE;\n  }\n\n  /**\n   * Creates an empty Variant.\n   *\n   * @param {number} id\n   * @return {!shaka.extern.Variant}\n   * @private\n   */\n  createEmptyVariant_(id) {\n    return {\n      id: id,\n      language: '',\n      primary: false,\n      audio: null,\n      video: null,\n      bandwidth: 0,\n      allowedByApplication: true,\n      allowedByKeySystem: true,\n      decodingInfos: [],\n    };\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.OfflineScheme');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @summary A plugin that handles requests for offline content.\n * @export\n */\nshaka.offline.OfflineScheme = class {\n  /**\n   * @param {string} uri\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a\n   *   progress event happened.\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @export\n   */\n  static plugin(uri, request, requestType, progressUpdated) {\n    const offlineUri = shaka.offline.OfflineUri.parse(uri);\n\n    if (offlineUri && offlineUri.isManifest()) {\n      return shaka.offline.OfflineScheme.getManifest_(uri);\n    }\n\n    if (offlineUri && offlineUri.isSegment()) {\n      return shaka.offline.OfflineScheme.getSegment_(\n          offlineUri.key(), offlineUri);\n    }\n\n    return shaka.util.AbortableOperation.failed(\n        new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n            uri));\n  }\n\n  /**\n   * @param {string} uri\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @private\n   */\n  static getManifest_(uri) {\n    /** @type {shaka.extern.Response} */\n    const response = {\n      uri: uri,\n      originalUri: uri,\n      data: new ArrayBuffer(0),\n      headers: {'content-type': 'application/x-offline-manifest'},\n    };\n\n    return shaka.util.AbortableOperation.completed(response);\n  }\n\n  /**\n   * @param {number} id\n   * @param {!shaka.offline.OfflineUri} uri\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @private\n   */\n  static getSegment_(id, uri) {\n    goog.asserts.assert(\n        uri.isSegment(),\n        'Only segment uri\\'s should be given to getSegment');\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n\n    return shaka.util.AbortableOperation.completed(undefined)\n        .chain(() => muxer.init())\n        .chain(() => muxer.getCell(uri.mechanism(), uri.cell()))\n        .chain((cell) => cell.getSegments([uri.key()]))\n        .chain((segments) => {\n          const segment = segments[0];\n\n          return {\n            uri: uri,\n            data: segment.data,\n            headers: {},\n          };\n        })\n        .finally(() => muxer.destroy());\n  }\n};\n\nshaka.net.NetworkingEngine.registerScheme(\n    'offline', shaka.offline.OfflineScheme.plugin);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.SessionDeleter');\n\n\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.util.ArrayUtils');\ngoog.requireType('shaka.net.NetworkingEngine');\n\n\n/**\n * Contains a utility method to delete persistent EME sessions.\n */\nshaka.offline.SessionDeleter = class {\n  /**\n   * Deletes the given sessions.  This never fails and instead logs the error.\n   *\n   * @param {shaka.extern.DrmConfiguration} config\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {!Array.<shaka.extern.EmeSessionDB>} sessions\n   * @return {!Promise.<!Array.<string>>} The session IDs that were deleted.\n   */\n  async delete(config, netEngine, sessions) {\n    const SessionDeleter = shaka.offline.SessionDeleter;\n\n    let deleted = [];\n    for (const bucket of SessionDeleter.createBuckets_(sessions)) {\n      // Run these sequentially to avoid creating multiple CDM instances at one\n      // time.  Some embedded platforms may not support multiples.\n      const p = this.doDelete_(config, netEngine, bucket);\n      const cur = await p;  // eslint-disable-line no-await-in-loop\n      deleted = deleted.concat(cur);\n    }\n    return deleted;\n  }\n\n\n  /**\n   * Performs the deletion of the given session IDs.\n   *\n   * @param {shaka.extern.DrmConfiguration} config\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {shaka.offline.SessionDeleter.Bucket_} bucket\n   * @return {!Promise.<!Array.<string>>} The sessions that were deleted\n   * @private\n   */\n  async doDelete_(config, netEngine, bucket) {\n    /** @type {!shaka.media.DrmEngine} */\n    const drmEngine = new shaka.media.DrmEngine({\n      netEngine: netEngine,\n      onError: () => {},\n      onKeyStatus: () => {},\n      onExpirationUpdated: () => {},\n      onEvent: () => {},\n    });\n\n    try {\n      drmEngine.configure(config);\n      await drmEngine.initForRemoval(\n          bucket.info.keySystem, bucket.info.licenseUri,\n          bucket.info.serverCertificate,\n          bucket.info.audioCapabilities, bucket.info.videoCapabilities);\n    } catch (e) {\n      shaka.log.warning('Error initializing EME', e);\n      await drmEngine.destroy();\n      return [];\n    }\n\n    try {\n      await drmEngine.setServerCertificate();\n    } catch (e) {\n      shaka.log.warning('Error setting server certificate', e);\n      await drmEngine.destroy();\n      return [];\n    }\n\n    /** @type {!Array.<string>} */\n    const sessionIds = [];\n    await Promise.all(bucket.sessionIds.map(async (sessionId) => {\n      // This method is in a .map(), so this starts multiple removes at once,\n      // so this removes the sessions in parallel.\n      try {\n        await drmEngine.removeSession(sessionId);\n        sessionIds.push(sessionId);\n      } catch (e) {\n        shaka.log.warning('Error deleting offline session', e);\n      }\n    }));\n    await drmEngine.destroy();\n    return sessionIds;\n  }\n\n\n  /**\n   * Collects the given sessions into buckets that can be done at the same time.\n   * Since querying with different parameters can give us back different CDMs,\n   * we can't just use one CDM instance to delete everything.\n   *\n   * @param {!Array.<shaka.extern.EmeSessionDB>} sessions\n   * @return {!Array.<shaka.offline.SessionDeleter.Bucket_>}\n   * @private\n   */\n  static createBuckets_(sessions) {\n    const SessionDeleter = shaka.offline.SessionDeleter;\n\n    /** @type {!Array.<shaka.offline.SessionDeleter.Bucket_>} */\n    const ret = [];\n    for (const session of sessions) {\n      let found = false;\n      for (const bucket of ret) {\n        if (SessionDeleter.isCompatible_(bucket.info, session)) {\n          bucket.sessionIds.push(session.sessionId);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        ret.push({info: session, sessionIds: [session.sessionId]});\n      }\n    }\n\n    return ret;\n  }\n\n\n  /**\n   * Returns whether the given session infos are compatible with each other.\n   * @param {shaka.extern.EmeSessionDB} a\n   * @param {shaka.extern.EmeSessionDB} b\n   * @return {boolean}\n   * @private\n   */\n  static isCompatible_(a, b) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n\n    // TODO: Add a way to change the license server in DrmEngine to avoid\n    // resetting EME for different license servers.\n    const comp = (x, y) =>\n      x.robustness == y.robustness && x.contentType == y.contentType;\n    return a.keySystem == b.keySystem && a.licenseUri == b.licenseUri &&\n        ArrayUtils.hasSameElements(\n            a.audioCapabilities, b.audioCapabilities, comp) &&\n        ArrayUtils.hasSameElements(\n            a.videoCapabilities, b.videoCapabilities, comp);\n  }\n};\n\n\n/**\n * @typedef {{\n *   info: shaka.extern.EmeSessionDB,\n *   sessionIds: !Array.<string>\n * }}\n */\nshaka.offline.SessionDeleter.Bucket_;\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.StoredContentUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.offline.ManifestConverter');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.util.StreamUtils');\n\n\n/**\n * A utility class used to create |shaka.extern.StoredContent| from different\n * types of input.\n */\nshaka.offline.StoredContentUtils = class {\n  /**\n   * @param {string} originalUri\n   * @param {shaka.extern.Manifest} manifest\n   * @param {number} size\n   * @param {!Object} metadata\n   * @return {shaka.extern.StoredContent}\n   */\n  static fromManifest(originalUri, manifest, size, metadata) {\n    goog.asserts.assert(\n        manifest.variants.length,\n        'Cannot create stored content from manifest with no variants.');\n\n    /** @type {number} */\n    const duration = manifest.presentationTimeline.getDuration();\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    const tracks = shaka.offline.StoredContentUtils.getTracks_(manifest);\n\n    /** @type {shaka.extern.StoredContent} */\n    const content = {\n      offlineUri: null,\n      originalManifestUri: originalUri,\n      duration: duration,\n      size: size,\n      // This expiration value is temporary and will be used in progress reports\n      // during the storage process.  The real value would have to come from\n      // DrmEngine.\n      expiration: Infinity,\n      tracks: tracks,\n      appMetadata: metadata,\n      isIncomplete: false,\n    };\n\n    return content;\n  }\n\n  /**\n   * @param {!shaka.offline.OfflineUri} offlineUri\n   * @param {shaka.extern.ManifestDB} manifestDB\n   * @return {shaka.extern.StoredContent}\n   */\n  static fromManifestDB(offlineUri, manifestDB) {\n    goog.asserts.assert(\n        manifestDB.streams.length,\n        'Cannot create stored content from manifestDB with no streams.');\n\n    const converter = new shaka.offline.ManifestConverter(\n        offlineUri.mechanism(), offlineUri.cell());\n\n    /** @type {shaka.extern.Manifest} */\n    const manifest = converter.fromManifestDB(manifestDB);\n\n    /** @type {!Object} */\n    const metadata = manifestDB.appMetadata || {};\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    const tracks = shaka.offline.StoredContentUtils.getTracks_(manifest);\n\n    goog.asserts.assert(\n        manifestDB.expiration != null,\n        'Manifest expiration must be set by now!');\n\n    /** @type {shaka.extern.StoredContent} */\n    const content = {\n      offlineUri: offlineUri.toString(),\n      originalManifestUri: manifestDB.originalManifestUri,\n      duration: manifestDB.duration,\n      size: manifestDB.size,\n      expiration: manifestDB.expiration,\n      tracks: tracks,\n      appMetadata: metadata,\n      isIncomplete: (manifestDB.isIncomplete || false),\n    };\n\n    return content;\n  }\n\n  /**\n   * Gets track representations of all playable variants and all text streams.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @return {!Array.<shaka.extern.Track>}\n   * @private\n   */\n  static getTracks_(manifest) {\n    const StreamUtils = shaka.util.StreamUtils;\n\n    const tracks = [];\n\n    const variants = StreamUtils.getPlayableVariants(manifest.variants);\n    for (const variant of variants) {\n      tracks.push(StreamUtils.variantToTrack(variant));\n    }\n\n    const textStreams = manifest.textStreams;\n    for (const stream of textStreams) {\n      tracks.push(StreamUtils.textStreamToTrack(stream));\n    }\n\n    return tracks;\n  }\n};\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.Storage');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.Player');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.offline.DownloadInfo');\ngoog.require('shaka.offline.DownloadManager');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.offline.SessionDeleter');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.offline.StoredContentUtils');\ngoog.require('shaka.offline.StreamBandwidthEstimator');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.ConfigUtils');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.PlayerConfiguration');\ngoog.require('shaka.util.StreamUtils');\ngoog.requireType('shaka.media.SegmentReference');\ngoog.requireType('shaka.offline.StorageCellHandle');\n\n\n/**\n * @summary\n * This manages persistent offline data including storage, listing, and deleting\n * stored manifests.  Playback of offline manifests are done through the Player\n * using a special URI (see shaka.offline.OfflineUri).\n *\n * First, check support() to see if offline is supported by the platform.\n * Second, configure() the storage object with callbacks to your application.\n * Third, call store(), remove(), or list() as needed.\n * When done, call destroy().\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.offline.Storage = class {\n  /**\n   * @param {!shaka.Player=} player\n   *    A player instance to share a networking engine and configuration with.\n   *    When initializing with a player, storage is only valid as long as\n   *    |destroy| has not been called on the player instance. When omitted,\n   *    storage will manage its own networking engine and configuration.\n   */\n  constructor(player) {\n    // It is an easy mistake to make to pass a Player proxy from CastProxy.\n    // Rather than throw a vague exception later, throw an explicit and clear\n    // one now.\n    //\n    // TODO(vaage): After we decide whether or not we want to support\n    //  initializing storage with a player proxy, we should either remove\n    //  this error or rename the error.\n    if (player && player.constructor != shaka.Player) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.LOCAL_PLAYER_INSTANCE_REQUIRED);\n    }\n\n    /** @private {?shaka.extern.PlayerConfiguration} */\n    this.config_ = null;\n\n    /** @private {shaka.net.NetworkingEngine} */\n    this.networkingEngine_ = null;\n\n    // Initialize |config_| and |networkingEngine_| based on whether or not\n    // we were given a player instance.\n    if (player) {\n      this.config_ = player.getSharedConfiguration();\n      this.networkingEngine_ = player.getNetworkingEngine();\n\n      goog.asserts.assert(\n          this.networkingEngine_,\n          'Storage should not be initialized with a player that had ' +\n              '|destroy| called on it.');\n    } else {\n      this.config_ = shaka.util.PlayerConfiguration.createDefault();\n      this.networkingEngine_ = new shaka.net.NetworkingEngine();\n    }\n\n    /**\n     * A list of open operations that are being performed by this instance of\n     * |shaka.offline.Storage|.\n     *\n     * @private {!Array.<!Promise>}\n     */\n    this.openOperations_ = [];\n\n    /**\n     * A list of open download managers that are being used to download things.\n     *\n     * @private {!Array.<!shaka.offline.DownloadManager>}\n     */\n    this.openDownloadManagers_ = [];\n\n    /**\n     * Storage should only destroy the networking engine if it was initialized\n     * without a player instance. Store this as a flag here to avoid including\n     * the player object in the destoyer's closure.\n     *\n     * @type {boolean}\n     */\n    const destroyNetworkingEngine = !player;\n\n    /** @private {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(async () => {\n      // Cancel all in-progress store operations.\n      await Promise.all(this.openDownloadManagers_.map((dl) => dl.abortAll()));\n\n      // Wait for all remaining open operations to end. Wrap each operations so\n      // that a single rejected promise won't cause |Promise.all| to return\n      // early or to return a rejected Promise.\n      const noop = () => {};\n      const awaits = [];\n      for (const op of this.openOperations_) {\n        awaits.push(op.then(noop, noop));\n      }\n      await Promise.all(awaits);\n\n      // Wait until after all the operations have finished before we destroy\n      // the networking engine to avoid any unexpected errors.\n      if (destroyNetworkingEngine) {\n        await this.networkingEngine_.destroy();\n      }\n\n      // Drop all references to internal objects to help with GC.\n      this.config_ = null;\n      this.networkingEngine_ = null;\n    });\n  }\n\n\n  /**\n   * Gets whether offline storage is supported.  Returns true if offline storage\n   * is supported for clear content.  Support for offline storage of encrypted\n   * content will not be determined until storage is attempted.\n   *\n   * @return {boolean}\n   * @export\n   */\n  static support() {\n    // Our Storage system is useless without MediaSource.  MediaSource allows us\n    // to pull data from anywhere (including our Storage system) and feed it to\n    // the video element.\n    if (!shaka.util.Platform.supportsMediaSource()) {\n      return false;\n    }\n\n    return shaka.offline.StorageMuxer.support();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /**\n   * Sets configuration values for Storage.  This is associated with\n   * Player.configure and will change the player instance given at\n   * initialization.\n   *\n   * @param {string|!Object} config This should either be a field name or an\n   *   object following the form of {@link shaka.extern.PlayerConfiguration},\n   *   where you may omit any field you do not wish to change.\n   * @param {*=} value This should be provided if the previous parameter\n   *   was a string field name.\n   * @return {boolean}\n   * @export\n   */\n  configure(config, value) {\n    goog.asserts.assert(typeof(config) == 'object' || arguments.length == 2,\n        'String configs should have values!');\n\n    // ('fieldName', value) format\n    if (arguments.length == 2 && typeof(config) == 'string') {\n      config = shaka.util.ConfigUtils.convertToConfigObject(config, value);\n    }\n\n    goog.asserts.assert(typeof(config) == 'object', 'Should be an object!');\n\n    // Deprecate 'manifest.dash.defaultPresentationDelay' configuration.\n    if (config['manifest'] && config['manifest']['dash'] &&\n          'defaultPresentationDelay' in config['manifest']['dash']) {\n      shaka.Deprecate.deprecateFeature(4,\n          'manifest.dash.defaultPresentationDelay configuration',\n          'Please Use manifest.defaultPresentationDelay instead.');\n      config['manifest']['defaultPresentationDelay'] =\n          config['manifest']['dash']['defaultPresentationDelay'];\n      delete config['manifest']['dash']['defaultPresentationDelay'];\n    }\n\n    goog.asserts.assert(\n        this.config_, 'Cannot reconfigure storage after calling destroy.');\n    return shaka.util.PlayerConfiguration.mergeConfigObjects(\n        /* destination= */ this.config_, /* updates= */ config );\n  }\n\n  /**\n   * Return a copy of the current configuration.  Modifications of the returned\n   * value will not affect the Storage instance's active configuration.  You\n   * must call storage.configure() to make changes.\n   *\n   * @return {shaka.extern.PlayerConfiguration}\n   * @export\n   */\n  getConfiguration() {\n    goog.asserts.assert(this.config_, 'Config must not be null!');\n\n    const ret = shaka.util.PlayerConfiguration.createDefault();\n    shaka.util.PlayerConfiguration.mergeConfigObjects(\n        ret, this.config_, shaka.util.PlayerConfiguration.createDefault());\n    return ret;\n  }\n\n  /**\n   * Return the networking engine that storage is using. If storage was\n   * initialized with a player instance, then the networking engine returned\n   * will be the same as |player.getNetworkingEngine()|.\n   *\n   * The returned value will only be null if |destroy| was called before\n   * |getNetworkingEngine|.\n   *\n   * @return {shaka.net.NetworkingEngine}\n   * @export\n   */\n  getNetworkingEngine() {\n    return this.networkingEngine_;\n  }\n\n  /**\n   * Stores the given manifest.  If the content is encrypted, and encrypted\n   * content cannot be stored on this platform, the Promise will be rejected\n   * with error code 6001, REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE.\n   * Multiple assets can be downloaded at the same time, but note that since\n   * the storage instance has a single networking engine, multiple storage\n   * objects will be necessary if some assets require unique network filters.\n   * This snapshots the storage config at the time of the call, so it will not\n   * honor any changes to config mid-store operation.\n   *\n   * @param {string} uri The URI of the manifest to store.\n   * @param {!Object=} appMetadata An arbitrary object from the application\n   *   that will be stored along-side the offline content.  Use this for any\n   *   application-specific metadata you need associated with the stored\n   *   content.  For details on the data types that can be stored here, please\n   *   refer to {@link https://bit.ly/StructClone}\n   * @param {string=} mimeType\n   *   The mime type for the content |manifestUri| points to.\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.StoredContent>}\n   *   An AbortableOperation that resolves with a structure representing what\n   *   was stored.  The \"offlineUri\" member is the URI that should be given to\n   *   Player.load() to play this piece of content offline.  The \"appMetadata\"\n   *   member is the appMetadata argument you passed to store().\n   *   If you want to cancel this download, call the \"abort\" method on\n   *   AbortableOperation.\n   * @export\n   */\n  store(uri, appMetadata, mimeType) {\n    goog.asserts.assert(\n        this.networkingEngine_,\n        'Cannot call |store| after calling |destroy|.');\n\n    // Get a copy of the current config.\n    const config = this.getConfiguration();\n\n    const getParser = async () => {\n      goog.asserts.assert(\n          this.networkingEngine_, 'Should not call |store| after |destroy|');\n\n      const factory = await shaka.media.ManifestParser.getFactory(\n          uri,\n          this.networkingEngine_,\n          config.manifest.retryParameters,\n          mimeType || null);\n\n      return shaka.util.Functional.callFactory(factory);\n    };\n\n    /** @type {!shaka.offline.DownloadManager} */\n    const downloader =\n        new shaka.offline.DownloadManager(this.networkingEngine_);\n    this.openDownloadManagers_.push(downloader);\n\n    const storeOp = this.store_(\n        uri, appMetadata || {}, getParser, config, downloader);\n    const abortableStoreOp = new shaka.util.AbortableOperation(storeOp, () => {\n      return downloader.abortAll();\n    });\n    abortableStoreOp.finally(() => {\n      shaka.util.ArrayUtils.remove(this.openDownloadManagers_, downloader);\n    });\n\n    // Provide a temporary shim for \"then\" for backward compatibility.\n    /** @type {!Object} */ (abortableStoreOp)['then'] = (onSuccess) => {\n      shaka.Deprecate.deprecateFeature(4,\n          'shaka.offline.Storage.store.then',\n          'Storage operations now return a shaka.util.AbortableOperation, ' +\n          'rather than a promise.  Please update to conform to this new API; ' +\n          'you can use the |chain| method instead.');\n      return abortableStoreOp.promise.then(onSuccess);\n    };\n\n    return this.startAbortableOperation_(abortableStoreOp);\n  }\n\n  /**\n   * Returns true if an asset is currently downloading.\n   *\n   * @return {boolean}\n   * @deprecated\n   * @export\n   */\n  getStoreInProgress() {\n    shaka.Deprecate.deprecateFeature(4,\n        'shaka.offline.Storage.getStoreInProgress',\n        'Multiple concurrent downloads are now supported.');\n    return false;\n  }\n\n  /**\n   * See |shaka.offline.Storage.store| for details.\n   *\n   * @param {string} uri\n   * @param {!Object} appMetadata\n   * @param {function():!Promise.<shaka.extern.ManifestParser>} getParser\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @return {!Promise.<shaka.extern.StoredContent>}\n   * @private\n   */\n  async store_(uri, appMetadata, getParser, config, downloader) {\n    this.requireSupport_();\n\n    // Since we will need to use |parser|, |drmEngine|, |activeHandle|, and\n    // |muxer| in the catch/finally blocks, we need to define them out here.\n    // Since they may not get initialized when we enter the catch/finally block,\n    // we need to assume that they may be null/undefined when we get there.\n\n    /** @type {?shaka.extern.ManifestParser} */\n    let parser = null;\n    /** @type {?shaka.media.DrmEngine} */\n    let drmEngine = null;\n    /** @type {shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n    /** @type {?shaka.offline.StorageCellHandle} */\n    let activeHandle = null;\n    /** @type {?number} */\n    let manifestId = null;\n\n    // This will be used to store any errors from drm engine. Whenever drm\n    // engine is passed to another function to do work, we should check if this\n    // was set.\n    let drmError = null;\n\n    try {\n      parser = await getParser();\n\n      const manifest = await this.parseManifest(uri, parser, config);\n\n      // Check if we were asked to destroy ourselves while we were \"away\"\n      // downloading the manifest.\n      this.ensureNotDestroyed_();\n\n      // Check if we can even download this type of manifest before trying to\n      // create the drm engine.\n      const canDownload = !manifest.presentationTimeline.isLive() &&\n                          !manifest.presentationTimeline.isInProgress();\n      if (!canDownload) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.CANNOT_STORE_LIVE_OFFLINE,\n            uri);\n      }\n\n      // Create the DRM engine, and load the keys in the manifest.\n      drmEngine = await this.createDrmEngine(\n          manifest,\n          (e) => { drmError = drmError || e; },\n          config);\n\n      // We could have been asked to destroy ourselves while we were \"away\"\n      // creating the drm engine.\n      this.ensureNotDestroyed_();\n      if (drmError) {\n        throw drmError;\n      }\n\n      await this.filterManifest_(manifest, drmEngine, config);\n\n      await muxer.init();\n      this.ensureNotDestroyed_();\n\n      // Get the cell that we are saving the manifest to. Once we get a cell\n      // we will only reference the cell and not the muxer so that the manifest\n      // and segments will all be saved to the same cell.\n      activeHandle = await muxer.getActive();\n      this.ensureNotDestroyed_();\n\n      goog.asserts.assert(drmEngine, 'drmEngine should be non-null here.');\n      const {manifestDB, toDownload} = this.makeManifestDB_(\n          drmEngine, manifest, uri, appMetadata, config, downloader);\n\n      // Store the empty manifest, before downloading the segments.\n      const ids = await activeHandle.cell.addManifests([manifestDB]);\n      this.ensureNotDestroyed_();\n      manifestId = ids[0];\n\n      goog.asserts.assert(drmEngine, 'drmEngine should be non-null here.');\n      this.ensureNotDestroyed_();\n      if (drmError) {\n        throw drmError;\n      }\n\n      await this.downloadSegments_(toDownload, manifestId, manifestDB,\n          downloader, config, activeHandle.cell, manifest, drmEngine);\n      this.ensureNotDestroyed_();\n\n      const offlineUri = shaka.offline.OfflineUri.manifest(\n          activeHandle.path.mechanism, activeHandle.path.cell, manifestId);\n\n      return shaka.offline.StoredContentUtils.fromManifestDB(\n          offlineUri, manifestDB);\n    } catch (e) {\n      if (manifestId != null) {\n        await shaka.offline.Storage.cleanStoredManifest(manifestId);\n      }\n\n      // If we already had an error, ignore this error to avoid hiding\n      // the original error.\n      throw drmError || e;\n    } finally {\n      await muxer.destroy();\n\n      if (parser) {\n        await parser.stop();\n      }\n\n      if (drmEngine) {\n        await drmEngine.destroy();\n      }\n    }\n  }\n\n  /**\n   * Download and then store the contents of each segment.\n   * The promise this returns will wait for local downloads.\n   *\n   * @param {!Array.<!shaka.offline.DownloadInfo>} toDownload\n   * @param {number} manifestId\n   * @param {shaka.extern.ManifestDB} manifestDB\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @param {shaka.extern.StorageCell} storage\n   * @param {shaka.extern.Manifest} manifest\n   * @param {!shaka.media.DrmEngine} drmEngine\n   * @return {!Promise}\n   * @private\n   */\n  async downloadSegments_(\n      toDownload, manifestId, manifestDB, downloader, config, storage,\n      manifest, drmEngine) {\n    let pendingManifestUpdates = {};\n    let pendingDataSize = 0;\n\n    /**\n     * @param {!Array.<!shaka.offline.DownloadInfo>} toDownload\n     * @param {boolean} updateDRM\n     */\n    const download = async (toDownload, updateDRM) => {\n      for (const download of toDownload) {\n        const request = download.makeSegmentRequest(config);\n        const estimateId = download.estimateId;\n        const isInitSegment = download.isInitSegment;\n\n        const onDownloaded = async (data) => {\n          // Store the data.\n          const dataKeys = await storage.addSegments([{data}]);\n          this.ensureNotDestroyed_();\n\n          // Store the necessary update to the manifest, to be processed later.\n          const ref = /** @type {!shaka.media.SegmentReference} */ (\n            download.ref);\n          const id = shaka.offline.DownloadInfo.idForSegmentRef(ref);\n          pendingManifestUpdates[id] = dataKeys[0];\n          pendingDataSize += data.byteLength;\n        };\n\n        downloader.queue(download.groupId,\n            request, estimateId, isInitSegment, onDownloaded);\n      }\n      await downloader.waitToFinish();\n\n      if (updateDRM) {\n        // Re-store the manifest, to attach session IDs.\n        // These were (maybe) discovered inside the downloader; we can only add\n        // them now, at the end, since the manifestDB is in flux during the\n        // process of downloading and storing, and assignSegmentsToManifest\n        // does not know about the DRM engine.\n        this.ensureNotDestroyed_();\n        this.setManifestDrmFields_(manifest, manifestDB, drmEngine, config);\n        await storage.updateManifest(manifestId, manifestDB);\n      }\n    };\n\n    const usingBgFetch = false; // TODO: Get.\n\n    try {\n      if (this.getManifestIsEncrypted_(manifest) && usingBgFetch &&\n          !this.getManifestIncludesInitData_(manifest)) {\n        // Background fetch can't make DRM sessions, so if we have to get the\n        // init data from the init segments, download those first before\n        // anything else.\n        await download(toDownload.filter((info) => info.isInitSegment), true);\n        this.ensureNotDestroyed_();\n        toDownload = toDownload.filter((info) => !info.isInitSegment);\n\n        // Copy these and reset them now, before calling await.\n        const manifestUpdates = pendingManifestUpdates;\n        const dataSize = pendingDataSize;\n        pendingManifestUpdates = {};\n        pendingDataSize = 0;\n\n        await shaka.offline.Storage.assignSegmentsToManifest(\n            storage, manifestId, manifestDB, manifestUpdates, dataSize,\n            () => this.ensureNotDestroyed_());\n        this.ensureNotDestroyed_();\n      }\n\n      if (!usingBgFetch) {\n        await download(toDownload, false);\n        this.ensureNotDestroyed_();\n\n        // Copy these and reset them now, before calling await.\n        const manifestUpdates = pendingManifestUpdates;\n        const dataSize = pendingDataSize;\n        pendingManifestUpdates = {};\n        pendingDataSize = 0;\n\n        await shaka.offline.Storage.assignSegmentsToManifest(\n            storage, manifestId, manifestDB, manifestUpdates, dataSize,\n            () => this.ensureNotDestroyed_());\n        this.ensureNotDestroyed_();\n\n        goog.asserts.assert(\n            !manifestDB.isIncomplete, 'The manifest should be complete by now');\n      } else {\n        // TODO: Send the request to the service worker. Don't await the result.\n      }\n    } catch (error) {\n      const dataKeys = Object.values(pendingManifestUpdates);\n      // Remove these pending segments that are not yet linked to the manifest.\n      await storage.removeSegments(dataKeys, (key) => {});\n\n      throw error;\n    }\n  }\n\n  /**\n   * Removes all of the contents for a given manifest, statelessly.\n   *\n   * @param {number} manifestId\n   * @return {!Promise}\n   */\n  static async cleanStoredManifest(manifestId) {\n    const muxer = new shaka.offline.StorageMuxer();\n    await muxer.init();\n    const activeHandle = await muxer.getActive();\n    const uri = shaka.offline.OfflineUri.manifest(\n        activeHandle.path.mechanism,\n        activeHandle.path.cell,\n        manifestId);\n    await muxer.destroy();\n    const storage = new shaka.offline.Storage();\n    await storage.remove(uri.toString());\n  }\n\n  /**\n   * Updates the given manifest, assigns database keys to segments, then stores\n   * the updated manifest.\n   *\n   * It is up to the caller to ensure that this method is not called\n   * concurrently on the same manifest.\n   *\n   * @param {shaka.extern.StorageCell} storage\n   * @param {number} manifestId\n   * @param {!shaka.extern.ManifestDB} manifestDB\n   * @param {!Object.<string, number>} manifestUpdates\n   * @param {number} dataSizeUpdate\n   * @param {function()} throwIfAbortedFn  A function that should throw if the\n   *   download has been aborted.\n   * @return {!Promise}\n   */\n  static async assignSegmentsToManifest(\n      storage, manifestId, manifestDB, manifestUpdates, dataSizeUpdate,\n      throwIfAbortedFn) {\n    let manifestUpdated = false;\n\n    try {\n      // Assign the stored data to the manifest.\n      let complete = true;\n      for (const stream of manifestDB.streams) {\n        for (const segment of stream.segments) {\n          let dataKey = segment.pendingSegmentRefId ?\n              manifestUpdates[segment.pendingSegmentRefId] : null;\n          if (dataKey != null) {\n            segment.dataKey = dataKey;\n            // Now that the segment has been associated with the appropriate\n            // dataKey, the pendingSegmentRefId is no longer necessary.\n            segment.pendingSegmentRefId = undefined;\n          }\n\n          dataKey = segment.pendingInitSegmentRefId ?\n              manifestUpdates[segment.pendingInitSegmentRefId] : null;\n          if (dataKey != null) {\n            segment.initSegmentKey = dataKey;\n            // Now that the init segment has been associated with the\n            // appropriate initSegmentKey, the pendingInitSegmentRefId is no\n            // longer necessary.\n            segment.pendingInitSegmentRefId = undefined;\n          }\n\n          if (segment.pendingSegmentRefId) {\n            complete = false;\n          }\n          if (segment.pendingInitSegmentRefId) {\n            complete = false;\n          }\n        }\n      }\n\n      // Update the size of the manifest.\n      manifestDB.size += dataSizeUpdate;\n\n      // Mark the manifest as complete, if all segments are downloaded.\n      if (complete) {\n        manifestDB.isIncomplete = false;\n      }\n\n      // Update the manifest.\n      await storage.updateManifest(manifestId, manifestDB);\n      manifestUpdated = true;\n      throwIfAbortedFn();\n    } catch (e) {\n      await shaka.offline.Storage.cleanStoredManifest(manifestId);\n\n      if (!manifestUpdated) {\n        const dataKeys = Object.values(manifestUpdates);\n        // The cleanStoredManifest method will not \"see\" any segments that have\n        // been downloaded but not assigned to the manifest yet. So un-store\n        // them separately.\n        await storage.removeSegments(dataKeys, (key) => {});\n      }\n\n      throw e;\n    }\n  }\n\n  /**\n   * Filter |manifest| such that it will only contain the variants and text\n   * streams that we want to store and can actually play.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @param {!shaka.media.DrmEngine} drmEngine\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {!Promise}\n   * @private\n   */\n  async filterManifest_(manifest, drmEngine, config) {\n    // Filter the manifest based on the restrictions given in the player\n    // configuration.\n    const maxHwRes = {width: Infinity, height: Infinity};\n    shaka.util.StreamUtils.filterByRestrictions(\n        manifest, config.restrictions, maxHwRes);\n\n    // Filter the manifest based on what we know MediaCapabilities will be able\n    // to play later (no point storing something we can't play).\n    await shaka.util.StreamUtils.filterManifestByMediaCapabilities(\n        manifest, config.offline.usePersistentLicense);\n\n    // Gather all tracks.\n    const allTracks = [];\n\n    // Choose the codec that has the lowest average bandwidth.\n    const preferredAudioChannelCount = config.preferredAudioChannelCount;\n    const preferredDecodingAttributes = config.preferredDecodingAttributes;\n    const preferredVideoCodecs = config.preferredVideoCodecs;\n    const preferredAudioCodecs = config.preferredAudioCodecs;\n\n    shaka.util.StreamUtils.chooseCodecsAndFilterManifest(\n        manifest, preferredVideoCodecs, preferredAudioCodecs,\n        preferredAudioChannelCount, preferredDecodingAttributes);\n\n    for (const variant of manifest.variants) {\n      goog.asserts.assert(\n          shaka.util.StreamUtils.isPlayable(variant),\n          'We should have already filtered by \"is playable\"');\n\n      allTracks.push(shaka.util.StreamUtils.variantToTrack(variant));\n    }\n\n    for (const text of manifest.textStreams) {\n      allTracks.push(shaka.util.StreamUtils.textStreamToTrack(text));\n    }\n\n    for (const image of manifest.imageStreams) {\n      allTracks.push(shaka.util.StreamUtils.imageStreamToTrack(image));\n    }\n\n    // Let the application choose which tracks to store.\n    const chosenTracks =\n        await config.offline.trackSelectionCallback(allTracks);\n    const duration = manifest.presentationTimeline.getDuration();\n    let sizeEstimate = 0;\n    for (const track of chosenTracks) {\n      const trackSize = track.bandwidth * duration / 8;\n      sizeEstimate += trackSize;\n    }\n    try {\n      const allowedDownload =\n          await config.offline.downloadSizeCallback(sizeEstimate);\n      if (!allowedDownload) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.STORAGE_LIMIT_REACHED);\n      }\n    } catch (e) {\n      // It is necessary to be able to catch the STORAGE_LIMIT_REACHED error\n      if (e instanceof shaka.util.Error) {\n        throw e;\n      }\n      shaka.log.warning(\n          'downloadSizeCallback has produced an unexpected error', e);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.DOWNLOAD_SIZE_CALLBACK_ERROR);\n    }\n\n    /** @type {!Set.<number>} */\n    const variantIds = new Set();\n    /** @type {!Set.<number>} */\n    const textIds = new Set();\n    /** @type {!Set.<number>} */\n    const imageIds = new Set();\n\n    // Collect the IDs of the chosen tracks.\n    for (const track of chosenTracks) {\n      if (track.type == 'variant') {\n        variantIds.add(track.id);\n      }\n      if (track.type == 'text') {\n        textIds.add(track.id);\n      }\n      if (track.type == 'image') {\n        imageIds.add(track.id);\n      }\n    }\n\n    // Filter the manifest to keep only what the app chose.\n    manifest.variants =\n        manifest.variants.filter((variant) => variantIds.has(variant.id));\n    manifest.textStreams =\n        manifest.textStreams.filter((stream) => textIds.has(stream.id));\n    manifest.imageStreams =\n        manifest.imageStreams.filter((stream) => imageIds.has(stream.id));\n\n    // Check the post-filtered manifest for characteristics that may indicate\n    // issues with how the app selected tracks.\n    shaka.offline.Storage.validateManifest_(manifest);\n  }\n\n  /**\n   * Create a download manager and download the manifest.\n   * This also sets up download infos for each segment to be downloaded.\n   *\n   * @param {!shaka.media.DrmEngine} drmEngine\n   * @param {shaka.extern.Manifest} manifest\n   * @param {string} uri\n   * @param {!Object} metadata\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @return {{\n   *   manifestDB: shaka.extern.ManifestDB,\n   *   toDownload: !Array.<!shaka.offline.DownloadInfo>\n   * }}\n   * @private\n   */\n  makeManifestDB_(drmEngine, manifest, uri, metadata, config, downloader) {\n    const pendingContent = shaka.offline.StoredContentUtils.fromManifest(\n        uri, manifest, /* size= */ 0, metadata);\n    // In https://github.com/shaka-project/shaka-player/issues/2652, we found\n    // that this callback would be removed by the compiler if we reference the\n    // config in the onProgress closure below.  Reading it into a local\n    // variable first seems to work around this apparent compiler bug.\n    const progressCallback = config.offline.progressCallback;\n\n    const onProgress = (progress, size) => {\n      // Update the size of the stored content before issuing a progress\n      // update.\n      pendingContent.size = size;\n      progressCallback(pendingContent, progress);\n    };\n    const onInitData = (initData, systemId) => {\n      if (needsInitData && config.offline.usePersistentLicense &&\n          currentSystemId == systemId) {\n        drmEngine.newInitData('cenc', initData);\n      }\n    };\n    downloader.setCallbacks(onProgress, onInitData);\n\n    const needsInitData = this.getManifestIsEncrypted_(manifest) &&\n                          !this.getManifestIncludesInitData_(manifest);\n\n    let currentSystemId = null;\n    if (needsInitData) {\n      const drmInfo = drmEngine.getDrmInfo();\n      currentSystemId =\n          shaka.offline.Storage.defaultSystemIds_.get(drmInfo.keySystem);\n    }\n\n    // Make the estimator, which is used to make the download registries.\n    const estimator = new shaka.offline.StreamBandwidthEstimator();\n    for (const stream of manifest.textStreams) {\n      estimator.addText(stream);\n    }\n    for (const stream of manifest.imageStreams) {\n      estimator.addImage(stream);\n    }\n    for (const variant of manifest.variants) {\n      estimator.addVariant(variant);\n    }\n    const {streams, toDownload} = this.createStreams_(\n        downloader, estimator, drmEngine, manifest, config);\n\n    const drmInfo = drmEngine.getDrmInfo();\n    const usePersistentLicense = config.offline.usePersistentLicense;\n    if (drmInfo && usePersistentLicense) {\n      // Don't store init data, since we have stored sessions.\n      drmInfo.initData = [];\n    }\n\n    const manifestDB = {\n      creationTime: Date.now(),\n      originalManifestUri: uri,\n      duration: manifest.presentationTimeline.getDuration(),\n      size: 0,\n      expiration: drmEngine.getExpiration(),\n      streams,\n      sessionIds: usePersistentLicense ? drmEngine.getSessionIds() : [],\n      drmInfo,\n      appMetadata: metadata,\n      isIncomplete: true,\n    };\n\n    return {manifestDB, toDownload};\n  }\n\n  /**\n   * @param {shaka.extern.Manifest} manifest\n   * @return {boolean}\n   * @private\n   */\n  getManifestIsEncrypted_(manifest) {\n    return manifest.variants.some((variant) => {\n      const videoEncrypted = variant.video && variant.video.encrypted;\n      const audioEncrypted = variant.audio && variant.audio.encrypted;\n      return videoEncrypted || audioEncrypted;\n    });\n  }\n\n  /**\n   * @param {shaka.extern.Manifest} manifest\n   * @return {boolean}\n   * @private\n   */\n  getManifestIncludesInitData_(manifest) {\n    return manifest.variants.some((variant) => {\n      const videoDrmInfos = variant.video ? variant.video.drmInfos : [];\n      const audioDrmInfos = variant.audio ? variant.audio.drmInfos : [];\n      const drmInfos = videoDrmInfos.concat(audioDrmInfos);\n      return drmInfos.some((drmInfos) => {\n        return drmInfos.initData && drmInfos.initData.length;\n      });\n    });\n  }\n\n  /**\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.extern.ManifestDB} manifestDB\n   * @param {!shaka.media.DrmEngine} drmEngine\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @private\n   */\n  setManifestDrmFields_(manifest, manifestDB, drmEngine, config) {\n    manifestDB.expiration = drmEngine.getExpiration();\n\n    const sessions = drmEngine.getSessionIds();\n    manifestDB.sessionIds = config.offline.usePersistentLicense ?\n        sessions : [];\n\n    if (this.getManifestIsEncrypted_(manifest) &&\n        config.offline.usePersistentLicense && !sessions.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.NO_INIT_DATA_FOR_OFFLINE);\n    }\n  }\n\n  /**\n   * Removes the given stored content.  This will also attempt to release the\n   * licenses, if any.\n   *\n   * @param {string} contentUri\n   * @return {!Promise}\n   * @export\n   */\n  remove(contentUri) {\n    return this.startOperation_(this.remove_(contentUri));\n  }\n\n  /**\n   * See |shaka.offline.Storage.remove| for details.\n   *\n   * @param {string} contentUri\n   * @return {!Promise}\n   * @private\n   */\n  async remove_(contentUri) {\n    this.requireSupport_();\n\n    const nullableUri = shaka.offline.OfflineUri.parse(contentUri);\n    if (nullableUri == null || !nullableUri.isManifest()) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n          contentUri);\n    }\n\n    /** @type {!shaka.offline.OfflineUri} */\n    const uri = nullableUri;\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n\n    try {\n      await muxer.init();\n\n      const cell = await muxer.getCell(uri.mechanism(), uri.cell());\n      const manifests = await cell.getManifests([uri.key()]);\n      const manifest = manifests[0];\n\n      await Promise.all([\n        this.removeFromDRM_(uri, manifest, muxer),\n        this.removeFromStorage_(cell, uri, manifest),\n      ]);\n    } finally {\n      await muxer.destroy();\n    }\n  }\n\n  /**\n   * @param {shaka.extern.ManifestDB} manifestDb\n   * @param {boolean} isVideo\n   * @return {!Array.<MediaKeySystemMediaCapability>}\n   * @private\n   */\n  static getCapabilities_(manifestDb, isVideo) {\n    const MimeUtils = shaka.util.MimeUtils;\n\n    const ret = [];\n    for (const stream of manifestDb.streams) {\n      if (isVideo && stream.type == 'video') {\n        ret.push({\n          contentType: MimeUtils.getFullType(stream.mimeType, stream.codecs),\n          robustness: manifestDb.drmInfo.videoRobustness,\n        });\n      } else if (!isVideo && stream.type == 'audio') {\n        ret.push({\n          contentType: MimeUtils.getFullType(stream.mimeType, stream.codecs),\n          robustness: manifestDb.drmInfo.audioRobustness,\n        });\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * @param {!shaka.offline.OfflineUri} uri\n   * @param {shaka.extern.ManifestDB} manifestDb\n   * @param {!shaka.offline.StorageMuxer} muxer\n   * @return {!Promise}\n   * @private\n   */\n  async removeFromDRM_(uri, manifestDb, muxer) {\n    goog.asserts.assert(this.networkingEngine_, 'Cannot be destroyed');\n    await shaka.offline.Storage.deleteLicenseFor_(\n        this.networkingEngine_, this.config_.drm, muxer, manifestDb);\n  }\n\n  /**\n   * @param {shaka.extern.StorageCell} storage\n   * @param {!shaka.offline.OfflineUri} uri\n   * @param {shaka.extern.ManifestDB} manifest\n   * @return {!Promise}\n   * @private\n   */\n  removeFromStorage_(storage, uri, manifest) {\n    /** @type {!Array.<number>} */\n    const segmentIds = shaka.offline.Storage.getAllSegmentIds_(manifest);\n\n    // Count(segments) + Count(manifests)\n    const toRemove = segmentIds.length + 1;\n    let removed = 0;\n\n    const pendingContent = shaka.offline.StoredContentUtils.fromManifestDB(\n        uri, manifest);\n\n    const onRemove = (key) => {\n      removed += 1;\n      this.config_.offline.progressCallback(pendingContent, removed / toRemove);\n    };\n\n    return Promise.all([\n      storage.removeSegments(segmentIds, onRemove),\n      storage.removeManifests([uri.key()], onRemove),\n    ]);\n  }\n\n  /**\n   * Removes any EME sessions that were not successfully removed before.  This\n   * returns whether all the sessions were successfully removed.\n   *\n   * @return {!Promise.<boolean>}\n   * @export\n   */\n  removeEmeSessions() {\n    return this.startOperation_(this.removeEmeSessions_());\n  }\n\n  /**\n   * @return {!Promise.<boolean>}\n   * @private\n   */\n  async removeEmeSessions_() {\n    this.requireSupport_();\n\n    goog.asserts.assert(this.networkingEngine_, 'Cannot be destroyed');\n    const net = this.networkingEngine_;\n    const config = this.config_.drm;\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n    /** @type {!shaka.offline.SessionDeleter} */\n    const deleter = new shaka.offline.SessionDeleter();\n\n    let hasRemaining = false;\n\n    try {\n      await muxer.init();\n\n      /** @type {!Array.<shaka.extern.EmeSessionStorageCell>} */\n      const cells = [];\n      muxer.forEachEmeSessionCell((c) => cells.push(c));\n\n      // Run these sequentially to avoid creating too many DrmEngine instances\n      // and having multiple CDMs alive at once.  Some embedded platforms may\n      // not support that.\n      for (const sessionIdCell of cells) {\n        /* eslint-disable no-await-in-loop */\n        const sessions = await sessionIdCell.getAll();\n        const deletedSessionIds = await deleter.delete(config, net, sessions);\n        await sessionIdCell.remove(deletedSessionIds);\n\n        if (deletedSessionIds.length != sessions.length) {\n          hasRemaining = true;\n        }\n        /* eslint-enable no-await-in-loop */\n      }\n    } finally {\n      await muxer.destroy();\n    }\n\n    return !hasRemaining;\n  }\n\n  /**\n   * Lists all the stored content available.\n   *\n   * @return {!Promise.<!Array.<shaka.extern.StoredContent>>}  A Promise to an\n   *   array of structures representing all stored content.  The \"offlineUri\"\n   *   member of the structure is the URI that should be given to Player.load()\n   *   to play this piece of content offline.  The \"appMetadata\" member is the\n   *   appMetadata argument you passed to store().\n   * @export\n   */\n  list() {\n    return this.startOperation_(this.list_());\n  }\n\n  /**\n   * See |shaka.offline.Storage.list| for details.\n   *\n   * @return {!Promise.<!Array.<shaka.extern.StoredContent>>}\n   * @private\n   */\n  async list_() {\n    this.requireSupport_();\n\n    /** @type {!Array.<shaka.extern.StoredContent>} */\n    const result = [];\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n    try {\n      await muxer.init();\n\n      let p = Promise.resolve();\n      muxer.forEachCell((path, cell) => {\n        p = p.then(async () => {\n          const manifests = await cell.getAllManifests();\n\n          manifests.forEach((manifest, key) => {\n            const uri = shaka.offline.OfflineUri.manifest(\n                path.mechanism,\n                path.cell,\n                key);\n\n            const content = shaka.offline.StoredContentUtils.fromManifestDB(\n                uri,\n                manifest);\n\n            result.push(content);\n          });\n        });\n      });\n\n      await p;\n    } finally {\n      await muxer.destroy();\n    }\n\n    return result;\n  }\n\n\n  /**\n   * This method is public so that it can be overridden in testing.\n   *\n   * @param {string} uri\n   * @param {shaka.extern.ManifestParser} parser\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {!Promise.<shaka.extern.Manifest>}\n   */\n  async parseManifest(uri, parser, config) {\n    let error = null;\n\n    const networkingEngine = this.networkingEngine_;\n    goog.asserts.assert(networkingEngine, 'Should be initialized!');\n\n    /** @type {shaka.extern.ManifestParser.PlayerInterface} */\n    const playerInterface = {\n      networkingEngine: networkingEngine,\n\n      // No need to apply CMCD data for offline requests\n      modifyManifestRequest: (request, manifestInfo) => {},\n      modifySegmentRequest: (request, segmentInfo) => {},\n\n      // Don't bother filtering now. We will do that later when we have all the\n      // information we need to filter.\n      filter: () => Promise.resolve(),\n\n      // The responsibility for making mock text streams for closed captions is\n      // handled inside shaka.offline.OfflineManifestParser, before playback.\n      makeTextStreamsForClosedCaptions: (manifest) => {},\n\n      onTimelineRegionAdded: () => {},\n      onEvent: () => {},\n\n      // Used to capture an error from the manifest parser. We will check the\n      // error before returning.\n      onError: (e) => {\n        error = e;\n      },\n      isLowLatencyMode: () => false,\n      isAutoLowLatencyMode: () => false,\n      enableLowLatencyMode: () => {},\n    };\n\n    parser.configure(config.manifest);\n\n    // We may have been destroyed while we were waiting on |getParser| to\n    // resolve.\n    this.ensureNotDestroyed_();\n\n    const manifest = await parser.start(uri, playerInterface);\n\n    // We may have been destroyed while we were waiting on |start| to\n    // resolve.\n    this.ensureNotDestroyed_();\n\n    // Get all the streams that are used in the manifest.\n    const streams =\n        shaka.offline.Storage.getAllStreamsFromManifest_(manifest);\n\n    // Wait for each stream to create their segment indexes.\n    await Promise.all(shaka.util.Iterables.map(streams, (stream) => {\n      return stream.createSegmentIndex();\n    }));\n\n    // We may have been destroyed while we were waiting on\n    // |createSegmentIndex| to resolve for each stream.\n    this.ensureNotDestroyed_();\n\n    // If we saw an error while parsing, surface the error.\n    if (error) {\n      throw error;\n    }\n\n    return manifest;\n  }\n\n  /**\n   * This method is public so that it can be override in testing.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @param {function(shaka.util.Error)} onError\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {!Promise.<!shaka.media.DrmEngine>}\n   */\n  async createDrmEngine(manifest, onError, config) {\n    goog.asserts.assert(\n        this.networkingEngine_,\n        'Cannot call |createDrmEngine| after |destroy|');\n\n    /** @type {!shaka.media.DrmEngine} */\n    const drmEngine = new shaka.media.DrmEngine({\n      netEngine: this.networkingEngine_,\n      onError: onError,\n      onKeyStatus: () => {},\n      onExpirationUpdated: () => {},\n      onEvent: () => {},\n    });\n\n    drmEngine.configure(config.drm);\n    await drmEngine.initForStorage(\n        manifest.variants, config.offline.usePersistentLicense);\n    await drmEngine.setServerCertificate();\n    await drmEngine.createOrLoad();\n\n    return drmEngine;\n  }\n\n  /**\n   * Converts manifest Streams to database Streams.\n   *\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @param {shaka.offline.StreamBandwidthEstimator} estimator\n   * @param {!shaka.media.DrmEngine} drmEngine\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {{\n   *   streams: !Array.<shaka.extern.StreamDB>,\n   *   toDownload: !Array.<!shaka.offline.DownloadInfo>\n   * }}\n   * @private\n   */\n  createStreams_(downloader, estimator, drmEngine, manifest, config) {\n    // Download infos are stored based on their refId, to dedup them.\n    /** @type {!Map.<string, !shaka.offline.DownloadInfo>} */\n    const toDownload = new Map();\n\n    // Find the streams we want to download and create a stream db instance\n    // for each of them.\n    const streamSet =\n        shaka.offline.Storage.getAllStreamsFromManifest_(manifest);\n    const streamDBs = new Map();\n\n    for (const stream of streamSet) {\n      const streamDB = this.createStream_(\n          downloader, estimator, manifest, stream, config, toDownload);\n      streamDBs.set(stream.id, streamDB);\n    }\n\n    // Connect streams and variants together.\n    for (const variant of manifest.variants) {\n      if (variant.audio) {\n        streamDBs.get(variant.audio.id).variantIds.push(variant.id);\n      }\n      if (variant.video) {\n        streamDBs.get(variant.video.id).variantIds.push(variant.id);\n      }\n    }\n\n    return {\n      streams: Array.from(streamDBs.values()),\n      toDownload: Array.from(toDownload.values()),\n    };\n  }\n\n  /**\n   * Converts a manifest stream to a database stream.  This will search the\n   * segment index and add all the segments to the download infos.\n   *\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @param {shaka.offline.StreamBandwidthEstimator} estimator\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.extern.Stream} stream\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @param {!Map.<string, !shaka.offline.DownloadInfo>} toDownload\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  createStream_(downloader, estimator, manifest, stream, config, toDownload) {\n    /** @type {shaka.extern.StreamDB} */\n    const streamDb = {\n      id: stream.id,\n      originalId: stream.originalId,\n      primary: stream.primary,\n      type: stream.type,\n      mimeType: stream.mimeType,\n      codecs: stream.codecs,\n      frameRate: stream.frameRate,\n      pixelAspectRatio: stream.pixelAspectRatio,\n      hdr: stream.hdr,\n      kind: stream.kind,\n      language: stream.language,\n      label: stream.label,\n      width: stream.width || null,\n      height: stream.height || null,\n      encrypted: stream.encrypted,\n      keyIds: stream.keyIds,\n      segments: [],\n      variantIds: [],\n      roles: stream.roles,\n      forced: stream.forced,\n      channelsCount: stream.channelsCount,\n      audioSamplingRate: stream.audioSamplingRate,\n      spatialAudio: stream.spatialAudio,\n      closedCaptions: stream.closedCaptions,\n      tilesLayout: stream.tilesLayout,\n    };\n\n    const startTime =\n        manifest.presentationTimeline.getSegmentAvailabilityStart();\n\n    shaka.offline.Storage.forEachSegment_(stream, startTime, (segment) => {\n      const pendingSegmentRefId =\n          shaka.offline.DownloadInfo.idForSegmentRef(segment);\n      let pendingInitSegmentRefId = undefined;\n\n      // Set up the download for the segment, which will be downloaded later,\n      // perhaps in a service worker.\n      if (!toDownload.has(pendingSegmentRefId)) {\n        const estimateId = downloader.addDownloadEstimate(\n            estimator.getSegmentEstimate(stream.id, segment));\n        const segmentDownload = new shaka.offline.DownloadInfo(\n            segment,\n            estimateId,\n            stream.id,\n            /* isInitSegment= */ false);\n        toDownload.set(pendingSegmentRefId, segmentDownload);\n      }\n\n      // Set up the download for the init segment, similarly, if there is one.\n      if (segment.initSegmentReference) {\n        pendingInitSegmentRefId = shaka.offline.DownloadInfo.idForSegmentRef(\n            segment.initSegmentReference);\n        if (!toDownload.has(pendingInitSegmentRefId)) {\n          const estimateId = downloader.addDownloadEstimate(\n              estimator.getInitSegmentEstimate(stream.id));\n          const initDownload = new shaka.offline.DownloadInfo(\n              segment.initSegmentReference,\n              estimateId,\n              stream.id,\n              /* isInitSegment= */ true);\n          toDownload.set(pendingInitSegmentRefId, initDownload);\n        }\n      }\n\n      /** @type {!shaka.extern.SegmentDB} */\n      const segmentDB = {\n        pendingInitSegmentRefId,\n        initSegmentKey: pendingInitSegmentRefId ? 0 : null,\n        startTime: segment.startTime,\n        endTime: segment.endTime,\n        appendWindowStart: segment.appendWindowStart,\n        appendWindowEnd: segment.appendWindowEnd,\n        timestampOffset: segment.timestampOffset,\n        tilesLayout: segment.tilesLayout,\n        pendingSegmentRefId,\n        dataKey: 0,\n      };\n      streamDb.segments.push(segmentDB);\n    });\n\n    return streamDb;\n  }\n\n  /**\n   * @param {shaka.extern.Stream} stream\n   * @param {number} startTime\n   * @param {function(!shaka.media.SegmentReference)} callback\n   * @private\n   */\n  static forEachSegment_(stream, startTime, callback) {\n    /** @type {?number} */\n    let i = stream.segmentIndex.find(startTime);\n\n    if (i == null) {\n      return;\n    }\n\n    /** @type {?shaka.media.SegmentReference} */\n    let ref = stream.segmentIndex.get(i);\n    while (ref) {\n      callback(ref);\n      ref = stream.segmentIndex.get(++i);\n    }\n  }\n\n  /**\n   * Throws an error if the object is destroyed.\n   * @private\n   */\n  ensureNotDestroyed_() {\n    if (this.destroyer_.destroyed()) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.OPERATION_ABORTED);\n    }\n  }\n\n  /**\n   * Used by functions that need storage support to ensure that the current\n   * platform has storage support before continuing. This should only be\n   * needed to be used at the start of public methods.\n   *\n   * @private\n   */\n  requireSupport_() {\n    if (!shaka.offline.Storage.support()) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.STORAGE_NOT_SUPPORTED);\n    }\n  }\n\n  /**\n   * Perform an action. Track the action's progress so that when we destroy\n   * we will wait until all the actions have completed before allowing destroy\n   * to resolve.\n   *\n   * @param {!Promise<T>} action\n   * @return {!Promise<T>}\n   * @template T\n   * @private\n   */\n  async startOperation_(action) {\n    this.openOperations_.push(action);\n\n    try {\n      // Await |action| so we can use the finally statement to remove |action|\n      // from |openOperations_| when we still have a reference to |action|.\n      return await action;\n    } finally {\n      shaka.util.ArrayUtils.remove(this.openOperations_, action);\n    }\n  }\n\n  /**\n   * The equivalent of startOperation_, but for abortable operations.\n   *\n   * @param {!shaka.extern.IAbortableOperation<T>} action\n   * @return {!shaka.extern.IAbortableOperation<T>}\n   * @template T\n   * @private\n   */\n  startAbortableOperation_(action) {\n    const promise = action.promise;\n    this.openOperations_.push(promise);\n\n    // Remove the open operation once the action has completed. So that we\n    // can still return the AbortableOperation, this is done using a |finally|\n    // block, rather than awaiting the result.\n    return action.finally(() => {\n      shaka.util.ArrayUtils.remove(this.openOperations_, promise);\n    });\n  }\n\n  /**\n   * @param {shaka.extern.ManifestDB} manifest\n   * @return {!Array.<number>}\n   * @private\n   */\n  static getAllSegmentIds_(manifest) {\n    /** @type {!Set.<number>} */\n    const ids = new Set();\n\n    // Get every segment for every stream in the manifest.\n    for (const stream of manifest.streams) {\n      for (const segment of stream.segments) {\n        if (segment.initSegmentKey != null) {\n          ids.add(segment.initSegmentKey);\n        }\n\n        ids.add(segment.dataKey);\n      }\n    }\n\n    return Array.from(ids);\n  }\n\n  /**\n   * Delete the on-disk storage and all the content it contains. This should not\n   * be done in normal circumstances. Only do it when storage is rendered\n   * unusable, such as by a version mismatch. No business logic will be run, and\n   * licenses will not be released.\n   *\n   * @return {!Promise}\n   * @export\n   */\n  static async deleteAll() {\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n    try {\n      // Wipe all content from all storage mechanisms.\n      await muxer.erase();\n    } finally {\n      // Destroy the muxer, whether or not erase() succeeded.\n      await muxer.destroy();\n    }\n  }\n\n  /**\n   * @param {!shaka.net.NetworkingEngine} net\n   * @param {!shaka.extern.DrmConfiguration} drmConfig\n   * @param {!shaka.offline.StorageMuxer} muxer\n   * @param {shaka.extern.ManifestDB} manifestDb\n   * @return {!Promise}\n   * @private\n   */\n  static async deleteLicenseFor_(net, drmConfig, muxer, manifestDb) {\n    if (!manifestDb.drmInfo) {\n      return;\n    }\n\n    const sessionIdCell = muxer.getEmeSessionCell();\n\n    /** @type {!Array.<shaka.extern.EmeSessionDB>} */\n    const sessions = manifestDb.sessionIds.map((sessionId) => {\n      return {\n        sessionId: sessionId,\n        keySystem: manifestDb.drmInfo.keySystem,\n        licenseUri: manifestDb.drmInfo.licenseServerUri,\n        serverCertificate: manifestDb.drmInfo.serverCertificate,\n        audioCapabilities: shaka.offline.Storage.getCapabilities_(\n            manifestDb,\n            /* isVideo= */ false),\n        videoCapabilities: shaka.offline.Storage.getCapabilities_(\n            manifestDb,\n            /* isVideo= */ true),\n      };\n    });\n    // Try to delete the sessions; any sessions that weren't deleted get stored\n    // in the database so we can try to remove them again later.  This allows us\n    // to still delete the stored content but not \"forget\" about these sessions.\n    // Later, we can remove the sessions to free up space.\n    const deleter = new shaka.offline.SessionDeleter();\n    const deletedSessionIds = await deleter.delete(drmConfig, net, sessions);\n    await sessionIdCell.remove(deletedSessionIds);\n    await sessionIdCell.add(sessions.filter(\n        (session) => !deletedSessionIds.includes(session.sessionId)));\n  }\n\n  /**\n   * Get the set of all streams in |manifest|.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @return {!Set.<shaka.extern.Stream>}\n   * @private\n   */\n  static getAllStreamsFromManifest_(manifest) {\n    /** @type {!Set.<shaka.extern.Stream>} */\n    const set = new Set();\n\n    for (const text of manifest.textStreams) {\n      set.add(text);\n    }\n\n    for (const image of manifest.imageStreams) {\n      set.add(image);\n    }\n\n    for (const variant of manifest.variants) {\n      if (variant.audio) {\n        set.add(variant.audio);\n      }\n      if (variant.video) {\n        set.add(variant.video);\n      }\n    }\n\n    return set;\n  }\n\n  /**\n   * Go over a manifest and issue warnings for any suspicious properties.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @private\n   */\n  static validateManifest_(manifest) {\n    const videos = new Set(manifest.variants.map((v) => v.video));\n    const audios = new Set(manifest.variants.map((v) => v.audio));\n    const texts = manifest.textStreams;\n\n    if (videos.size > 1) {\n      shaka.log.warning('Multiple video tracks selected to be stored');\n    }\n\n    for (const audio1 of audios) {\n      for (const audio2 of audios) {\n        if (audio1 != audio2 && audio1.language == audio2.language) {\n          shaka.log.warning(\n              'Similar audio tracks were selected to be stored',\n              audio1.id,\n              audio2.id);\n        }\n      }\n    }\n\n    for (const text1 of texts) {\n      for (const text2 of texts) {\n        if (text1 != text2 && text1.language == text2.language) {\n          shaka.log.warning(\n              'Similar text tracks were selected to be stored',\n              text1.id,\n              text2.id);\n        }\n      }\n    }\n  }\n};\n\nshaka.offline.Storage.defaultSystemIds_ = new Map()\n    .set('org.w3.clearkey', '1077efecc0b24d02ace33c1e52e2fb4b')\n    .set('com.widevine.alpha', 'edef8ba979d64acea3c827dcd51d21ed')\n    .set('com.microsoft.playready', '9a04f07998404286ab92e65be0885f95')\n    .set('com.microsoft.playready.recommendation',\n        '9a04f07998404286ab92e65be0885f95')\n    .set('com.microsoft.playready.software',\n        '9a04f07998404286ab92e65be0885f95')\n    .set('com.microsoft.playready.hardware',\n        '9a04f07998404286ab92e65be0885f95')\n    .set('com.adobe.primetime', 'f239e769efa348509c16a903c6932efb');\n\nshaka.Player.registerSupportPlugin('offline', shaka.offline.Storage.support);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.StreamBandwidthEstimator');\n\ngoog.require('shaka.log');\ngoog.requireType('shaka.media.SegmentReference');\n\n\n/**\n * A utility class to help estimate the size of streams based on stream and\n * variant bandwidths. This class's main purpose is to isolate the logic in\n * creating non-zero bandwidth estimates for all streams so that each stream\n * will have some influence over the progress of the download.\n */\nshaka.offline.StreamBandwidthEstimator = class {\n  /** */\n  constructor() {\n    /** @private {!Object.<number, number>} */\n    this.estimateByStreamId_ = {};\n  }\n\n  /**\n   * Add a new variant to the estimator. This will update the estimates for all\n   * streams in the variant.\n   *\n   * @param {shaka.extern.Variant} variant\n   */\n  addVariant(variant) {\n    // Three cases:\n    //  1 - Only Audio\n    //  2 - Only Video\n    //  3 - Audio and Video\n\n    const audio = variant.audio;\n    const video = variant.video;\n\n    // Case 1\n    if (audio && !video) {\n      const audioBitRate = audio.bandwidth || variant.bandwidth;\n      this.setBitrate_(audio.id, audioBitRate);\n    }\n\n    // Case 2\n    if (!audio && video) {\n      const videoBitRate = video.bandwidth || variant.bandwidth;\n      this.setBitrate_(video.id, videoBitRate);\n    }\n\n    // Case 3\n    if (audio && video) {\n      // Get the audio's bandwidth. If it is missing, default to our default\n      // audio bandwidth.\n      const audioBitRate =\n          audio.bandwidth ||\n          shaka.offline.StreamBandwidthEstimator.DEFAULT_AUDIO_BITRATE_;\n\n      // Get the video's bandwidth. If it is missing, use the variant bandwidth\n      // less the audio. If we get a negative bit rate, fall back to our\n      // default video bandwidth.\n      let videoBitRate = video.bandwidth || (variant.bandwidth - audioBitRate);\n      if (videoBitRate <= 0) {\n        shaka.log.warning(\n            'Audio bit rate consumes variants bandwidth. Setting video ' +\n            'bandwidth to match variant\\'s bandwidth.');\n        videoBitRate = variant.bandwidth;\n      }\n\n      this.setBitrate_(audio.id, audioBitRate);\n      this.setBitrate_(video.id, videoBitRate);\n    }\n  }\n\n  /**\n   * @param {number} stream\n   * @param {number} bitRate\n   * @private\n   */\n  setBitrate_(stream, bitRate) {\n    this.estimateByStreamId_[stream] = bitRate;\n  }\n\n  /**\n   * Create an estimate for the text stream.\n   *\n   * @param {shaka.extern.Stream} text\n   */\n  addText(text) {\n    this.estimateByStreamId_[text.id] =\n        shaka.offline.StreamBandwidthEstimator.DEFAULT_TEXT_BITRATE_;\n  }\n\n  /**\n   * Create an estimate for the image stream.\n   *\n   * @param {shaka.extern.Stream} image\n   */\n  addImage(image) {\n    this.estimateByStreamId_[image.id] = image.bandwidth ||\n        shaka.offline.StreamBandwidthEstimator.DEFAULT_IMAGE_BITRATE_;\n  }\n\n  /**\n   * Get the estimate for a segment that is part of a stream that has already\n   * added to the estimator.\n   *\n   * @param {number} id\n   * @param {!shaka.media.SegmentReference} segment\n   * @return {number}\n   */\n  getSegmentEstimate(id, segment) {\n    const duration = segment.endTime - segment.startTime;\n    return this.getEstimate_(id) * duration;\n  }\n\n  /**\n   * Get the estimate for an init segment for a stream that has already\n   * added to the estimator.\n   *\n   * @param {number} id\n   * @return {number}\n   */\n  getInitSegmentEstimate(id) {\n    // Assume that the init segment is worth approximately half a second of\n    // content.\n    const duration = 0.5;\n    return this.getEstimate_(id) * duration;\n  }\n\n  /**\n   * @param {number} id\n   * @return {number}\n   * @private\n   */\n  getEstimate_(id) {\n    let bitRate = this.estimateByStreamId_[id];\n\n    if (bitRate == null) {\n      bitRate = 0;\n      shaka.log.error(\n          'Asking for bitrate of stream not given to the estimator');\n    }\n\n    if (bitRate == 0) {\n      shaka.log.warning(\n          'Using bitrate of 0, this stream won\\'t affect progress');\n    }\n\n    return bitRate;\n  }\n};\n\n\n/**\n * Since audio bandwidth does not vary much, we are going to use a constant\n * approximation for audio bit rate allowing use to more accurately guess at\n * the video bitrate.\n *\n * YouTube's suggested bitrate for stereo audio is 384 kbps so we are going to\n * assume that: https://support.google.com/youtube/answer/1722171?hl=en\n *\n * @const {number}\n * @private\n */\nshaka.offline.StreamBandwidthEstimator.DEFAULT_AUDIO_BITRATE_ = 393216;\n\n\n/**\n * Since we don't normally get the bitrate for text, we still want to create\n * some approximation so that it can influence progress. This will use the\n * bitrate from \"Tears of Steal\" to give some kind of data-driven result.\n *\n * The file size for English subtitles is 4.7 KB. The video is 12:14 long,\n * which means that the text's bit rate is around 52 bps.\n *\n * @const {number}\n * @private\n */\nshaka.offline.StreamBandwidthEstimator.DEFAULT_TEXT_BITRATE_ = 52;\n\n\n/**\n * Since we don't normally get the bitrate for image, we still want to create\n * some approximation so that it can influence progress.\n *\n * The size of the thumbnail usually is 2KB.\n *\n * @const {number}\n * @private\n */\nshaka.offline.StreamBandwidthEstimator.DEFAULT_IMAGE_BITRATE_ = 2048;\n\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill');\n\ngoog.require('shaka.log');\n\n\n/**\n * @summary A one-stop installer for all polyfills.\n * @see http://enwp.org/polyfill\n * @export\n */\nshaka.polyfill = class {\n  /**\n   * Install all polyfills.\n   * @export\n   */\n  static installAll() {\n    for (const polyfill of shaka.polyfill.polyfills_) {\n      try {\n        polyfill.callback();\n      } catch (error) {\n        shaka.log.alwaysWarn('Error installing polyfill!', error);\n      }\n    }\n  }\n\n  /**\n   * Registers a new polyfill to be installed.\n   *\n   * @param {function()} polyfill\n   * @param {number=} priority An optional number priority.  Higher priorities\n   *   will be executed before lower priority ones.  Default is 0.\n   * @export\n   */\n  static register(polyfill, priority) {\n    const newItem = {priority: priority || 0, callback: polyfill};\n    for (let i = 0; i < shaka.polyfill.polyfills_.length; i++) {\n      const item = shaka.polyfill.polyfills_[i];\n      if (item.priority < newItem.priority) {\n        shaka.polyfill.polyfills_.splice(i, 0, newItem);\n        return;\n      }\n    }\n    shaka.polyfill.polyfills_.push(newItem);\n  }\n};\n\n\n/**\n * Contains the polyfills that will be installed.\n * @private {!Array.<{priority: number, callback: function()}>}\n */\nshaka.polyfill.polyfills_ = [];\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.Aria');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n/**\n * @summary A polyfill to add support for the ARIAMixin interface mixin, for\n * browsers that do not implement it (e.g. Firefox).\n * Note that IE also does not support ARIAMixin, but this polyfill does not work\n * for that platform, as it relies on getters and setters.\n * @see https://w3c.github.io/aria/#ARIAMixin\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Element\n * @export\n */\nshaka.polyfill.Aria = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    // eslint-disable-next-line no-restricted-syntax\n    if (Object.getOwnPropertyDescriptor(Element.prototype, 'ariaHidden')) {\n      shaka.log.info('Using native ARIAMixin interface.');\n      return;\n    }\n    shaka.log.info('ARIAMixin interface not detected. Installing polyfill.');\n\n    // Define a list of all of the ARIAMixin properties that we have externs\n    // for.\n    const attributes = [\n      'ariaHidden',\n      'ariaLabel',\n      'ariaPressed',\n      'ariaSelected',\n    ];\n\n    // Add each attribute, one by one.\n    for (const attribute of attributes) {\n      shaka.polyfill.Aria.addARIAMixinAttribute_(attribute);\n    }\n  }\n\n  /**\n   * Adds an attribute with the given name.\n   * @param {string} name The name of the attribute, in camelCase.\n   * @private\n   */\n  static addARIAMixinAttribute_(name) {\n    const baseName = name.toLowerCase().replace(/^aria/, '');\n    // NOTE: All the attributes listed in the method above begin with \"aria\".\n    // However, to add extra protection against the possibility of XSS attacks\n    // through this method, this enforces \"aria-\" at the beginning of the\n    // snake-case name, even if somehow \"aria\" were missing from the input.\n    const snakeCaseName = `aria-${baseName}`;\n\n    /* eslint-disable no-restricted-syntax */\n    Object.defineProperty(Element.prototype, name, {\n      get() {\n        const element = /** @type {!Element} */ (this);\n        return element.getAttribute(snakeCaseName);\n      },\n      set(value) {\n        const element = /** @type {!Element} */ (this);\n        if (value == null || value == undefined) {\n          element.removeAttribute(snakeCaseName);\n        } else {\n          element.setAttribute(snakeCaseName, value);\n        }\n      },\n    });\n    /* eslint-enable no-restricted-syntax */\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.Aria.install);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.EncryptionScheme');\n\ngoog.require('shaka.polyfill');\n\n/**\n * @summary A polyfill to add support for EncryptionScheme queries in EME.\n * @see https://wicg.github.io/encrypted-media-encryption-scheme/\n * @see https://github.com/w3c/encrypted-media/pull/457\n * @see https://github.com/shaka-project/eme-encryption-scheme-polyfill\n * @export\n */\nshaka.polyfill.EncryptionScheme = class {\n  /**\n   * Install the polyfill if needed.\n   *\n   * @suppress {missingRequire}\n   * @export\n   */\n  static install() {\n    EncryptionSchemePolyfills.install();\n  }\n};\n\n// Install at a low priority so that other EME polyfills go first.\nshaka.polyfill.register(shaka.polyfill.EncryptionScheme.install, -2);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.Fullscreen');\n\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to unify fullscreen APIs across browsers.\n * Many browsers have prefixed fullscreen methods on Element and document.\n * See {@link https://mzl.la/2K0xcHo Using fullscreen mode} on MDN for more\n * information.\n * @export\n */\nshaka.polyfill.Fullscreen = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (!window.Document) {\n      // Avoid errors on very old browsers.\n      return;\n    }\n\n    // eslint-disable-next-line no-restricted-syntax\n    let proto = Element.prototype;\n    proto.requestFullscreen = proto.requestFullscreen ||\n                              proto.mozRequestFullScreen ||\n                              proto.msRequestFullscreen ||\n                              proto.webkitRequestFullscreen;\n\n    // eslint-disable-next-line no-restricted-syntax\n    proto = Document.prototype;\n    proto.exitFullscreen = proto.exitFullscreen ||\n                           proto.mozCancelFullScreen ||\n                           proto.msExitFullscreen ||\n                           proto.webkitCancelFullScreen;\n\n    if (!('fullscreenElement' in document)) {\n      Object.defineProperty(document, 'fullscreenElement', {\n        get: () => {\n          return document.mozFullScreenElement ||\n                 document.msFullscreenElement ||\n                 document.webkitCurrentFullScreenElement ||\n                 document.webkitFullscreenElement;\n        },\n      });\n      Object.defineProperty(document, 'fullscreenEnabled', {\n        get: () => {\n          return document.mozFullScreenEnabled ||\n                 document.msFullscreenEnabled ||\n                 document.webkitFullscreenEnabled;\n        },\n      });\n    }\n\n    const proxy = shaka.polyfill.Fullscreen.proxyEvent_;\n    document.addEventListener('webkitfullscreenchange', proxy);\n    document.addEventListener('webkitfullscreenerror', proxy);\n    document.addEventListener('mozfullscreenchange', proxy);\n    document.addEventListener('mozfullscreenerror', proxy);\n    document.addEventListener('MSFullscreenChange', proxy);\n    document.addEventListener('MSFullscreenError', proxy);\n  }\n\n  /**\n   * Proxy fullscreen events after changing their name.\n   * @param {!Event} event\n   * @private\n   */\n  static proxyEvent_(event) {\n    const eventType = event.type.replace(/^(webkit|moz|MS)/, '').toLowerCase();\n\n    const newEvent = document.createEvent('Event');\n    newEvent.initEvent(eventType, event.bubbles, event.cancelable);\n\n    event.target.dispatchEvent(newEvent);\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.Fullscreen.install);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\ngoog.provide('shaka.polyfill.MathRound');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n/**\n * @summary A polyfill to patch math round bug on some browsers.\n * @see https://stackoverflow.com/q/12830742\n * @export\n */\nshaka.polyfill.MathRound = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    shaka.log.debug('mathRound.install');\n\n    const testNumber = shaka.polyfill.MathRound.MAX_ACCURATE_INPUT_ + 1;\n    if (Math.round(testNumber) != testNumber) {\n      shaka.log.debug('polyfill Math.round');\n      const originalMathRound = Math.round;\n      Math.round = (number) => {\n        let result = number;\n        // Due to the precision of JavaScript numbers, the number must be\n        // integer.\n        if (number <= shaka.polyfill.MathRound.MAX_ACCURATE_INPUT_) {\n          result = originalMathRound(number);\n        }\n        return result;\n      };\n    }\n  }\n};\n\n\n/**\n @const {number}\n @private\n */\nshaka.polyfill.MathRound.MAX_ACCURATE_INPUT_ = 0x10000000000000;\n\n\nshaka.polyfill.register(shaka.polyfill.MathRound.install);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.MediaCapabilities');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.Platform');\n\n\n/**\n * @summary A polyfill to provide navigator.mediaCapabilities on all browsers.\n * This is necessary for Tizen 3, Xbox One and possibly others we have yet to\n * discover.\n * @export\n */\nshaka.polyfill.MediaCapabilities = class {\n  /**\n   * Install the polyfill if needed.\n   * @suppress {const}\n   * @export\n   */\n  static install() {\n    // Since MediaCapabilities is not fully supported on Chromecast yet, we\n    // should always install polyfill for Chromecast.\n    // TODO: re-evaluate MediaCapabilities in the future versions of Chromecast.\n    // Since MediaCapabilities implementation is buggy in Apple browsers, we\n    // should always install polyfill for Apple browsers.\n    // See: https://github.com/shaka-project/shaka-player/issues/3530\n    // TODO: re-evaluate MediaCapabilities in the future versions of Apple\n    // Browsers.\n    // Since MediaCapabilities implementation is buggy in PS5 browsers, we\n    // should always install polyfill for PS5 browsers.\n    // See: https://github.com/shaka-project/shaka-player/issues/3582\n    // TODO: re-evaluate MediaCapabilities in the future versions of PS5\n    // Browsers.\n    if (!shaka.util.Platform.isChromecast() &&\n        !shaka.util.Platform.isApple() &&\n        !shaka.util.Platform.isPS4() &&\n        !shaka.util.Platform.isPS5() &&\n        !shaka.util.Platform.isWebOS() &&\n        !shaka.util.Platform.isTizen() &&\n        !shaka.util.Platform.isEOS() &&\n        !shaka.util.Platform.isHisense() &&\n        navigator.mediaCapabilities) {\n      shaka.log.info(\n          'MediaCapabilities: Native mediaCapabilities support found.');\n      return;\n    }\n\n    shaka.log.info('MediaCapabilities: install');\n\n    if (!navigator.mediaCapabilities) {\n      navigator.mediaCapabilities = /** @type {!MediaCapabilities} */ ({});\n    }\n\n    // Keep the patched MediaCapabilities object from being garbage-collected in\n    // Safari.\n    // See https://github.com/shaka-project/shaka-player/issues/3696#issuecomment-1009472718\n    shaka.polyfill.MediaCapabilities.originalMcap =\n        navigator.mediaCapabilities;\n\n    navigator.mediaCapabilities.decodingInfo =\n        shaka.polyfill.MediaCapabilities.decodingInfo_;\n  }\n\n  /**\n   * @param {!MediaDecodingConfiguration} mediaDecodingConfig\n   * @return {!Promise.<!MediaCapabilitiesDecodingInfo>}\n   * @private\n   */\n  static async decodingInfo_(mediaDecodingConfig) {\n    const res = {\n      supported: false,\n      powerEfficient: true,\n      smooth: true,\n      keySystemAccess: null,\n      configuration: mediaDecodingConfig,\n    };\n\n    if (!mediaDecodingConfig) {\n      return res;\n    }\n\n    const videoConfig = mediaDecodingConfig['video'];\n    const audioConfig = mediaDecodingConfig['audio'];\n\n    if (mediaDecodingConfig.type == 'media-source') {\n      if (!shaka.util.Platform.supportsMediaSource()) {\n        return res;\n      }\n      // Use 'MediaSource.isTypeSupported' to check if the stream is supported.\n      // Cast platforms will additionally check canDisplayType(), which\n      // accepts extended MIME type parameters.\n      // See: https://github.com/shaka-project/shaka-player/issues/4726\n      if (videoConfig) {\n        let isSupported;\n        if (shaka.util.Platform.isChromecast()) {\n          isSupported =\n              shaka.polyfill.MediaCapabilities.canCastDisplayType_(videoConfig);\n        } else if (shaka.util.Platform.isTizen()) {\n          let extendedType = videoConfig.contentType;\n          if (videoConfig.width && videoConfig.height) {\n            extendedType += `; width=${videoConfig.width}`;\n            extendedType += `; height=${videoConfig.height}`;\n          }\n          if (videoConfig.framerate) {\n            extendedType += `; framerate=${videoConfig.framerate}`;\n          }\n          if (videoConfig.bitrate) {\n            extendedType += `; bitrate=${videoConfig.bitrate}`;\n          }\n          isSupported = MediaSource.isTypeSupported(extendedType);\n        } else {\n          isSupported = MediaSource.isTypeSupported(videoConfig.contentType);\n        }\n        if (!isSupported) {\n          return res;\n        }\n      }\n\n      if (audioConfig) {\n        const contentType = audioConfig.contentType;\n        const isSupported = MediaSource.isTypeSupported(contentType);\n        if (!isSupported) {\n          return res;\n        }\n      }\n    } else if (mediaDecodingConfig.type == 'file') {\n      if (videoConfig) {\n        const contentType = videoConfig.contentType;\n        const isSupported = shaka.util.Platform.supportsMediaType(contentType);\n        if (!isSupported) {\n          return res;\n        }\n      }\n\n      if (audioConfig) {\n        const contentType = audioConfig.contentType;\n        const isSupported = shaka.util.Platform.supportsMediaType(contentType);\n        if (!isSupported) {\n          return res;\n        }\n      }\n    } else {\n      // Otherwise not supported.\n      return res;\n    }\n\n    if (!mediaDecodingConfig.keySystemConfiguration) {\n      // The variant is supported if it's unencrypted.\n      res.supported = true;\n      return Promise.resolve(res);\n    } else {\n      // Get the MediaKeySystemAccess for the key system.\n      // Convert the MediaDecodingConfiguration object to a\n      // MediaKeySystemConfiguration object.\n\n      /** @type {MediaCapabilitiesKeySystemConfiguration} */\n      const mediaCapkeySystemConfig =\n          mediaDecodingConfig.keySystemConfiguration;\n      const audioCapabilities = [];\n      const videoCapabilities = [];\n\n      if (mediaCapkeySystemConfig.audio) {\n        const capability = {\n          robustness: mediaCapkeySystemConfig.audio.robustness || '',\n          contentType: mediaDecodingConfig.audio.contentType,\n        };\n        audioCapabilities.push(capability);\n      }\n\n      if (mediaCapkeySystemConfig.video) {\n        const capability = {\n          robustness: mediaCapkeySystemConfig.video.robustness || '',\n          contentType: mediaDecodingConfig.video.contentType,\n        };\n        videoCapabilities.push(capability);\n      }\n\n      /** @type {MediaKeySystemConfiguration} */\n      const mediaKeySystemConfig = {\n        initDataTypes: [mediaCapkeySystemConfig.initDataType],\n        distinctiveIdentifier: mediaCapkeySystemConfig.distinctiveIdentifier,\n        persistentState: mediaCapkeySystemConfig.persistentState,\n        sessionTypes: mediaCapkeySystemConfig.sessionTypes,\n      };\n\n      // Only add the audio video capabilities if they have valid data.\n      // Otherwise the query will fail.\n      if (audioCapabilities.length) {\n        mediaKeySystemConfig.audioCapabilities = audioCapabilities;\n      }\n      if (videoCapabilities.length) {\n        mediaKeySystemConfig.videoCapabilities = videoCapabilities;\n      }\n\n      let keySystemAccess;\n      try {\n        keySystemAccess = await navigator.requestMediaKeySystemAccess(\n            mediaCapkeySystemConfig.keySystem, [mediaKeySystemConfig]);\n      } catch (e) {\n        shaka.log.info('navigator.requestMediaKeySystemAccess failed.');\n      }\n\n      if (keySystemAccess) {\n        res.supported = true;\n        res.keySystemAccess = keySystemAccess;\n      }\n    }\n\n    return res;\n  }\n\n  /**\n   * Checks if the given media parameters of the video or audio streams are\n   * supported by the Cast platform.\n   * @param {!VideoConfiguration} videoConfig The 'video' field of the\n   *     MediaDecodingConfiguration.\n   * @return {boolean} `true` when the stream can be displayed on a Cast device.\n   * @private\n   */\n  static canCastDisplayType_(videoConfig) {\n    if (!(window.cast &&\n        cast.__platform__ && cast.__platform__.canDisplayType)) {\n      shaka.log.warning('Expected cast APIs to be available! Falling back to ' +\n          'MediaSource.isTypeSupported() for type support.');\n      return MediaSource.isTypeSupported(videoConfig.contentType);\n    }\n\n    let displayType = videoConfig.contentType;\n    if (videoConfig.width && videoConfig.height) {\n      displayType +=\n          `; width=${videoConfig.width}; height=${videoConfig.height}`;\n    }\n    if (videoConfig.framerate) {\n      displayType += `; framerate=${videoConfig.framerate}`;\n    }\n    if (videoConfig.transferFunction === 'pq') {\n      // A \"PQ\" transfer function indicates this is an HDR-capable stream;\n      // \"smpte2084\" is the published standard. We need to inform the platform\n      // this query is specifically for HDR.\n      displayType += '; eotf=smpte2084';\n    }\n    return cast.__platform__.canDisplayType(displayType);\n  }\n};\n\n/**\n * A copy of the MediaCapabilities instance, to prevent Safari from\n * garbage-collecting the polyfilled method on it.  We make it public and export\n * it to ensure that it is not stripped out by the compiler.\n *\n * @type {MediaCapabilities}\n * @export\n */\nshaka.polyfill.MediaCapabilities.originalMcap = null;\n\n// Install at a lower priority than MediaSource polyfill, so that we have\n// MediaSource available first.\nshaka.polyfill.register(shaka.polyfill.MediaCapabilities.install, -1);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.MediaSource');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Platform');\n\n/**\n * @summary A polyfill to patch MSE bugs.\n * @export\n */\nshaka.polyfill.MediaSource = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    shaka.log.debug('MediaSource.install');\n\n    // MediaSource bugs are difficult to detect without checking for the\n    // affected platform.  SourceBuffer is not always exposed on window, for\n    // example, and instances are only accessible after setting up MediaSource\n    // on a video element.  Because of this, we use UA detection and other\n    // platform detection tricks to decide which patches to install.\n    const safariVersion = shaka.util.Platform.safariVersion();\n\n    if (!window.MediaSource) {\n      shaka.log.info('No MSE implementation available.');\n    } else if (window.cast && cast.__platform__ &&\n               cast.__platform__.canDisplayType) {\n      shaka.log.info('Patching Chromecast MSE bugs.');\n      // Chromecast cannot make accurate determinations via isTypeSupported.\n      shaka.polyfill.MediaSource.patchCastIsTypeSupported_();\n    } else if (safariVersion) {\n      // TS content is broken on Safari in general.\n      // See https://github.com/shaka-project/shaka-player/issues/743\n      // and https://bugs.webkit.org/show_bug.cgi?id=165342\n      shaka.polyfill.MediaSource.rejectTsContent_();\n\n      // NOTE:  shaka.Player.isBrowserSupported() has its own restrictions on\n      // Safari version.\n      if (safariVersion <= 12) {\n        shaka.log.info('Patching Safari 11 & 12 MSE bugs.');\n        // Safari 11 & 12 do not correctly implement abort() on SourceBuffer.\n        // Calling abort() before appending a segment causes that segment to be\n        // incomplete in the buffer.\n        // Bug filed: https://bugs.webkit.org/show_bug.cgi?id=165342\n        shaka.polyfill.MediaSource.stubAbort_();\n\n        // If you remove up to a keyframe, Safari 11 & 12 incorrectly will also\n        // remove that keyframe and the content up to the next.\n        // Offsetting the end of the removal range seems to help.\n        // Bug filed: https://bugs.webkit.org/show_bug.cgi?id=177884\n        shaka.polyfill.MediaSource.patchRemovalRange_();\n      } else if (safariVersion <= 15) {\n        shaka.log.info('Patching Safari 13 & 14 & 15 MSE bugs.');\n        // Safari 13 does not correctly implement abort() on SourceBuffer.\n        // Calling abort() before appending a segment causes that segment to be\n        // incomplete in the buffer.\n        // Bug filed: https://bugs.webkit.org/show_bug.cgi?id=165342\n        shaka.polyfill.MediaSource.stubAbort_();\n      }\n    } else if (shaka.util.Platform.isEdge()) {\n      shaka.log.info('Rejecting TS container.');\n      // TS content is broken on Edge in general.\n      // See https://github.com/shaka-project/shaka-player/issues/4955\n      shaka.polyfill.MediaSource.rejectTsContent_();\n    } else if (shaka.util.Platform.isTizen2() ||\n        shaka.util.Platform.isTizen3() ||\n        shaka.util.Platform.isTizen4()) {\n      shaka.log.info('Rejecting Opus.');\n      // Tizen's implementation of MSE does not work well with opus. To prevent\n      // the player from trying to play opus on Tizen, we will override media\n      // source to always reject opus content.\n      shaka.polyfill.MediaSource.rejectCodec_('opus');\n    } else {\n      shaka.log.info('Using native MSE as-is.');\n    }\n\n    if (window.MediaSource &&\n        MediaSource.isTypeSupported('video/webm; codecs=\"vp9\"') &&\n        !MediaSource.isTypeSupported('video/webm; codecs=\"vp09.00.10.08\"')) {\n      shaka.log.info('Patching vp09 support queries.');\n      // Only the old, deprecated style of VP9 codec strings is supported.\n      // This occurs on older smart TVs.\n      // Patch isTypeSupported to translate the new strings into the old one.\n      shaka.polyfill.MediaSource.patchVp09_();\n    }\n  }\n\n  /**\n   * Stub out abort().  On some buggy MSE implementations, calling abort()\n   * causes various problems.\n   *\n   * @private\n   */\n  static stubAbort_() {\n    /* eslint-disable no-restricted-syntax */\n    const addSourceBuffer = MediaSource.prototype.addSourceBuffer;\n    MediaSource.prototype.addSourceBuffer = function(...varArgs) {\n      const sourceBuffer = addSourceBuffer.apply(this, varArgs);\n      sourceBuffer.abort = function() {}; // Stub out for buggy implementations.\n      return sourceBuffer;\n    };\n    /* eslint-enable no-restricted-syntax */\n  }\n\n  /**\n   * Patch remove().  On Safari 11, if you call remove() to remove the content\n   * up to a keyframe, Safari will also remove the keyframe and all of the data\n   * up to the next one. For example, if the keyframes are at 0s, 5s, and 10s,\n   * and you tried to remove 0s-5s, it would instead remove 0s-10s.\n   *\n   * Offsetting the end of the range seems to be a usable workaround.\n   *\n   * @private\n   */\n  static patchRemovalRange_() {\n    // eslint-disable-next-line no-restricted-syntax\n    const originalRemove = SourceBuffer.prototype.remove;\n\n    // eslint-disable-next-line no-restricted-syntax\n    SourceBuffer.prototype.remove = function(startTime, endTime) {\n      // eslint-disable-next-line no-restricted-syntax\n      return originalRemove.call(this, startTime, endTime - 0.001);\n    };\n  }\n\n  /**\n   * Patch isTypeSupported() to reject TS content.  Used to avoid TS-related MSE\n   * bugs on Safari.\n   *\n   * @private\n   */\n  static rejectTsContent_() {\n    const originalIsTypeSupported = MediaSource.isTypeSupported;\n\n    MediaSource.isTypeSupported = (mimeType) => {\n      // Parse the basic MIME type from its parameters.\n      const pieces = mimeType.split(/ *; */);\n      const basicMimeType = pieces[0];\n      const container = basicMimeType.split('/')[1];\n\n      if (container.toLowerCase() == 'mp2t') {\n        return false;\n      }\n\n      return originalIsTypeSupported(mimeType);\n    };\n  }\n\n  /**\n   * Patch |MediaSource.isTypeSupported| to always reject |codec|. This is used\n   * when we know that we are on a platform that does not work well with a given\n   * codec.\n   *\n   * @param {string} codec\n   * @private\n   */\n  static rejectCodec_(codec) {\n    const isTypeSupported = MediaSource.isTypeSupported;\n\n    MediaSource.isTypeSupported = (mimeType) => {\n      const actualCodec = shaka.util.MimeUtils.getCodecBase(mimeType);\n      return actualCodec != codec && isTypeSupported(mimeType);\n    };\n  }\n\n  /**\n   * Patch isTypeSupported() to chain to a private API on the Chromecast which\n   * can query for support of detailed content parameters.\n   *\n   * @private\n   */\n  static patchCastIsTypeSupported_() {\n    const originalIsTypeSupported = MediaSource.isTypeSupported;\n\n    MediaSource.isTypeSupported = (mimeType) => {\n      // Parse the basic MIME type from its parameters.\n      const pieces = mimeType.split(/ *; */);\n      pieces.shift();  // Remove basic MIME type from pieces.\n\n      const hasCodecs = pieces.some((piece) => piece.startsWith('codecs='));\n      if (!hasCodecs) {\n        // Though the original reason for this special case was not documented,\n        // it is presumed to be because the platform won't accept a MIME type\n        // without codecs in canDisplayType.  It is valid, however, in\n        // isTypeSupported.\n        return originalIsTypeSupported(mimeType);\n      }\n\n      // Only canDisplayType can check extended MIME type parameters on this\n      // platform (such as frame rate, resolution, etc).\n      // In previous versions of this polyfill, the MIME type parameters were\n      // manipulated, filtered, or extended.  This is no longer true, so we pass\n      // the full MIME type to the platform as we received it.\n      return cast.__platform__.canDisplayType(mimeType);\n    };\n  }\n\n  /**\n   * Patch isTypeSupported() to translate vp09 codec strings into vp9, to allow\n   * such content to play on older smart TVs.\n   *\n   * @private\n   */\n  static patchVp09_() {\n    const originalIsTypeSupported = MediaSource.isTypeSupported;\n\n    if (shaka.util.Platform.isWebOS()) {\n      // Don't do this on LG webOS as otherwise it is unable\n      // to play vp09 at all.\n      return;\n    }\n\n    MediaSource.isTypeSupported = (mimeType) => {\n      // Split the MIME type into its various parameters.\n      const pieces = mimeType.split(/ *; */);\n\n      const codecsIndex =\n          pieces.findIndex((piece) => piece.startsWith('codecs='));\n      if (codecsIndex < 0) {\n        // No codec? Call the original without modifying the MIME type.\n        return originalIsTypeSupported(mimeType);\n      }\n\n      const codecsParam = pieces[codecsIndex];\n      const codecs = codecsParam\n          .replace('codecs=', '').replace(/\"/g, '').split(/\\s*,\\s*/);\n\n      const vp09Index = codecs.findIndex(\n          (codecName) => codecName.startsWith('vp09'));\n      if (vp09Index >= 0) {\n        // vp09? Replace it with vp9.\n        codecs[vp09Index] = 'vp9';\n        pieces[codecsIndex] = 'codecs=\"' + codecs.join(',') + '\"';\n        mimeType = pieces.join('; ');\n      }\n\n      return originalIsTypeSupported(mimeType);\n    };\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.MediaSource.install);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.Orientation');\n\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill for systems that do not implement screen.orientation.\n * For now, this only handles systems that implement the deprecated\n * window.orientation feature... e.g. iPad.\n * @export\n */\nshaka.polyfill.Orientation = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (screen.orientation) {\n      // Not needed.\n      return;\n    }\n\n    // There is no way to check to see if the 'orientationchange' event exists\n    // on window, which could theoretically lead to this making a\n    // screen.orientation object that doesn't actually work.\n    // However, it looks like all platforms that support the deprecated\n    // window.orientation feature also support that event.\n    if (window.orientation != undefined) {\n      shaka.polyfill.Orientation.installBasedOnWindowMethods_();\n    }\n  }\n\n  /**\n   * Makes a polyfill for orientation, based on window methods.\n   * Note that some of the features this is based on are deprecated, so this\n   * will not necessarily work on all platforms.\n   * @private\n   */\n  static installBasedOnWindowMethods_() {\n    const orientation = new shaka.polyfill.Orientation.FakeOrientation();\n    screen.orientation = /** @type {!ScreenOrientation} */ (orientation);\n    const setValues = () => {\n      switch (window.orientation) {\n        case -90:\n          orientation.type = 'landscape-secondary';\n          orientation.angle = 270;\n          break;\n        case 0:\n          orientation.type = 'portrait-primary';\n          orientation.angle = 0;\n          break;\n        case 90:\n          orientation.type = 'landscape-primary';\n          orientation.angle = 90;\n          break;\n        case 180:\n          orientation.type = 'portrait-secondary';\n          orientation.angle = 180;\n          break;\n      }\n    };\n\n    setValues();\n    window.addEventListener('orientationchange', () => {\n      setValues();\n      orientation.dispatchChangeEvent();\n    });\n  }\n};\n\n\nshaka.polyfill.Orientation.FakeOrientation =\nclass extends shaka.util.FakeEventTarget {\n  /** */\n  constructor() {\n    super();\n\n    /** @type {string} */\n    this.type = '';\n\n    /** @type {number} */\n    this.angle = 0;\n  }\n\n  /** Dispatch a 'change' event. */\n  dispatchChangeEvent() {\n    const event = new shaka.util.FakeEvent('change');\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * @param {string} orientation\n   * @return {!Promise}\n   */\n  lock(orientation) {\n    /**\n     * @param {string} orientation\n     * @return {boolean}\n     */\n    const lockOrientation = (orientation) => {\n      if (screen.lockOrientation) {\n        return screen.lockOrientation(orientation);\n      }\n      if (screen.mozLockOrientation) {\n        return screen.mozLockOrientation(orientation);\n      }\n      if (screen.msLockOrientation) {\n        return screen.msLockOrientation(orientation);\n      }\n      return false;\n    };\n\n    let success = false;\n    // The set of input strings for screen.orientation.lock and for\n    // screen.lockOrientation are almost, but not entirely, the same.\n    switch (orientation) {\n      case 'natural':\n        success = lockOrientation('default');\n        break;\n      case 'any':\n        // It's not quite clear what locking the screen orientation to 'any'\n        // is supposed to mean... presumably, that's equivalent to not being\n        // locked?\n        success = true;\n        this.unlock();\n        break;\n      default:\n        success = lockOrientation(orientation);\n        break;\n    }\n    // According to the docs, there \"may be a delay\" between the\n    // lockOrientation method being called and the screen actually being\n    // locked.  Unfortunately, without any idea as to how long that delay is,\n    // and with no events to listen for, we cannot account for it here.\n    if (success) {\n      return Promise.resolve();\n    }\n    // Either locking was not available, or the process failed... either way,\n    // reject this with a mock error.\n    // This should be a DOMException, but there is not a public constructor for\n    // that.  So we make this look-alike instead.\n    const unsupportedKeySystemError =\n        new Error('screen.orientation.lock() is not available on this device');\n    unsupportedKeySystemError.name = 'NotSupportedError';\n    unsupportedKeySystemError['code'] = DOMException.NOT_SUPPORTED_ERR;\n    return Promise.reject(unsupportedKeySystemError);\n  }\n\n  /** Unlock the screen orientation. */\n  unlock() {\n    // screen.unlockOrientation has a return value, but\n    // screen.orientation.unlock does not. So ignore the return value.\n    if (screen.unlockOrientation) {\n      screen.unlockOrientation();\n    } else if (screen.mozUnlockOrientation) {\n      screen.mozUnlockOrientation();\n    } else if (screen.msUnlockOrientation) {\n      screen.msUnlockOrientation();\n    }\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.Orientation.install);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysApple');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.MediaReadyState');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @summary A polyfill to implement modern, standardized EME on top of Apple's\n * prefixed EME in Safari.\n * @export\n */\nshaka.polyfill.PatchedMediaKeysApple = class {\n  /**\n   * Installs the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (!window.HTMLVideoElement || !window.WebKitMediaKeys) {\n      // No HTML5 video or no prefixed EME.\n      return;\n    }\n\n    /* Unprefixed EME disabled.  See:\n       https://github.com/google/shaka-player/pull/3021#issuecomment-766999811\n\n    // Only tested in Safari 14.\n    const safariVersion = shaka.util.Platform.safariVersion();\n    if (navigator.requestMediaKeySystemAccess &&\n        // eslint-disable-next-line no-restricted-syntax\n        MediaKeySystemAccess.prototype.getConfiguration &&\n        safariVersion && safariVersion >= 14) {\n      // Unprefixed EME is preferable.\n      return;\n    }\n    */\n\n    shaka.log.info('Using Apple-prefixed EME');\n\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    // Delete mediaKeys to work around strict mode compatibility issues.\n    // eslint-disable-next-line no-restricted-syntax\n    delete HTMLMediaElement.prototype['mediaKeys'];\n    // Work around read-only declaration for mediaKeys by using a string.\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype['mediaKeys'] = null;\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype.setMediaKeys =\n        PatchedMediaKeysApple.setMediaKeys;\n\n    // Install patches\n    window.MediaKeys = PatchedMediaKeysApple.MediaKeys;\n    window.MediaKeySystemAccess = PatchedMediaKeysApple.MediaKeySystemAccess;\n    navigator.requestMediaKeySystemAccess =\n        PatchedMediaKeysApple.requestMediaKeySystemAccess;\n  }\n\n  /**\n   * An implementation of navigator.requestMediaKeySystemAccess.\n   * Retrieves a MediaKeySystemAccess object.\n   *\n   * @this {!Navigator}\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   * @return {!Promise.<!MediaKeySystemAccess>}\n   */\n  static requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysApple.requestMediaKeySystemAccess');\n    goog.asserts.assert(this == navigator,\n        'bad \"this\" for requestMediaKeySystemAccess');\n\n    // Alias.\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n    try {\n      const access = new PatchedMediaKeysApple.MediaKeySystemAccess(\n          keySystem, supportedConfigurations);\n      return Promise.resolve(/** @type {!MediaKeySystemAccess} */ (access));\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n  }\n\n  /**\n   * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n   * Attaches a MediaKeys object to the media element.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {MediaKeys} mediaKeys\n   * @return {!Promise}\n   */\n  static setMediaKeys(mediaKeys) {\n    shaka.log.debug('PatchedMediaKeysApple.setMediaKeys');\n    goog.asserts.assert(this instanceof HTMLMediaElement,\n        'bad \"this\" for setMediaKeys');\n\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    const newMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysApple.MediaKeys} */ (\n        mediaKeys);\n    const oldMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysApple.MediaKeys} */ (\n        this.mediaKeys);\n\n    if (oldMediaKeys && oldMediaKeys != newMediaKeys) {\n      goog.asserts.assert(\n          oldMediaKeys instanceof PatchedMediaKeysApple.MediaKeys,\n          'non-polyfill instance of oldMediaKeys');\n      // Have the old MediaKeys stop listening to events on the video tag.\n      oldMediaKeys.setMedia(null);\n    }\n\n    delete this['mediaKeys'];  // in case there is an existing getter\n    this['mediaKeys'] = mediaKeys;  // work around read-only declaration\n\n    if (newMediaKeys) {\n      goog.asserts.assert(\n          newMediaKeys instanceof PatchedMediaKeysApple.MediaKeys,\n          'non-polyfill instance of newMediaKeys');\n      return newMediaKeys.setMedia(this);\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Handler for the native media elements webkitneedkey event.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {!MediaKeyEvent} event\n   * @suppress {constantProperty} We reassign what would be const on a real\n   *   MediaEncryptedEvent, but in our look-alike event.\n   * @private\n   */\n  static onWebkitNeedKey_(event) {\n    shaka.log.debug('PatchedMediaKeysApple.onWebkitNeedKey_', event);\n\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n    const mediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysApple.MediaKeys} */(\n        this.mediaKeys);\n    goog.asserts.assert(mediaKeys instanceof PatchedMediaKeysApple.MediaKeys,\n        'non-polyfill instance of newMediaKeys');\n\n    goog.asserts.assert(event.initData != null, 'missing init data!');\n\n    // Convert the prefixed init data to match the native 'encrypted' event.\n    const uint8 = shaka.util.BufferUtils.toUint8(event.initData);\n    const dataview = shaka.util.BufferUtils.toDataView(uint8);\n    // The first part is a 4 byte little-endian int, which is the length of\n    // the second part.\n    const length = dataview.getUint32(\n        /* position= */ 0, /* littleEndian= */ true);\n    if (length + 4 != uint8.byteLength) {\n      throw new RangeError('Malformed FairPlay init data');\n    }\n    // The remainder is a UTF-16 skd URL.  Convert this to UTF-8 and pass on.\n    const str = shaka.util.StringUtils.fromUTF16(\n        uint8.subarray(4), /* littleEndian= */ true);\n    const initData = shaka.util.StringUtils.toUTF8(str);\n\n    // NOTE: Because \"this\" is a real EventTarget, the event we dispatch here\n    // must also be a real Event.\n    const event2 = new Event('encrypted');\n\n    const encryptedEvent =\n      /** @type {!MediaEncryptedEvent} */(/** @type {?} */(event2));\n    encryptedEvent.initDataType = 'skd';\n    encryptedEvent.initData = shaka.util.BufferUtils.toArrayBuffer(initData);\n\n    this.dispatchEvent(event2);\n  }\n};\n\n\n/**\n * An implementation of MediaKeySystemAccess.\n *\n * @implements {MediaKeySystemAccess}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySystemAccess = class {\n  /**\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   */\n  constructor(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySystemAccess');\n\n    /** @type {string} */\n    this.keySystem = keySystem;\n\n    /** @private {!MediaKeySystemConfiguration} */\n    this.configuration_;\n\n    // Optimization: WebKitMediaKeys.isTypeSupported delays responses by a\n    // significant amount of time, possibly to discourage fingerprinting.\n    // Since we know only FairPlay is supported here, let's skip queries for\n    // anything else to speed up the process.\n    if (keySystem.startsWith('com.apple.fps')) {\n      for (const cfg of supportedConfigurations) {\n        const newCfg = this.checkConfig_(cfg);\n        if (newCfg) {\n          this.configuration_ = newCfg;\n          return;\n        }\n      }\n    }\n\n    // According to the spec, this should be a DOMException, but there is not a\n    // public constructor for that.  So we make this look-alike instead.\n    const unsupportedKeySystemError = new Error('Unsupported keySystem');\n    unsupportedKeySystemError.name = 'NotSupportedError';\n    unsupportedKeySystemError['code'] = DOMException.NOT_SUPPORTED_ERR;\n    throw unsupportedKeySystemError;\n  }\n\n  /**\n   * Check a single config for MediaKeySystemAccess.\n   *\n   * @param {MediaKeySystemConfiguration} cfg The requested config.\n   * @return {?MediaKeySystemConfiguration} A matching config we can support, or\n   *   null if the input is not supportable.\n   * @private\n   */\n  checkConfig_(cfg) {\n    if (cfg.persistentState == 'required') {\n      // Not supported by the prefixed API.\n      return null;\n    }\n\n    // Create a new config object and start adding in the pieces which we find\n    // support for.  We will return this from getConfiguration() later if\n    // asked.\n\n    /** @type {!MediaKeySystemConfiguration} */\n    const newCfg = {\n      'audioCapabilities': [],\n      'videoCapabilities': [],\n      // It is technically against spec to return these as optional, but we\n      // don't truly know their values from the prefixed API:\n      'persistentState': 'optional',\n      'distinctiveIdentifier': 'optional',\n      // Pretend the requested init data types are supported, since we don't\n      // really know that either:\n      'initDataTypes': cfg.initDataTypes,\n      'sessionTypes': ['temporary'],\n      'label': cfg.label,\n    };\n\n    // PatchedMediaKeysApple tests for key system availability through\n    // WebKitMediaKeys.isTypeSupported.\n    let ranAnyTests = false;\n    let success = false;\n\n    if (cfg.audioCapabilities) {\n      for (const cap of cfg.audioCapabilities) {\n        if (cap.contentType) {\n          ranAnyTests = true;\n\n          const contentType = cap.contentType.split(';')[0];\n          if (WebKitMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n            newCfg.audioCapabilities.push(cap);\n            success = true;\n          }\n        }\n      }\n    }\n\n    if (cfg.videoCapabilities) {\n      for (const cap of cfg.videoCapabilities) {\n        if (cap.contentType) {\n          ranAnyTests = true;\n\n          const contentType = cap.contentType.split(';')[0];\n          if (WebKitMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n            newCfg.videoCapabilities.push(cap);\n            success = true;\n          }\n        }\n      }\n    }\n\n    if (!ranAnyTests) {\n      // If no specific types were requested, we check all common types to\n      // find out if the key system is present at all.\n      success = WebKitMediaKeys.isTypeSupported(this.keySystem, 'video/mp4');\n    }\n\n    if (success) {\n      return newCfg;\n    }\n    return null;\n  }\n\n  /** @override */\n  createMediaKeys() {\n    shaka.log.debug(\n        'PatchedMediaKeysApple.MediaKeySystemAccess.createMediaKeys');\n\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    const mediaKeys = new PatchedMediaKeysApple.MediaKeys(this.keySystem);\n    return Promise.resolve(/** @type {!MediaKeys} */ (mediaKeys));\n  }\n\n  /** @override */\n  getConfiguration() {\n    shaka.log.debug(\n        'PatchedMediaKeysApple.MediaKeySystemAccess.getConfiguration');\n    return this.configuration_;\n  }\n};\n\n\n/**\n * An implementation of MediaKeys.\n *\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeys = class {\n  /** @param {string} keySystem */\n  constructor(keySystem) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeys');\n\n    /** @private {!WebKitMediaKeys} */\n    this.nativeMediaKeys_ = new WebKitMediaKeys(keySystem);\n\n    /** @private {!shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n  }\n\n  /** @override */\n  createSession(sessionType) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeys.createSession');\n\n    sessionType = sessionType || 'temporary';\n    // For now, only the 'temporary' type is supported.\n    if (sessionType != 'temporary') {\n      throw new TypeError('Session type ' + sessionType +\n      ' is unsupported on this platform.');\n    }\n\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    return new PatchedMediaKeysApple.MediaKeySession(\n        this.nativeMediaKeys_, sessionType);\n  }\n\n  /** @override */\n  setServerCertificate(serverCertificate) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeys.setServerCertificate');\n    return Promise.resolve(false);\n  }\n\n  /**\n   * @param {HTMLMediaElement} media\n   * @protected\n   * @return {!Promise}\n   */\n  setMedia(media) {\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    // Remove any old listeners.\n    this.eventManager_.removeAll();\n\n    // It is valid for media to be null; null is used to flag that event\n    // handlers need to be cleaned up.\n    if (!media) {\n      return Promise.resolve();\n    }\n\n    // Intercept and translate these prefixed EME events.\n    this.eventManager_.listen(media, 'webkitneedkey',\n    /** @type {shaka.util.EventManager.ListenerType} */\n        (PatchedMediaKeysApple.onWebkitNeedKey_));\n\n    // Wrap native HTMLMediaElement.webkitSetMediaKeys with a Promise.\n    try {\n      // Some browsers require that readyState >=1 before mediaKeys can be\n      // set, so check this and wait for loadedmetadata if we are not in the\n      // correct state\n      shaka.util.MediaReadyState.waitForReadyState(media,\n          HTMLMediaElement.HAVE_METADATA,\n          this.eventManager_, () => {\n            media.webkitSetMediaKeys(this.nativeMediaKeys_);\n          });\n\n      return Promise.resolve();\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n  }\n};\n\n\n/**\n * An implementation of MediaKeySession.\n *\n * @implements {MediaKeySession}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySession =\nclass extends shaka.util.FakeEventTarget {\n  /**\n   * @param {WebKitMediaKeys} nativeMediaKeys\n   * @param {string} sessionType\n   */\n  constructor(nativeMediaKeys, sessionType) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySession');\n    super();\n\n    /**\n     * The native MediaKeySession, which will be created in generateRequest.\n     * @private {WebKitMediaKeySession}\n     */\n    this.nativeMediaKeySession_ = null;\n\n    /** @private {WebKitMediaKeys} */\n    this.nativeMediaKeys_ = nativeMediaKeys;\n\n    // Promises that are resolved later\n    /** @private {shaka.util.PublicPromise} */\n    this.generateRequestPromise_ = null;\n\n    /** @private {shaka.util.PublicPromise} */\n    this.updatePromise_ = null;\n\n    /** @private {!shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @type {string} */\n    this.sessionId = '';\n\n    /** @type {number} */\n    this.expiration = NaN;\n\n    /** @type {!shaka.util.PublicPromise} */\n    this.closed = new shaka.util.PublicPromise();\n\n    /** @type {!shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap} */\n    this.keyStatuses =\n        new shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap();\n  }\n\n  /** @override */\n  generateRequest(initDataType, initData) {\n    shaka.log.debug(\n        'PatchedMediaKeysApple.MediaKeySession.generateRequest');\n\n    this.generateRequestPromise_ = new shaka.util.PublicPromise();\n\n    try {\n      // This EME spec version requires a MIME content type as the 1st param to\n      // createSession, but doesn't seem to matter what the value is.\n      // It also only accepts Uint8Array, not ArrayBuffer, so explicitly make\n      // initData into a Uint8Array.\n      const session = this.nativeMediaKeys_.createSession(\n          'video/mp4', shaka.util.BufferUtils.toUint8(initData));\n      this.nativeMediaKeySession_ = session;\n      this.sessionId = session.sessionId || '';\n\n      // Attach session event handlers here.\n      this.eventManager_.listen(\n          this.nativeMediaKeySession_, 'webkitkeymessage',\n          /** @type {shaka.util.EventManager.ListenerType} */\n          ((event) => this.onWebkitKeyMessage_(event)));\n      this.eventManager_.listen(session, 'webkitkeyadded',\n          /** @type {shaka.util.EventManager.ListenerType} */\n          ((event) => this.onWebkitKeyAdded_(event)));\n      this.eventManager_.listen(session, 'webkitkeyerror',\n          /** @type {shaka.util.EventManager.ListenerType} */\n          ((event) => this.onWebkitKeyError_(event)));\n\n      this.updateKeyStatus_('status-pending');\n    } catch (exception) {\n      this.generateRequestPromise_.reject(exception);\n    }\n\n    return this.generateRequestPromise_;\n  }\n\n  /** @override */\n  load() {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.load');\n\n    return Promise.reject(new Error('MediaKeySession.load not yet supported'));\n  }\n\n  /** @override */\n  update(response) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.update');\n\n    this.updatePromise_ = new shaka.util.PublicPromise();\n\n    try {\n      // Pass through to the native session.\n      this.nativeMediaKeySession_.update(\n          shaka.util.BufferUtils.toUint8(response));\n    } catch (exception) {\n      this.updatePromise_.reject(exception);\n    }\n\n    return this.updatePromise_;\n  }\n\n  /** @override */\n  close() {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.close');\n\n    try {\n      // Pass through to the native session.\n      this.nativeMediaKeySession_.close();\n\n      this.closed.resolve();\n      this.eventManager_.removeAll();\n    } catch (exception) {\n      this.closed.reject(exception);\n    }\n\n    return this.closed;\n  }\n\n  /** @override */\n  remove() {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.remove');\n\n    return Promise.reject(new Error(\n        'MediaKeySession.remove is only applicable for persistent licenses, ' +\n        'which are not supported on this platform'));\n  }\n\n  /**\n   * Handler for the native keymessage event on WebKitMediaKeySession.\n   *\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyMessage_(event) {\n    shaka.log.debug('PatchedMediaKeysApple.onWebkitKeyMessage_', event);\n\n    // We can now resolve this.generateRequestPromise, which should be non-null.\n    goog.asserts.assert(this.generateRequestPromise_,\n        'generateRequestPromise_ should be set before now!');\n    if (this.generateRequestPromise_) {\n      this.generateRequestPromise_.resolve();\n      this.generateRequestPromise_ = null;\n    }\n\n    const isNew = this.keyStatuses.getStatus() == undefined;\n\n    const data = new Map()\n        .set('messageType', isNew ? 'license-request' : 'license-renewal')\n        .set('message', shaka.util.BufferUtils.toArrayBuffer(event.message));\n    const event2 = new shaka.util.FakeEvent('message', data);\n\n    this.dispatchEvent(event2);\n  }\n\n  /**\n   * Handler for the native keyadded event on WebKitMediaKeySession.\n   *\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyAdded_(event) {\n    shaka.log.debug('PatchedMediaKeysApple.onWebkitKeyAdded_', event);\n\n    // This shouldn't fire while we're in the middle of generateRequest,\n    // but if it does, we will need to change the logic to account for it.\n    goog.asserts.assert(!this.generateRequestPromise_,\n        'Key added during generate!');\n\n    // We can now resolve this.updatePromise, which should be non-null.\n    goog.asserts.assert(this.updatePromise_,\n        'updatePromise_ should be set before now!');\n    if (this.updatePromise_) {\n      this.updateKeyStatus_('usable');\n      this.updatePromise_.resolve();\n      this.updatePromise_ = null;\n    }\n  }\n\n  /**\n   * Handler for the native keyerror event on WebKitMediaKeySession.\n   *\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyError_(event) {\n    shaka.log.debug('PatchedMediaKeysApple.onWebkitKeyError_', event);\n\n    const error = new Error('EME PatchedMediaKeysApple key error');\n    error['errorCode'] = this.nativeMediaKeySession_.error;\n\n    if (this.generateRequestPromise_ != null) {\n      this.generateRequestPromise_.reject(error);\n      this.generateRequestPromise_ = null;\n    } else if (this.updatePromise_ != null) {\n      this.updatePromise_.reject(error);\n      this.updatePromise_ = null;\n    } else {\n      // Unexpected error - map native codes to standardised key statuses.\n      // Possible values of this.nativeMediaKeySession_.error.code:\n      // MEDIA_KEYERR_UNKNOWN        = 1\n      // MEDIA_KEYERR_CLIENT         = 2\n      // MEDIA_KEYERR_SERVICE        = 3\n      // MEDIA_KEYERR_OUTPUT         = 4\n      // MEDIA_KEYERR_HARDWARECHANGE = 5\n      // MEDIA_KEYERR_DOMAIN         = 6\n\n      switch (this.nativeMediaKeySession_.error.code) {\n        case WebKitMediaKeyError.MEDIA_KEYERR_OUTPUT:\n        case WebKitMediaKeyError.MEDIA_KEYERR_HARDWARECHANGE:\n          this.updateKeyStatus_('output-not-allowed');\n          break;\n        default:\n          this.updateKeyStatus_('internal-error');\n          break;\n      }\n    }\n  }\n\n  /**\n   * Updates key status and dispatch a 'keystatuseschange' event.\n   *\n   * @param {string} status\n   * @private\n   */\n  updateKeyStatus_(status) {\n    this.keyStatuses.setStatus(status);\n    const event = new shaka.util.FakeEvent('keystatuseschange');\n    this.dispatchEvent(event);\n  }\n};\n\n\n/**\n * @summary An implementation of MediaKeyStatusMap.\n * This fakes a map with a single key ID.\n *\n * @todo Consolidate the MediaKeyStatusMap types in these polyfills.\n * @implements {MediaKeyStatusMap}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap = class {\n  /** */\n  constructor() {\n    /**\n     * @type {number}\n     */\n    this.size = 0;\n\n    /**\n     * @private {string|undefined}\n     */\n    this.status_ = undefined;\n  }\n\n  /**\n   * An internal method used by the session to set key status.\n   * @param {string|undefined} status\n   */\n  setStatus(status) {\n    this.size = status == undefined ? 0 : 1;\n    this.status_ = status;\n  }\n\n  /**\n   * An internal method used by the session to get key status.\n   * @return {string|undefined}\n   */\n  getStatus() {\n    return this.status_;\n  }\n\n  /** @override */\n  forEach(fn) {\n    if (this.status_) {\n      fn(this.status_, shaka.media.DrmEngine.DUMMY_KEY_ID.value());\n    }\n  }\n\n  /** @override */\n  get(keyId) {\n    if (this.has(keyId)) {\n      return this.status_;\n    }\n    return undefined;\n  }\n\n  /** @override */\n  has(keyId) {\n    const fakeKeyId = shaka.media.DrmEngine.DUMMY_KEY_ID.value();\n    if (this.status_ && shaka.util.BufferUtils.equal(keyId, fakeKeyId)) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  entries() {\n    goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  keys() {\n    goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  values() {\n    goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.PatchedMediaKeysApple.install);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysMs');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.MediaReadyState');\ngoog.require('shaka.util.Pssh');\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * @summary A polyfill to implement\n * {@link https://bit.ly/EmeMar15 EME draft 12 March 2015}\n * on top of ms-prefixed\n * {@link https://www.w3.org/TR/2014/WD-encrypted-media-20140218/ EME v20140218}\n * @export\n */\nshaka.polyfill.PatchedMediaKeysMs = class {\n  /**\n   * Installs the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (!window.HTMLVideoElement || !window.MSMediaKeys ||\n        (navigator.requestMediaKeySystemAccess &&\n         // eslint-disable-next-line no-restricted-syntax\n         MediaKeySystemAccess.prototype.getConfiguration)) {\n      return;\n    }\n    shaka.log.info('Using ms-prefixed EME v20140218');\n\n    // Alias\n    const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n    // Delete mediaKeys to work around strict mode compatibility issues.\n    // eslint-disable-next-line no-restricted-syntax\n    delete HTMLMediaElement.prototype['mediaKeys'];\n    // Work around read-only declaration for mediaKeys by using a string.\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype['mediaKeys'] = null;\n\n    // Install patches\n    window.MediaKeys = PatchedMediaKeysMs.MediaKeys;\n    window.MediaKeySystemAccess = PatchedMediaKeysMs.MediaKeySystemAccess;\n    navigator.requestMediaKeySystemAccess =\n        PatchedMediaKeysMs.requestMediaKeySystemAccess;\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype.setMediaKeys =\n        PatchedMediaKeysMs.MediaKeySystemAccess.setMediaKeys;\n  }\n\n  /**\n   * An implementation of navigator.requestMediaKeySystemAccess.\n   * Retrieves a MediaKeySystemAccess object.\n   *\n   * @this {!Navigator}\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   * @return {!Promise.<!MediaKeySystemAccess>}\n   */\n  static requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysMs.requestMediaKeySystemAccess');\n    goog.asserts.assert(this == navigator,\n        'bad \"this\" for requestMediaKeySystemAccess');\n\n    // Alias.\n    const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n    try {\n      const access = new PatchedMediaKeysMs.MediaKeySystemAccess(\n          keySystem, supportedConfigurations);\n      return Promise.resolve(/** @type {!MediaKeySystemAccess} */ (access));\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n  }\n\n  /**\n   * Handler for the native media elements msNeedKey event.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {!MediaKeyEvent} event\n   * @suppress {constantProperty} We reassign what would be const on a real\n   *   MediaEncryptedEvent, but in our look-alike event.\n   * @private\n   */\n  static onMsNeedKey_(event) {\n    shaka.log.debug('PatchedMediaKeysMs.onMsNeedKey_', event);\n    if (!event.initData) {\n      return;\n    }\n\n    const event2 = new CustomEvent('encrypted');\n    const encryptedEvent =\n      /** @type {!MediaEncryptedEvent} */(/** @type {?} */(event2));\n    encryptedEvent.initDataType = 'cenc';\n    encryptedEvent.initData = shaka.util.BufferUtils.toArrayBuffer(\n        shaka.util.Pssh.normaliseInitData(event.initData));\n\n    this.dispatchEvent(event2);\n  }\n};\n\n\n/**\n * An implementation of MediaKeySystemAccess.\n *\n * @implements {MediaKeySystemAccess}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySystemAccess = class {\n  /**\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   */\n  constructor(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeySystemAccess');\n\n    /** @type {string} */\n    this.keySystem = keySystem;\n\n    /** @private {!MediaKeySystemConfiguration} */\n    this.configuration_;\n\n    const allowPersistentState = false;\n\n    let success = false;\n    for (const cfg of supportedConfigurations) {\n      // Create a new config object and start adding in the pieces which we\n      // find support for.  We will return this from getConfiguration() if\n      // asked.\n      /** @type {!MediaKeySystemConfiguration} */\n      const newCfg = {\n        'audioCapabilities': [],\n        'videoCapabilities': [],\n        // It is technically against spec to return these as optional, but we\n        // don't truly know their values from the prefixed API:\n        'persistentState': 'optional',\n        'distinctiveIdentifier': 'optional',\n        // Pretend the requested init data types are supported, since we don't\n        // really know that either:\n        'initDataTypes': cfg.initDataTypes,\n        'sessionTypes': ['temporary'],\n        'label': cfg.label,\n      };\n\n      // PatchedMediaKeysMs tests for key system availability through\n      // MSMediaKeys.isTypeSupported\n      let ranAnyTests = false;\n      if (cfg.audioCapabilities) {\n        for (const cap of cfg.audioCapabilities) {\n          if (cap.contentType) {\n            ranAnyTests = true;\n            const contentType = cap.contentType.split(';')[0];\n            if (MSMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n              newCfg.audioCapabilities.push(cap);\n              success = true;\n            }\n          }\n        }\n      }\n      if (cfg.videoCapabilities) {\n        for (const cap of cfg.videoCapabilities) {\n          if (cap.contentType) {\n            ranAnyTests = true;\n            const contentType = cap.contentType.split(';')[0];\n            if (MSMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n              newCfg.videoCapabilities.push(cap);\n              success = true;\n            }\n          }\n        }\n      }\n\n      if (!ranAnyTests) {\n        // If no specific types were requested, we check all common types to\n        // find out if the key system is present at all.\n        success = MSMediaKeys.isTypeSupported(this.keySystem, 'video/mp4');\n      }\n      if (cfg.persistentState == 'required') {\n        if (allowPersistentState) {\n          newCfg.persistentState = 'required';\n          newCfg.sessionTypes = ['persistent-license'];\n        } else {\n          success = false;\n        }\n      }\n\n      if (success) {\n        this.configuration_ = newCfg;\n        return;\n      }\n    }  // for each cfg in supportedConfigurations\n\n    // According to the spec, this should be a DOMException, but there is not a\n    // public constructor for that.  So we make this look-alike instead.\n    const unsupportedKeySystemError = new Error('Unsupported keySystem');\n    unsupportedKeySystemError.name = 'NotSupportedError';\n    unsupportedKeySystemError['code'] = DOMException.NOT_SUPPORTED_ERR;\n    throw unsupportedKeySystemError;\n  }\n\n  /** @override */\n  createMediaKeys() {\n    shaka.log.debug(\n        'PatchedMediaKeysMs.MediaKeySystemAccess.createMediaKeys');\n\n    // Alias\n    const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n    const mediaKeys = new PatchedMediaKeysMs.MediaKeys(this.keySystem);\n    return Promise.resolve(/** @type {!MediaKeys} */ (mediaKeys));\n  }\n\n  /** @override */\n  getConfiguration() {\n    shaka.log.debug(\n        'PatchedMediaKeysMs.MediaKeySystemAccess.getConfiguration');\n    return this.configuration_;\n  }\n\n  /**\n   * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n   * Attaches a MediaKeys object to the media element.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {MediaKeys} mediaKeys\n   * @return {!Promise}\n   */\n  static setMediaKeys(mediaKeys) {\n    shaka.log.debug('PatchedMediaKeysMs.setMediaKeys');\n    goog.asserts.assert(this instanceof HTMLMediaElement,\n        'bad \"this\" for setMediaKeys');\n\n    // Alias\n    const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n    const newMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysMs.MediaKeys} */ (\n        mediaKeys);\n    const oldMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysMs.MediaKeys} */ (\n        this.mediaKeys);\n\n    if (oldMediaKeys && oldMediaKeys != newMediaKeys) {\n      goog.asserts.assert(oldMediaKeys instanceof PatchedMediaKeysMs.MediaKeys,\n          'non-polyfill instance of oldMediaKeys');\n      // Have the old MediaKeys stop listening to events on the video tag.\n      oldMediaKeys.setMedia(null);\n    }\n\n    delete this['mediaKeys'];  // in case there is an existing getter\n    this['mediaKeys'] = mediaKeys;  // work around read-only declaration\n\n    if (newMediaKeys) {\n      goog.asserts.assert(newMediaKeys instanceof PatchedMediaKeysMs.MediaKeys,\n          'non-polyfill instance of newMediaKeys');\n      return newMediaKeys.setMedia(this);\n    }\n\n    return Promise.resolve();\n  }\n};\n\n\n/**\n * An implementation of MediaKeys.\n *\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeys = class {\n  /** @param {string} keySystem */\n  constructor(keySystem) {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeys');\n\n    /** @private {!MSMediaKeys} */\n    this.nativeMediaKeys_ = new MSMediaKeys(keySystem);\n\n    /** @private {!shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n  }\n\n  /** @override */\n  createSession(sessionType) {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeys.createSession');\n\n    sessionType = sessionType || 'temporary';\n    // For now, only the 'temporary' type is supported.\n    if (sessionType != 'temporary') {\n      throw new TypeError('Session type ' + sessionType +\n      ' is unsupported on this platform.');\n    }\n\n    // Alias\n    const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n    return new PatchedMediaKeysMs.MediaKeySession(\n        this.nativeMediaKeys_, sessionType);\n  }\n\n  /** @override */\n  setServerCertificate(serverCertificate) {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeys.setServerCertificate');\n\n    // There is no equivalent in PatchedMediaKeysMs, so return failure.\n    return Promise.resolve(false);\n  }\n\n  /**\n   * @param {HTMLMediaElement} media\n   * @protected\n   * @return {!Promise}\n   */\n  setMedia(media) {\n    // Alias\n    const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n    // Remove any old listeners.\n    this.eventManager_.removeAll();\n\n    // It is valid for media to be null; null is used to flag that event\n    // handlers need to be cleaned up.\n    if (!media) {\n      return Promise.resolve();\n    }\n\n    // Intercept and translate these prefixed EME events.\n    this.eventManager_.listen(media, 'msneedkey',\n    /** @type {shaka.util.EventManager.ListenerType} */\n        (PatchedMediaKeysMs.onMsNeedKey_));\n\n    // Wrap native HTMLMediaElement.msSetMediaKeys with a Promise.\n    try {\n      // Edge requires that readyState >=1 before mediaKeys can be set,\n      // so check this and wait for loadedmetadata if we are not in the\n      // correct state\n      shaka.util.MediaReadyState.waitForReadyState(media,\n          HTMLMediaElement.HAVE_METADATA,\n          this.eventManager_, () => {\n            media.msSetMediaKeys(this.nativeMediaKeys_);\n          });\n\n      return Promise.resolve();\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n  }\n};\n\n\n/**\n * An implementation of MediaKeySession.\n *\n * @implements {MediaKeySession}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession =\nclass extends shaka.util.FakeEventTarget {\n  /**\n   * @param {MSMediaKeys} nativeMediaKeys\n   * @param {string} sessionType\n   */\n  constructor(nativeMediaKeys, sessionType) {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeySession');\n    super();\n\n    /**\n     * The native MediaKeySession, which will be created in generateRequest.\n     * @private {MSMediaKeySession}\n     */\n    this.nativeMediaKeySession_ = null;\n\n    /** @private {MSMediaKeys} */\n    this.nativeMediaKeys_ = nativeMediaKeys;\n\n    // Promises that are resolved later\n    /** @private {shaka.util.PublicPromise} */\n    this.generateRequestPromise_ = null;\n\n    /** @private {shaka.util.PublicPromise} */\n    this.updatePromise_ = null;\n\n    /** @private {!shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @type {string} */\n    this.sessionId = '';\n\n    /** @type {number} */\n    this.expiration = NaN;\n\n    /** @type {!shaka.util.PublicPromise} */\n    this.closed = new shaka.util.PublicPromise();\n\n    /** @type {!shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap} */\n    this.keyStatuses =\n        new shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap();\n  }\n\n  /** @override */\n  generateRequest(initDataType, initData) {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.generateRequest');\n\n    this.generateRequestPromise_ = new shaka.util.PublicPromise();\n\n    try {\n      // This EME spec version requires a MIME content type as the 1st param to\n      // createSession, but doesn't seem to matter what the value is.\n\n      // NOTE: Edge 12 only accepts Uint8Array.\n      this.nativeMediaKeySession_ = this.nativeMediaKeys_.createSession(\n          'video/mp4', shaka.util.BufferUtils.toUint8(initData), null);\n\n      // Attach session event handlers here.\n      this.eventManager_.listen(this.nativeMediaKeySession_, 'mskeymessage',\n      /** @type {shaka.util.EventManager.ListenerType} */\n          ((event) => this.onMsKeyMessage_(event)));\n      this.eventManager_.listen(this.nativeMediaKeySession_, 'mskeyadded',\n      /** @type {shaka.util.EventManager.ListenerType} */\n          ((event) => this.onMsKeyAdded_(event)));\n      this.eventManager_.listen(this.nativeMediaKeySession_, 'mskeyerror',\n      /** @type {shaka.util.EventManager.ListenerType} */\n          ((event) => this.onMsKeyError_(event)));\n\n      this.updateKeyStatus_('status-pending');\n    } catch (exception) {\n      this.generateRequestPromise_.reject(exception);\n    }\n\n    return this.generateRequestPromise_;\n  }\n\n  /** @override */\n  load() {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.load');\n\n    return Promise.reject(new Error('MediaKeySession.load not yet supported'));\n  }\n\n  /** @override */\n  update(response) {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.update');\n\n    this.updatePromise_ = new shaka.util.PublicPromise();\n\n    try {\n      // Pass through to the native session.\n      // NOTE: Edge 12 only accepts Uint8Array.\n      this.nativeMediaKeySession_.update(\n          shaka.util.BufferUtils.toUint8(response));\n    } catch (exception) {\n      this.updatePromise_.reject(exception);\n    }\n\n    return this.updatePromise_;\n  }\n\n  /** @override */\n  close() {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.close');\n\n    try {\n      // Pass through to the native session.\n      // NOTE: IE seems to have a spec discrepancy here - v2010218 should have\n      // MediaKeySession.release, but actually uses \"close\". The next version of\n      // the spec is the initial Promise based one, so it's not the target spec\n      // either.\n      this.nativeMediaKeySession_.close();\n\n      this.closed.resolve();\n      this.eventManager_.removeAll();\n    } catch (exception) {\n      this.closed.reject(exception);\n    }\n\n    return this.closed;\n  }\n\n  /** @override */\n  remove() {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.remove');\n\n    return Promise.reject(new Error(\n        'MediaKeySession.remove is only applicable for persistent licenses, ' +\n        'which are not supported on this platform'));\n  }\n\n  /**\n   * Handler for the native keymessage event on MSMediaKeySession.\n   *\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onMsKeyMessage_(event) {\n    shaka.log.debug('PatchedMediaKeysMs.onMsKeyMessage_', event);\n\n    // We can now resolve this.generateRequestPromise, which should be non-null.\n    goog.asserts.assert(this.generateRequestPromise_,\n        'generateRequestPromise_ not set in onMsKeyMessage_');\n    if (this.generateRequestPromise_) {\n      this.generateRequestPromise_.resolve();\n      this.generateRequestPromise_ = null;\n    }\n\n    const isNew = this.keyStatuses.getStatus() == undefined;\n\n    const data = new Map()\n        .set('messageType', isNew ? 'license-request' : 'license-renewal')\n        .set('message', shaka.util.BufferUtils.toArrayBuffer(event.message));\n    const event2 = new shaka.util.FakeEvent('message', data);\n\n    this.dispatchEvent(event2);\n  }\n\n  /**\n   * Handler for the native keyadded event on MSMediaKeySession.\n   *\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onMsKeyAdded_(event) {\n    shaka.log.debug('PatchedMediaKeysMs.onMsKeyAdded_', event);\n\n    // PlayReady's concept of persistent licenses makes emulation difficult\n    // here. A license policy can say that the license persists, which causes\n    // the CDM to store it for use in a later session.  The result is that in\n    // IE11, the CDM fires 'mskeyadded' without ever firing 'mskeymessage'.\n    if (this.generateRequestPromise_) {\n      shaka.log.debug('Simulating completion for a PR persistent license.');\n      goog.asserts.assert(!this.updatePromise_,\n          'updatePromise_ and generateRequestPromise_ set in onMsKeyAdded_');\n      this.updateKeyStatus_('usable');\n      this.generateRequestPromise_.resolve();\n      this.generateRequestPromise_ = null;\n      return;\n    }\n\n    // We can now resolve this.updatePromise, which should be non-null.\n    goog.asserts.assert(this.updatePromise_,\n        'updatePromise_ not set in onMsKeyAdded_');\n    if (this.updatePromise_) {\n      this.updateKeyStatus_('usable');\n      this.updatePromise_.resolve();\n      this.updatePromise_ = null;\n    }\n  }\n\n  /**\n   * Handler for the native keyerror event on MSMediaKeySession.\n   *\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onMsKeyError_(event) {\n    shaka.log.debug('PatchedMediaKeysMs.onMsKeyError_', event);\n\n    const error = new Error('EME PatchedMediaKeysMs key error');\n    error['errorCode'] = this.nativeMediaKeySession_.error;\n\n    if (this.generateRequestPromise_ != null) {\n      this.generateRequestPromise_.reject(error);\n      this.generateRequestPromise_ = null;\n    } else if (this.updatePromise_ != null) {\n      this.updatePromise_.reject(error);\n      this.updatePromise_ = null;\n    } else {\n      // Unexpected error - map native codes to standardised key statuses.\n      // Possible values of this.nativeMediaKeySession_.error.code:\n      // MS_MEDIA_KEYERR_UNKNOWN        = 1\n      // MS_MEDIA_KEYERR_CLIENT         = 2\n      // MS_MEDIA_KEYERR_SERVICE        = 3\n      // MS_MEDIA_KEYERR_OUTPUT         = 4\n      // MS_MEDIA_KEYERR_HARDWARECHANGE = 5\n      // MS_MEDIA_KEYERR_DOMAIN         = 6\n\n      switch (this.nativeMediaKeySession_.error.code) {\n        case MSMediaKeyError.MS_MEDIA_KEYERR_OUTPUT:\n        case MSMediaKeyError.MS_MEDIA_KEYERR_HARDWARECHANGE:\n          this.updateKeyStatus_('output-not-allowed');\n          break;\n        default:\n          this.updateKeyStatus_('internal-error');\n          break;\n      }\n    }\n  }\n\n  /**\n   * Updates key status and dispatch a 'keystatuseschange' event.\n   *\n   * @param {string} status\n   * @private\n   */\n  updateKeyStatus_(status) {\n    this.keyStatuses.setStatus(status);\n    const event = new shaka.util.FakeEvent('keystatuseschange');\n    this.dispatchEvent(event);\n  }\n};\n\n\n/**\n * @summary An implementation of MediaKeyStatusMap.\n * This fakes a map with a single key ID.\n *\n * @todo Consolidate the MediaKeyStatusMap types in these polyfills.\n * @implements {MediaKeyStatusMap}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap = class {\n  /** */\n  constructor() {\n    /**\n     * @type {number}\n     */\n    this.size = 0;\n\n    /**\n     * @private {string|undefined}\n     */\n    this.status_ = undefined;\n  }\n\n  /**\n   * An internal method used by the session to set key status.\n   * @param {string|undefined} status\n   */\n  setStatus(status) {\n    this.size = status == undefined ? 0 : 1;\n    this.status_ = status;\n  }\n\n  /**\n   * An internal method used by the session to get key status.\n   * @return {string|undefined}\n   */\n  getStatus() {\n    return this.status_;\n  }\n\n  /** @override */\n  forEach(fn) {\n    if (this.status_) {\n      fn(this.status_, shaka.media.DrmEngine.DUMMY_KEY_ID.value());\n    }\n  }\n\n  /** @override */\n  get(keyId) {\n    if (this.has(keyId)) {\n      return this.status_;\n    }\n    return undefined;\n  }\n\n  /** @override */\n  has(keyId) {\n    const fakeKeyId = shaka.media.DrmEngine.DUMMY_KEY_ID.value();\n    if (this.status_ && shaka.util.BufferUtils.equal(keyId, fakeKeyId)) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  entries() {\n    goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  keys() {\n    goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  values() {\n    goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.PatchedMediaKeysMs.install);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysNop');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to stub out\n * {@link https://bit.ly/EmeMar15 EME draft 12 March 2015} on browsers without\n * EME.\n * All methods will fail.\n * @export\n */\nshaka.polyfill.PatchedMediaKeysNop = class {\n  /**\n   * Installs the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (!window.HTMLVideoElement ||\n        (navigator.requestMediaKeySystemAccess &&\n         // eslint-disable-next-line no-restricted-syntax\n         MediaKeySystemAccess.prototype.getConfiguration)) {\n      return;\n    }\n    shaka.log.info('EME not available.');\n\n    // Alias.\n    const PatchedMediaKeysNop = shaka.polyfill.PatchedMediaKeysNop;\n\n    // Install patches.\n    navigator.requestMediaKeySystemAccess =\n        PatchedMediaKeysNop.requestMediaKeySystemAccess;\n    // Delete mediaKeys to work around strict mode compatibility issues.\n    // eslint-disable-next-line no-restricted-syntax\n    delete HTMLMediaElement.prototype['mediaKeys'];\n    // Work around read-only declaration for mediaKeys by using a string.\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype['mediaKeys'] = null;\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype.setMediaKeys = PatchedMediaKeysNop.setMediaKeys;\n    // These are not usable, but allow Player.isBrowserSupported to pass.\n    window.MediaKeys = PatchedMediaKeysNop.MediaKeys;\n    window.MediaKeySystemAccess = PatchedMediaKeysNop.MediaKeySystemAccess;\n  }\n\n  /**\n   * An implementation of navigator.requestMediaKeySystemAccess.\n   * Retrieves a MediaKeySystemAccess object.\n   *\n   * @this {!Navigator}\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   * @return {!Promise.<!MediaKeySystemAccess>}\n   */\n  static requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysNop.requestMediaKeySystemAccess');\n    goog.asserts.assert(this == navigator,\n        'bad \"this\" for requestMediaKeySystemAccess');\n\n    return Promise.reject(new Error(\n        'The key system specified is not supported.'));\n  }\n\n  /**\n   * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n   * Attaches a MediaKeys object to the media element.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {MediaKeys} mediaKeys\n   * @return {!Promise}\n   */\n  static setMediaKeys(mediaKeys) {\n    shaka.log.debug('PatchedMediaKeysNop.setMediaKeys');\n    goog.asserts.assert(this instanceof HTMLMediaElement,\n        'bad \"this\" for setMediaKeys');\n\n    if (mediaKeys == null) {\n      return Promise.resolve();\n    }\n\n    return Promise.reject(new Error('MediaKeys not supported.'));\n  }\n};\n\n\n/**\n * An unusable constructor for MediaKeys.\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeys = class {\n  /** */\n  constructor() {\n    throw new TypeError('Illegal constructor.');\n  }\n\n  /** @override */\n  createSession() {}\n\n  /** @override */\n  setServerCertificate() {}\n};\n\n\n/**\n * An unusable constructor for MediaKeySystemAccess.\n * @implements {MediaKeySystemAccess}\n */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess = class {\n  /** */\n  constructor() {\n    /** @override */\n    this.keySystem = '';  // For the compiler.\n\n    throw new TypeError('Illegal constructor.');\n  }\n\n  /** @override */\n  getConfiguration() {}\n\n  /** @override */\n  createMediaKeys() {}\n};\n\n\n// A low priority ensures this is the last and acts as a fallback.\nshaka.polyfill.register(shaka.polyfill.PatchedMediaKeysNop.install, -10);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysWebkit');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Timer');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @summary A polyfill to implement\n * {@link https://bit.ly/EmeMar15 EME draft 12 March 2015} on top of\n * webkit-prefixed {@link https://bit.ly/Eme01b EME v0.1b}.\n * @export\n */\nshaka.polyfill.PatchedMediaKeysWebkit = class {\n  /**\n   * Installs the polyfill if needed.\n   * @export\n   */\n  static install() {\n    // Alias.\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    if (!window.HTMLVideoElement ||\n        (navigator.requestMediaKeySystemAccess &&\n         // eslint-disable-next-line no-restricted-syntax\n         MediaKeySystemAccess.prototype.getConfiguration)) {\n      return;\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    if (HTMLMediaElement.prototype.webkitGenerateKeyRequest) {\n      shaka.log.info('Using webkit-prefixed EME v0.1b');\n      PatchedMediaKeysWebkit.prefix_ = 'webkit';\n      // eslint-disable-next-line no-restricted-syntax\n    } else if (HTMLMediaElement.prototype.generateKeyRequest) {\n      shaka.log.info('Using nonprefixed EME v0.1b');\n    } else {\n      return;\n    }\n\n    goog.asserts.assert(\n        // eslint-disable-next-line no-restricted-syntax\n        HTMLMediaElement.prototype[\n            PatchedMediaKeysWebkit.prefixApi_('generateKeyRequest')],\n        'PatchedMediaKeysWebkit APIs not available!');\n\n    // Install patches.\n    navigator.requestMediaKeySystemAccess =\n        PatchedMediaKeysWebkit.requestMediaKeySystemAccess;\n    // Delete mediaKeys to work around strict mode compatibility issues.\n    // eslint-disable-next-line no-restricted-syntax\n    delete HTMLMediaElement.prototype['mediaKeys'];\n    // Work around read-only declaration for mediaKeys by using a string.\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype['mediaKeys'] = null;\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype.setMediaKeys =\n        PatchedMediaKeysWebkit.setMediaKeys;\n    window.MediaKeys = PatchedMediaKeysWebkit.MediaKeys;\n    window.MediaKeySystemAccess = PatchedMediaKeysWebkit.MediaKeySystemAccess;\n  }\n\n  /**\n   * Prefix the api with the stored prefix.\n   *\n   * @param {string} api\n   * @return {string}\n   * @private\n   */\n  static prefixApi_(api) {\n    const prefix = shaka.polyfill.PatchedMediaKeysWebkit.prefix_;\n    if (prefix) {\n      return prefix + api.charAt(0).toUpperCase() + api.slice(1);\n    }\n    return api;\n  }\n\n  /**\n   * An implementation of navigator.requestMediaKeySystemAccess.\n   * Retrieves a MediaKeySystemAccess object.\n   *\n   * @this {!Navigator}\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   * @return {!Promise.<!MediaKeySystemAccess>}\n   */\n  static requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysWebkit.requestMediaKeySystemAccess');\n    goog.asserts.assert(this == navigator,\n        'bad \"this\" for requestMediaKeySystemAccess');\n\n    // Alias.\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n    try {\n      const access = new PatchedMediaKeysWebkit.MediaKeySystemAccess(\n          keySystem, supportedConfigurations);\n      return Promise.resolve(/** @type {!MediaKeySystemAccess} */ (access));\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n  }\n\n  /**\n   * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n   * Attaches a MediaKeys object to the media element.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {MediaKeys} mediaKeys\n   * @return {!Promise}\n   */\n  static setMediaKeys(mediaKeys) {\n    shaka.log.debug('PatchedMediaKeysWebkit.setMediaKeys');\n    goog.asserts.assert(this instanceof HTMLMediaElement,\n        'bad \"this\" for setMediaKeys');\n\n    // Alias.\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    const newMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys} */ (\n        mediaKeys);\n    const oldMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys} */ (\n        this.mediaKeys);\n\n    if (oldMediaKeys && oldMediaKeys != newMediaKeys) {\n      goog.asserts.assert(\n          oldMediaKeys instanceof PatchedMediaKeysWebkit.MediaKeys,\n          'non-polyfill instance of oldMediaKeys');\n      // Have the old MediaKeys stop listening to events on the video tag.\n      oldMediaKeys.setMedia(null);\n    }\n\n    delete this['mediaKeys'];  // In case there is an existing getter.\n    this['mediaKeys'] = mediaKeys;  // Work around the read-only declaration.\n\n    if (newMediaKeys) {\n      goog.asserts.assert(\n          newMediaKeys instanceof PatchedMediaKeysWebkit.MediaKeys,\n          'non-polyfill instance of newMediaKeys');\n      newMediaKeys.setMedia(this);\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * For some of this polyfill's implementation, we need to query a video\n   * element.  But for some embedded systems, it is memory-expensive to create\n   * multiple video elements.  Therefore, we check the document to see if we can\n   * borrow one to query before we fall back to creating one temporarily.\n   *\n   * @return {!HTMLVideoElement}\n   * @private\n   */\n  static getVideoElement_() {\n    const videos = document.getElementsByTagName('video');\n    const video = videos.length ? videos[0] : document.createElement('video');\n    return /** @type {!HTMLVideoElement} */(video);\n  }\n};\n\n\n/**\n * An implementation of MediaKeySystemAccess.\n *\n * @implements {MediaKeySystemAccess}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySystemAccess = class {\n  /**\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   */\n  constructor(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySystemAccess');\n\n    /** @type {string} */\n    this.keySystem = keySystem;\n\n    /** @private {string} */\n    this.internalKeySystem_ = keySystem;\n\n    /** @private {!MediaKeySystemConfiguration} */\n    this.configuration_;\n\n    // This is only a guess, since we don't really know from the prefixed API.\n    let allowPersistentState = false;\n\n    if (keySystem == 'org.w3.clearkey') {\n      // ClearKey's string must be prefixed in v0.1b.\n      this.internalKeySystem_ = 'webkit-org.w3.clearkey';\n      // ClearKey doesn't support persistence.\n      allowPersistentState = false;\n    }\n\n    let success = false;\n    const tmpVideo = shaka.polyfill.PatchedMediaKeysWebkit.getVideoElement_();\n    for (const cfg of supportedConfigurations) {\n      // Create a new config object and start adding in the pieces which we\n      // find support for.  We will return this from getConfiguration() if\n      // asked.\n      /** @type {!MediaKeySystemConfiguration} */\n      const newCfg = {\n        'audioCapabilities': [],\n        'videoCapabilities': [],\n        // It is technically against spec to return these as optional, but we\n        // don't truly know their values from the prefixed API:\n        'persistentState': 'optional',\n        'distinctiveIdentifier': 'optional',\n        // Pretend the requested init data types are supported, since we don't\n        // really know that either:\n        'initDataTypes': cfg.initDataTypes,\n        'sessionTypes': ['temporary'],\n        'label': cfg.label,\n      };\n\n      // v0.1b tests for key system availability with an extra argument on\n      // canPlayType.\n      let ranAnyTests = false;\n      if (cfg.audioCapabilities) {\n        for (const cap of cfg.audioCapabilities) {\n          if (cap.contentType) {\n            ranAnyTests = true;\n            // In Chrome <= 40, if you ask about Widevine-encrypted audio\n            // support, you get a false-negative when you specify codec\n            // information. Work around this by stripping codec info for audio\n            // types.\n            const contentType = cap.contentType.split(';')[0];\n            if (tmpVideo.canPlayType(contentType, this.internalKeySystem_)) {\n              newCfg.audioCapabilities.push(cap);\n              success = true;\n            }\n          }\n        }\n      }\n      if (cfg.videoCapabilities) {\n        for (const cap of cfg.videoCapabilities) {\n          if (cap.contentType) {\n            ranAnyTests = true;\n            if (tmpVideo.canPlayType(\n                cap.contentType, this.internalKeySystem_)) {\n              newCfg.videoCapabilities.push(cap);\n              success = true;\n            }\n          }\n        }\n      }\n\n      if (!ranAnyTests) {\n        // If no specific types were requested, we check all common types to\n        // find out if the key system is present at all.\n        success =\n            tmpVideo.canPlayType('video/mp4', this.internalKeySystem_) ||\n            tmpVideo.canPlayType('video/webm', this.internalKeySystem_);\n      }\n      if (cfg.persistentState == 'required') {\n        if (allowPersistentState) {\n          newCfg.persistentState = 'required';\n          newCfg.sessionTypes = ['persistent-license'];\n        } else {\n          success = false;\n        }\n      }\n\n      if (success) {\n        this.configuration_ = newCfg;\n        return;\n      }\n    }  // for each cfg in supportedConfigurations\n\n    let message = 'Unsupported keySystem';\n    if (keySystem == 'org.w3.clearkey' || keySystem == 'com.widevine.alpha') {\n      message = 'None of the requested configurations were supported.';\n    }\n\n    // According to the spec, this should be a DOMException, but there is not a\n    // public constructor for that.  So we make this look-alike instead.\n    const unsupportedError = new Error(message);\n    unsupportedError.name = 'NotSupportedError';\n    unsupportedError['code'] = DOMException.NOT_SUPPORTED_ERR;\n    throw unsupportedError;\n  }\n\n  /** @override */\n  createMediaKeys() {\n    shaka.log.debug(\n        'PatchedMediaKeysWebkit.MediaKeySystemAccess.createMediaKeys');\n\n    // Alias.\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n    const mediaKeys =\n    new PatchedMediaKeysWebkit.MediaKeys(this.internalKeySystem_);\n    return Promise.resolve(/** @type {!MediaKeys} */ (mediaKeys));\n  }\n\n  /** @override */\n  getConfiguration() {\n    shaka.log.debug(\n        'PatchedMediaKeysWebkit.MediaKeySystemAccess.getConfiguration');\n    return this.configuration_;\n  }\n};\n\n\n/**\n * An implementation of MediaKeys.\n *\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys = class {\n  /**\n   * @param {string} keySystem\n   */\n  constructor(keySystem) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys');\n\n    /** @private {string} */\n    this.keySystem_ = keySystem;\n\n    /** @private {HTMLMediaElement} */\n    this.media_ = null;\n\n    /** @private {!shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /**\n     * @private {Array.<!shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession>}\n     */\n    this.newSessions_ = [];\n\n    /**\n     * @private {!Map.<string,\n     *                 !shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession>}\n     */\n    this.sessionMap_ = new Map();\n  }\n\n  /**\n   * @param {HTMLMediaElement} media\n   * @protected\n   */\n  setMedia(media) {\n    this.media_ = media;\n\n    // Remove any old listeners.\n    this.eventManager_.removeAll();\n\n    const prefix = shaka.polyfill.PatchedMediaKeysWebkit.prefix_;\n    if (media) {\n      // Intercept and translate these prefixed EME events.\n      this.eventManager_.listen(media, prefix + 'needkey',\n      /** @type {shaka.util.EventManager.ListenerType} */ (\n            (event) => this.onWebkitNeedKey_(event)));\n\n      this.eventManager_.listen(media, prefix + 'keymessage',\n      /** @type {shaka.util.EventManager.ListenerType} */ (\n            (event) => this.onWebkitKeyMessage_(event)));\n\n      this.eventManager_.listen(media, prefix + 'keyadded',\n      /** @type {shaka.util.EventManager.ListenerType} */ (\n            (event) => this.onWebkitKeyAdded_(event)));\n\n      this.eventManager_.listen(media, prefix + 'keyerror',\n      /** @type {shaka.util.EventManager.ListenerType} */ (\n            (event) => this.onWebkitKeyError_(event)));\n    }\n  }\n\n  /** @override */\n  createSession(sessionType) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys.createSession');\n\n    sessionType = sessionType || 'temporary';\n    if (sessionType != 'temporary' && sessionType != 'persistent-license') {\n      throw new TypeError('Session type ' + sessionType +\n                      ' is unsupported on this platform.');\n    }\n\n    // Alias.\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    // Unprefixed EME allows for session creation without a video tag or src.\n    // Prefixed EME requires both a valid HTMLMediaElement and a src.\n    const media = this.media_ || /** @type {!HTMLMediaElement} */(\n      document.createElement('video'));\n    if (!media.src) {\n      media.src = 'about:blank';\n    }\n\n    const session = new PatchedMediaKeysWebkit.MediaKeySession(\n        media, this.keySystem_, sessionType);\n    this.newSessions_.push(session);\n    return session;\n  }\n\n  /** @override */\n  setServerCertificate(serverCertificate) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys.setServerCertificate');\n\n    // There is no equivalent in v0.1b, so return failure.\n    return Promise.resolve(false);\n  }\n\n  /**\n   * @param {!MediaKeyEvent} event\n   * @suppress {constantProperty} We reassign what would be const on a real\n   *   MediaEncryptedEvent, but in our look-alike event.\n   * @private\n   */\n  onWebkitNeedKey_(event) {\n    shaka.log.debug('PatchedMediaKeysWebkit.onWebkitNeedKey_', event);\n    goog.asserts.assert(this.media_, 'media_ not set in onWebkitNeedKey_');\n\n    const event2 = new CustomEvent('encrypted');\n    const encryptedEvent =\n      /** @type {!MediaEncryptedEvent} */(/** @type {?} */(event2));\n    // initDataType is not used by v0.1b EME, so any valid value is fine here.\n    encryptedEvent.initDataType = 'cenc';\n    encryptedEvent.initData = shaka.util.BufferUtils.toArrayBuffer(\n        event.initData);\n\n    this.media_.dispatchEvent(event2);\n  }\n\n  /**\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyMessage_(event) {\n    shaka.log.debug('PatchedMediaKeysWebkit.onWebkitKeyMessage_', event);\n\n    const session = this.findSession_(event.sessionId);\n    if (!session) {\n      shaka.log.error('Session not found', event.sessionId);\n      return;\n    }\n\n    const isNew = session.keyStatuses.getStatus() == undefined;\n\n    const data = new Map()\n        .set('messageType', isNew ? 'licenserequest' : 'licenserenewal')\n        .set('message', event.message);\n    const event2 = new shaka.util.FakeEvent('message', data);\n\n    session.generated();\n    session.dispatchEvent(event2);\n  }\n\n  /**\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyAdded_(event) {\n    shaka.log.debug('PatchedMediaKeysWebkit.onWebkitKeyAdded_', event);\n\n    const session = this.findSession_(event.sessionId);\n    goog.asserts.assert(\n        session, 'unable to find session in onWebkitKeyAdded_');\n    if (session) {\n      session.ready();\n    }\n  }\n\n  /**\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyError_(event) {\n    shaka.log.debug('PatchedMediaKeysWebkit.onWebkitKeyError_', event);\n\n    const session = this.findSession_(event.sessionId);\n    goog.asserts.assert(\n        session, 'unable to find session in onWebkitKeyError_');\n    if (session) {\n      session.handleError(event);\n    }\n  }\n\n  /**\n   * @param {string} sessionId\n   * @return {shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession}\n   * @private\n   */\n  findSession_(sessionId) {\n    let session = this.sessionMap_.get(sessionId);\n    if (session) {\n      shaka.log.debug(\n          'PatchedMediaKeysWebkit.MediaKeys.findSession_', session);\n      return session;\n    }\n\n    session = this.newSessions_.shift();\n    if (session) {\n      session.sessionId = sessionId;\n      this.sessionMap_.set(sessionId, session);\n      shaka.log.debug(\n          'PatchedMediaKeysWebkit.MediaKeys.findSession_', session);\n      return session;\n    }\n\n    return null;\n  }\n};\n\n\n/**\n * An implementation of MediaKeySession.\n *\n * @implements {MediaKeySession}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession =\nclass extends shaka.util.FakeEventTarget {\n  /**\n   * @param {!HTMLMediaElement} media\n   * @param {string} keySystem\n   * @param {string} sessionType\n   */\n  constructor(media, keySystem, sessionType) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession');\n    super();\n\n    /** @private {!HTMLMediaElement} */\n    this.media_ = media;\n\n    /** @private {boolean} */\n    this.initialized_ = false;\n\n    /** @private {shaka.util.PublicPromise} */\n    this.generatePromise_ = null;\n\n    /** @private {shaka.util.PublicPromise} */\n    this.updatePromise_ = null;\n\n    /** @private {string} */\n    this.keySystem_ = keySystem;\n\n    /** @private {string} */\n    this.type_ = sessionType;\n\n    /** @type {string} */\n    this.sessionId = '';\n\n    /** @type {number} */\n    this.expiration = NaN;\n\n    /** @type {!shaka.util.PublicPromise} */\n    this.closed = new shaka.util.PublicPromise();\n\n    /** @type {!shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap} */\n    this.keyStatuses =\n        new shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap();\n  }\n\n  /**\n   * Signals that the license request has been generated.  This resolves the\n   * 'generateRequest' promise.\n   *\n   * @protected\n   */\n  generated() {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.generated');\n\n    if (this.generatePromise_) {\n      this.generatePromise_.resolve();\n      this.generatePromise_ = null;\n    }\n  }\n\n  /**\n   * Signals that the session is 'ready', which is the terminology used in older\n   * versions of EME.  The new signal is to resolve the 'update' promise.  This\n   * translates between the two.\n   *\n   * @protected\n   */\n  ready() {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.ready');\n\n    this.updateKeyStatus_('usable');\n\n    if (this.updatePromise_) {\n      this.updatePromise_.resolve();\n    }\n    this.updatePromise_ = null;\n  }\n\n  /**\n   * Either rejects a promise, or dispatches an error event, as appropriate.\n   *\n   * @param {!MediaKeyEvent} event\n   */\n  handleError(event) {\n    shaka.log.debug(\n        'PatchedMediaKeysWebkit.MediaKeySession.handleError', event);\n\n    // This does not match the DOMException we get in current WD EME, but it\n    // will at least provide some information which can be used to look into the\n    // problem.\n    const error = new Error('EME v0.1b key error');\n    const errorCode = event.errorCode;\n    errorCode.systemCode = event.systemCode;\n    error['errorCode'] = errorCode;\n\n    // The presence or absence of sessionId indicates whether this corresponds\n    // to generateRequest() or update().\n    if (!event.sessionId && this.generatePromise_) {\n      if (event.systemCode == 45) {\n        error.message = 'Unsupported session type.';\n      }\n      this.generatePromise_.reject(error);\n      this.generatePromise_ = null;\n    } else if (event.sessionId && this.updatePromise_) {\n      this.updatePromise_.reject(error);\n      this.updatePromise_ = null;\n    } else {\n      // This mapping of key statuses is imperfect at best.\n      const code = event.errorCode.code;\n      const systemCode = event.systemCode;\n      if (code == MediaKeyError['MEDIA_KEYERR_OUTPUT']) {\n        this.updateKeyStatus_('output-restricted');\n      } else if (systemCode == 1) {\n        this.updateKeyStatus_('expired');\n      } else {\n        this.updateKeyStatus_('internal-error');\n      }\n    }\n  }\n\n  /**\n   * Logic which is shared between generateRequest() and load(), both of which\n   * are ultimately implemented with webkitGenerateKeyRequest in prefixed EME.\n   *\n   * @param {?BufferSource} initData\n   * @param {?string} offlineSessionId\n   * @return {!Promise}\n   * @private\n   */\n  generate_(initData, offlineSessionId) {\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    if (this.initialized_) {\n      const error = new Error('The session is already initialized.');\n      return Promise.reject(error);\n    }\n\n    this.initialized_ = true;\n\n    /** @type {!Uint8Array} */\n    let mangledInitData;\n\n    try {\n      if (this.type_ == 'persistent-license') {\n        const StringUtils = shaka.util.StringUtils;\n        if (!offlineSessionId) {\n          goog.asserts.assert(initData, 'expecting init data');\n          // Persisting the initial license.\n          // Prefix the init data with a tag to indicate persistence.\n          const prefix = StringUtils.toUTF8('PERSISTENT|');\n          mangledInitData = shaka.util.Uint8ArrayUtils.concat(prefix, initData);\n        } else {\n          // Loading a stored license.\n          // Prefix the init data (which is really a session ID) with a tag to\n          // indicate that we are loading a persisted session.\n          mangledInitData = shaka.util.BufferUtils.toUint8(\n              StringUtils.toUTF8('LOAD_SESSION|' + offlineSessionId));\n        }\n      } else {\n        // Streaming.\n        goog.asserts.assert(this.type_ == 'temporary',\n            'expected temporary session');\n        goog.asserts.assert(!offlineSessionId,\n            'unexpected offline session ID');\n        goog.asserts.assert(initData, 'expecting init data');\n        mangledInitData = shaka.util.BufferUtils.toUint8(initData);\n      }\n\n      goog.asserts.assert(mangledInitData, 'init data not set!');\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n\n    goog.asserts.assert(this.generatePromise_ == null,\n        'generatePromise_ should be null');\n    this.generatePromise_ = new shaka.util.PublicPromise();\n\n    // Because we are hacking media.src in createSession to better emulate\n    // unprefixed EME's ability to create sessions and license requests without\n    // a video tag, we can get ourselves into trouble.  It seems that sometimes,\n    // the setting of media.src hasn't been processed by some other thread, and\n    // GKR can throw an exception.  If this occurs, wait 10 ms and try again at\n    // most once.  This situation should only occur when init data is available\n    // ahead of the 'needkey' event.\n\n    const generateKeyRequestName =\n        PatchedMediaKeysWebkit.prefixApi_('generateKeyRequest');\n    try {\n      this.media_[generateKeyRequestName](this.keySystem_, mangledInitData);\n    } catch (exception) {\n      if (exception.name != 'InvalidStateError') {\n        this.generatePromise_ = null;\n        return Promise.reject(exception);\n      }\n\n      const timer = new shaka.util.Timer(() => {\n        try {\n          this.media_[generateKeyRequestName](this.keySystem_, mangledInitData);\n        } catch (exception2) {\n          this.generatePromise_.reject(exception2);\n          this.generatePromise_ = null;\n        }\n      });\n\n      timer.tickAfter(/* seconds= */ 0.01);\n    }\n\n    return this.generatePromise_;\n  }\n\n  /**\n   * An internal version of update which defers new calls while old ones are in\n   * progress.\n   *\n   * @param {!shaka.util.PublicPromise} promise  The promise associated with\n   *   this call.\n   * @param {BufferSource} response\n   * @private\n   */\n  update_(promise, response) {\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    if (this.updatePromise_) {\n      // We already have an update in-progress, so defer this one until after\n      // the old one is resolved.  Execute this whether the original one\n      // succeeds or fails.\n      this.updatePromise_.then(() => this.update_(promise, response))\n          .catch(() => this.update_(promise, response));\n      return;\n    }\n\n    this.updatePromise_ = promise;\n\n    let key;\n    let keyId;\n\n    if (this.keySystem_ == 'webkit-org.w3.clearkey') {\n      // The current EME version of clearkey wants a structured JSON response.\n      // The v0.1b version wants just a raw key.  Parse the JSON response and\n      // extract the key and key ID.\n      const StringUtils = shaka.util.StringUtils;\n      const Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n      const licenseString = StringUtils.fromUTF8(response);\n      const jwkSet = /** @type {JWKSet} */ (JSON.parse(licenseString));\n      const kty = jwkSet.keys[0].kty;\n      if (kty != 'oct') {\n        // Reject the promise.\n        this.updatePromise_.reject(new Error(\n            'Response is not a valid JSON Web Key Set.'));\n        this.updatePromise_ = null;\n      }\n      key = Uint8ArrayUtils.fromBase64(jwkSet.keys[0].k);\n      keyId = Uint8ArrayUtils.fromBase64(jwkSet.keys[0].kid);\n    } else {\n      // The key ID is not required.\n      key = shaka.util.BufferUtils.toUint8(response);\n      keyId = null;\n    }\n\n    const addKeyName = PatchedMediaKeysWebkit.prefixApi_('addKey');\n    try {\n      this.media_[addKeyName](this.keySystem_, key, keyId, this.sessionId);\n    } catch (exception) {\n      // Reject the promise.\n      this.updatePromise_.reject(exception);\n      this.updatePromise_ = null;\n    }\n  }\n\n  /**\n   * Update key status and dispatch a 'keystatuseschange' event.\n   *\n   * @param {string} status\n   * @private\n   */\n  updateKeyStatus_(status) {\n    this.keyStatuses.setStatus(status);\n    const event = new shaka.util.FakeEvent('keystatuseschange');\n    this.dispatchEvent(event);\n  }\n\n  /** @override */\n  generateRequest(initDataType, initData) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.generateRequest');\n    return this.generate_(initData, null);\n  }\n\n  /** @override */\n  load(sessionId) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.load');\n    if (this.type_ == 'persistent-license') {\n      return this.generate_(null, sessionId);\n    } else {\n      return Promise.reject(new Error('Not a persistent session.'));\n    }\n  }\n\n  /** @override */\n  update(response) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.update', response);\n    goog.asserts.assert(this.sessionId, 'update without session ID');\n\n    const nextUpdatePromise = new shaka.util.PublicPromise();\n    this.update_(nextUpdatePromise, response);\n    return nextUpdatePromise;\n  }\n\n  /** @override */\n  close() {\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.close');\n\n    // This will remove a persistent session, but it's also the only way to free\n    // CDM resources on v0.1b.\n    if (this.type_ != 'persistent-license') {\n      // sessionId may reasonably be null if no key request has been generated\n      // yet.  Unprefixed EME will return a rejected promise in this case.  We\n      // will use the same error message that Chrome 41 uses in its EME\n      // implementation.\n      if (!this.sessionId) {\n        this.closed.reject(new Error('The session is not callable.'));\n        return this.closed;\n      }\n\n      // This may throw an exception, but we ignore it because we are only using\n      // it to clean up resources in v0.1b.  We still consider the session\n      // closed. We can't let the exception propagate because\n      // MediaKeySession.close() should not throw.\n      const cancelKeyRequestName =\n          PatchedMediaKeysWebkit.prefixApi_('cancelKeyRequest');\n      try {\n        this.media_[cancelKeyRequestName](this.keySystem_, this.sessionId);\n      } catch (exception) {}\n    }\n\n    // Resolve the 'closed' promise and return it.\n    this.closed.resolve();\n    return this.closed;\n  }\n\n  /** @override */\n  remove() {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.remove');\n\n    if (this.type_ != 'persistent-license') {\n      return Promise.reject(new Error('Not a persistent session.'));\n    }\n\n    return this.close();\n  }\n};\n\n\n/**\n * An implementation of MediaKeyStatusMap.\n * This fakes a map with a single key ID.\n *\n * @todo Consolidate the MediaKeyStatusMap types in these polyfills.\n * @implements {MediaKeyStatusMap}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap = class {\n  /** */\n  constructor() {\n    /**\n     * @type {number}\n     */\n    this.size = 0;\n\n    /**\n     * @private {string|undefined}\n     */\n    this.status_ = undefined;\n  }\n\n  /**\n   * An internal method used by the session to set key status.\n   * @param {string|undefined} status\n   */\n  setStatus(status) {\n    this.size = status == undefined ? 0 : 1;\n    this.status_ = status;\n  }\n\n  /**\n   * An internal method used by the session to get key status.\n   * @return {string|undefined}\n   */\n  getStatus() {\n    return this.status_;\n  }\n\n  /** @override */\n  forEach(fn) {\n    if (this.status_) {\n      fn(this.status_, shaka.media.DrmEngine.DUMMY_KEY_ID.value());\n    }\n  }\n\n  /** @override */\n  get(keyId) {\n    if (this.has(keyId)) {\n      return this.status_;\n    }\n    return undefined;\n  }\n\n  /** @override */\n  has(keyId) {\n    const fakeKeyId = shaka.media.DrmEngine.DUMMY_KEY_ID.value();\n    if (this.status_ && shaka.util.BufferUtils.equal(keyId, fakeKeyId)) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  entries() {\n    goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  keys() {\n    goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  values() {\n    goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n  }\n};\n\n\n/**\n * Store api prefix.\n *\n * @private {string}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.prefix_ = '';\n\n\nshaka.polyfill.register(shaka.polyfill.PatchedMediaKeysWebkit.install);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.PiPWebkit');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n/**\n * @summary A polyfill to provide PiP support in Safari.\n * Note that Safari only supports PiP on video elements, not audio.\n * @export\n */\nshaka.polyfill.PiPWebkit = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (!window.HTMLVideoElement) {\n      // Avoid errors on very old browsers.\n      return;\n    }\n\n    // eslint-disable-next-line no-restricted-syntax\n    const proto = HTMLVideoElement.prototype;\n    if (proto.requestPictureInPicture &&\n      document.exitPictureInPicture) {\n      // No polyfill needed.\n      return;\n    }\n\n    if (!proto.webkitSupportsPresentationMode) {\n      // No Webkit PiP API available.\n      return;\n    }\n\n    const PiPWebkit = shaka.polyfill.PiPWebkit;\n    shaka.log.debug('PiPWebkit.install');\n\n    // Polyfill document.pictureInPictureEnabled.\n    // It's definitely enabled now.  :-)\n    document.pictureInPictureEnabled = true;\n\n    // Polyfill document.pictureInPictureElement.\n    // This is initially empty.  We don't need getter or setter because we don't\n    // need any special handling when this is set.  We assume in good faith that\n    // applications won't try to set this directly.\n    document.pictureInPictureElement = null;\n\n    // Polyfill HTMLVideoElement.requestPictureInPicture.\n    proto.requestPictureInPicture = PiPWebkit.requestPictureInPicture_;\n\n    // Polyfill HTMLVideoElement.disablePictureInPicture.\n    Object.defineProperty(proto, 'disablePictureInPicture', {\n      get: PiPWebkit.getDisablePictureInPicture_,\n      set: PiPWebkit.setDisablePictureInPicture_,\n      // You should be able to discover this property.\n      enumerable: true,\n      // And maybe we're not so smart.  Let someone else change it if they want.\n      configurable: true,\n    });\n\n    // Polyfill document.exitPictureInPicture.\n    document.exitPictureInPicture = PiPWebkit.exitPictureInPicture_;\n\n    // Use the \"capturing\" event phase to get the webkit presentation mode event\n    // from the document.  This way, we get the event on its way from document\n    // to the target element without having to intercept events in every\n    // possible video element.\n    document.addEventListener(\n        'webkitpresentationmodechanged', PiPWebkit.proxyEvent_,\n        /* useCapture= */ true);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   */\n  static proxyEvent_(event) {\n    const PiPWebkit = shaka.polyfill.PiPWebkit;\n    const element = /** @type {!HTMLVideoElement} */(event.target);\n\n    if (element.webkitPresentationMode == PiPWebkit.PIP_MODE_) {\n      // Keep track of the PiP element.  This element just entered PiP mode.\n      document.pictureInPictureElement = element;\n\n      // Dispatch a standard event to match.\n      const event2 = new Event('enterpictureinpicture');\n      element.dispatchEvent(event2);\n    } else {\n      // Keep track of the PiP element.  This element just left PiP mode.\n      // If something else hasn't already take its place, clear it.\n      if (document.pictureInPictureElement == element) {\n        document.pictureInPictureElement = null;\n      }\n\n      // Dispatch a standard event to match.\n      const event2 = new Event('leavepictureinpicture');\n      element.dispatchEvent(event2);\n    }\n  }\n\n  /**\n   * @this {HTMLVideoElement}\n   * @return {!Promise}\n   * @private\n   */\n  static requestPictureInPicture_() {\n    const PiPWebkit = shaka.polyfill.PiPWebkit;\n    // NOTE: \"this\" here is the video element.\n\n    // Check if PiP is enabled for this element.\n    if (!this.webkitSupportsPresentationMode(PiPWebkit.PIP_MODE_)) {\n      const error = new Error('PiP not allowed by video element');\n      return Promise.reject(error);\n    } else {\n      // Enter PiP mode.\n      this.webkitSetPresentationMode(PiPWebkit.PIP_MODE_);\n      document.pictureInPictureElement = this;\n      return Promise.resolve();\n    }\n  }\n\n  /**\n   * @this {Document}\n   * @return {!Promise}\n   * @private\n   */\n  static exitPictureInPicture_() {\n    const PiPWebkit = shaka.polyfill.PiPWebkit;\n\n    const pipElement =\n    /** @type {HTMLVideoElement} */(document.pictureInPictureElement);\n    if (pipElement) {\n      // Exit PiP mode.\n      pipElement.webkitSetPresentationMode(PiPWebkit.INLINE_MODE_);\n      document.pictureInPictureElement = null;\n      return Promise.resolve();\n    } else {\n      const error = new Error('No picture in picture element found');\n      return Promise.reject(error);\n    }\n  }\n\n  /**\n   * @this {HTMLVideoElement}\n   * @return {boolean}\n   * @private\n   */\n  static getDisablePictureInPicture_() {\n    // This respects the HTML attribute, which may have been set in HTML or\n    // through the JS setter.\n    if (this.hasAttribute('disablePictureInPicture')) {\n      return true;\n    }\n\n    // Use Apple's non-standard API to know if PiP is allowed on this\n    // device for this content. If not, say that PiP is disabled, even\n    // if not specified by the user through the setter or HTML attribute.\n    const PiPWebkit = shaka.polyfill.PiPWebkit;\n    return !this.webkitSupportsPresentationMode(PiPWebkit.PIP_MODE_);\n  }\n\n  /**\n   * @this {HTMLVideoElement}\n   * @param {boolean} value\n   * @private\n   */\n  static setDisablePictureInPicture_(value) {\n    // This mimics how the JS setter works in browsers that implement the spec.\n    if (value) {\n      this.setAttribute('disablePictureInPicture', '');\n    } else {\n      this.removeAttribute('disablePictureInPicture');\n    }\n  }\n};\n\n\n/**\n * The presentation mode string used to indicate PiP mode in Safari.\n *\n * @const {string}\n * @private\n */\nshaka.polyfill.PiPWebkit.PIP_MODE_ = 'picture-in-picture';\n\n\n/**\n * The presentation mode string used to indicate inline mode in Safari.\n *\n * @const {string}\n * @private\n */\nshaka.polyfill.PiPWebkit.INLINE_MODE_ = 'inline';\n\n\nshaka.polyfill.register(shaka.polyfill.PiPWebkit.install);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\ngoog.provide('shaka.polyfill.RandomUUID');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n/**\n * @summary A polyfill to provide window.crypto.randomUUID in all browsers.\n * @export\n */\nshaka.polyfill.RandomUUID = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    shaka.log.debug('randomUUID.install');\n\n    if (!window.crypto) {\n      // See: https://caniuse.com/cryptography\n      shaka.log.debug(\n          'window.crypto must be available to install randomUUID polyfill.');\n      return;\n    }\n\n    if ('randomUUID' in window.crypto) {\n      shaka.log.debug(\n          'RandomUUID: Native window.crypto.randomUUID() support found.');\n      return;\n    }\n\n    window.crypto.randomUUID = shaka.polyfill.RandomUUID.randomUUID_;\n  }\n\n  /**\n   * @return {string}\n   * @private\n   */\n  static randomUUID_() {\n    const url = URL.createObjectURL(new Blob());\n    const uuid = url.toString();\n    URL.revokeObjectURL(url);\n    return uuid.substr(uuid.lastIndexOf('/') + 1);\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.RandomUUID.install);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.StorageEstimate');\n\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to provide navigator.storage.estimate in old\n * webkit browsers.\n * See: https://developers.google.com/web/updates/2017/08/estimating-available-storage-space#the-present\n * @export\n */\nshaka.polyfill.StorageEstimate = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (navigator.storage && navigator.storage.estimate) {\n      // No need.\n      return;\n    }\n\n    if (navigator.webkitTemporaryStorage &&\n        navigator.webkitTemporaryStorage.queryUsageAndQuota) {\n      if (!('storage' in navigator)) {\n        navigator.storage = /** @type {!StorageManager} */ ({});\n      }\n      navigator.storage.estimate =\n          shaka.polyfill.StorageEstimate.storageEstimate_;\n    }\n  }\n\n  /**\n   * @this {StorageManager}\n   * @return {!Promise}\n   * @private\n   */\n  static storageEstimate_() {\n    return new Promise((resolve, reject) => {\n      navigator.webkitTemporaryStorage.queryUsageAndQuota(\n          (usage, quota) => {\n            resolve({usage: usage, quota: quota});\n          },\n          reject,\n      );\n    });\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.StorageEstimate.install);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\ngoog.provide('shaka.polyfill.Symbol');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n/**\n * @summary A polyfill to provide Symbol.prototype.description in all browsers.\n * See: https://caniuse.com/mdn-javascript_builtins_symbol_description\n * @export\n */\nshaka.polyfill.Symbol = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    shaka.log.debug('Symbol.install');\n\n    // eslint-disable-next-line no-restricted-syntax\n    const proto = Symbol.prototype;\n\n    if (!('description' in proto)) {\n      Object.defineProperty(proto, 'description', {\n        get: shaka.polyfill.Symbol.getSymbolDescription_,\n      });\n    }\n  }\n\n  /**\n   * @this {Symbol}\n   * @return {(string|undefined)}\n   * @private\n   */\n  static getSymbolDescription_() {\n    const m = /\\((.*)\\)/.exec(this.toString());\n    return m ? m[1] : undefined;\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.Symbol.install);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.VideoPlayPromise');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to silence the play() Promise in HTML5 video.\n * @export\n */\nshaka.polyfill.VideoPlayPromise = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    shaka.log.debug('VideoPlayPromise.install');\n\n    if (window.HTMLMediaElement) {\n      // eslint-disable-next-line no-restricted-syntax\n      const originalPlay = HTMLMediaElement.prototype.play;\n      // eslint-disable-next-line no-restricted-syntax\n      HTMLMediaElement.prototype.play = function() {\n        // eslint-disable-next-line no-restricted-syntax\n        const p = originalPlay.apply(this);\n        if (p) {\n          // This browser is returning a Promise from play().\n          // If the play() call fails or is interrupted, the Promise will be\n          // rejected.  Some apps, however, don't listen to this Promise,\n          // especially since it is not available cross-browser.  If the Promise\n          // is rejected without anyone listening for the failure, an error will\n          // appear in the JS console.\n          // To avoid confusion over this innocuous \"error\", we will install a\n          // catch handler on the Promise.  This does not prevent the app from\n          // also catching failures and handling them.  It only prevents the\n          // console message.\n          p.catch(() => {});\n        }\n        return p;\n      };\n    }\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.VideoPlayPromise.install);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.VideoPlaybackQuality');\n\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.Platform');\n\n\n/**\n * @summary A polyfill to provide MSE VideoPlaybackQuality metrics.\n * Many browsers do not yet provide this API, and Chrome currently provides\n * similar data through individual prefixed attributes on HTMLVideoElement.\n * @export\n */\nshaka.polyfill.VideoPlaybackQuality = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (!window.HTMLVideoElement) {\n      // Avoid errors on very old browsers.\n      return;\n    }\n\n    // eslint-disable-next-line no-restricted-syntax\n    const proto = HTMLVideoElement.prototype;\n    if (proto.getVideoPlaybackQuality) {\n      // No polyfill needed.\n      return;\n    }\n\n    if ('webkitDroppedFrameCount' in proto ||\n        shaka.util.Platform.isWebOS3()) {\n      proto.getVideoPlaybackQuality =\n          shaka.polyfill.VideoPlaybackQuality.webkit_;\n    }\n  }\n\n  /**\n   * @this {HTMLVideoElement}\n   * @return {!VideoPlaybackQuality}\n   * @private\n   */\n  static webkit_() {\n    return {\n      'droppedVideoFrames': this.webkitDroppedFrameCount,\n      'totalVideoFrames': this.webkitDecodedFrameCount,\n      // Not provided by this polyfill:\n      'corruptedVideoFrames': 0,\n      'creationTime': NaN,\n      'totalFrameDelay': 0,\n    };\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.VideoPlaybackQuality.install);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.VTTCue');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to provide VTTCue.\n * @export\n */\nshaka.polyfill.VTTCue = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (window.VTTCue) {\n      shaka.log.info('Using native VTTCue.');\n      return;\n    }\n\n    if (!window.TextTrackCue) {\n      shaka.log.error('VTTCue not available.');\n      return;\n    }\n\n    /** @type {?function(number, number, string):!TextTrackCue} */\n    let replacement = null;\n    const constructorLength = TextTrackCue.length;\n    if (constructorLength == 3) {\n      shaka.log.info('Using VTTCue polyfill from 3 argument TextTrackCue.');\n      replacement = shaka.polyfill.VTTCue.from3ArgsTextTrackCue_;\n    } else if (constructorLength == 6) {\n      shaka.log.info('Using VTTCue polyfill from 6 argument TextTrackCue.');\n      replacement = shaka.polyfill.VTTCue.from6ArgsTextTrackCue_;\n    } else if (shaka.polyfill.VTTCue.canUse3ArgsTextTrackCue_()) {\n      shaka.log.info('Using VTTCue polyfill from 3 argument TextTrackCue.');\n      replacement = shaka.polyfill.VTTCue.from3ArgsTextTrackCue_;\n    }\n\n    if (!replacement) {\n      shaka.log.error('No recognized signature for TextTrackCue found!');\n      return;\n    }\n\n    // The polyfilled VTTCue must be callable with \"new\", but the static methods\n    // in this class cannot be called that way on legacy Edge.  So we must wrap\n    // the replacement in a plain function.\n    // eslint-disable-next-line no-restricted-syntax\n    window['VTTCue'] = function(start, end, text) {\n      return replacement(start, end, text);\n    };\n  }\n\n  /**\n   * Draft spec TextTrackCue with 3 constructor arguments.\n   * @see {@link https://bit.ly/2IdyKbA W3C Working Draft 25 October 2012}.\n   *\n   * @param {number} startTime\n   * @param {number} endTime\n   * @param {string} text\n   * @return {!TextTrackCue}\n   * @private\n   */\n  static from3ArgsTextTrackCue_(startTime, endTime, text) {\n    return new window.TextTrackCue(startTime, endTime, text);\n  }\n\n  /**\n   * Draft spec TextTrackCue with 6 constructor arguments (5th & 6th are\n   * optional).\n   * @see {@link https://bit.ly/2KaGSP2 W3C Working Draft 29 March 2012}.\n   *\n   * @param {number} startTime\n   * @param {number} endTime\n   * @param {string} text\n   * @return {!TextTrackCue}\n   * @private\n   */\n  static from6ArgsTextTrackCue_(startTime, endTime, text) {\n    const id = startTime + '-' + endTime + '-' + text;\n    // Quoting the access to the TextTrackCue object to satisfy the compiler.\n    return new window['TextTrackCue'](id, startTime, endTime, text);\n  }\n\n  /**\n   * Edge returns TextTrackCue.length = 0, although it accepts 3\n   * constructor arguments.\n   *\n   * @return {boolean}\n   * @private\n   */\n  static canUse3ArgsTextTrackCue_() {\n    try {\n      return !!shaka.polyfill.VTTCue.from3ArgsTextTrackCue_(1, 2, '');\n    } catch (error) {\n      return false;\n    }\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.VTTCue.install);\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.LrcTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * LRC file format: https://en.wikipedia.org/wiki/LRC_(file_format)\n *\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.LrcTextParser = class {\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    goog.asserts.assert(false, 'LRC does not have init segments');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const StringUtils = shaka.util.StringUtils;\n    const LrcTextParser = shaka.text.LrcTextParser;\n\n    // Get the input as a string.\n    const str = StringUtils.fromUTF8(data);\n\n    /** @type {shaka.extern.Cue} */\n    let prevCue = null;\n\n    /** @type {!Array.<!shaka.extern.Cue>} */\n    const cues = [];\n    const lines = str.split(/\\r?\\n/);\n    for (const line of lines) {\n      if (!line || /^\\s+$/.test(line)) {\n        continue;\n      }\n\n      // LRC content\n      const match = LrcTextParser.lyricLine_.exec(line);\n      if (match) {\n        const startTime = LrcTextParser.parseTime_(match[1]);\n        // This time can be overwritten by a subsequent cue.\n        // By default we add 2 seconds of duration.\n        const endTime = time.segmentEnd ? time.segmentEnd : startTime + 2;\n        const payload = match[2];\n        const cue = new shaka.text.Cue(startTime, endTime, payload);\n\n        // Update previous\n        if (prevCue) {\n          prevCue.endTime = startTime;\n          cues.push(prevCue);\n        }\n        prevCue = cue;\n        continue;\n      }\n      shaka.log.warning('LrcTextParser encountered an unknown line.', line);\n    }\n    if (prevCue) {\n      cues.push(prevCue);\n    }\n\n    return cues;\n  }\n\n  /**\n   * Parses a LRC time from the given parser.\n   *\n   * @param {string} string\n   * @return {number}\n   * @private\n   */\n  static parseTime_(string) {\n    const LrcTextParser = shaka.text.LrcTextParser;\n    const match = LrcTextParser.timeFormat_.exec(string);\n    const minutes = parseInt(match[1], 10);\n    const seconds = parseFloat(match[2].replace(',', '.'));\n    return minutes * 60 + seconds;\n  }\n};\n\n/**\n * @const\n * @private {!RegExp}\n * @example [00:12.0]Text or [00:12.00]Text or [00:12.000]Text or\n * [00:12,0]Text or [00:12,00]Text or [00:12,000]Text\n */\nshaka.text.LrcTextParser.lyricLine_ =\n    /^\\[(\\d{1,2}:\\d{1,2}(?:[.,]\\d{1,3})?)\\](.*)/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 00:12.0 or 00:12.00 or 00:12.000 or\n * 00:12,0 or 00:12,00 or 00:12,000\n */\nshaka.text.LrcTextParser.timeFormat_ =\n    /^(\\d+):(\\d{1,2}(?:[.,]\\d{1,3})?)$/;\n\nshaka.text.TextEngine.registerParser(\n    'application/x-subtitle-lrc', () => new shaka.text.LrcTextParser());\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.TtmlTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.CueRegion');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.TtmlTextParser = class {\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    goog.asserts.assert(false, 'TTML does not have init segments');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const TtmlTextParser = shaka.text.TtmlTextParser;\n    const XmlUtils = shaka.util.XmlUtils;\n    const ttpNs = TtmlTextParser.parameterNs_;\n    const ttsNs = TtmlTextParser.styleNs_;\n    const str = shaka.util.StringUtils.fromUTF8(data);\n    const cues = [];\n\n    // dont try to parse empty string as\n    // DOMParser will not throw error but return an errored xml\n    if (str == '') {\n      return cues;\n    }\n\n    const tt = XmlUtils.parseXmlString(str, 'tt');\n    if (!tt) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_XML,\n          'Failed to parse TTML.');\n    }\n\n    const body = tt.getElementsByTagName('body')[0];\n    if (!body) {\n      return [];\n    }\n\n    // Get the framerate, subFrameRate and frameRateMultiplier if applicable.\n    const frameRate = XmlUtils.getAttributeNSList(tt, ttpNs, 'frameRate');\n    const subFrameRate = XmlUtils.getAttributeNSList(\n        tt, ttpNs, 'subFrameRate');\n    const frameRateMultiplier =\n        XmlUtils.getAttributeNSList(tt, ttpNs, 'frameRateMultiplier');\n    const tickRate = XmlUtils.getAttributeNSList(tt, ttpNs, 'tickRate');\n\n    const cellResolution = XmlUtils.getAttributeNSList(\n        tt, ttpNs, 'cellResolution');\n    const spaceStyle = tt.getAttribute('xml:space') || 'default';\n    const extent = XmlUtils.getAttributeNSList(tt, ttsNs, 'extent');\n\n    if (spaceStyle != 'default' && spaceStyle != 'preserve') {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_XML,\n          'Invalid xml:space value: ' + spaceStyle);\n    }\n    const whitespaceTrim = spaceStyle == 'default';\n\n    const rateInfo = new TtmlTextParser.RateInfo_(\n        frameRate, subFrameRate, frameRateMultiplier, tickRate);\n\n    const cellResolutionInfo =\n      TtmlTextParser.getCellResolution_(cellResolution);\n\n    const metadata = tt.getElementsByTagName('metadata')[0];\n    const metadataElements = metadata ? XmlUtils.getChildren(metadata) : [];\n    const styles = Array.from(tt.getElementsByTagName('style'));\n    const regionElements = Array.from(tt.getElementsByTagName('region'));\n\n    const cueRegions = [];\n    for (const region of regionElements) {\n      const cueRegion =\n          TtmlTextParser.parseCueRegion_(region, styles, extent);\n      if (cueRegion) {\n        cueRegions.push(cueRegion);\n      }\n    }\n\n    // A <body> element should only contain <div> elements, not <p> or <span>\n    // elements.  We used to allow this, but it is non-compliant, and the\n    // loose nature of our previous parser made it difficult to implement TTML\n    // nesting more fully.\n    if (XmlUtils.findChildren(body, 'p').length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_TEXT_CUE,\n          '<p> can only be inside <div> in TTML');\n    }\n\n    for (const div of XmlUtils.findChildren(body, 'div')) {\n      // A <div> element should only contain <p>, not <span>.\n      if (XmlUtils.findChildren(div, 'span').length) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.TEXT,\n            shaka.util.Error.Code.INVALID_TEXT_CUE,\n            '<span> can only be inside <p> in TTML');\n      }\n    }\n\n    const cue = TtmlTextParser.parseCue_(\n        body, time, rateInfo, metadataElements, styles,\n        regionElements, cueRegions, whitespaceTrim,\n        cellResolutionInfo, /* parentCueElement= */ null,\n        /* isContent= */ false);\n    if (cue) {\n      // According to the TTML spec, backgrounds default to transparent.\n      // So default the background of the top-level element to transparent.\n      // Nested elements may override that background color already.\n      if (!cue.backgroundColor) {\n        cue.backgroundColor = 'transparent';\n      }\n      cues.push(cue);\n    }\n\n    return cues;\n  }\n\n  /**\n   * Parses a TTML node into a Cue.\n   *\n   * @param {!Node} cueNode\n   * @param {shaka.extern.TextParser.TimeContext} timeContext\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @param {!Array.<!Element>} metadataElements\n   * @param {!Array.<!Element>} styles\n   * @param {!Array.<!Element>} regionElements\n   * @param {!Array.<!shaka.text.CueRegion>} cueRegions\n   * @param {boolean} whitespaceTrim\n   * @param {?{columns: number, rows: number}} cellResolution\n   * @param {?Element} parentCueElement\n   * @param {boolean} isContent\n   * @return {shaka.text.Cue}\n   * @private\n   */\n  static parseCue_(\n      cueNode, timeContext, rateInfo, metadataElements, styles, regionElements,\n      cueRegions, whitespaceTrim, cellResolution, parentCueElement, isContent) {\n    /** @type {Element} */\n    let cueElement;\n    /** @type {Element} */\n    let parentElement = /** @type {Element} */ (cueNode.parentNode);\n\n    if (cueNode.nodeType == Node.COMMENT_NODE) {\n      // The comments do not contain information that interests us here.\n      return null;\n    }\n\n    if (cueNode.nodeType == Node.TEXT_NODE) {\n      if (!isContent) {\n        // Ignore text elements outside the content. For example, whitespace\n        // on the same lexical level as the <p> elements, in a document with\n        // xml:space=\"preserve\", should not be renderer.\n        return null;\n      }\n      // This should generate an \"anonymous span\" according to the TTML spec.\n      // So pretend the element was a <span>.  parentElement was set above, so\n      // we should still be able to correctly traverse up for timing\n      // information later.\n      const span = document.createElement('span');\n      span.textContent = cueNode.textContent;\n      cueElement = span;\n    } else {\n      goog.asserts.assert(cueNode.nodeType == Node.ELEMENT_NODE,\n          'nodeType should be ELEMENT_NODE!');\n      cueElement = /** @type {!Element} */(cueNode);\n    }\n    goog.asserts.assert(cueElement, 'cueElement should be non-null!');\n\n    let imageElement = null;\n    for (const nameSpace of shaka.text.TtmlTextParser.smpteNsList_) {\n      imageElement = shaka.text.TtmlTextParser.getElementsFromCollection_(\n          cueElement, 'backgroundImage', metadataElements, '#',\n          nameSpace)[0];\n      if (imageElement) {\n        break;\n      }\n    }\n\n    const parentIsContent = isContent;\n    if (cueNode.nodeName == 'p' || imageElement) {\n      isContent = true;\n    }\n\n    const spaceStyle = cueElement.getAttribute('xml:space') ||\n        (whitespaceTrim ? 'default' : 'preserve');\n\n    const localWhitespaceTrim = spaceStyle == 'default';\n\n    // Parse any nested cues first.\n    const isTextNode = (node) => {\n      return node.nodeType == Node.TEXT_NODE;\n    };\n    const isLeafNode = Array.from(cueElement.childNodes).every(isTextNode);\n    const nestedCues = [];\n    if (!isLeafNode) {\n      // Otherwise, recurse into the children.  Text nodes will convert into\n      // anonymous spans, which will then be leaf nodes.\n      for (const childNode of cueElement.childNodes) {\n        const nestedCue = shaka.text.TtmlTextParser.parseCue_(\n            childNode,\n            timeContext,\n            rateInfo,\n            metadataElements,\n            styles,\n            regionElements,\n            cueRegions,\n            localWhitespaceTrim,\n            cellResolution,\n            cueElement,\n            isContent,\n        );\n\n        // This node may or may not generate a nested cue.\n        if (nestedCue) {\n          nestedCues.push(nestedCue);\n        }\n      }\n    }\n\n    const isNested = /** @type {boolean} */ (parentCueElement != null);\n\n    // In this regex, \"\\S\" means \"non-whitespace character\".\n    const hasTextContent = /\\S/.test(cueElement.textContent);\n    const hasTimeAttributes =\n        cueElement.hasAttribute('begin') ||\n        cueElement.hasAttribute('end') ||\n        cueElement.hasAttribute('dur');\n\n    if (!hasTimeAttributes && !hasTextContent && cueElement.tagName != 'br' &&\n        nestedCues.length == 0) {\n      if (!isNested) {\n        // Disregards empty <p> elements without time attributes nor content.\n        // <p begin=\"...\" smpte:backgroundImage=\"...\" /> will go through,\n        // as some information could be held by its attributes.\n        // <p /> won't, as it would not be displayed.\n        return null;\n      } else if (localWhitespaceTrim) {\n        // Disregards empty anonymous spans when (local) trim is true.\n        return null;\n      }\n    }\n\n    // Get local time attributes.\n    let {start, end} = shaka.text.TtmlTextParser.parseTime_(\n        cueElement, rateInfo);\n    // Resolve local time relative to parent elements.  Time elements can appear\n    // all the way up to 'body', but not 'tt'.\n    while (parentElement && parentElement.nodeType == Node.ELEMENT_NODE &&\n        parentElement.tagName != 'tt') {\n      ({start, end} = shaka.text.TtmlTextParser.resolveTime_(\n          parentElement, rateInfo, start, end));\n      parentElement = /** @type {Element} */(parentElement.parentNode);\n    }\n\n    if (start == null) {\n      start = 0;\n    }\n    start += timeContext.periodStart;\n\n    // If end is null, that means the duration is effectively infinite.\n    if (end == null) {\n      end = Infinity;\n    } else {\n      end += timeContext.periodStart;\n    }\n\n    // Clip times to segment boundaries.\n    // https://github.com/shaka-project/shaka-player/issues/4631\n    start = Math.max(start, timeContext.segmentStart);\n    end = Math.min(end, timeContext.segmentEnd);\n\n    if (!hasTimeAttributes && nestedCues.length > 0) {\n      // If no time is defined for this cue, base the timing information on\n      // the time of the nested cues. In the case of multiple nested cues with\n      // different start times, it is the text displayer's responsibility to\n      // make sure that only the appropriate nested cue is drawn at any given\n      // time.\n      start = Infinity;\n      end = 0;\n      for (const cue of nestedCues) {\n        start = Math.min(start, cue.startTime);\n        end = Math.max(end, cue.endTime);\n      }\n    }\n\n    if (cueElement.tagName == 'br') {\n      const cue = new shaka.text.Cue(start, end, '');\n      cue.lineBreak = true;\n      return cue;\n    }\n\n    let payload = '';\n    if (isLeafNode) {\n      // If the childNodes are all text, this is a leaf node.  Get the payload.\n      payload = cueElement.textContent;\n      if (localWhitespaceTrim) {\n        // Trim leading and trailing whitespace.\n        payload = payload.trim();\n        // Collapse multiple spaces into one.\n        payload = payload.replace(/\\s+/g, ' ');\n      }\n    }\n\n    const cue = new shaka.text.Cue(start, end, payload);\n    cue.nestedCues = nestedCues;\n\n    if (!isContent) {\n      // If this is not a <p> element or a <div> with images, and it has no\n      // parent that was a <p> element, then it's part of the outer containers\n      // (e.g. the <body> or a normal <div> element within it).\n      cue.isContainer = true;\n    }\n\n    if (cellResolution) {\n      cue.cellResolution = cellResolution;\n    }\n\n    // Get other properties if available.\n    const regionElement = shaka.text.TtmlTextParser.getElementsFromCollection_(\n        cueElement, 'region', regionElements, /* prefix= */ '')[0];\n    // Do not actually apply that region unless it is non-inherited, though.\n    // This makes it so that, if a parent element has a region, the children\n    // don't also all independently apply the positioning of that region.\n    if (cueElement.hasAttribute('region')) {\n      if (regionElement && regionElement.getAttribute('xml:id')) {\n        const regionId = regionElement.getAttribute('xml:id');\n        cue.region = cueRegions.filter((region) => region.id == regionId)[0];\n      }\n    }\n\n    let regionElementForStyle = regionElement;\n    if (parentCueElement && isNested && !cueElement.getAttribute('region') &&\n      !cueElement.getAttribute('style')) {\n      regionElementForStyle =\n          shaka.text.TtmlTextParser.getElementsFromCollection_(\n              parentCueElement, 'region', regionElements, /* prefix= */ '')[0];\n    }\n\n    shaka.text.TtmlTextParser.addStyle_(\n        cue,\n        cueElement,\n        regionElementForStyle,\n        imageElement,\n        styles,\n        /** isNested= */ parentIsContent, // \"nested in a <div>\" doesn't count.\n        /** isLeaf= */ (nestedCues.length == 0));\n\n    return cue;\n  }\n\n  /**\n   * Parses an Element into a TextTrackCue or VTTCue.\n   *\n   * @param {!Element} regionElement\n   * @param {!Array.<!Element>} styles Defined in the top of tt  element and\n   * used principally for images.\n   * @param {?string} globalExtent\n   * @return {shaka.text.CueRegion}\n   * @private\n   */\n  static parseCueRegion_(regionElement, styles, globalExtent) {\n    const TtmlTextParser = shaka.text.TtmlTextParser;\n    const region = new shaka.text.CueRegion();\n    const id = regionElement.getAttribute('xml:id');\n    if (!id) {\n      shaka.log.warning('TtmlTextParser parser encountered a region with ' +\n                        'no id. Region will be ignored.');\n      return null;\n    }\n    region.id = id;\n\n    let globalResults = null;\n    if (globalExtent) {\n      globalResults = TtmlTextParser.percentValues_.exec(globalExtent) ||\n        TtmlTextParser.pixelValues_.exec(globalExtent);\n    }\n    const globalWidth = globalResults ? Number(globalResults[1]) : null;\n    const globalHeight = globalResults ? Number(globalResults[2]) : null;\n\n    let results = null;\n    let percentage = null;\n    const extent = TtmlTextParser.getStyleAttributeFromRegion_(\n        regionElement, styles, 'extent');\n    if (extent) {\n      percentage = TtmlTextParser.percentValues_.exec(extent);\n      results = percentage || TtmlTextParser.pixelValues_.exec(extent);\n      if (results != null) {\n        region.width = Number(results[1]);\n        region.height = Number(results[2]);\n\n        if (!percentage) {\n          if (globalWidth != null) {\n            region.width = region.width * 100 / globalWidth;\n          }\n          if (globalHeight != null) {\n            region.height = region.height * 100 / globalHeight;\n          }\n        }\n\n        region.widthUnits = percentage || globalWidth != null ?\n                           shaka.text.CueRegion.units.PERCENTAGE :\n                           shaka.text.CueRegion.units.PX;\n\n        region.heightUnits = percentage || globalHeight != null ?\n                           shaka.text.CueRegion.units.PERCENTAGE :\n                           shaka.text.CueRegion.units.PX;\n      }\n    }\n\n    const origin = TtmlTextParser.getStyleAttributeFromRegion_(\n        regionElement, styles, 'origin');\n    if (origin) {\n      percentage = TtmlTextParser.percentValues_.exec(origin);\n      results = percentage || TtmlTextParser.pixelValues_.exec(origin);\n      if (results != null) {\n        region.viewportAnchorX = Number(results[1]);\n        region.viewportAnchorY = Number(results[2]);\n\n        if (!percentage) {\n          if (globalHeight != null) {\n            region.viewportAnchorY = region.viewportAnchorY * 100 /\n              globalHeight;\n          }\n          if (globalWidth != null) {\n            region.viewportAnchorX = region.viewportAnchorX * 100 /\n              globalWidth;\n          }\n        }\n\n        region.viewportAnchorUnits = percentage || globalWidth != null ?\n                  shaka.text.CueRegion.units.PERCENTAGE :\n                  shaka.text.CueRegion.units.PX;\n      }\n    }\n\n    return region;\n  }\n\n  /**\n   * Adds applicable style properties to a cue.\n   *\n   * @param {!shaka.text.Cue} cue\n   * @param {!Element} cueElement\n   * @param {Element} region\n   * @param {Element} imageElement\n   * @param {!Array.<!Element>} styles\n   * @param {boolean} isNested\n   * @param {boolean} isLeaf\n   * @private\n   */\n  static addStyle_(\n      cue, cueElement, region, imageElement, styles, isNested, isLeaf) {\n    const TtmlTextParser = shaka.text.TtmlTextParser;\n    const Cue = shaka.text.Cue;\n\n    // Styles should be inherited from regions, if a style property is not\n    // associated with a Content element (or an anonymous span).\n    const shouldInheritRegionStyles = isNested || isLeaf;\n\n    const direction = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'direction', shouldInheritRegionStyles);\n    if (direction == 'rtl') {\n      cue.direction = Cue.direction.HORIZONTAL_RIGHT_TO_LEFT;\n    }\n\n    // Direction attribute specifies one-dimentional writing direction\n    // (left to right or right to left). Writing mode specifies that\n    // plus whether text is vertical or horizontal.\n    // They should not contradict each other. If they do, we give\n    // preference to writing mode.\n    const writingMode = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'writingMode', shouldInheritRegionStyles);\n    // Set cue's direction if the text is horizontal, and cue's writingMode if\n    // it's vertical.\n    if (writingMode == 'tb' || writingMode == 'tblr') {\n      cue.writingMode = Cue.writingMode.VERTICAL_LEFT_TO_RIGHT;\n    } else if (writingMode == 'tbrl') {\n      cue.writingMode = Cue.writingMode.VERTICAL_RIGHT_TO_LEFT;\n    } else if (writingMode == 'rltb' || writingMode == 'rl') {\n      cue.direction = Cue.direction.HORIZONTAL_RIGHT_TO_LEFT;\n    } else if (writingMode) {\n      cue.direction = Cue.direction.HORIZONTAL_LEFT_TO_RIGHT;\n    }\n\n    const align = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'textAlign', true);\n    if (align) {\n      cue.positionAlign = TtmlTextParser.textAlignToPositionAlign_[align];\n      cue.lineAlign = TtmlTextParser.textAlignToLineAlign_[align];\n\n      goog.asserts.assert(align.toUpperCase() in Cue.textAlign,\n          align.toUpperCase() + ' Should be in Cue.textAlign values!');\n\n      cue.textAlign = Cue.textAlign[align.toUpperCase()];\n    } else {\n      // Default value is START in the TTML spec: https://bit.ly/32OGmvo\n      // But to make the subtitle render consitent with other players and the\n      // shaka.text.Cue we use CENTER\n      cue.textAlign = Cue.textAlign.CENTER;\n    }\n\n    const displayAlign = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'displayAlign', true);\n    if (displayAlign) {\n      goog.asserts.assert(displayAlign.toUpperCase() in Cue.displayAlign,\n          displayAlign.toUpperCase() +\n                          ' Should be in Cue.displayAlign values!');\n      cue.displayAlign = Cue.displayAlign[displayAlign.toUpperCase()];\n    }\n\n    const color = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'color', shouldInheritRegionStyles);\n    if (color) {\n      cue.color = color;\n    }\n\n    // Background color should not be set on a container.  If this is a nested\n    // cue, you can set the background.  If it's a top-level that happens to\n    // also be a leaf, you can set the background.\n    // See https://github.com/shaka-project/shaka-player/issues/2623\n    // This used to be handled in the displayer, but that is confusing.  The Cue\n    // structure should reflect what you want to happen in the displayer, and\n    // the displayer shouldn't have to know about TTML.\n    const backgroundColor = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'backgroundColor',\n        shouldInheritRegionStyles);\n    if (backgroundColor) {\n      cue.backgroundColor = backgroundColor;\n    }\n\n    const border = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'border', shouldInheritRegionStyles);\n    if (border) {\n      cue.border = border;\n    }\n\n    const fontFamily = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'fontFamily', shouldInheritRegionStyles);\n    // See https://github.com/sandflow/imscJS/blob/1.1.3/src/main/js/html.js#L1384\n    if (fontFamily) {\n      switch (fontFamily) {\n        case 'monospaceSerif':\n          cue.fontFamily = 'Courier New,Liberation Mono,Courier,monospace';\n          break;\n        case 'proportionalSansSerif':\n          cue.fontFamily = 'Arial,Helvetica,Liberation Sans,sans-serif';\n          break;\n        case 'sansSerif':\n          cue.fontFamily = 'sans-serif';\n          break;\n        case 'monospaceSansSerif':\n          cue.fontFamily = 'Consolas,monospace';\n          break;\n        case 'proportionalSerif':\n          cue.fontFamily = 'serif';\n          break;\n        default:\n          cue.fontFamily = fontFamily;\n          break;\n      }\n    }\n\n    const fontWeight = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'fontWeight', shouldInheritRegionStyles);\n    if (fontWeight && fontWeight == 'bold') {\n      cue.fontWeight = Cue.fontWeight.BOLD;\n    }\n\n    const wrapOption = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'wrapOption', shouldInheritRegionStyles);\n    if (wrapOption && wrapOption == 'noWrap') {\n      cue.wrapLine = false;\n    } else {\n      cue.wrapLine = true;\n    }\n\n    const lineHeight = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'lineHeight', shouldInheritRegionStyles);\n    if (lineHeight && lineHeight.match(TtmlTextParser.unitValues_)) {\n      cue.lineHeight = lineHeight;\n    }\n\n    const fontSize = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'fontSize', shouldInheritRegionStyles);\n    if (fontSize) {\n      const isValidFontSizeUnit =\n          fontSize.match(TtmlTextParser.unitValues_) ||\n          fontSize.match(TtmlTextParser.percentValue_);\n\n      if (isValidFontSizeUnit) {\n        cue.fontSize = fontSize;\n      }\n    }\n\n    const fontStyle = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'fontStyle', shouldInheritRegionStyles);\n    if (fontStyle) {\n      goog.asserts.assert(fontStyle.toUpperCase() in Cue.fontStyle,\n          fontStyle.toUpperCase() +\n                          ' Should be in Cue.fontStyle values!');\n      cue.fontStyle = Cue.fontStyle[fontStyle.toUpperCase()];\n    }\n\n    if (imageElement) {\n      // According to the spec, we should use imageType (camelCase), but\n      // historically we have checked for imagetype (lowercase).\n      // This was the case since background image support was first introduced\n      // in PR #1859, in April 2019, and first released in v2.5.0.\n      // Now we check for both, although only imageType (camelCase) is to spec.\n      const backgroundImageType =\n          imageElement.getAttribute('imageType') ||\n          imageElement.getAttribute('imagetype');\n      const backgroundImageEncoding = imageElement.getAttribute('encoding');\n      const backgroundImageData = imageElement.textContent.trim();\n      if (backgroundImageType == 'PNG' &&\n          backgroundImageEncoding == 'Base64' &&\n          backgroundImageData) {\n        cue.backgroundImage = 'data:image/png;base64,' + backgroundImageData;\n      }\n    }\n\n    const textOutline = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'textOutline', shouldInheritRegionStyles);\n    if (textOutline) {\n      // tts:textOutline isn't natively supported by browsers, but it can be\n      // mostly replicated using the non-standard -webkit-text-stroke-width and\n      // -webkit-text-stroke-color properties.\n      const split = textOutline.split(' ');\n      if (split[0].match(TtmlTextParser.unitValues_)) {\n        // There is no defined color, so default to the text color.\n        cue.textStrokeColor = cue.color;\n      } else {\n        cue.textStrokeColor = split[0];\n        split.shift();\n      }\n      if (split[0] && split[0].match(TtmlTextParser.unitValues_)) {\n        cue.textStrokeWidth = split[0];\n      } else {\n        // If there is no width, or the width is not a number, don't draw a\n        // border.\n        cue.textStrokeColor = '';\n      }\n      // There is an optional blur radius also, but we have no way of\n      // replicating that, so ignore it.\n    }\n\n    const letterSpacing = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'letterSpacing', shouldInheritRegionStyles);\n    if (letterSpacing && letterSpacing.match(TtmlTextParser.unitValues_)) {\n      cue.letterSpacing = letterSpacing;\n    }\n\n    const linePadding = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'linePadding', shouldInheritRegionStyles);\n    if (linePadding && linePadding.match(TtmlTextParser.unitValues_)) {\n      cue.linePadding = linePadding;\n    }\n\n    const opacity = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'opacity', shouldInheritRegionStyles);\n    if (opacity) {\n      cue.opacity = parseFloat(opacity);\n    }\n\n    // Text decoration is an array of values which can come both from the\n    // element's style or be inherited from elements' parent nodes. All of those\n    // values should be applied as long as they don't contradict each other. If\n    // they do, elements' own style gets preference.\n    const textDecorationRegion = TtmlTextParser.getStyleAttributeFromRegion_(\n        region, styles, 'textDecoration');\n    if (textDecorationRegion) {\n      TtmlTextParser.addTextDecoration_(cue, textDecorationRegion);\n    }\n\n    const textDecorationElement = TtmlTextParser.getStyleAttributeFromElement_(\n        cueElement, styles, 'textDecoration');\n    if (textDecorationElement) {\n      TtmlTextParser.addTextDecoration_(cue, textDecorationElement);\n    }\n  }\n\n  /**\n   * Parses text decoration values and adds/removes them to/from the cue.\n   *\n   * @param {!shaka.text.Cue} cue\n   * @param {string} decoration\n   * @private\n   */\n  static addTextDecoration_(cue, decoration) {\n    const Cue = shaka.text.Cue;\n    for (const value of decoration.split(' ')) {\n      switch (value) {\n        case 'underline':\n          if (!cue.textDecoration.includes(Cue.textDecoration.UNDERLINE)) {\n            cue.textDecoration.push(Cue.textDecoration.UNDERLINE);\n          }\n          break;\n        case 'noUnderline':\n          if (cue.textDecoration.includes(Cue.textDecoration.UNDERLINE)) {\n            shaka.util.ArrayUtils.remove(cue.textDecoration,\n                Cue.textDecoration.UNDERLINE);\n          }\n          break;\n        case 'lineThrough':\n          if (!cue.textDecoration.includes(Cue.textDecoration.LINE_THROUGH)) {\n            cue.textDecoration.push(Cue.textDecoration.LINE_THROUGH);\n          }\n          break;\n        case 'noLineThrough':\n          if (cue.textDecoration.includes(Cue.textDecoration.LINE_THROUGH)) {\n            shaka.util.ArrayUtils.remove(cue.textDecoration,\n                Cue.textDecoration.LINE_THROUGH);\n          }\n          break;\n        case 'overline':\n          if (!cue.textDecoration.includes(Cue.textDecoration.OVERLINE)) {\n            cue.textDecoration.push(Cue.textDecoration.OVERLINE);\n          }\n          break;\n        case 'noOverline':\n          if (cue.textDecoration.includes(Cue.textDecoration.OVERLINE)) {\n            shaka.util.ArrayUtils.remove(cue.textDecoration,\n                Cue.textDecoration.OVERLINE);\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * Finds a specified attribute on either the original cue element or its\n   * associated region and returns the value if the attribute was found.\n   *\n   * @param {!Element} cueElement\n   * @param {Element} region\n   * @param {!Array.<!Element>} styles\n   * @param {string} attribute\n   * @param {boolean=} shouldInheritRegionStyles\n   * @return {?string}\n   * @private\n   */\n  static getStyleAttribute_(cueElement, region, styles, attribute,\n      shouldInheritRegionStyles=true) {\n    // An attribute can be specified on region level or in a styling block\n    // associated with the region or original element.\n    const TtmlTextParser = shaka.text.TtmlTextParser;\n    const attr = TtmlTextParser.getStyleAttributeFromElement_(\n        cueElement, styles, attribute);\n    if (attr) {\n      return attr;\n    }\n\n    if (shouldInheritRegionStyles) {\n      return TtmlTextParser.getStyleAttributeFromRegion_(\n          region, styles, attribute);\n    }\n    return null;\n  }\n\n  /**\n   * Finds a specified attribute on the element's associated region\n   * and returns the value if the attribute was found.\n   *\n   * @param {Element} region\n   * @param {!Array.<!Element>} styles\n   * @param {string} attribute\n   * @return {?string}\n   * @private\n   */\n  static getStyleAttributeFromRegion_(region, styles, attribute) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const ttsNs = shaka.text.TtmlTextParser.styleNs_;\n\n    if (!region) {\n      return null;\n    }\n\n    const attr = XmlUtils.getAttributeNSList(region, ttsNs, attribute);\n    if (attr) {\n      return attr;\n    }\n\n    return shaka.text.TtmlTextParser.getInheritedStyleAttribute_(\n        region, styles, attribute);\n  }\n\n  /**\n   * Finds a specified attribute on the cue element and returns the value\n   * if the attribute was found.\n   *\n   * @param {!Element} cueElement\n   * @param {!Array.<!Element>} styles\n   * @param {string} attribute\n   * @return {?string}\n   * @private\n   */\n  static getStyleAttributeFromElement_(cueElement, styles, attribute) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const ttsNs = shaka.text.TtmlTextParser.styleNs_;\n\n    // Styling on elements should take precedence\n    // over the main styling attributes\n    const elementAttribute = XmlUtils.getAttributeNSList(\n        cueElement,\n        ttsNs,\n        attribute);\n\n    if (elementAttribute) {\n      return elementAttribute;\n    }\n    return shaka.text.TtmlTextParser.getInheritedStyleAttribute_(\n        cueElement, styles, attribute);\n  }\n\n  /**\n   * Finds a specified attribute on an element's styles and the styles those\n   * styles inherit from.\n   *\n   * @param {!Element} element\n   * @param {!Array.<!Element>} styles\n   * @param {string} attribute\n   * @return {?string}\n   * @private\n   */\n  static getInheritedStyleAttribute_(element, styles, attribute) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const ttsNs = shaka.text.TtmlTextParser.styleNs_;\n    const ebuttsNs = shaka.text.TtmlTextParser.styleEbuttsNs_;\n\n    const inheritedStyles =\n        shaka.text.TtmlTextParser.getElementsFromCollection_(\n            element, 'style', styles, /* prefix= */ '');\n\n    let styleValue = null;\n\n    // The last value in our styles stack takes the precedence over the others\n    for (let i = 0; i < inheritedStyles.length; i++) {\n      // Check ebu namespace first.\n      let styleAttributeValue = XmlUtils.getAttributeNS(\n          inheritedStyles[i],\n          ebuttsNs,\n          attribute);\n\n      if (!styleAttributeValue) {\n        // Fall back to tts namespace.\n        styleAttributeValue = XmlUtils.getAttributeNSList(\n            inheritedStyles[i],\n            ttsNs,\n            attribute);\n      }\n\n      if (!styleAttributeValue) {\n        // Next, check inheritance.\n        // Styles can inherit from other styles, so traverse up that chain.\n        styleAttributeValue =\n            shaka.text.TtmlTextParser.getStyleAttributeFromElement_(\n                inheritedStyles[i], styles, attribute);\n      }\n\n      if (styleAttributeValue) {\n        styleValue = styleAttributeValue;\n      }\n    }\n\n    return styleValue;\n  }\n\n\n  /**\n   * Selects items from |collection| whose id matches |attributeName|\n   * from |element|.\n   *\n   * @param {Element} element\n   * @param {string} attributeName\n   * @param {!Array.<Element>} collection\n   * @param {string} prefixName\n   * @param {string=} nsName\n   * @return {!Array.<!Element>}\n   * @private\n   */\n  static getElementsFromCollection_(\n      element, attributeName, collection, prefixName, nsName) {\n    const items = [];\n\n    if (!element || collection.length < 1) {\n      return items;\n    }\n\n    const attributeValue = shaka.text.TtmlTextParser.getInheritedAttribute_(\n        element, attributeName, nsName);\n\n    if (attributeValue) {\n      // There could be multiple items in one attribute\n      // <span style=\"style1 style2\">A cue</span>\n      const itemNames = attributeValue.split(' ');\n\n      for (const name of itemNames) {\n        for (const item of collection) {\n          if ((prefixName + item.getAttribute('xml:id')) == name) {\n            items.push(item);\n            break;\n          }\n        }\n      }\n    }\n\n    return items;\n  }\n\n\n  /**\n   * Traverses upwards from a given node until a given attribute is found.\n   *\n   * @param {!Element} element\n   * @param {string} attributeName\n   * @param {string=} nsName\n   * @return {?string}\n   * @private\n   */\n  static getInheritedAttribute_(element, attributeName, nsName) {\n    let ret = null;\n    const XmlUtils = shaka.util.XmlUtils;\n    while (element) {\n      ret = nsName ?\n          XmlUtils.getAttributeNS(element, nsName, attributeName) :\n          element.getAttribute(attributeName);\n      if (ret) {\n        break;\n      }\n\n      // Element.parentNode can lead to XMLDocument, which is not an Element and\n      // has no getAttribute().\n      const parentNode = element.parentNode;\n      if (parentNode instanceof Element) {\n        element = parentNode;\n      } else {\n        break;\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * Factor parent/ancestor time attributes into the parsed time of a\n   * child/descendent.\n   *\n   * @param {!Element} parentElement\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @param {?number} start The child's start time\n   * @param {?number} end The child's end time\n   * @return {{start: ?number, end: ?number}}\n   * @private\n   */\n  static resolveTime_(parentElement, rateInfo, start, end) {\n    const parentTime = shaka.text.TtmlTextParser.parseTime_(\n        parentElement, rateInfo);\n\n    if (start == null) {\n      // No start time of your own?  Inherit from the parent.\n      start = parentTime.start;\n    } else {\n      // Otherwise, the start time is relative to the parent's start time.\n      if (parentTime.start != null) {\n        start += parentTime.start;\n      }\n    }\n\n    if (end == null) {\n      // No end time of your own?  Inherit from the parent.\n      end = parentTime.end;\n    } else {\n      // Otherwise, the end time is relative to the parent's _start_ time.\n      // This is not a typo.  Both times are relative to the parent's _start_.\n      if (parentTime.start != null) {\n        end += parentTime.start;\n      }\n    }\n\n    return {start, end};\n  }\n\n  /**\n   * Parse TTML time attributes from the given element.\n   *\n   * @param {!Element} element\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @return {{start: ?number, end: ?number}}\n   * @private\n   */\n  static parseTime_(element, rateInfo) {\n    const start = shaka.text.TtmlTextParser.parseTimeAttribute_(\n        element.getAttribute('begin'), rateInfo);\n    let end = shaka.text.TtmlTextParser.parseTimeAttribute_(\n        element.getAttribute('end'), rateInfo);\n    const duration = shaka.text.TtmlTextParser.parseTimeAttribute_(\n        element.getAttribute('dur'), rateInfo);\n    if (end == null && duration != null) {\n      end = start + duration;\n    }\n    return {start, end};\n  }\n\n  /**\n   * Parses a TTML time from the given attribute text.\n   *\n   * @param {string} text\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @return {?number}\n   * @private\n   */\n  static parseTimeAttribute_(text, rateInfo) {\n    let ret = null;\n    const TtmlTextParser = shaka.text.TtmlTextParser;\n\n    if (TtmlTextParser.timeColonFormatFrames_.test(text)) {\n      ret = TtmlTextParser.parseColonTimeWithFrames_(rateInfo, text);\n    } else if (TtmlTextParser.timeColonFormat_.test(text)) {\n      ret = TtmlTextParser.parseTimeFromRegex_(\n          TtmlTextParser.timeColonFormat_, text);\n    } else if (TtmlTextParser.timeColonFormatMilliseconds_.test(text)) {\n      ret = TtmlTextParser.parseTimeFromRegex_(\n          TtmlTextParser.timeColonFormatMilliseconds_, text);\n    } else if (TtmlTextParser.timeFramesFormat_.test(text)) {\n      ret = TtmlTextParser.parseFramesTime_(rateInfo, text);\n    } else if (TtmlTextParser.timeTickFormat_.test(text)) {\n      ret = TtmlTextParser.parseTickTime_(rateInfo, text);\n    } else if (TtmlTextParser.timeHMSFormat_.test(text)) {\n      ret = TtmlTextParser.parseTimeFromRegex_(\n          TtmlTextParser.timeHMSFormat_, text);\n    } else if (text) {\n      // It's not empty or null, but it doesn't match a known format.\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_TEXT_CUE,\n          'Could not parse cue time range in TTML');\n    }\n\n    return ret;\n  }\n\n  /**\n   * Parses a TTML time in frame format.\n   *\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @param {string} text\n   * @return {?number}\n   * @private\n   */\n  static parseFramesTime_(rateInfo, text) {\n    // 75f or 75.5f\n    const results = shaka.text.TtmlTextParser.timeFramesFormat_.exec(text);\n    const frames = Number(results[1]);\n\n    return frames / rateInfo.frameRate;\n  }\n\n  /**\n   * Parses a TTML time in tick format.\n   *\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @param {string} text\n   * @return {?number}\n   * @private\n   */\n  static parseTickTime_(rateInfo, text) {\n    // 50t or 50.5t\n    const results = shaka.text.TtmlTextParser.timeTickFormat_.exec(text);\n    const ticks = Number(results[1]);\n\n    return ticks / rateInfo.tickRate;\n  }\n\n  /**\n   * Parses a TTML colon formatted time containing frames.\n   *\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @param {string} text\n   * @return {?number}\n   * @private\n   */\n  static parseColonTimeWithFrames_(rateInfo, text) {\n    // 01:02:43:07 ('07' is frames) or 01:02:43:07.1 (subframes)\n    const results = shaka.text.TtmlTextParser.timeColonFormatFrames_.exec(text);\n\n    const hours = Number(results[1]);\n    const minutes = Number(results[2]);\n    let seconds = Number(results[3]);\n    let frames = Number(results[4]);\n    const subframes = Number(results[5]) || 0;\n\n    frames += subframes / rateInfo.subFrameRate;\n    seconds += frames / rateInfo.frameRate;\n\n    return seconds + (minutes * 60) + (hours * 3600);\n  }\n\n  /**\n   * Parses a TTML time with a given regex. Expects regex to be some\n   * sort of a time-matcher to match hours, minutes, seconds and milliseconds\n   *\n   * @param {!RegExp} regex\n   * @param {string} text\n   * @return {?number}\n   * @private\n   */\n  static parseTimeFromRegex_(regex, text) {\n    const results = regex.exec(text);\n    if (results == null || results[0] == '') {\n      return null;\n    }\n    // This capture is optional, but will still be in the array as undefined,\n    // in which case it is 0.\n    const hours = Number(results[1]) || 0;\n    const minutes = Number(results[2]) || 0;\n    const seconds = Number(results[3]) || 0;\n    const milliseconds = Number(results[4]) || 0;\n\n    return (milliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);\n  }\n\n  /**\n   * If ttp:cellResolution provided returns cell resolution info\n   * with number of columns and rows into which the Root Container\n   * Region area is divided\n   *\n   * @param {?string} cellResolution\n   * @return {?{columns: number, rows: number}}\n   * @private\n   */\n  static getCellResolution_(cellResolution) {\n    if (!cellResolution) {\n      return null;\n    }\n    const matches = /^(\\d+) (\\d+)$/.exec(cellResolution);\n\n    if (!matches) {\n      return null;\n    }\n\n    const columns = parseInt(matches[1], 10);\n    const rows = parseInt(matches[2], 10);\n\n    return {columns, rows};\n  }\n};\n\n/**\n * @summary\n * Contains information about frame/subframe rate\n * and frame rate multiplier for time in frame format.\n *\n * @example 01:02:03:04(4 frames) or 01:02:03:04.1(4 frames, 1 subframe)\n * @private\n */\nshaka.text.TtmlTextParser.RateInfo_ = class {\n  /**\n   * @param {?string} frameRate\n   * @param {?string} subFrameRate\n   * @param {?string} frameRateMultiplier\n   * @param {?string} tickRate\n   */\n  constructor(frameRate, subFrameRate, frameRateMultiplier, tickRate) {\n    /**\n     * @type {number}\n     */\n    this.frameRate = Number(frameRate) || 30;\n\n    /**\n     * @type {number}\n     */\n    this.subFrameRate = Number(subFrameRate) || 1;\n\n    /**\n     * @type {number}\n     */\n    this.tickRate = Number(tickRate);\n    if (this.tickRate == 0) {\n      if (frameRate) {\n        this.tickRate = this.frameRate * this.subFrameRate;\n      } else {\n        this.tickRate = 1;\n      }\n    }\n\n    if (frameRateMultiplier) {\n      const multiplierResults = /^(\\d+) (\\d+)$/g.exec(frameRateMultiplier);\n      if (multiplierResults) {\n        const numerator = Number(multiplierResults[1]);\n        const denominator = Number(multiplierResults[2]);\n        const multiplierNum = numerator / denominator;\n        this.frameRate *= multiplierNum;\n      }\n    }\n  }\n};\n\n/**\n * @const\n * @private {!RegExp}\n * @example 50.17% 10%\n */\nshaka.text.TtmlTextParser.percentValues_ =\n    /^(\\d{1,2}(?:\\.\\d+)?|100(?:\\.0+)?)% (\\d{1,2}(?:\\.\\d+)?|100(?:\\.0+)?)%$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 0.6% 90%\n */\nshaka.text.TtmlTextParser.percentValue_ = /^(\\d{1,2}(?:\\.\\d+)?|100)%$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 100px, 8em, 0.80c\n */\nshaka.text.TtmlTextParser.unitValues_ = /^(\\d+px|\\d+em|\\d*\\.?\\d+c)$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 100px\n */\nshaka.text.TtmlTextParser.pixelValues_ = /^(\\d+)px (\\d+)px$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)\n */\nshaka.text.TtmlTextParser.timeColonFormatFrames_ =\n    /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 00:00:40 or 00:40\n */\nshaka.text.TtmlTextParser.timeColonFormat_ = /^(?:(\\d{2,}):)?(\\d{2}):(\\d{2})$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 01:02:43.0345555 or 02:43.03\n */\nshaka.text.TtmlTextParser.timeColonFormatMilliseconds_ =\n    /^(?:(\\d{2,}):)?(\\d{2}):(\\d{2}\\.\\d{2,})$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 75f or 75.5f\n */\nshaka.text.TtmlTextParser.timeFramesFormat_ = /^(\\d*(?:\\.\\d*)?)f$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 50t or 50.5t\n */\nshaka.text.TtmlTextParser.timeTickFormat_ = /^(\\d*(?:\\.\\d*)?)t$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 3.45h, 3m or 4.20s\n */\nshaka.text.TtmlTextParser.timeHMSFormat_ =\n    new RegExp(['^(?:(\\\\d*(?:\\\\.\\\\d*)?)h)?',\n      '(?:(\\\\d*(?:\\\\.\\\\d*)?)m)?',\n      '(?:(\\\\d*(?:\\\\.\\\\d*)?)s)?',\n      '(?:(\\\\d*(?:\\\\.\\\\d*)?)ms)?$'].join(''));\n\n/**\n * @const\n * @private {!Object.<string, shaka.text.Cue.lineAlign>}\n */\nshaka.text.TtmlTextParser.textAlignToLineAlign_ = {\n  'left': shaka.text.Cue.lineAlign.START,\n  'center': shaka.text.Cue.lineAlign.CENTER,\n  'right': shaka.text.Cue.lineAlign.END,\n  'start': shaka.text.Cue.lineAlign.START,\n  'end': shaka.text.Cue.lineAlign.END,\n};\n\n/**\n * @const\n * @private {!Object.<string, shaka.text.Cue.positionAlign>}\n */\nshaka.text.TtmlTextParser.textAlignToPositionAlign_ = {\n  'left': shaka.text.Cue.positionAlign.LEFT,\n  'center': shaka.text.Cue.positionAlign.CENTER,\n  'right': shaka.text.Cue.positionAlign.RIGHT,\n};\n\n/**\n * The namespace URL for TTML parameters.  Can be assigned any name in the TTML\n * document, not just \"ttp:\", so we use this with getAttributeNS() to ensure\n * that we support arbitrary namespace names.\n *\n * @const {!Array.<string>}\n * @private\n */\nshaka.text.TtmlTextParser.parameterNs_ = [\n  'http://www.w3.org/ns/ttml#parameter',\n  'http://www.w3.org/2006/10/ttaf1#parameter',\n];\n\n/**\n * The namespace URL for TTML styles.  Can be assigned any name in the TTML\n * document, not just \"tts:\", so we use this with getAttributeNS() to ensure\n * that we support arbitrary namespace names.\n *\n * @const {!Array.<string>}\n * @private\n */\nshaka.text.TtmlTextParser.styleNs_ = [\n  'http://www.w3.org/ns/ttml#styling',\n  'http://www.w3.org/2006/10/ttaf1#styling',\n];\n\n/**\n * The namespace URL for EBU TTML styles.  Can be assigned any name in the TTML\n * document, not just \"ebutts:\", so we use this with getAttributeNS() to ensure\n * that we support arbitrary namespace names.\n *\n * @const {string}\n * @private\n */\nshaka.text.TtmlTextParser.styleEbuttsNs_ = 'urn:ebu:tt:style';\n\n/**\n * The supported namespace URLs for SMPTE fields.\n * @const {!Array.<string>}\n * @private\n */\nshaka.text.TtmlTextParser.smpteNsList_ = [\n  'http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt',\n  'http://www.smpte-ra.org/schemas/2052-1/2013/smpte-tt',\n];\n\nshaka.text.TextEngine.registerParser(\n    'application/ttml+xml', () => new shaka.text.TtmlTextParser());\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.Mp4TtmlParser');\n\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.text.TtmlTextParser');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Mp4Parser');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.Mp4TtmlParser = class {\n  /** */\n  constructor() {\n    /**\n     * @type {!shaka.extern.TextParser}\n     * @private\n     */\n    this.parser_ = new shaka.text.TtmlTextParser();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    const Mp4Parser = shaka.util.Mp4Parser;\n\n    let sawSTPP = false;\n\n    new Mp4Parser()\n        .box('moov', Mp4Parser.children)\n        .box('trak', Mp4Parser.children)\n        .box('mdia', Mp4Parser.children)\n        .box('minf', Mp4Parser.children)\n        .box('stbl', Mp4Parser.children)\n        .fullBox('stsd', Mp4Parser.sampleDescription)\n        .box('stpp', (box) => {\n          sawSTPP = true;\n          box.parser.stop();\n        }).parse(data);\n\n    if (!sawSTPP) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_TTML);\n    }\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const Mp4Parser = shaka.util.Mp4Parser;\n\n    let sawMDAT = false;\n    let payload = [];\n\n    const parser = new Mp4Parser()\n        .box('mdat', Mp4Parser.allData((data) => {\n          sawMDAT = true;\n          // Join this to any previous payload, in case the mp4 has multiple\n          // mdats.\n          payload = payload.concat(this.parser_.parseMedia(data, time));\n        }));\n    parser.parse(data, /* partialOkay= */ false);\n\n    if (!sawMDAT) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_TTML);\n    }\n\n    return payload;\n  }\n};\n\n\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"stpp\"', () => new shaka.text.Mp4TtmlParser());\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"stpp.ttml\"',\n    () => new shaka.text.Mp4TtmlParser());\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"stpp.ttml.im1t\"',\n    () => new shaka.text.Mp4TtmlParser());\n// Legacy codec string uses capital \"TTML\", i.e.: prior to HLS rfc8216bis:\n//   Note that if a Variant Stream specifies one or more Renditions that\n//   include IMSC subtitles, the CODECS attribute MUST indicate this with a\n//   format identifier such as \"stpp.ttml.im1t\".\n// (https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-05#section-4.4.5.2)\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"stpp.TTML.im1t\"',\n    () => new shaka.text.Mp4TtmlParser());\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.VttTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.CueRegion');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.VttTextParser = class {\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    goog.asserts.assert(false, 'VTT does not have init segments');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const VttTextParser = shaka.text.VttTextParser;\n    // Get the input as a string.  Normalize newlines to \\n.\n    let str = shaka.util.StringUtils.fromUTF8(data);\n    str = str.replace(/\\r\\n|\\r(?=[^\\n]|$)/gm, '\\n');\n    const blocks = str.split(/\\n{2,}/m);\n\n    if (!/^WEBVTT($|[ \\t\\n])/m.test(blocks[0])) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_TEXT_HEADER);\n    }\n\n    // NOTE: \"periodStart\" is the timestamp offset applied via TextEngine.\n    // It is no longer closely tied to periods, but the name stuck around.\n    let offset = time.periodStart;\n\n    if (blocks[0].includes('X-TIMESTAMP-MAP')) {\n      // https://bit.ly/2K92l7y\n      // The 'X-TIMESTAMP-MAP' header is used in HLS to align text with\n      // the rest of the media.\n      // The header format is 'X-TIMESTAMP-MAP=MPEGTS:n,LOCAL:m'\n      // (the attributes can go in any order)\n      // where n is MPEG-2 time and m is cue time it maps to.\n      // For example 'X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:900000'\n      // means an offset of 10 seconds\n      // 900000/MPEG_TIMESCALE - cue time.\n      const cueTimeMatch =\n            blocks[0].match(/LOCAL:((?:(\\d{1,}):)?(\\d{2}):(\\d{2})\\.(\\d{3}))/m);\n\n      const mpegTimeMatch = blocks[0].match(/MPEGTS:(\\d+)/m);\n      if (cueTimeMatch && mpegTimeMatch) {\n        const parser = new shaka.util.TextParser(cueTimeMatch[1]);\n        const cueTime = shaka.text.VttTextParser.parseTime_(parser);\n        if (cueTime == null) {\n          throw new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.TEXT,\n              shaka.util.Error.Code.INVALID_TEXT_HEADER);\n        }\n\n        let mpegTime = Number(mpegTimeMatch[1]);\n        const mpegTimescale = shaka.text.VttTextParser.MPEG_TIMESCALE_;\n\n        const rolloverSeconds =\n            shaka.text.VttTextParser.TS_ROLLOVER_ / mpegTimescale;\n        let segmentStart = time.segmentStart;\n        while (segmentStart >= rolloverSeconds) {\n          segmentStart -= rolloverSeconds;\n          mpegTime += shaka.text.VttTextParser.TS_ROLLOVER_;\n        }\n\n        // Apple-encoded HLS content uses absolute timestamps, so assume the\n        // presence of the map tag means the content uses absolute timestamps.\n        offset = time.periodStart + mpegTime / mpegTimescale - cueTime;\n      }\n    }\n\n    // Parse VTT regions.\n    /* !Array.<!shaka.extern.CueRegion> */\n    const regions = [];\n    for (const line of blocks[0].split('\\n')) {\n      if (/^Region:/.test(line)) {\n        const region = VttTextParser.parseRegion_(line);\n        regions.push(region);\n      }\n    }\n\n    /** @type {!Map.<string, shaka.text.Cue>} */\n    const styles = new Map();\n    VttTextParser.addDefaultTextColor_(styles);\n\n    // Parse cues.\n    const ret = [];\n    for (const block of blocks.slice(1)) {\n      const lines = block.split('\\n');\n      VttTextParser.parseStyle_(lines, styles);\n      const cue = VttTextParser.parseCue_(lines, offset, regions, styles);\n      if (cue) {\n        ret.push(cue);\n      }\n    }\n\n    return ret;\n  }\n\n  /**\n   * Add default color\n   *\n   * @param {!Map.<string, shaka.text.Cue>} styles\n   * @private\n   */\n  static addDefaultTextColor_(styles) {\n    const textColor = shaka.text.Cue.defaultTextColor;\n    for (const [key, value] of Object.entries(textColor)) {\n      const cue = new shaka.text.Cue(0, 0, '');\n      cue.color = value;\n      styles.set('.' + key, cue);\n    }\n\n    const bgColor = shaka.text.Cue.defaultTextBackgroundColor;\n    for (const [key, value] of Object.entries(bgColor)) {\n      const cue = new shaka.text.Cue(0, 0, '');\n      cue.backgroundColor = value;\n      styles.set('.' + key, cue);\n    }\n  }\n\n  /**\n   * Parses a string into a Region object.\n   *\n   * @param {string} text\n   * @return {!shaka.extern.CueRegion}\n   * @private\n   */\n  static parseRegion_(text) {\n    const VttTextParser = shaka.text.VttTextParser;\n    const parser = new shaka.util.TextParser(text);\n    // The region string looks like this:\n    // Region: id=fred width=50% lines=3 regionanchor=0%,100%\n    //         viewportanchor=10%,90% scroll=up\n    const region = new shaka.text.CueRegion();\n\n    // Skip 'Region:'\n    parser.readWord();\n    parser.skipWhitespace();\n\n    let word = parser.readWord();\n    while (word) {\n      if (!VttTextParser.parseRegionSetting_(region, word)) {\n        shaka.log.warning(\n            'VTT parser encountered an invalid VTTRegion setting: ', word,\n            ' The setting will be ignored.');\n      }\n      parser.skipWhitespace();\n      word = parser.readWord();\n    }\n\n    return region;\n  }\n\n  /**\n   * Parses a style block into a Cue object.\n   *\n   * @param {!Array.<string>} text\n   * @param {!Map.<string, shaka.text.Cue>} styles\n   * @private\n   */\n  static parseStyle_(text, styles) {\n    // Skip empty blocks.\n    if (text.length == 1 && !text[0]) {\n      return;\n    }\n\n    // Skip comment blocks.\n    if (/^NOTE($|[ \\t])/.test(text[0])) {\n      return;\n    }\n\n    // Only style block are allowed.\n    if (text[0] != 'STYLE') {\n      return;\n    }\n\n    /** @type {!Array.<!Array.<string>>} */\n    const styleBlocks = [];\n    let lastBlockIndex = -1;\n    for (let i = 1; i < text.length; i++) {\n      if (text[i].includes('::cue')) {\n        styleBlocks.push([]);\n        lastBlockIndex = styleBlocks.length - 1;\n      }\n      if (lastBlockIndex == -1) {\n        continue;\n      }\n      styleBlocks[lastBlockIndex].push(text[i]);\n      if (text[i].includes('}')) {\n        lastBlockIndex = -1;\n      }\n    }\n\n    for (const styleBlock of styleBlocks) {\n      let styleSelector = 'global';\n      // Look for what is within parentheses. For example:\n      // <code>:: cue (b) {</code>, what we are looking for is <code>b</code>\n      const selector = styleBlock[0].match(/\\((.*)\\)/);\n      if (selector) {\n        styleSelector = selector.pop();\n      }\n\n      // We start at 1 to avoid '::cue' and end earlier to avoid '}'\n      let propertyLines = styleBlock.slice(1, -1);\n      if (styleBlock[0].includes('}')) {\n        const payload = /\\{(.*?)\\}/.exec(styleBlock[0]);\n        if (payload) {\n          propertyLines = payload[1].split(';');\n        }\n      }\n\n      // Continue styles over multiple selectors if necessary.\n      // For example,\n      //   ::cue(b) { background: white; } ::cue(b) { color: blue; }\n      // should set both the background and foreground of bold tags.\n      let cue = styles.get(styleSelector);\n      if (!cue) {\n        cue = new shaka.text.Cue(0, 0, '');\n      }\n\n      let validStyle = false;\n      for (let i = 0; i < propertyLines.length; i++) {\n        // We look for CSS properties. As a general rule they are separated by\n        // <code>:</code>. Eg: <code>color: red;</code>\n        const lineParts = /^\\s*([^:]+):\\s*(.*)/.exec(propertyLines[i]);\n        if (lineParts) {\n          const name = lineParts[1].trim();\n          const value = lineParts[2].trim().replace(';', '');\n          switch (name) {\n            case 'background-color':\n            case 'background':\n              validStyle = true;\n              cue.backgroundColor = value;\n              break;\n            case 'color':\n              validStyle = true;\n              cue.color = value;\n              break;\n            case 'font-family':\n              validStyle = true;\n              cue.fontFamily = value;\n              break;\n            case 'font-size':\n              validStyle = true;\n              cue.fontSize = value;\n              break;\n            case 'font-weight':\n              if (parseInt(value, 10) >= 700 || value == 'bold') {\n                validStyle = true;\n                cue.fontWeight = shaka.text.Cue.fontWeight.BOLD;\n              }\n              break;\n            case 'font-style':\n              switch (value) {\n                case 'normal':\n                  validStyle = true;\n                  cue.fontStyle = shaka.text.Cue.fontStyle.NORMAL;\n                  break;\n                case 'italic':\n                  validStyle = true;\n                  cue.fontStyle = shaka.text.Cue.fontStyle.ITALIC;\n                  break;\n                case 'oblique':\n                  validStyle = true;\n                  cue.fontStyle = shaka.text.Cue.fontStyle.OBLIQUE;\n                  break;\n              }\n              break;\n            case 'opacity':\n              validStyle = true;\n              cue.opacity = parseFloat(value);\n              break;\n            case 'text-shadow':\n              validStyle = true;\n              cue.textShadow = value;\n              break;\n            case 'white-space':\n              validStyle = true;\n              cue.wrapLine = value != 'noWrap';\n              break;\n            default:\n              shaka.log.warning('VTT parser encountered an unsupported style: ',\n                  lineParts);\n              break;\n          }\n        }\n      }\n\n      if (validStyle) {\n        styles.set(styleSelector, cue);\n      }\n    }\n  }\n\n  /**\n   * Parses a text block into a Cue object.\n   *\n   * @param {!Array.<string>} text\n   * @param {number} timeOffset\n   * @param {!Array.<!shaka.extern.CueRegion>} regions\n   * @param {!Map.<string, shaka.text.Cue>} styles\n   * @return {shaka.text.Cue}\n   * @private\n   */\n  static parseCue_(text, timeOffset, regions, styles) {\n    const VttTextParser = shaka.text.VttTextParser;\n\n    // Skip empty blocks.\n    if (text.length == 1 && !text[0]) {\n      return null;\n    }\n\n    // Skip comment blocks.\n    if (/^NOTE($|[ \\t])/.test(text[0])) {\n      return null;\n    }\n\n    // Skip style and region blocks.\n    if (text[0] == 'STYLE' || text[0] == 'REGION') {\n      return null;\n    }\n\n    let id = null;\n    if (!text[0].includes('-->')) {\n      id = text[0];\n      text.splice(0, 1);\n    }\n\n    // Parse the times.\n    const parser = new shaka.util.TextParser(text[0]);\n    let start = VttTextParser.parseTime_(parser);\n    const expect = parser.readRegex(/[ \\t]+-->[ \\t]+/g);\n    let end = VttTextParser.parseTime_(parser);\n\n    if (start == null || expect == null || end == null) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_TEXT_CUE,\n          'Could not parse cue time range in WebVTT');\n    }\n\n    start += timeOffset;\n    end += timeOffset;\n\n    // Get the payload.\n    const payload = text.slice(1).join('\\n').trim();\n\n    let cue = null;\n    if (styles.has('global')) {\n      cue = styles.get('global').clone();\n      cue.startTime = start;\n      cue.endTime = end;\n      cue.payload = '';\n    } else {\n      cue = new shaka.text.Cue(start, end, '');\n    }\n\n    VttTextParser.parseCueStyles(payload, cue, styles);\n\n    // Parse optional settings.\n    parser.skipWhitespace();\n    let word = parser.readWord();\n    while (word) {\n      if (!VttTextParser.parseCueSetting(cue, word, regions)) {\n        shaka.log.warning('VTT parser encountered an invalid VTT setting: ',\n            word,\n            ' The setting will be ignored.');\n      }\n      parser.skipWhitespace();\n      word = parser.readWord();\n    }\n\n    if (id != null) {\n      cue.id = id;\n    }\n    return cue;\n  }\n\n  /**\n   * Parses a WebVTT styles from the given payload.\n   *\n   * @param {string} payload\n   * @param {!shaka.text.Cue} rootCue\n   * @param {!Map.<string, shaka.text.Cue>} styles\n   */\n  static parseCueStyles(payload, rootCue, styles) {\n    const VttTextParser = shaka.text.VttTextParser;\n    if (styles.size === 0) {\n      VttTextParser.addDefaultTextColor_(styles);\n    }\n    payload = VttTextParser.replaceColorPayload_(payload);\n    payload = VttTextParser.replaceVoiceStylePayload_(payload);\n    const xmlPayload = '<span>' + payload + '</span>';\n    const element = shaka.util.XmlUtils.parseXmlString(xmlPayload, 'span');\n    if (element) {\n      /** @type {!Array.<!shaka.extern.Cue>} */\n      const cues = [];\n      const childNodes = element.childNodes;\n      if (childNodes.length == 1) {\n        const childNode = childNodes[0];\n        if (childNode.nodeType == Node.TEXT_NODE ||\n            childNode.nodeType == Node.CDATA_SECTION_NODE) {\n          rootCue.payload = VttTextParser.htmlUnescape_(payload);\n          return;\n        }\n      }\n      for (const childNode of childNodes) {\n        VttTextParser.generateCueFromElement_(\n            childNode, rootCue, cues, styles);\n      }\n      rootCue.nestedCues = cues;\n    } else {\n      shaka.log.warning('The cue\\'s markup could not be parsed: ', payload);\n      rootCue.payload = VttTextParser.htmlUnescape_(payload);\n    }\n  }\n\n  /**\n   * Converts voice style tag to be valid for xml parsing\n   * For example,\n   * input: <v Shaka>Test\n   * output: <v.voice-Shaka>Test</v.voice-Shaka>\n   *\n   * @param {string} payload\n   * @return {string} processed payload\n   * @private\n   */\n  static replaceVoiceStylePayload_(payload) {\n    const voiceTag = 'v';\n    const names = [];\n    let nameStart = -1;\n    let newPayload = '';\n    let hasVoiceEndTag = false;\n    for (let i = 0; i < payload.length; i++) {\n      // This condition is used to manage tags that have end tags.\n      if (payload[i] === '/') {\n        const end = payload.indexOf('>', i);\n        if (end === -1) {\n          return payload;\n        }\n        const tagEnd = payload.substring(i + 1, end);\n        if (!tagEnd || tagEnd != voiceTag) {\n          newPayload += payload[i];\n          continue;\n        }\n        hasVoiceEndTag = true;\n        let tagStart = null;\n        if (names.length) {\n          tagStart = names[names.length -1];\n        }\n        if (!tagStart) {\n          newPayload += payload[i];\n        } else if (tagStart === tagEnd) {\n          newPayload += '/' + tagEnd + '>';\n          i += tagEnd.length + 1;\n        } else {\n          if (!tagStart.startsWith(voiceTag)) {\n            newPayload += payload[i];\n            continue;\n          }\n          newPayload += '/' + tagStart + '>';\n          i += tagEnd.length + 1;\n        }\n      } else {\n        // Here we only want the tag name, not any other payload.\n        if (payload[i] === '<') {\n          nameStart = i + 1;\n          if (payload[nameStart] != voiceTag) {\n            nameStart = -1;\n          }\n        } else if (payload[i] === '>') {\n          if (nameStart > 0) {\n            names.push(payload.substr(nameStart, i - nameStart));\n            nameStart = -1;\n          }\n        }\n        newPayload += payload[i];\n      }\n    }\n    for (const name of names) {\n      const newName = name.replace(' ', '.voice-');\n      newPayload = newPayload.replace(`<${name}>`, `<${newName}>`);\n      newPayload = newPayload.replace(`</${name}>`, `</${newName}>`);\n      if (!hasVoiceEndTag) {\n        newPayload += `</${newName}>`;\n      }\n    }\n    return newPayload;\n  }\n\n  /**\n   * Converts color end tag to be valid for xml parsing\n   * For example,\n   * input: <c.yellow.bg_blue>Yellow text on blue bg</c>\n   * output: <c.yellow.bg_blue>Yellow text on blue bg</c.yellow.bg_blue>\n   *\n   * Returns original payload if invalid tag is found.\n   * Invalid tag example: <c.yellow><b>Example</c></b>\n   *\n   * @param {string} payload\n   * @return {string} processed payload\n   * @private\n   */\n  static replaceColorPayload_(payload) {\n    const names = [];\n    let nameStart = -1;\n    let newPayload = '';\n    for (let i = 0; i < payload.length; i++) {\n      if (payload[i] === '/' && i > 0 && payload[i - 1] === '<') {\n        const end = payload.indexOf('>', i);\n        if (end <= i) {\n          return payload;\n        }\n        const tagEnd = payload.substring(i + 1, end);\n        if (!tagEnd || tagEnd !== 'c') {\n          newPayload += payload[i];\n          continue;\n        }\n        const tagStart = names.pop();\n        if (!tagStart) {\n          newPayload += payload[i];\n        } else if (tagStart === tagEnd) {\n          newPayload += '/' + tagEnd + '>';\n          i += tagEnd.length + 1;\n        } else {\n          if (!tagStart.startsWith('c.')) {\n            newPayload += payload[i];\n            continue;\n          }\n          i += tagEnd.length + 1;\n          newPayload += '/' + tagStart + '>';\n        }\n      } else {\n        if (payload[i] === '<') {\n          nameStart = i + 1;\n          if (payload[nameStart] != 'c') {\n            nameStart = -1;\n          }\n        } else if (payload[i] === '>') {\n          if (nameStart > 0) {\n            names.push(payload.substr(nameStart, i - nameStart));\n            nameStart = -1;\n          }\n        }\n        newPayload += payload[i];\n      }\n    }\n    return newPayload;\n  }\n\n  /**\n   * @param {string} value\n   * @param {string} defaultValue\n   * @private\n   */\n  static getOrDefault_(value, defaultValue) {\n    if (value && value.length > 0) {\n      return value;\n    }\n    return defaultValue;\n  }\n\n  /**\n   * Merges values created in parseStyle_\n   * @param {!shaka.extern.Cue} cue\n   * @param {shaka.extern.Cue} refCue\n   * @private\n   */\n  static mergeStyle_(cue, refCue) {\n    if (!refCue) {\n      return;\n    }\n\n    const VttTextParser = shaka.text.VttTextParser;\n    // Overwrites if new value string length > 0\n    cue.backgroundColor = VttTextParser.getOrDefault_(\n        refCue.backgroundColor, cue.backgroundColor);\n    cue.color = VttTextParser.getOrDefault_(\n        refCue.color, cue.color);\n    cue.fontFamily = VttTextParser.getOrDefault_(\n        refCue.fontFamily, cue.fontFamily);\n    cue.fontSize = VttTextParser.getOrDefault_(\n        refCue.fontSize, cue.fontSize);\n\n    // Overwrite with new values as unable to determine\n    // if new value is set or not\n    cue.fontWeight = refCue.fontWeight;\n    cue.fontStyle = refCue.fontStyle;\n    cue.opacity = refCue.opacity;\n    cue.wrapLine = refCue.wrapLine;\n  }\n\n  /**\n   * @param {!Node} element\n   * @param {!shaka.text.Cue} rootCue\n   * @param {Array.<!shaka.extern.Cue>} cues\n   * @param {!Map.<string, shaka.text.Cue>} styles\n   * @private\n   */\n  static generateCueFromElement_(element, rootCue, cues, styles) {\n    const VttTextParser = shaka.text.VttTextParser;\n    const nestedCue = rootCue.clone();\n    if (element.nodeType === Node.ELEMENT_NODE && element.nodeName) {\n      const bold = shaka.text.Cue.fontWeight.BOLD;\n      const italic = shaka.text.Cue.fontStyle.ITALIC;\n      const underline = shaka.text.Cue.textDecoration.UNDERLINE;\n      const tags = element.nodeName.split(/(?=[ .])+/g);\n      for (const tag of tags) {\n        let styleTag = tag;\n        // White blanks at start indicate that the style is a voice\n        if (styleTag.startsWith('.voice-')) {\n          const voice = styleTag.split('-').pop();\n          styleTag = `v[voice=\"${voice}\"]`;\n          // The specification allows to have quotes and not, so we check to\n          // see which one is being used.\n          if (!styles.has(styleTag)) {\n            styleTag = `v[voice=${voice}]`;\n          }\n        }\n        if (styles.has(styleTag)) {\n          VttTextParser.mergeStyle_(nestedCue, styles.get(styleTag));\n        }\n        switch (tag) {\n          case 'br': {\n            const lineBreakCue = rootCue.clone();\n            lineBreakCue.lineBreak = true;\n            cues.push(lineBreakCue);\n            break;\n          }\n          case 'b':\n            nestedCue.fontWeight = bold;\n            break;\n          case 'i':\n            nestedCue.fontStyle = italic;\n            break;\n          case 'u':\n            nestedCue.textDecoration.push(underline);\n            break;\n          default:\n            break;\n        }\n      }\n    }\n    const isTextNode = shaka.util.XmlUtils.isText(element);\n    if (isTextNode) {\n      // Trailing line breaks may lost when convert cue to HTML tag\n      // Need to insert line break cue to preserve line breaks\n      const textArr = element.textContent.split('\\n');\n      let isFirst = true;\n      for (const text of textArr) {\n        if (!isFirst) {\n          const lineBreakCue = rootCue.clone();\n          lineBreakCue.lineBreak = true;\n          cues.push(lineBreakCue);\n        }\n        if (text.length > 0) {\n          const textCue = nestedCue.clone();\n          textCue.payload = VttTextParser.htmlUnescape_(text);\n          cues.push(textCue);\n        }\n        isFirst = false;\n      }\n    } else {\n      for (const childNode of element.childNodes) {\n        VttTextParser.generateCueFromElement_(\n            childNode, nestedCue, cues, styles);\n      }\n    }\n  }\n\n  /**\n   * Parses a WebVTT setting from the given word.\n   *\n   * @param {!shaka.text.Cue} cue\n   * @param {string} word\n   * @param {!Array.<!shaka.text.CueRegion>} regions\n   * @return {boolean} True on success.\n   */\n  static parseCueSetting(cue, word, regions) {\n    const VttTextParser = shaka.text.VttTextParser;\n    let results = null;\n    if ((results = /^align:(start|middle|center|end|left|right)$/.exec(word))) {\n      VttTextParser.setTextAlign_(cue, results[1]);\n    } else if ((results = /^vertical:(lr|rl)$/.exec(word))) {\n      VttTextParser.setVerticalWritingMode_(cue, results[1]);\n    } else if ((results = /^size:([\\d.]+)%$/.exec(word))) {\n      cue.size = Number(results[1]);\n    } else if ((results =\n        /^position:([\\d.]+)%(?:,(line-left|line-right|center|start|end))?$/\n            .exec(word))) {\n      cue.position = Number(results[1]);\n      if (results[2]) {\n        VttTextParser.setPositionAlign_(cue, results[2]);\n      }\n    } else if ((results = /^region:(.*)$/.exec(word))) {\n      const region = VttTextParser.getRegionById_(regions, results[1]);\n      if (region) {\n        cue.region = region;\n      }\n    } else {\n      return VttTextParser.parsedLineValueAndInterpretation_(cue, word);\n    }\n\n    return true;\n  }\n\n  /**\n   *\n   * @param {!Array.<!shaka.text.CueRegion>} regions\n   * @param {string} id\n   * @return {?shaka.text.CueRegion}\n   * @private\n   */\n  static getRegionById_(regions, id) {\n    const regionsWithId = regions.filter((region) => {\n      return region.id == id;\n    });\n    if (!regionsWithId.length) {\n      shaka.log.warning('VTT parser could not find a region with id: ',\n          id,\n          ' The region will be ignored.');\n      return null;\n    }\n    goog.asserts.assert(regionsWithId.length == 1,\n        'VTTRegion ids should be unique!');\n\n    return regionsWithId[0];\n  }\n\n  /**\n   * Parses a WebVTTRegion setting from the given word.\n   *\n   * @param {!shaka.text.CueRegion} region\n   * @param {string} word\n   * @return {boolean} True on success.\n   * @private\n   */\n  static parseRegionSetting_(region, word) {\n    let results = null;\n    if ((results = /^id=(.*)$/.exec(word))) {\n      region.id = results[1];\n    } else if ((results = /^width=(\\d{1,2}|100)%$/.exec(word))) {\n      region.width = Number(results[1]);\n    } else if ((results = /^lines=(\\d+)$/.exec(word))) {\n      region.height = Number(results[1]);\n      region.heightUnits = shaka.text.CueRegion.units.LINES;\n    } else if ((results = /^regionanchor=(\\d{1,2}|100)%,(\\d{1,2}|100)%$/\n        .exec(word))) {\n      region.regionAnchorX = Number(results[1]);\n      region.regionAnchorY = Number(results[2]);\n    } else if ((results = /^viewportanchor=(\\d{1,2}|100)%,(\\d{1,2}|100)%$/\n        .exec(word))) {\n      region.viewportAnchorX = Number(results[1]);\n      region.viewportAnchorY = Number(results[2]);\n    } else if ((results = /^scroll=up$/.exec(word))) {\n      region.scroll = shaka.text.CueRegion.scrollMode.UP;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {!shaka.text.Cue} cue\n   * @param {string} align\n   * @private\n   */\n  static setTextAlign_(cue, align) {\n    const Cue = shaka.text.Cue;\n    if (align == 'middle') {\n      cue.textAlign = Cue.textAlign.CENTER;\n    } else {\n      goog.asserts.assert(align.toUpperCase() in Cue.textAlign,\n          align.toUpperCase() +\n                          ' Should be in Cue.textAlign values!');\n\n      cue.textAlign = Cue.textAlign[align.toUpperCase()];\n    }\n  }\n\n  /**\n   * @param {!shaka.text.Cue} cue\n   * @param {string} align\n   * @private\n   */\n  static setPositionAlign_(cue, align) {\n    const Cue = shaka.text.Cue;\n    if (align == 'line-left' || align == 'start') {\n      cue.positionAlign = Cue.positionAlign.LEFT;\n    } else if (align == 'line-right' || align == 'end') {\n      cue.positionAlign = Cue.positionAlign.RIGHT;\n    } else {\n      cue.positionAlign = Cue.positionAlign.CENTER;\n    }\n  }\n\n  /**\n   * @param {!shaka.text.Cue} cue\n   * @param {string} value\n   * @private\n   */\n  static setVerticalWritingMode_(cue, value) {\n    const Cue = shaka.text.Cue;\n    if (value == 'lr') {\n      cue.writingMode = Cue.writingMode.VERTICAL_LEFT_TO_RIGHT;\n    } else {\n      cue.writingMode = Cue.writingMode.VERTICAL_RIGHT_TO_LEFT;\n    }\n  }\n\n  /**\n   * @param {!shaka.text.Cue} cue\n   * @param {string} word\n   * @return {boolean}\n   * @private\n   */\n  static parsedLineValueAndInterpretation_(cue, word) {\n    const Cue = shaka.text.Cue;\n    let results = null;\n    if ((results = /^line:([\\d.]+)%(?:,(start|end|center))?$/.exec(word))) {\n      cue.lineInterpretation = Cue.lineInterpretation.PERCENTAGE;\n      cue.line = Number(results[1]);\n      if (results[2]) {\n        goog.asserts.assert(\n            results[2].toUpperCase() in Cue.lineAlign,\n            results[2].toUpperCase() + ' Should be in Cue.lineAlign values!');\n        cue.lineAlign = Cue.lineAlign[results[2].toUpperCase()];\n      }\n    } else if ((results =\n                    /^line:(-?\\d+)(?:,(start|end|center))?$/.exec(word))) {\n      cue.lineInterpretation = Cue.lineInterpretation.LINE_NUMBER;\n      cue.line = Number(results[1]);\n      if (results[2]) {\n        goog.asserts.assert(\n            results[2].toUpperCase() in Cue.lineAlign,\n            results[2].toUpperCase() + ' Should be in Cue.lineAlign values!');\n        cue.lineAlign = Cue.lineAlign[results[2].toUpperCase()];\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Parses a WebVTT time from the given parser.\n   *\n   * @param {!shaka.util.TextParser} parser\n   * @return {?number}\n   * @private\n   */\n  static parseTime_(parser) {\n    // 00:00.000 or 00:00:00.000 or 0:00:00.000 or\n    // 00:00.00 or 00:00:00.00 or 0:00:00.00\n    const regexExpresion = /(?:(\\d{1,}):)?(\\d{2}):(\\d{2})\\.(\\d{2,3})/g;\n    const results = parser.readRegex(regexExpresion);\n    if (results == null) {\n      return null;\n    }\n    // This capture is optional, but will still be in the array as undefined,\n    // in which case it is 0.\n    const hours = Number(results[1]) || 0;\n    const minutes = Number(results[2]);\n    const seconds = Number(results[3]);\n    const milliseconds = Number(results[4]);\n    if (minutes > 59 || seconds > 59) {\n      return null;\n    }\n\n    return (milliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);\n  }\n\n  /**\n   * This method converts the HTML entities &amp;, &lt;, &gt;, &quot;, &#39;,\n   * &nbsp;, &lrm; and &rlm; in string to their corresponding characters.\n   *\n   * @param {!string} input\n   * @return {string}\n   * @private\n   */\n  static htmlUnescape_(input) {\n    // Used to map HTML entities to characters.\n    const htmlUnescapes = {\n      '&amp;': '&',\n      '&lt;': '<',\n      '&gt;': '>',\n      '&quot;': '\"',\n      '&#39;': '\\'',\n      '&nbsp;': '\\u{a0}',\n      '&lrm;': '\\u{200e}',\n      '&rlm;': '\\u{200f}',\n    };\n\n    // Used to match HTML entities and HTML characters.\n    const reEscapedHtml = /&(?:amp|lt|gt|quot|#(0+)?39|nbsp|lrm|rlm);/g;\n    const reHasEscapedHtml = RegExp(reEscapedHtml.source);\n    // This check is an optimization, since replace always makes a copy\n    if (input && reHasEscapedHtml.test(input)) {\n      return input.replace(reEscapedHtml, (entity) => {\n        // The only thing that might not match the dictionary above is the\n        // single quote, which can be matched by many strings in the regex, but\n        // only has a single entry in the dictionary.\n        return htmlUnescapes[entity] || '\\'';\n      });\n    }\n    return input || '';\n  }\n};\n\n/**\n * @const {number}\n * @private\n */\nshaka.text.VttTextParser.MPEG_TIMESCALE_ = 90000;\n\n/**\n * At this value, timestamps roll over in TS content.\n * @const {number}\n * @private\n */\nshaka.text.VttTextParser.TS_ROLLOVER_ = 0x200000000;\n\nshaka.text.TextEngine.registerParser(\n    'text/vtt', () => new shaka.text.VttTextParser());\n\nshaka.text.TextEngine.registerParser(\n    'text/vtt; codecs=\"vtt\"', () => new shaka.text.VttTextParser());\n\nshaka.text.TextEngine.registerParser(\n    'text/vtt; codecs=\"wvtt\"', () => new shaka.text.VttTextParser());\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.Mp4VttParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.text.VttTextParser');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Mp4BoxParsers');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.Mp4VttParser = class {\n  /** */\n  constructor() {\n    /**\n     * The current time scale used by the VTT parser.\n     *\n     * @type {?number}\n     * @private\n     */\n    this.timescale_ = null;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    const Mp4Parser = shaka.util.Mp4Parser;\n\n    let sawWVTT = false;\n\n    new Mp4Parser()\n        .box('moov', Mp4Parser.children)\n        .box('trak', Mp4Parser.children)\n        .box('mdia', Mp4Parser.children)\n        .fullBox('mdhd', (box) => {\n          goog.asserts.assert(\n              box.version == 0 || box.version == 1,\n              'MDHD version can only be 0 or 1');\n\n          const parsedMDHDBox = shaka.util.Mp4BoxParsers.parseMDHD(\n              box.reader, box.version);\n          this.timescale_ = parsedMDHDBox.timescale;\n        })\n        .box('minf', Mp4Parser.children)\n        .box('stbl', Mp4Parser.children)\n        .fullBox('stsd', Mp4Parser.sampleDescription)\n        .box('wvtt', (box) => {\n          // A valid vtt init segment, though we have no actual subtitles yet.\n          sawWVTT = true;\n        }).parse(data);\n\n    if (!this.timescale_) {\n      // Missing timescale for VTT content. It should be located in the MDHD.\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_VTT);\n    }\n\n    if (!sawWVTT) {\n      // A WVTT box should have been seen (a valid vtt init segment with no\n      // actual subtitles).\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_VTT);\n    }\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    if (!data.length) {\n      return [];\n    }\n\n    if (!this.timescale_) {\n      // Missing timescale for VTT content. We should have seen the init\n      // segment.\n      shaka.log.error('No init segment for MP4+VTT!');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_VTT);\n    }\n\n    const Mp4Parser = shaka.util.Mp4Parser;\n\n    let baseTime = 0;\n    /** @type {!Array.<shaka.util.ParsedTRUNSample>} */\n    let presentations = [];\n    /** @type {!Uint8Array} */\n    let rawPayload;\n    /** @type {!Array.<shaka.text.Cue>} */\n    const cues = [];\n\n    let sawTFDT = false;\n    let sawTRUN = false;\n    let sawMDAT = false;\n    let defaultDuration = null;\n\n    const parser = new Mp4Parser()\n        .box('moof', Mp4Parser.children)\n        .box('traf', Mp4Parser.children)\n        .fullBox('tfdt', (box) => {\n          sawTFDT = true;\n          goog.asserts.assert(\n              box.version == 0 || box.version == 1,\n              'TFDT version can only be 0 or 1');\n\n          const parsedTFDTBox = shaka.util.Mp4BoxParsers.parseTFDT(\n              box.reader, box.version);\n          baseTime = parsedTFDTBox.baseMediaDecodeTime;\n        })\n        .fullBox('tfhd', (box) => {\n          goog.asserts.assert(\n              box.flags != null,\n              'A TFHD box should have a valid flags value');\n          const parsedTFHDBox = shaka.util.Mp4BoxParsers.parseTFHD(\n              box.reader, box.flags);\n          defaultDuration = parsedTFHDBox.defaultSampleDuration;\n        })\n        .fullBox('trun', (box) => {\n          sawTRUN = true;\n          goog.asserts.assert(\n              box.version != null,\n              'A TRUN box should have a valid version value');\n          goog.asserts.assert(\n              box.flags != null,\n              'A TRUN box should have a valid flags value');\n\n          const parsedTRUNBox = shaka.util.Mp4BoxParsers.parseTRUN(\n              box.reader, box.version, box.flags);\n          presentations = parsedTRUNBox.sampleData;\n        })\n        .box('mdat', Mp4Parser.allData((data) => {\n          goog.asserts.assert(\n              !sawMDAT,\n              'VTT cues in mp4 with multiple MDAT are not currently supported');\n          sawMDAT = true;\n          rawPayload = data;\n        }));\n    parser.parse(data, /* partialOkay= */ false);\n\n    if (!sawMDAT && !sawTFDT && !sawTRUN) {\n      // A required box is missing.\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_VTT);\n    }\n\n    let currentTime = baseTime;\n\n    /** @type {!shaka.util.DataViewReader} */\n    const reader = new shaka.util.DataViewReader(\n        rawPayload, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n    for (const presentation of presentations) {\n      // If one presentation corresponds to multiple payloads, it is assumed\n      // that all of those payloads have the same start time and duration.\n      const duration = presentation.sampleDuration || defaultDuration;\n      const startTime = presentation.sampleCompositionTimeOffset ?\n                      baseTime + presentation.sampleCompositionTimeOffset :\n                      currentTime;\n      currentTime = startTime + (duration || 0);\n\n      // Read samples until it adds up to the given size.\n      let totalSize = 0;\n      do {\n        // Read the payload size.\n        const payloadSize = reader.readUint32();\n        totalSize += payloadSize;\n\n        // Skip the type.\n        const payloadType = reader.readUint32();\n        const payloadName = shaka.util.Mp4Parser.typeToString(payloadType);\n\n        // Read the data payload.\n        /** @type {Uint8Array} */\n        let payload = null;\n        if (payloadName == 'vttc') {\n          if (payloadSize > 8) {\n            payload = reader.readBytes(payloadSize - 8);\n          }\n        } else if (payloadName == 'vtte') {\n          // It's a vtte, which is a vtt cue that is empty. Ignore any data that\n          // does exist.\n          reader.skip(payloadSize - 8);\n        } else {\n          shaka.log.error('Unknown box ' + payloadName + '! Skipping!');\n          reader.skip(payloadSize - 8);\n        }\n\n        if (duration) {\n          if (payload) {\n            goog.asserts.assert(\n                this.timescale_ != null, 'Timescale should not be null!');\n            const cue = shaka.text.Mp4VttParser.parseVTTC_(\n                payload,\n                time.periodStart + startTime / this.timescale_,\n                time.periodStart + currentTime / this.timescale_);\n            cues.push(cue);\n          }\n        } else {\n          shaka.log.error(\n              'WVTT sample duration unknown, and no default found!');\n        }\n\n        goog.asserts.assert(\n            !presentation.sampleSize || totalSize <= presentation.sampleSize,\n            'The samples do not fit evenly into the sample sizes given in ' +\n            'the TRUN box!');\n\n        // If no sampleSize was specified, it's assumed that this presentation\n        // corresponds to only a single cue.\n      } while (presentation.sampleSize &&\n               (totalSize < presentation.sampleSize));\n    }\n\n    goog.asserts.assert(\n        !reader.hasMoreData(),\n        'MDAT which contain VTT cues and non-VTT data are not currently ' +\n        'supported!');\n\n    return /** @type {!Array.<!shaka.extern.Cue>} */ (\n      cues.filter(shaka.util.Functional.isNotNull));\n  }\n\n  /**\n   * Parses a vttc box into a cue.\n   *\n   * @param {!Uint8Array} data\n   * @param {number} startTime\n   * @param {number} endTime\n   * @return {shaka.text.Cue}\n   * @private\n   */\n  static parseVTTC_(data, startTime, endTime) {\n    let payload;\n    let id;\n    let settings;\n\n    new shaka.util.Mp4Parser()\n        .box('payl', shaka.util.Mp4Parser.allData((data) => {\n          payload = shaka.util.StringUtils.fromUTF8(data);\n        }))\n        .box('iden', shaka.util.Mp4Parser.allData((data) => {\n          id = shaka.util.StringUtils.fromUTF8(data);\n        }))\n        .box('sttg', shaka.util.Mp4Parser.allData((data) => {\n          settings = shaka.util.StringUtils.fromUTF8(data);\n        }))\n        .parse(data);\n\n    if (payload) {\n      return shaka.text.Mp4VttParser.assembleCue_(\n          payload, id, settings, startTime, endTime);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Take the individual components that make a cue and create a vttc cue.\n   *\n   * @param {string} payload\n   * @param {?string} id\n   * @param {?string} settings\n   * @param {number} startTime\n   * @param {number} endTime\n   * @return {!shaka.text.Cue}\n   * @private\n   */\n  static assembleCue_(payload, id, settings, startTime, endTime) {\n    const cue = new shaka.text.Cue(startTime, endTime, '');\n\n    /** @type {!Map.<string, shaka.text.Cue>} */\n    const styles = new Map();\n    shaka.text.VttTextParser.parseCueStyles(payload, cue, styles);\n\n    if (id) {\n      cue.id = id;\n    }\n\n    if (settings) {\n      const parser = new shaka.util.TextParser(settings);\n\n      let word = parser.readWord();\n\n      while (word) {\n        // TODO: Check WebVTTConfigurationBox for region info.\n        if (!shaka.text.VttTextParser.parseCueSetting(\n            cue, word, /* VTTRegions= */[])) {\n          shaka.log.warning(\n              'VTT parser encountered an invalid VTT setting: ', word,\n              ' The setting will be ignored.');\n        }\n\n        parser.skipWhitespace();\n        word = parser.readWord();\n      }\n    }\n\n    return cue;\n  }\n};\n\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"wvtt\"', () => new shaka.text.Mp4VttParser());\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.SbvTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.SbvTextParser = class {\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    goog.asserts.assert(false, 'SubViewer does not have init segments');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const SbvTextParser = shaka.text.SbvTextParser;\n    const StringUtils = shaka.util.StringUtils;\n\n    // Get the input as a string.\n    const strFromData = StringUtils.fromUTF8(data);\n    // remove dos newlines\n    let str = strFromData.replace(/\\r+/g, '');\n    // trim white space start and end\n    str = str.trim();\n\n    /** @type {!Array.<!shaka.extern.Cue>} */\n    const cues = [];\n\n    // Supports no cues\n    if (str == '') {\n      return cues;\n    }\n\n    // get cues\n    const blocklist = str.split('\\n\\n');\n    for (const block of blocklist) {\n      const lines = block.split('\\n');\n      // Parse the times.\n      const parser = new shaka.util.TextParser(lines[0]);\n      const start = SbvTextParser.parseTime_(parser);\n      const expect = parser.readRegex(/,/g);\n      const end = SbvTextParser.parseTime_(parser);\n\n      if (start == null || expect == null || end == null) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.TEXT,\n            shaka.util.Error.Code.INVALID_TEXT_CUE,\n            'Could not parse cue time range in SubViewer');\n      }\n\n      // Get the payload.\n      const payload = lines.slice(1).join('\\n').trim();\n\n      const cue = new shaka.text.Cue(start, end, payload);\n      cues.push(cue);\n    }\n\n    return cues;\n  }\n\n  /**\n   * Parses a SubViewer time from the given parser.\n   *\n   * @param {!shaka.util.TextParser} parser\n   * @return {?number}\n   * @private\n   */\n  static parseTime_(parser) {\n    // 00:00.000 or 00:00:00.000 or 0:00:00.000 or\n    // 00:00.00 or 00:00:00.00 or 0:00:00.00\n    const regexExpresion = /(?:(\\d{1,}):)?(\\d{2}):(\\d{2})\\.(\\d{2,3})/g;\n    const results = parser.readRegex(regexExpresion);\n    if (results == null) {\n      return null;\n    }\n    // This capture is optional, but will still be in the array as undefined,\n    // in which case it is 0.\n    const hours = Number(results[1]) || 0;\n    const minutes = Number(results[2]);\n    const seconds = Number(results[3]);\n    const milliseconds = Number(results[4]);\n    if (minutes > 59 || seconds > 59) {\n      return null;\n    }\n\n    return (milliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);\n  }\n};\n\n\nshaka.text.TextEngine.registerParser(\n    'text/x-subviewer', () => new shaka.text.SbvTextParser());\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.SrtTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.text.VttTextParser');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.SrtTextParser = class {\n  /** */\n  constructor() {\n    /**\n     * @type {!shaka.extern.TextParser}\n     * @private\n     */\n    this.parser_ = new shaka.text.VttTextParser();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    goog.asserts.assert(false, 'SRT does not have init segments');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const SrtTextParser = shaka.text.SrtTextParser;\n    const BufferUtils = shaka.util.BufferUtils;\n    const StringUtils = shaka.util.StringUtils;\n\n    // Get the input as a string.\n    const str = StringUtils.fromUTF8(data);\n\n    const vvtText = SrtTextParser.srt2webvtt(str);\n\n    const newData = BufferUtils.toUint8(StringUtils.toUTF8(vvtText));\n\n    return this.parser_.parseMedia(newData, time);\n  }\n\n  /**\n   * Convert a SRT format to WebVTT\n   *\n   * @param {string} data\n   * @return {string}\n   * @export\n   */\n  static srt2webvtt(data) {\n    const SrtTextParser = shaka.text.SrtTextParser;\n    let result = 'WEBVTT\\n\\n';\n\n    // Supports no cues\n    if (data == '') {\n      return result;\n    }\n\n    // remove dos newlines\n    let srt = data.replace(/\\r+/g, '');\n    // trim white space start and end\n    srt = srt.trim();\n\n    // get cues\n    const cuelist = srt.split('\\n\\n');\n    for (const cue of cuelist) {\n      result += SrtTextParser.convertSrtCue_(cue);\n    }\n\n    return result;\n  }\n\n  /**\n   * Convert a SRT cue into WebVTT cue\n   *\n   * @param {string} caption\n   * @return {string}\n   * @private\n   */\n  static convertSrtCue_(caption) {\n    const lines = caption.split(/\\n/);\n\n    // detect and skip numeric identifier\n    if (lines[0].match(/\\d+/)) {\n      lines.shift();\n    }\n\n    // convert time codes\n    lines[0] = lines[0].replace(/,/g, '.');\n\n    return lines.join('\\n') + '\\n\\n';\n  }\n};\n\n\nshaka.text.TextEngine.registerParser(\n    'text/srt', () => new shaka.text.SrtTextParser());\n", "/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.SsaTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * Documentation: http://moodub.free.fr/video/ass-specs.doc\n * https://en.wikipedia.org/wiki/SubStation_Alpha\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.SsaTextParser = class {\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    goog.asserts.assert(false, 'SSA does not have init segments');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const StringUtils = shaka.util.StringUtils;\n    const SsaTextParser = shaka.text.SsaTextParser;\n\n    // Get the input as a string.\n    const str = StringUtils.fromUTF8(data);\n\n    const section = {\n      styles: '',\n      events: '',\n    };\n\n    const parts = str.split(/\\r?\\n\\s*\\r?\\n/);\n    for (const part of parts) {\n      // SSA content\n      const match = SsaTextParser.ssaContent_.exec(part);\n      if (match) {\n        const tag = match[1];\n        const lines = match[2];\n        if (tag == 'V4 Styles' || tag == 'V4+ Styles') {\n          section.styles = lines;\n          continue;\n        }\n        if (tag == 'Events') {\n          section.events = lines;\n          continue;\n        }\n      }\n      shaka.log.warning('SsaTextParser parser encountered an unknown part.',\n          part);\n    }\n\n    // Process styles\n    const styles = [];\n\n    // Used to be able to iterate over the style parameters.\n    let styleColumns = null;\n\n    const styleLines = section.styles.split(/\\r?\\n/);\n    for (const line of styleLines) {\n      if (/^\\s*;/.test(line)) {\n        // Skip comment\n        continue;\n      }\n      const lineParts = SsaTextParser.lineParts_.exec(line);\n      if (lineParts) {\n        const name = lineParts[1].trim();\n        const value = lineParts[2].trim();\n        if (name == 'Format') {\n          styleColumns = value.split(SsaTextParser.valuesFormat_);\n          continue;\n        }\n        if (name == 'Style') {\n          const values = value.split(SsaTextParser.valuesFormat_);\n          const style = {};\n          for (let c = 0; c < styleColumns.length && c < values.length; c++) {\n            style[styleColumns[c]] = values[c];\n          }\n          styles.push(style);\n          continue;\n        }\n      }\n    }\n\n    // Process cues\n    /** @type {!Array.<!shaka.extern.Cue>} */\n    const cues = [];\n\n    // Used to be able to iterate over the event parameters.\n    let eventColumns = null;\n\n    const eventLines = section.events.split(/\\r?\\n/);\n    for (const line of eventLines) {\n      if (/^\\s*;/.test(line)) {\n        // Skip comment\n        continue;\n      }\n      const lineParts = SsaTextParser.lineParts_.exec(line);\n      if (lineParts) {\n        const name = lineParts[1].trim();\n        const value = lineParts[2].trim();\n        if (name == 'Format') {\n          eventColumns = value.split(SsaTextParser.valuesFormat_);\n          continue;\n        }\n        if (name == 'Dialogue') {\n          const values = value.split(SsaTextParser.valuesFormat_);\n          const data = {};\n          for (let c = 0; c < eventColumns.length && c < values.length; c++) {\n            data[eventColumns[c]] = values[c];\n          }\n\n          const startTime = SsaTextParser.parseTime_(data['Start']);\n          const endTime = SsaTextParser.parseTime_(data['End']);\n\n          // Note: Normally, you should take the \"Text\" field, but if it\n          // has a comma, it fails.\n          const payload = values.slice(eventColumns.length - 1).join(',')\n              .replace(/\\\\N/g, '\\n') // '\\n' for new line\n              .replace(/\\{[^}]+\\}/g, ''); // {\\pos(400,570)}\n\n          const cue = new shaka.text.Cue(startTime, endTime, payload);\n\n          const styleName = data['Style'];\n          const styleData = styles.find((s) => s['Name'] == styleName);\n          if (styleData) {\n            SsaTextParser.addStyle_(cue, styleData);\n          }\n          cues.push(cue);\n          continue;\n        }\n      }\n    }\n\n    return cues;\n  }\n\n  /**\n   * Adds applicable style properties to a cue.\n   *\n   * @param {shaka.extern.Cue} cue\n   * @param {Object} style\n   * @private\n   */\n  static addStyle_(cue, style) {\n    const Cue = shaka.text.Cue;\n    const SsaTextParser = shaka.text.SsaTextParser;\n    const fontFamily = style['Fontname'];\n    if (fontFamily) {\n      cue.fontFamily = fontFamily;\n    }\n    const fontSize = style['Fontsize'];\n    if (fontSize) {\n      cue.fontSize = fontSize + 'px';\n    }\n    const color = style['PrimaryColour'];\n    if (color) {\n      const ccsColor = SsaTextParser.parseSsaColor_(color);\n      if (ccsColor) {\n        cue.color = ccsColor;\n      }\n    }\n    const backgroundColor = style['BackColour'];\n    if (backgroundColor) {\n      const cssBackgroundColor = SsaTextParser.parseSsaColor_(backgroundColor);\n      if (cssBackgroundColor) {\n        cue.backgroundColor = cssBackgroundColor;\n      }\n    }\n    const bold = style['Bold'];\n    if (bold) {\n      cue.fontWeight = Cue.fontWeight.BOLD;\n    }\n    const italic = style['Italic'];\n    if (italic) {\n      cue.fontStyle = Cue.fontStyle.ITALIC;\n    }\n    const underline = style['Underline'];\n    if (underline) {\n      cue.textDecoration.push(Cue.textDecoration.UNDERLINE);\n    }\n    const letterSpacing = style['Spacing'];\n    if (letterSpacing) {\n      cue.letterSpacing = letterSpacing + 'px';\n    }\n    const alignment = style['Alignment'];\n    if (alignment) {\n      const alignmentInt = parseInt(alignment, 10);\n      switch (alignmentInt) {\n        case 1:\n          cue.displayAlign = Cue.displayAlign.AFTER;\n          cue.textAlign = Cue.textAlign.START;\n          break;\n        case 2:\n          cue.displayAlign = Cue.displayAlign.AFTER;\n          cue.textAlign = Cue.textAlign.CENTER;\n          break;\n        case 3:\n          cue.displayAlign = Cue.displayAlign.AFTER;\n          cue.textAlign = Cue.textAlign.END;\n          break;\n        case 5:\n          cue.displayAlign = Cue.displayAlign.BEFORE;\n          cue.textAlign = Cue.textAlign.START;\n          break;\n        case 6:\n          cue.displayAlign = Cue.displayAlign.BEFORE;\n          cue.textAlign = Cue.textAlign.CENTER;\n          break;\n        case 7:\n          cue.displayAlign = Cue.displayAlign.BEFORE;\n          cue.textAlign = Cue.textAlign.END;\n          break;\n        case 9:\n          cue.displayAlign = Cue.displayAlign.CENTER;\n          cue.textAlign = Cue.textAlign.START;\n          break;\n        case 10:\n          cue.displayAlign = Cue.displayAlign.CENTER;\n          cue.textAlign = Cue.textAlign.CENTER;\n          break;\n        case 11:\n          cue.displayAlign = Cue.displayAlign.CENTER;\n          cue.textAlign = Cue.textAlign.END;\n          break;\n      }\n    }\n    const opacity = style['AlphaLevel'];\n    if (opacity) {\n      cue.opacity = parseFloat(opacity);\n    }\n  }\n\n  /**\n   * Parses a SSA color .\n   *\n   * @param {string} colorString\n   * @return {?string}\n   * @private\n   */\n  static parseSsaColor_(colorString) {\n    // The SSA V4+ color can be represented in hex (&HAABBGGRR) or in decimal\n    // format (byte order AABBGGRR) and in both cases the alpha channel's\n    // value needs to be inverted as in case of SSA the 0xFF alpha value means\n    // transparent and 0x00 means opaque\n    /** @type {number} */\n    const abgr = parseInt(colorString.replace('&H', ''), 16);\n    if (abgr >= 0) {\n      const a = ((abgr >> 24) & 0xFF) ^ 0xFF; // Flip alpha.\n      const alpha = a / 255;\n      const b = (abgr >> 16) & 0xFF;\n      const g = (abgr >> 8) & 0xFF;\n      const r = abgr & 0xff;\n      return 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';\n    }\n    return null;\n  }\n\n  /**\n   * Parses a SSA time from the given parser.\n   *\n   * @param {string} string\n   * @return {number}\n   * @private\n   */\n  static parseTime_(string) {\n    const SsaTextParser = shaka.text.SsaTextParser;\n    const match = SsaTextParser.timeFormat_.exec(string);\n    const hours = match[1] ? parseInt(match[1].replace(':', ''), 10) : 0;\n    const minutes = parseInt(match[2], 10);\n    const seconds = parseFloat(match[3]);\n    return hours * 3600 + minutes * 60 + seconds;\n  }\n};\n\n/**\n * @const\n * @private {!RegExp}\n * @example [V4 Styles]\\nFormat: Name\\nStyle: DefaultVCD\n */\nshaka.text.SsaTextParser.ssaContent_ =\n    /^\\s*\\[([^\\]]+)\\]\\r?\\n([\\s\\S]*)/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example Style: DefaultVCD,...\n */\nshaka.text.SsaTextParser.lineParts_ =\n    /^\\s*([^:]+):\\s*(.*)/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example Style: DefaultVCD,...\n */\nshaka.text.SsaTextParser.valuesFormat_ = /\\s*,\\s*/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 0:00:01.1 or 0:00:01.18 or 0:00:01.180\n */\nshaka.text.SsaTextParser.timeFormat_ =\n    /^(\\d+:)?(\\d{1,2}):(\\d{1,2}(?:[.]\\d{1,3})?)?$/;\n\nshaka.text.TextEngine.registerParser(\n    'text/x-ssa', () => new shaka.text.SsaTextParser());\n", null],
  "mappings": "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,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe;UAAC;UAAO;QAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D;UAAC;UAAO;QAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe;UAAC;UAAO;QAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAC5D,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,GAAe,CAAC,OAAO,IAAR,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",
  "names": ["$jscomp.defineProperty", "window", "global", "$jscomp.global", "$jscomp.getGlobal", "$jscomp.polyfill", "$jscomp.iteratorPrototype", "$jscomp.arrayIteratorImpl", "$jscomp.objectCreate", "$jscomp.setPrototypeOf", "$jscomp.generator.Context", "$jscomp.asyncExecutePromiseGenerator", "$jscomp.generator.Generator_", "$jscomp.generator.Engine_", "k", "$jscomp.makeIterator", "$jscomp.owns", "$jscomp.findInternal", "$jscomp.checkStringArgs", "$jscomp.iteratorFromArray", "$jscomp.assign", "goog.global", "self", "goog.exportSymbol", "publicPath", "object", "parts", "split", "cur", "execScript", "part", "length", "shift", "undefined", "Object", "prototype", "constructor", "halfLife", "alpha_", "Math", "exp", "log", "totalWeight_", "estimate_", "shaka.abr.Ewma", "sample", "weight", "value", "adjAlpha", "pow", "newEstimate", "isNaN", "getEstimate", "fast_", "slow_", "bytesSampled_", "minTotalBytes_", "minBytes_", "shaka.abr.EwmaBandwidthEstimator", "configure", "config", "minTotalBytes", "minBytes", "fastHalfLife", "slowHalfLife", "durationMs", "numBytes", "bandwidth", "getBandwidthEstimate", "defaultEstimate", "min", "alwaysError", "alwaysWarn", "warnOnce", "id", "$jscomp.getRestArguments.apply", "shaka.log.oneTimeWarningIssued_.has", "has", "shaka.log.oneTimeWarningIssued_.add", "add", "shaka.log.alwaysWarn.apply", "shaka.log", "$jscomp.arrayFromIterable", "args", "error", "debug", "v1", "v2", "shaka.log.oneTimeWarningIssued_", "Set", "console", "bind", "shaka.log.logMap_", "ERROR", "WARNING", "warn", "INFO", "info", "DEBUG", "V1", "V2", "shaka.log.alwaysWarn", "shaka.log.alwaysError", "defaultEquals", "a", "b", "remove", "array", "element", "index", "indexOf", "splice", "hasSameElements", "compareFn", "shaka.util.ArrayUtils.defaultEquals", "copy", "slice", "item", "idx", "findIndex", "other", "pop", "equal", "i", "startTime", "endTime", "payload", "direction", "shaka.text.Cue.direction.HORIZONTAL_LEFT_TO_RIGHT", "region", "shaka.text.CueRegion", "position", "positionAlign", "shaka.text.Cue.positionAlign.AUTO", "size", "textAlign", "shaka.text.Cue.textAlign.CENTER", "writingMode", "shaka.text.Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM", "lineInterpretation", "shaka.text.Cue.lineInterpretation.LINE_NUMBER", "line", "lineHeight", "lineAlign", "shaka.text.Cue.lineAlign.START", "displayAlign", "shaka.text.Cue.displayAlign.AFTER", "fontSize", "textStrokeWidth", "textStrokeColor", "textShadow", "border", "backgroundImage", "backgroundColor", "color", "fontWeight", "shaka.text.Cue.fontWeight.NORMAL", "fontStyle", "shaka.text.Cue.fontStyle.NORMAL", "linePadding", "letterSpacing", "fontFamily", "opacity", "textDecoration", "wrapLine", "nestedCues", "spacer", "lineBreak", "isContainer", "cellResolution", "columns", "rows", "shaka.text.Cue", "clone", "Array", "cue1", "cue2", "shaka.util.ArrayUtils.equal", "shaka.text.Cue.equal", "k2", "isArray", "shaka.text.Cue.positionAlign", "shaka.text.Cue.textAlign", "shaka.text.Cue.displayAlign", "shaka.text.Cue.direction", "shaka.text.Cue.writingMode", "shaka.text.Cue.lineInterpretation", "shaka.text.Cue.lineAlign", "shaka.text.Cue.defaultTextColor", "shaka.text.Cue.defaultTextBackgroundColor", "shaka.text.Cue.fontWeight", "shaka.text.Cue.fontStyle", "shaka.text.Cue.textDecoration", "regionAnchorY", "regionAnchorX", "viewportAnchorY", "viewportAnchorX", "height", "width", "viewportAnchorUnits", "widthUnits", "heightUnits", "shaka.text.CueRegion.units.PERCENTAGE", "scroll", "shaka.text.CueRegion.scrollMode.NONE", "shaka.text.CueRegion.units", "shaka.text.CueRegion.scrollMode", "arr1", "arr2", "byteLength", "shaka.util.BufferUtils.unsafeGetArrayBuffer_", "byteOffset", "uint8A", "shaka.util.BufferUtils.toUint8", "uint8B", "unsafeGetArrayBuffer_", "view", "ArrayBuffer", "buffer", "toArrayBuffer", "Uint8Array", "toUint8", "data", "offset", "Infinity", "shaka.util.BufferUtils.view_", "toDataView", "DataView", "view_", "Type", "dataEnd", "start", "max", "end", "shaka.util.BufferUtils", "shaka.util.BufferUtils.toDataView", "shaka.util.BufferUtils.toArrayBuffer", "shaka.util.BufferUtils.equal", "major", "minor", "major_", "minor_", "shaka.deprecate.Version", "toString", "deprecateFeature", "name", "description", "expiresAt", "enforce", "shaka.Deprecate.enforcer_", "libraryVersion_", "minorCheck", "expiresOn", "onPending_", "onExpired_", "libraryVersion", "featureVersion", "join", "errorMessage", "collapseArrays", "all", "concat", "noop", "isNotNull", "callFactory", "factory", "obj", "create", "ret", "call", "shaka.Deprecate.deprecateFeature", "e", "shaka.dependencies", "key", "shaka.dependencies.dependencies_.has", "dep", "shaka.dependencies.Allowed", "Error", "shaka.dependencies.dependencies_.set", "set", "muxjs", "shaka.dependencies.dependencies_", "Map", "severity", "category", "code", "varArgs", "handled", "shaka.util.Error", "JSON", "stringify", "shaka.util.Error.Severity", "shaka.util.Error.Category", "shaka.util.Error.Code", "goog.uri.utils.splitRe_", "RegExp", "goog.Uri", "uri", "m", "setScheme", "scheme_", "setUserInfo", "userInfo_", "setDomain", "domain_", "setPort", "port_", "setPath", "path_", "setQueryData", "queryData_", "setFragment", "fragment_", "String", "match", "SCHEME", "goog.Uri.decodeOrEmpty_", "USER_INFO", "DOMAIN", "PORT", "PATH", "QUERY_DATA", "FRAGMENT", "goog.Uri.QueryData", "goog.Uri.prototype", "JSC$2222_scheme_", "goog.Uri.prototype.toString", "out", "scheme", "getScheme", "push", "goog.Uri.encodeSpecialChars_", "goog.Uri.reDisallowedInSchemeOrUserInfo_", "domain", "getDomain", "userInfo", "getUserInfo", "encodeURIComponent", "doubleEncodedString", "replace", "port", "getPort", "path", "getPath", "hasDomain", "charAt", "goog.Uri.reDisallowedInAbsolutePath_", "goog.Uri.reDisallowedInRelativePath_", "query", "getEncodedQuery", "fragment", "getFragment", "goog.Uri.reDisallowedInFragment_", "resolve", "goog.Uri.prototype.resolve", "relativeUri", "absoluteUri", "overridden", "hasPath", "lastSlashIndex", "lastIndexOf", "substr", "leadingSlash", "segments", "pos", "segment", "goog.Uri.prototype.clone", "goog.Uri.prototype.setScheme", "newScheme", "decode", "goog.Uri.prototype.setPort", "newPort", "Number", "goog.Uri.prototype.setQueryData", "queryData", "goog.Uri.reDisallowedInQuery_", "val", "preserveReserved", "decodeURI", "decodeURIComponent", "unescapedPart", "extra", "removeDoubleEncoding", "encoded", "encodeURI", "goog.Uri.encodeChar_", "ch", "n", "charCodeAt", "encodedQuery_", "goog.Uri.QueryData.prototype.ensureKeyMapInitialized_", "keyMap_", "count_", "pairs", "indexOfEquals", "substring", "goog.Uri.QueryData.prototype", "goog.Uri.QueryData.prototype.add", "ensureKeyMapInitialized_", "values", "hasOwnProperty", "goog.Uri.QueryData.prototype.set", "goog.Uri.QueryData.prototype.toString", "sb", "encodedKey", "j", "param", "goog.Uri.QueryData.prototype.clone", "rv", "cloneMap", "resolveUris", "baseUris", "relativeUris", "relativeAsGoog", "map", "base", "reduce", "shaka.util.Functional.collapseArrays", "createDrmInfo", "keySystem", "initData", "licenseServerUri", "distinctiveIdentifierRequired", "persistentStateRequired", "audioRobustness", "videoRobustness", "serverCertificate", "serverCertificateUri", "sessionType", "keyIds", "guessCodecs", "contentType", "codecs", "shaka.util.ManifestParserUtils.guessCodecsSafe", "shaka.util.Error.Severity.CRITICAL", "shaka.util.Error.Category.MANIFEST", "shaka.util.Error.Code.HLS_COULD_NOT_GUESS_CODECS", "guessCodecsSafe", "shaka.util.ManifestParserUtils.CODEC_REGEXPS_BY_CONTENT_TYPE_", "formats", "format", "codec", "test", "trim", "shaka.util.ManifestParserUtils.ContentType.TEXT", "TEXT", "shaka.util.ManifestParserUtils.ContentType", "VIDEO", "AUDIO", "IMAGE", "APPLICATION", "shaka.util.ManifestParserUtils.AUDIO_CODEC_REGEXPS_", "shaka.util.ManifestParserUtils.VIDEO_CODEC_REGEXPS_", "shaka.util.ManifestParserUtils.TEXT_CODEC_REGEXPS_", "resolvePromise", "rejectPromise", "publicPromise", "promise", "Promise", "reject", "shaka.util.PublicPromise", "gen", "gen_", "value_", "shaka.util.Lazy", "onTick", "onTick_", "cancelPending_", "shaka.util.DelayedTick", "tickAfter", "delayInSeconds", "stop", "alive", "timeoutId", "this.cancelPending_", "clearTimeout", "setTimeout", "ticker_", "shaka.util.Timer", "tickNow", "seconds", "tickEvery", "goog.exportProperty", "supportsMediaSource", "MediaSource", "isTypeSupported", "supportsMediaType", "mimeType", "shaka.util.Platform.anyMediaElement", "video", "canPlayType", "isXboxOne", "shaka.util.Platform.userAgentContains_", "isTizen", "isWebOS", "isChromecast", "isApple", "navigator", "vendor", "includes", "shaka.util.Platform.isTizen", "shaka.util.Platform.isPS4", "isPS4", "safariVersion", "shaka.util.Platform.isApple", "userAgent", "parseInt", "userAgentContains_", "anyMediaElement", "shaka.util.Platform.cachedMediaElement_", "shaka.util.Platform.cacheExpirationTimer_", "document", "getElementsByTagName", "createElement", "shaka.util.Platform.cacheExpirationTimer_.tickAfter", "fromUTF8", "uint8", "subarray", "TextDecoder", "decoded", "utf8decoder", "codePoint", "fromCharCode", "lowPart", "baseCodePoint", "fromUTF16", "littleEndian", "noThrow", "shaka.util.Error.Category.TEXT", "shaka.util.Error.Code.BAD_ENCODING", "floor", "arr", "Uint16Array", "dataView", "getUint16", "shaka.util.StringUtils.fromCharCodeImpl_.value", "fromBytesAutoDetect", "isAscii", "shaka.util.StringUtils.fromUTF8", "shaka.util.StringUtils.fromUTF16", "shaka.util.Error.Code.UNABLE_TO_DETECT_ENCODING", "toUTF8", "str", "TextEncoder", "utf8Encoder", "encode", "utf8", "unescape", "result", "toUTF16", "setUint16", "shaka.util.StringUtils", "resetFromCharCode", "shaka.util.StringUtils.fromCharCodeImpl_.reset", "shaka.util.StringUtils.toUTF16", "shaka.util.StringUtils.toUTF8", "shaka.util.StringUtils.fromBytesAutoDetect", "shaka.util.StringUtils.fromCharCodeImpl_", "supportsChunkSize", "apply", "foo", "subArray", "toStandardBase64", "btoa", "bytes", "toBase64", "padding", "base64", "shaka.util.Uint8ArrayUtils.toStandardBase64", "fromBase64", "atob", "fromHex", "toHex", "hex", "totalLength", "shaka.util.Uint8ArrayUtils", "shaka.util.Uint8ArrayUtils.concat", "shaka.util.Uint8ArrayUtils.toHex", "shaka.util.Uint8ArrayUtils.fromHex", "shaka.util.Uint8ArrayUtils.fromBase64", "shaka.util.Uint8ArrayUtils.toBase64", "muxjs_", "shaka.dependencies.dependencies_.get", "get", "transmuxPromise_", "muxTransmuxer_", "transmuxedData_", "captions_", "metadata_", "isTransmuxing_", "mp4", "Transmuxer", "on", "onTransmuxed_", "captions", "metadata", "initSegment", "output", "shaka.util.Uint8ArrayUtils.concat.apply", "onTransmuxDone_", "shaka.media.Transmuxer", "destroy", "dispose", "shaka.media.Transmuxer.isTsContainer", "shaka.media.Transmuxer.convertTsCodecs", "audioMime", "videoMime", "isTsContainer", "toLowerCase", "convertTsCodecs", "tsMimeType", "mp4MimeType", "exec", "newCodecString", "profile", "level", "transmux", "dataArray", "flush", "shaka.util.Error.Category.MEDIA", "shaka.util.Error.Code.TRANSMUXING_FAILED", "getFullType", "fullMimeType", "getFullOrConvertedType", "shaka.util.MimeUtils.getFullType", "getNormalizedCodec", "codecString", "shaka.util.MimeUtils.getCodecParts_", "getCodecs", "pieces", "find", "piece", "startsWith", "getCodecParts_", "displayer", "parser_", "displayer_", "appendWindowStart_", "timestampOffset_", "appendWindowEnd_", "bufferEnd_", "bufferStart_", "selectedClosedCaptionId_", "closedCaptionsMap_", "shaka.text.TextEngine.parserMap_", "shaka.util.MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE", "shaka.util.MimeUtils.CEA708_CLOSED_CAPTION_MIMETYPE", "shaka.text.TextEngine", "clear", "appendBuffer", "time", "allCues", "cuesToAppend", "$jscomp.asyncExecutePromiseGeneratorProgram", "parseInit", "periodStart", "segmentStart", "segmentEnd", "parseMedia", "filter", "cue", "append", "setAppendWindow", "appendWindowStart", "appendWindowEnd", "setSelectedClosedCaptionId", "bufferEndTime", "captionsMap", "keys", "cues", "startAndEndTime", "c", "convertMuxjsCaptionsToShakaCaptions", "closedCaptions", "caption", "stream", "text", "applyVideoTimestampOffsetRecursive_", "videoTimestampOffset", "nested", "storeAndAppendClosedCaptions", "findParser", "unregisterParser", "registerParser", "plugin", "areLanguageCompatible", "locale1", "locale2", "shaka.util.LanguageUtils.normalize", "components", "isParentOf", "possibleParent", "possibleChild", "possibleParentComponents", "possibleChildComponents", "isSiblingOf", "localeA", "localeB", "localeAComponents", "localeBComponents", "normalize", "locale", "language", "shaka.util.LanguageUtils.isoMap_.get", "toUpperCase", "relatedness", "target", "candidate", "shaka.util.LanguageUtils.isParentOf", "shaka.util.LanguageUtils.isSiblingOf", "getBase", "lang", "splitAt", "getLocaleForVariant", "variant", "audio", "findClosestLocale", "searchSpace", "safeTarget", "safeSearchSpace", "option", "shaka.util.LanguageUtils", "shaka.util.LanguageUtils.findClosestLocale", "shaka.util.LanguageUtils.getLocaleForVariant", "getLocaleForText", "shaka.util.LanguageUtils.getBase", "shaka.util.LanguageUtils.relatedness", "areSiblings", "baseA", "baseB", "shaka.util.LanguageUtils.areLanguageCompatible", "areLocaleCompatible", "shaka.util.LanguageUtils.isoMap_", "map_", "shaka.util.MultiMap.prototype", "list", "forEach", "callback", "chooseCodecsAndFilterManifest", "manifest", "preferredVideoCodecs", "preferredAudioCodecs", "preferredAudioChannelCount", "preferredDecodingAttributes", "variants", "shaka.util.StreamUtils.choosePreferredCodecs", "shaka.util.StreamUtils.filterVariantsByAudioChannelCount", "variantsByCodecs", "shaka.util.StreamUtils.getVariantsByCodecs_", "shaka.util.StreamUtils.filterVariantsByDensity_", "bestCodecs", "shaka.util.StreamUtils.chooseCodecsByDecodingAttributes_", "shaka.util.StreamUtils.getVariantCodecs_", "getVariantsByCodecs_", "shaka.util.MultiMap", "variantCodecs", "filterVariantsByDensity_", "maxDensity", "codecGroupsByDensity", "countCodecs", "density", "frameRate", "group", "choosePreferredCodecs", "videoCodec", "filtered", "subset", "audioCodec", "chooseCodecsByDecodingAttributes_", "attributes", "attribute", "shaka.util.StreamUtils.DecodingAttributes.SMOOTH", "shaka.util.StreamUtils.DecodingAttributes.POWER", "shaka.util.StreamUtils.chooseCodecsByMediaCapabilitiesInfo_", "shaka.util.StreamUtils.DecodingAttributes.BANDWIDTH", "shaka.util.StreamUtils.findCodecsByLowestBandwidth_", "chooseCodecsByMediaCapabilitiesInfo_", "highestScore", "bestVariantsByCodecs", "sum", "num", "decodingInfos", "averageScore", "findCodecsByLowestBandwidth_", "lowestAverageBandwidth", "averageBandwidth", "getVariantCodecs_", "baseVideoCodec", "shaka.util.MimeUtils.getNormalizedCodec", "baseAudioCodec", "filterByRestrictions", "restrictions", "maxHwResolution", "shaka.util.StreamUtils.meetsRestrictions", "meetsRestrictions", "maxHwRes", "inRange", "x", "minWidth", "maxWidth", "minHeight", "maxHeight", "minPixels", "maxPixels", "minFrameRate", "maxFrameRate", "minBandwidth", "maxBandwidth", "filterManifest", "currentVariant", "shaka.util.StreamUtils.filterManifestByMediaCapabilities", "offlineSessionIds", "shaka.util.StreamUtils.filterManifestByCurrentVariant", "shaka.util.StreamUtils.filterTextStreams_", "shaka.util.StreamUtils.filterImageStreams_", "filterManifestByMediaCapabilities", "usePersistentLicenses", "shaka.util.StreamUtils.getDecodingInfosForVariants", "videoCodecs", "shaka.util.StreamUtils.getCorrectVideoCodecs_", "allCodecs", "shaka.util.ManifestParserUtils.guessCodecs", "audioCodecs", "shaka.util.StreamUtils.getCorrectAudioCodecs_", "audioFullType", "shaka.util.MimeUtils.getFullOrConvertedType", "fullType", "shaka.util.Platform.isXboxOne", "shaka.log.debug", "shaka.util.StreamUtils.getVariantSummaryString_", "supported", "some", "decodingInfo", "getDecodingInfosForVariants", "srcEquals", "gotDecodingInfo", "mediaCapabilities", "operations", "getVariantDecodingInfos", "decodingConfigs", "decodingConfig", "shaka.util.StreamUtils.getDecodingConfigs_", "getDecodingConfigs_", "mediaDecodingConfig", "type", "channels", "bitrate", "samplerate", "spatialRendering", "framerate", "hdr", "transferFunction", "channelsCount", "audioSamplingRate", "spatialAudio", "allDrmInfos", "drmInfos", "configs", "drmInfoByKeySystems", "persistentState", "sessionTypes", "assign", "keySystemConfig", "initDataType", "distinctiveIdentifier", "initDataTypes", "robustness", "keySystemConfiguration", "getCorrectAudioCodecs_", "getCorrectVideoCodecs_", "avcdata", "filterManifestByCurrentVariant", "shaka.util.StreamUtils.areStreamsCompatible_", "filterTextStreams_", "textStreams", "shaka.text.TextEngine.isTypeSupported", "keep", "filterImageStreams_", "imageStreams", "validMimeTypes", "shaka.util.Platform.isWebOS", "shaka.util.Platform.isChromecast", "areStreamsCompatible_", "s0", "s1", "variantToTrack", "mimeTypes", "kinds", "kind", "roles", "role", "track", "active", "label", "pixelAspectRatio", "primary", "from", "audioRoles", "forced", "videoId", "audioId", "tilesLayout", "audioBandwidth", "videoBandwidth", "originalVideoId", "originalAudioId", "originalTextId", "originalImageId", "originalId", "textStreamToTrack", "imageStreamToTrack", "reference", "segmentIndex", "layout", "html5TrackId", "html5Track", "shaka.util.StreamUtils.nextTrackId_", "html5TextTrackToTrack", "textTrack", "shaka.util.StreamUtils.html5TrackToGenericShakaTrack_", "mode", "html5AudioTrackToTrack", "audioTrack", "enabled", "html5TrackToGenericShakaTrack_", "shaka.util.StreamUtils.html5TrackId", "isPlayable", "allowedByApplication", "allowedByKeySystem", "getPlayableVariants", "shaka.util.StreamUtils.isPlayable", "filterVariantsByAudioChannelCount", "variantsWithChannelCounts", "v", "variantsByChannelCount", "count", "channelCounts", "countLessThanOrEqualtoConfig", "filterStreamsByLanguageAndRole", "streams", "preferredLanguage", "preferredRole", "preferredForced", "chosen", "firstLanguage", "closestLocale", "roleMatches", "shaka.util.StreamUtils.filterTextStreamsByRole_", "noRoleMatches", "allRoles", "filterTextStreamsByRole_", "getVariantSummaryString_", "summaries", "shaka.util.StreamUtils.getStreamSummaryString_", "getStreamSummaryString_", "SMOOTH", "POWER", "BANDWIDTH", "switch_", "enabled_", "bandwidthEstimator_", "connection", "addEventListener", "config_", "useNetworkInformation", "advanced", "chosenVariant", "chooseVariant", "variants_", "playbackRate_", "startupComplete_", "lastTimeChosenMs_", "shaka.abr.SimpleAbrManager.prototype", "init", "switchCallback", "sortedVariants", "shaka.abr.SimpleAbrManager.filterAndSortVariants_", "currentBandwidth", "getDefaultBandwidth_", "defaultBandwidthEstimate", "playbackRate", "abs", "bandwidthDowngradeTarget", "next", "bandwidthUpgradeTarget", "Date", "now", "enable", "disable", "segmentDownloaded", "deltaTimeMs", "suggestStreams_", "switchInterval", "setVariants", "playbackRateChanged", "rate", "downlink", "filterAndSortVariants_", "sort", "shaka.abr.SimpleAbrManager", "root", "candidates", "root_", "shaka.media.AdaptationSet", "shaka.media.AdaptationSet.areAdaptable", "canInclude", "shaka.media.AdaptationSet.canTransitionBetween_", "shaka.media.AdaptationSet.areRolesEqual_", "codecsA", "codecsB", "areRolesEqual_", "aSet", "bSet", "delete", "mainRole", "example", "example_", "fallback_", "shaka.media.PreferenceBasedCriteria", "shaka.media.ExampleBasedCriteria", "shortList", "channelCount", "language_", "role_", "channelCount_", "label_", "current", "byLanguage", "shaka.media.PreferenceBasedCriteria.filterByLanguage_", "byPrimary", "byRole", "shaka.media.PreferenceBasedCriteria.filterVariantsByRole_", "byChannel", "byLabel", "shaka.media.PreferenceBasedCriteria.filterVariantsByLabel_", "filterByLanguage_", "preferredLocale", "filterVariantsByRole_", "filterVariantsByLabel_", "preferredLabel", "label1", "label2", "previousState_", "shaka.media.BufferingObserver.State.SATISFIED", "thresholds_", "thresholdWhenSatisfied", "shaka.media.BufferingObserver.State.STARVING", "thresholdWhenStarving", "setThresholds", "STARVING", "SATISFIED", "parameters", "autoReset", "defaults", "shaka.net.Backoff.defaultRetryParameters", "maxAttempts_", "maxAttempts", "baseDelay_", "baseDelay", "fuzzFactor_", "fuzzFactor", "backoffFactor_", "backoffFactor", "numAttempts_", "nextUnfuzzedDelay_", "autoReset_", "attempt", "currentAttempt", "fuzzedDelayMs", "reset_", "shaka.util.Error.Category.PLAYER", "shaka.util.Error.Code.ATTEMPTS_EXHAUSTED", "random", "timer", "defaultRetryParameters", "timeout", "stallTimeout", "connectionTimeout", "onAbort", "onAbort_", "aborted_", "failed", "shaka.util.AbortableOperation", "aborted", "p", "shaka.util.Error.Code.OPERATION_ABORTED", "catch", "completed", "notAbortable", "abort", "op", "finally", "onFinal", "then", "chain", "onSuccess", "onError", "makeCallback", "isSuccess", "newPromise", "abortError", "cb", "shaka.util.AbortableOperation.wrapChainCallback_", "exception", "publicName", "shaka.util.AbortableOperation.all", "shaka.util.AbortableOperation.notAbortable", "shaka.util.AbortableOperation.completed", "shaka.util.AbortableOperation.aborted", "shaka.util.AbortableOperation.failed", "dict", "defineProperty", "writable", "enumerable", "defaultPrevented", "cancelable", "bubbles", "timeStamp", "performance", "isTrusted", "currentTarget", "stopped", "fromRealEvent", "event", "fakeEvent", "shaka.util.FakeEvent", "preventDefault", "stopImmediatePropagation", "stopPropagation", "listeners_", "dispatchTarget", "shaka.util.FakeEventTarget", "listener", "removeEventListener", "dispatchEvent", "listeners", "universalListeners", "shaka.util.FakeEventTarget.ALL_EVENTS_", "handleEvent", "release", "cloneObject", "arg", "seenObjects", "shallowCloneObject", "original", "operations_", "manage", "operation", "shaka.util.ArrayUtils.remove", "shaka.util.OperationManager", "cleanup", "onProgressUpdated", "onHeadersReceived", "onDownloadFailed", "shaka.util.FakeEventTarget.call", "destroyed_", "operationManager_", "requestFilters_", "responseFilters_", "onProgressUpdated_", "onHeadersReceived_", "onDownloadFailed_", "forceHTTPS_", "$jscomp.inherits", "shaka.net.NetworkingEngine", "FakeEventTarget", "setForceHTTPS", "shaka.net.NetworkingEngine.prototype", "forceHTTPS", "registerScheme", "priority", "progressSupport", "shaka.net.NetworkingEngine.PluginPriority.APPLICATION", "existing", "shaka.net.NetworkingEngine.schemes_", "registerRequestFilter", "unregisterRequestFilter", "clearAllRequestFilters", "registerResponseFilter", "unregisterResponseFilter", "clearAllResponseFilters", "uris", "retryParams", "streamDataCallback", "method", "body", "headers", "allowCrossSiteCredentials", "retryParameters", "licenseRequestType", "sessionId", "super", "request", "numBytesRemainingObj", "shaka.net.NetworkingEngine.NumBytesRemainingClass", "shaka.net.NetworkingEngine.PendingRequest", "shaka.util.ObjectUtils.cloneObject", "requestFilterOperation", "filterRequest_", "requestOperation", "send_", "makeRequestWithRetry_", "backoff", "shaka.net.Backoff", "responseFilterOperation", "responseAndGotProgress", "filterResponse_", "requestFilterStartTime", "requestFilterMs", "responseFilterStartTime", "responseFilterMs", "response", "timeMs", "gotProgress", "fromCache", "shaka.net.NetworkingEngine.RequestType.SEGMENT", "pendingRequest", "filterOperation", "requestFilter", "shaka.util.Error.Category.NETWORK", "shaka.util.Error.Code.REQUEST_FILTER_ERROR", "lastError", "location", "protocol", "shaka.util.Error.Code.UNSUPPORTED_SCHEME", "connectionTimer", "stallTimer", "headersReceivedCalled", "startTimeMs", "backoffOperation", "requestPlugin", "progressUpdated", "numBytesRemaining", "stallTimeoutMs", "bytesToLoad_", "headersReceived", "connectionTimeoutMs", "shakaError", "httpResponseCode", "shaka.util.Error.Code.BAD_HTTP_STATUS", "shaka.util.Error.Severity.RECOVERABLE", "shaka.util.Error.Code.TIMEOUT", "sendOperation", "responseFilter", "resp", "shaka.util.Error.Code.RESPONSE_FILTER_ERROR", "shaka.net.NetworkingEngine.makeRequest", "unregisterScheme", "shaka.net.NetworkingEngine.registerScheme", "shaka.util.AbortableOperation.call", "bytesRemaining_", "AbortableOperation", "shaka.net.NetworkingEngine.RequestType", "shaka.net.NetworkingEngine.PluginPriority", "waitOnDestroy_", "onDestroy_", "shaka.util.Destroyer", "ensureNotDestroyed", "shaka.util.Error.Code.OBJECT_DESTROYED", "bindingMap_", "shaka.util.EventManager.prototype", "removeAll", "listen", "options", "binding", "shaka.util.EventManager.Binding_", "listenOnce", "shim", "unlisten", "shaka.util.EventManager", "shaka.util.EventManager.Binding_.convertOptions_", "convertOptions_", "ignored", "shaka.util.EventManager.Binding_.doesSupportObject_", "supports", "doesSupportObject_", "shaka.util.EventManager.Binding_.supportsObject_", "prop", "defaultGetContentId", "uriString", "initDataTransform", "contentId", "cert", "appendWithLength", "rebuiltInitData", "setUint32", "shaka.util.Error.Category.DRM", "shaka.util.Error.Code.SERVER_CERTIFICATE_REQUIRED", "contentIdArray", "sdkUri", "utf16", "shaka.util.FairPlayUtils", "shaka.util.FairPlayUtils.initDataTransform", "shaka.util.FairPlayUtils.defaultGetContentId", "iterable", "mapping", "every", "asMap", "asObject", "map1", "map2", "val2", "findChild", "elem", "children", "shaka.util.XmlUtils.findChildren", "findChildNS", "ns", "shaka.util.XmlUtils.findChildrenNS", "findChildren", "found", "childNodes", "child", "Element", "tagName", "getChildren", "findChildrenNS", "localName", "namespaceURI", "getAttributeNS", "hasAttributeNS", "getAttributeNSList", "nsList", "getContents", "shaka.util.XmlUtils.isText", "textContent", "isText", "nodeType", "Node", "TEXT_NODE", "CDATA_SECTION_NODE", "parseAttr", "parseFunction", "defaultValue", "parsedValue", "getAttribute", "parseDate", "dateString", "parse", "parseDuration", "durationString", "matches", "re", "d", "years", "months", "days", "hours", "minutes", "isFinite", "parseRange", "rangeString", "intString", "parsePositiveInt", "parseNonNegativeInt", "parseFloat", "floatString", "evalDivision", "exprString", "res", "parseXmlString", "xmlString", "expectedRootElemName", "parser", "DOMParser", "unsafeXmlString", "shaka.util.XmlUtils.trustedHTMLFromString_.value", "unsafeXml", "parseFromString", "rootElem", "documentElement", "parserErrorElements", "iterator", "createNodeIterator", "NodeFilter", "SHOW_ALL", "currentNode", "nextNode", "HTMLElement", "SVGElement", "parseXml", "string", "shaka.util.XmlUtils.parseXmlString", "shaka.util.XmlUtils.trustedHTMLFromString_", "trustedTypes", "policy", "createPolicy", "createHTML", "s", "playerInterface", "updateExpirationTime", "playerInterface_", "supportedTypes_", "video_", "mediaKeys_", "initializedForStorage_", "initialized_", "licenseTimeSeconds_", "currentDrmInfo_", "eventManager_", "activeSessions_", "offlineSessionIds_", "allSessionsLoaded_", "onError_", "this.onError_", "err", "keyStatusByKeyId_", "announcedKeyStatusByKeyId_", "keyStatusTimer_", "processKeyStatusChanges_", "usePersistentLicenses_", "mediaKeyMessageEvents_", "initialRequestsSent_", "expirationTimer_", "pollExpiration_", "destroyer_", "destroyNow_", "srcEquals_", "shaka.media.DrmEngine.prototype", "closeOpenSessions_", "setMediaKeys", "initForStorage", "init_", "initForPlayback", "initForRemoval", "audioCapabilities", "videoCapabilities", "configsByKeySystem", "queryMediaKeys_", "clearKeyDrmInfo", "hadDrmInfo", "servers", "hasDrmInfo", "configureClearKey_", "shaka.util.MapUtils.asMap", "shaka.media.DrmEngine.replaceDrmInfo_", "getVariantDrmInfos_", "shaka.media.DrmEngine.fillInDrmInfoDefaults_", "attach", "shaka.util.Error.Code.ENCRYPTED_CONTENT_WITHOUT_DRM_INFO", "onPlay_", "sendLicenseRequest_", "shaka.util.Error.Code.FAILED_TO_ATTACH_TO_VIDEO", "message", "createOrLoad", "newInitData", "setServerCertificate", "netEngine", "shaka.net.NetworkingEngine.RequestType.SERVER_CERTIFICATE", "shaka.util.Error.Code.SERVER_CERTIFICATE_REQUEST_FAILED", "shaka.util.Error.Code.INVALID_SERVER_CERTIFICATE", "removeSession", "session", "tasks", "loadOfflineSession_", "updatePromise", "initDatas", "initDataOverride", "metadatas", "createSession", "isPlayReadyKeySystem", "getSessionIds", "sessions", "ids", "shaka.util.Iterables.map", "getExpiration", "expiration", "getKeyStatuses", "shaka.util.MapUtils.asObject", "drmInfosByKeySystem", "mediaKeySystemAccess", "realConfig", "audioCaps", "videoCaps", "cap", "mediaKeys", "shaka.util.Error.Code.REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE", "getConfiguration", "licenseServers", "serverCertificateUris", "serverCerts", "shaka.media.DrmEngine.processDrmInfos_", "defaultSessionType", "shaka.util.Error.Code.NO_LICENSE_SERVER_GIVEN", "createMediaKeys", "shaka.util.Error.Code.FAILED_TO_CREATE_CDM", "getKeySystemAccessFromVariants_", "shaka.util.Error.Code.NO_RECOGNIZED_KEY_SYSTEMS", "preferredKeySystems", "preferredKeySystem", "keySystemAccess", "shouldHaveLicenseServer", "getKeySystemAccessByConfigs_", "hasLicenseServer", "requestMediaKeySystemAccess", "clearKeys", "keyHex", "keyIdHex", "keyId", "keyObj", "kty", "kid", "license", "jwkSet", "initDataStr", "present", "shaka.util.Error.Code.FAILED_TO_CREATE_SESSION", "onSessionMessage_", "delayLicenseRequestUntilPlayed", "paused", "onKeyStatusesChange_", "loaded", "oldExpiration", "load", "shaka.util.Error.Code.OFFLINE_SESSION_REMOVED", "areAllSessionsLoaded_", "shaka.util.Error.Code.INIT_DATA_TRANSFORM_ERROR", "logLicenseExchange", "generateRequest", "errorCode", "systemCode", "extended", "shaka.util.Error.Code.FAILED_TO_GENERATE_LICENSE_REQUEST", "defaultInitDataTransform", "drmInfo", "url", "advancedConfig", "startTimeRequest", "req", "shakaErr", "updateEvent", "messageType", "individualizationServer", "shaka.media.DrmEngine.isPlayReadyKeySystem", "unpackPlayReadyRequest_", "shaka.net.NetworkingEngine.RequestType.LICENSE", "shaka.util.Error.Code.LICENSE_REQUEST_FAILED", "update", "shaka.util.Error.Code.LICENSE_RESPONSE_REJECTED", "onEvent", "shaka.media.DrmEngine.SESSION_LOAD_TIMEOUT_", "xml", "dom", "header", "challenge", "hasExpiredKeys", "keyStatuses", "status", "tmp", "part0", "getUint32", "part1", "part2", "msUntilExpiration", "close", "shaka.media.DrmEngine.KEY_STATUS_BATCH_TIME", "privateMap", "publicMap", "statuses", "shaka.util.Error.Code.EXPIRED", "onKeyStatus", "probeSupport", "testKeySystems", "basicVideoCapabilities", "basicConfig", "offlineConfig", "support", "testSystem", "tests", "access", "closeSession_", "shaka.media.DrmEngine.CLOSE_TIMEOUT_", "race", "closed", "openSessions", "entries", "getCommonDrmInfos", "drms1", "drms2", "commonDrms", "drm1", "drm2", "d2", "mergedDrm", "oldTime", "newTime", "onExpirationUpdated", "shaka.util.Iterables.every", "replaceDrmInfo_", "keySystems", "processDrmInfos_", "fillInDrmInfoDefaults_", "advancedConfigs", "server", "cast", "__platform__", "shaka.media.DrmEngine.DUMMY_KEY_ID", "getFactory", "extension", "shaka.media.ManifestParser.parsersByMime", "shaka.media.ManifestParser.getExtension", "shaka.media.ManifestParser.parsersByExtension", "shaka.media.ManifestParser.getMimeType", "shaka.util.Error.Code.UNABLE_TO_GUESS_MANIFEST_TYPE", "getMimeType", "shaka.net.NetworkingEngine.RequestType.MANIFEST", "getExtension", "filenamePieces", "uriObj", "uriPieces", "uriFilename", "shaka.media.ManifestParser", "unregisterParserByMime", "registerParserByMime", "parserFactory", "registerParserByExtension", "endianness", "dataView_", "littleEndian_", "shaka.util.DataViewReader.Endianness.LITTLE_ENDIAN", "position_", "hasMoreData", "shaka.util.DataViewReader.prototype", "getPosition", "getLength", "readUint8", "getUint8", "outOfBounds_", "readUint16", "readUint32", "readInt32", "getInt32", "readUint64", "low", "high", "shaka.util.Error.Code.JS_INTEGER_OVERFLOW", "readBytes", "skip", "rewind", "seek", "readTerminatedString", "shaka.util.Error.Code.BUFFER_READ_OUT_OF_BOUNDS", "shaka.util.DataViewReader", "shaka.util.DataViewReader.Endianness", "headers_", "boxDefinitions_", "done_", "box", "shaka.util.Mp4Parser.prototype", "definition", "typeCode", "shaka.util.Mp4Parser.typeFromString_", "shaka.util.Mp4Parser.BoxType_.BASIC_BOX", "fullBox", "shaka.util.Mp4Parser.BoxType_.FULL_BOX", "partialOkay", "stopOnPartial", "reader", "shaka.util.DataViewReader.Endianness.BIG_ENDIAN", "parseNext", "absStart", "has64BitSize", "boxDefinition", "version", "flags", "versionAndFlags", "payloadSize", "payloadReader", "skipLength", "headerSize", "shaka.util.Mp4Parser.headerSize", "sampleDescription", "allData", "typeFromString_", "chr", "typeToString", "basicHeaderSize", "shaka.util.Mp4Parser", "shaka.util.Mp4Parser.typeToString", "shaka.util.Mp4Parser.allData", "shaka.util.Mp4Parser.sampleDescription", "shaka.util.Mp4Parser.children", "BASIC_BOX", "FULL_BOX", "fakeEncryption", "initSegmentBuffer", "onEncryptionMetadataBox", "isEncrypted", "onSimpleAncestorBox", "ancestorBoxes", "stsdBox", "boxesToModify", "newType", "shaka.media.ContentWorkarounds.BOX_TYPE_ENCV_", "shaka.media.ContentWorkarounds.BOX_TYPE_ENCA_", "shaka.log.v2", "shaka.util.Error.Code.CONTENT_TRANSFORMATION_FAILED", "reverse", "workItem", "shaka.media.ContentWorkarounds.insertEncryptionMetadata_", "insertEncryptionMetadata_", "sourceBox", "metadataBoxType", "sinfBoxArray", "shaka.media.ContentWorkarounds.CANNED_SINF_BOX_.value", "sourceBoxArray", "sourceBoxView", "metadataBoxArray", "metadataBoxView", "shaka.media.ContentWorkarounds.BOX_TYPE_OFFSET_", "sourceBoxType", "shaka.media.ContentWorkarounds.CANNED_SINF_BOX_FORMAT_OFFSET_", "shaka.media.ContentWorkarounds.updateBoxSize_", "newInitSegment", "cutPoint", "afterData", "beforeData", "stsdBoxView", "stsdBoxHeaderSize", "numEntries", "updateBoxSize_", "boxStart", "newBoxSize", "boxView", "sizeField", "shaka.media.ContentWorkarounds.BOX_SIZE_OFFSET_", "shaka.media.ContentWorkarounds.BOX_SIZE_64_OFFSET_", "shaka.media.ContentWorkarounds.CANNED_SINF_BOX_", "getParsedCaption", "topLevelCue", "memory", "firstNonEmptyRow", "lastNonEmptyRow", "character_", "currentItalics", "currentUnderline", "currentTextColor", "shaka.cea.CeaUtils.DEFAULT_TXT_COLOR", "currentBackgroundColor", "shaka.cea.CeaUtils.DEFAULT_BG_COLOR", "currentCue", "shaka.cea.CeaUtils.createStyledCue", "row", "firstNonEmptyCol", "lastNonEmptyCol", "getChar", "linebreakCue", "shaka.cea.CeaUtils.createLineBreakCue", "styledChar", "underline", "underline_", "italics", "italics_", "textColor", "textColor_", "backgroundColor_", "createStyledCue", "txtColor", "bgColor", "shaka.text.Cue.textDecoration.UNDERLINE", "shaka.text.Cue.fontStyle.ITALIC", "createLineBreakCue", "character", "fieldNum", "channelNum", "rows_", "row_", "scrollRows_", "fieldNum_", "channelNum_", "reset", "forceEmit", "shaka.cea.CeaUtils.getParsedCaption", "resetRows", "resetAllRows", "shaka.cea.Cea608Memory.CC_ROWS", "addChar", "char", "shaka.cea.Cea608Memory.CharSet.BASIC_NORTH_AMERICAN", "shaka.cea.Cea608Memory.CharSet.BasicNorthAmericanChars.has", "shaka.cea.Cea608Memory.CharSet.BasicNorthAmericanChars.get", "shaka.cea.Cea608Memory.CharSet.SPECIAL_NORTH_AMERICAN", "shaka.cea.Cea608Memory.CharSet.SpecialNorthAmericanChars.get", "shaka.cea.Cea608Memory.CharSet.SPANISH_FRENCH", "eraseChar", "shaka.cea.Cea608Memory.CharSet.ExtendedSpanishFrench.get", "shaka.cea.Cea608Memory.CharSet.PORTUGUESE_GERMAN", "shaka.cea.Cea608Memory.CharSet.ExtendedPortugueseGerman.get", "shaka.cea.CeaUtils.StyledChar", "moveRows", "dst", "src", "BASIC_NORTH_AMERICAN", "SPECIAL_NORTH_AMERICAN", "SPANISH_FRENCH", "PORTUGUESE_GERMAN", "shaka.cea.Cea608Memory.CharSet.BasicNorthAmericanChars", "shaka.cea.Cea608Memory.CharSet.SpecialNorthAmericanChars", "shaka.cea.Cea608Memory.CharSet.ExtendedSpanishFrench", "shaka.cea.Cea608Memory.CharSet.ExtendedPortugueseGerman", "type_", "shaka.cea.Cea608DataChannel.CaptionType.NONE", "text_", "shaka.cea.Cea608Memory", "displayedMemory_", "nonDisplayedMemory_", "curbuf_", "prevEndTime_", "lastcp_", "controlRu_", "scrollSize", "pts", "buf", "parsedClosedCaption", "shaka.cea.Cea608DataChannel.CaptionType.ROLLUP", "shaka.cea.Cea608DataChannel.CaptionType.TEXT", "controlRcl_", "shaka.cea.Cea608DataChannel.CaptionType.POPON", "scrollRows", "controlRtd_", "shaka.log.warnOnce", "NONE", "POPON", "ROLLUP", "shaka.cea.Cea608DataChannel.BG_COLORS", "shaka.cea.Cea608DataChannel.TEXT_COLORS", "visible_", "colCount_", "rowCount_", "justification_", "shaka.cea.Cea708Window.TextJustification.CENTER", "memory_", "col_", "startTime_", "resetMemory", "shaka.cea.Cea708Window.MAX_ROWS", "createNewRow_", "shaka.cea.Cea708Window.MAX_COLS", "setCharacter", "isPenInBounds_", "cea708Char", "inColBounds", "shaka.cea.Cea708Window", "isVisible", "serviceNumber", "shaka.cea.Cea708Window.TextJustification.LEFT", "shaka.text.Cue.textAlign.LEFT", "shaka.cea.Cea708Window.TextJustification.RIGHT", "shaka.text.Cue.textAlign.RIGHT", "setStartTime", "LEFT", "RIGHT", "CENTER", "builtPackets_", "currentPacketBeingBuilt_", "bytesLeftToAddInCurrentPacket_", "addByte", "cea708Byte", "shaka.cea.DtvccPacketBuilder.DTVCC_PACKET_START", "packet", "shaka.cea.DtvccPacket", "packetData", "pos_", "packetData_", "readByte", "numBlocks", "serviceNumber_", "windows_", "currentWindow_", "handleC1_", "dtvccPacket", "captionCommand", "windowNum", "setCurrentWindow_", "bitmap", "getSpecifiedWindowIds_", "clearWindows_", "windowId", "displayWindows_", "hideWindows_", "toggleWindows_", "deleteWindows_", "allWindowsBitmap", "attrByte2", "setPenAttributes_", "foregroundByte", "backgroundByte", "setPenColor_", "rgbColorToHex_", "foregroundColor", "locationByte1", "locationByte2", "setPenLocation_", "b3", "setWindowAttributes_", "windowAlreadyExists", "defineWindow_", "b1", "b4", "b5", "b6", "resetPen", "defineWindow", "windowsBitmap", "red", "green", "blue", "colorMapping", "shaka.cea.Cea708Service.Colors", "shaka.cea.Cea708Service.G2Charset", "cea608DataArray_", "cea708DataArray_", "dtvccPacketBuilder_", "shaka.cea.DtvccPacketBuilder", "badFrames_", "cea608ModeToStream_", "shaka.cea.Cea608DataChannel", "currentField2Channel_", "currentField1Channel_", "serviceNumberToService_", "PAINTON", "stableComparator", "p1", "p2", "order", "parsedClosedCaptions", "decodeCea608_", "cea608Packet", "decodeCea708_", "ccPacket", "ccData1", "selectedStream", "ccData2", "isOddParity_", "b2", "ccrowtab", "attr", "newTopRow", "RCL", "BS", "RU2", "RU3", "RU4", "FON", "RDC", "TR", "RTD", "EDM", "CR", "toprow", "ENM", "EOC", "serviceBlockHeader", "blockSize", "service", "shaka.cea.Cea708Service", "startPos", "blockData", "controlCode", "shaka.cea.Cea708Service.EXT_CEA708_CTRL_CODE_BYTE1", "extendedControlCodeBlock", "shaka.cea.Cea708Service.ASCII_BACKSPACE", "shaka.cea.Cea708Service.ASCII_CARRIAGE_RETURN", "shaka.cea.Cea708Service.ASCII_HOR_CARRIAGE_RETURN", "shaka.cea.Cea708Service.ASCII_FORM_FEED", "col", "shaka.cea.Cea708Service.G2Charset.has", "shaka.cea.Cea708Service.G2Charset.get", "closedCaption", "byte", "parity", "parseTFHD", "defaultSampleDuration", "defaultSampleSize", "trackId", "parseTFDT", "baseMediaDecodeTime", "parseMDHD", "timescale", "parseTRUN", "sampleCount", "sampleData", "sampleDuration", "sampleSize", "sampleCompositionTimeOffset", "trackIdToTimescale_", "defaultSampleSize_", "defaultSampleDuration_", "shaka.cea.Mp4CeaParser", "trackIds", "timescales", "parsedMDHDBox", "shaka.util.Mp4BoxParsers.parseMDHD", "shaka.util.Error.Code.INVALID_MP4_CEA", "mediaSegment", "captionPackets", "shaka.cea.ICeaParser.DEFAULT_TIMESCALE_VALUE", "shaka.util.Mp4BoxParsers.parseTRUN", "parsedTRUN", "parsedTFHD", "shaka.util.Mp4BoxParsers.parseTFHD", "shaka.util.Mp4BoxParsers.parseTFDT", "parsedTFDT", "sampleIndex", "naluSize", "shaka.cea.ICeaParser.NALU_TYPE_SEI", "timeOffset", "seiPayloads", "naluClone", "naluData", "zeroCount", "newArr", "payloadType", "ceaParser_", "ceaDecoder_", "shaka.cea.CeaDecoder", "shaka.media.ClosedCaptionParser", "parseFrom", "mediaFragment", "captionPacket", "uint8ArrayData", "shaka.cea.CeaDecoder.USA_COUNTRY_CODE", "shaka.cea.CeaDecoder.ATSC_PROVIDER_CODE", "shaka.cea.CeaDecoder.ATSC1_USER_IDENTIFIER", "captionData", "cc", "ccValid", "shaka.cea.CeaDecoder.NTSC_CC_FIELD_1", "ccType", "shaka.cea.CeaDecoder.NTSC_CC_FIELD_2", "shaka.cea.DtvccPacketBuilder.DTVCC_PACKET_DATA", "bufferEnd", "isBuffered", "smallGapLimit", "bufferedAheadOf", "shaka.media.TimeRangesUtils.getBufferedInfo", "getGapIndex", "threshold", "getBufferedInfo", "closedCaptionParser", "textDisplayer", "onMetadata", "textDisplayer_", "sourceBuffers_", "sourceBufferTypes_", "expectedEncryption_", "textEngine_", "onMetadata_", "onMetadataNoOp", "queues_", "transmuxers_", "captionParser_", "mediaSourceOpen_", "mediaSource_", "createMediaSource", "doDestroy_", "url_", "mediaSource", "URL", "revokeObjectURL", "onSourceOpen_", "shaka.media.MediaSourceEngine.createObjectURL", "shaka.media.MediaSourceEngine.prototype", "q", "inProgress", "shaka.util.Functional.noop", "removeAttribute", "streamsByType", "forceTransmuxTS", "ContentType", "sourceBuffer", "reinitText", "shaka.media.Transmuxer.isSupported", "addSourceBuffer", "shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_FAILED", "onUpdateEnd_", "shaka.util.Functional.callFactory", "ended", "readyState", "bufferStart", "shaka.media.TimeRangesUtils.bufferEnd", "getBuffered_", "buffered", "shaka.media.TimeRangesUtils.bufferedAheadOf", "total", "hasClosedCaptions", "videoOffset", "transmuxedData", "timestampOffset", "transmuxedSegment", "workAroundBrokenPlatforms_", "enqueueOperation_", "append_", "videoBufferEndTime", "clearSelectedClosedCaptionId", "remove_", "duration", "flush_", "currentTime", "setStreamProperties", "abort_", "setTimestampOffset_", "setAppendWindow_", "endOfStream", "reason", "enqueueBlockingOperation_", "setDuration", "getDuration", "popFromQueue_", "startOperation_", "run", "allWaiters", "ready", "shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW", "shaka.util.Error.Code.QUOTA_EXCEEDED_ERROR", "encryptionExpected", "shaka.media.ContentWorkarounds.fakeEncryption", "createObjectURL", "startByte", "endByte", "mediaQuality", "getUris", "shaka.media.InitSegmentReference", "getStartByte", "getEndByte", "reference1", "reference2", "initSegmentReference", "partialReferences", "tileDuration", "trueEndTime", "getUrisInner", "shaka.media.SegmentReference.prototype", "getStartTime", "getEndTime", "getTilesLayout", "getTileDuration", "shaka.media.SegmentReference", "presentationStartTime", "presentationDelay", "autoCorrectDrift", "presentationStartTime_", "presentationDelay_", "segmentAvailabilityDuration_", "duration_", "maxSegmentDuration_", "maxSegmentEndTime_", "minSegmentStartTime_", "clockOffset_", "static_", "userSeekStart_", "autoCorrectDrift_", "availabilityTimeOffset_", "startTimeLocked_", "shaka.media.PresentationTimeline.prototype", "getMaxSegmentDuration", "getPresentationStartTime", "setClockOffset", "setStatic", "isStatic", "setSegmentAvailabilityDuration", "segmentAvailabilityDuration", "setDelay", "delay", "getDelay", "notifySegments", "references", "lastReferenceEndTime", "notifyMinSegmentStartTime", "r", "lockStartTime", "notifyMaxSegmentDuration", "maxSegmentDuration", "isLive", "isInProgress", "getSegmentAvailabilityStart", "getSegmentAvailabilityEnd", "setUserSeekStart", "getLiveEdge_", "getSafeSeekRangeStart", "earliestSegmentTime", "ceil", "availabilityEnd", "getSeekRangeEnd", "desiredStart", "getSeekRangeStart", "usingPresentationStartTime", "setAvailabilityTimeOffset", "shaka.media.PresentationTimeline", "implementation", "stallThresholdSeconds", "implementation_", "wasMakingProgress_", "shouldBeMakingProgress", "mediaElement_", "lastUpdateSeconds_", "didJump_", "stallThresholdSeconds_", "onStall_", "this.onStall_", "shaka.media.StallDetector", "onStall", "doThis", "mediaElement", "timeInSeconds", "timeline", "stallDetector", "timeline_", "onEvent_", "seekingEventReceived_", "prevReadyState_", "didFireLargeGap_", "stallDetector_", "hadSegmentAppended_", "onPollGapJump_", "gapJumpTimer_", "shaka.media.GapJumpingController", "onSegmentAppended", "seeking", "autoplay", "impl", "wallTimeSeconds", "stallSeconds", "triggerCallback", "gapIndex", "shaka.media.TimeRangesUtils.getGapIndex", "gapDetectionThreshold", "jumpTo", "seekEnd", "jumpSize", "isGapSmall", "jumpLargeGap", "shaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE", "jumpLargeGaps", "waitForReadyState", "eventManager", "HTMLMediaElement", "HAVE_NOTHING", "eventName", "shaka.util.MediaReadyState.READY_STATES_TO_EVENT_NAMES_.value", "shaka.util.MediaReadyState.READY_STATES_TO_EVENT_NAMES_", "HAVE_METADATA", "HAVE_CURRENT_DATA", "HAVE_FUTURE_DATA", "HAVE_ENOUGH_DATA", "onSeek", "onSeek_", "started_", "mover_", "shaka.media.VideoWrapper.PlayheadMover", "shaka.util.MediaReadyState.waitForReadyState", "setStartTime_", "shaka.media.VideoWrapper", "this.onSeek_", "getTime", "setTime", "moveTo", "startListeningToSeeks_", "targetTime_", "originTime_", "remainingAttempts_", "timer_", "shaka.media.SrcEqualsPlayhead.prototype", "JSC$2491_ready", "onLoaded", "JSC$2491_setStartTime", "JSC$2491_getTime", "notifyOfBufferingChange", "presentationTimeline", "minBufferTime_", "minBufferTime", "lastCorrectiveSeek_", "gapController_", "createStallDetector_", "videoWrapper_", "onSeeking_", "targetTime", "reposition_", "getStartTime_", "checkWindowTimer_", "onPollWindow_", "seekStart", "minSeekRange_", "shaka.media.MediaSourcePlayhead.prototype", "clampTime_", "clampSeekToDuration_", "durationBackoff", "rebufferingGoal", "safeSeekOffset", "safe", "seekSafe", "shaka.media.TimeRangesUtils.isBuffered", "stallEnabled", "stallSkip", "detector", "shaka.media.StallDetector.MediaElementImplementation", "stallThreshold", "pause", "play", "numEvicted", "immutable_", "shaka.media.SegmentIndex.prototype", "markImmutable", "lastReferenceIndex", "ref", "merge", "mergeAndEvict", "windowStart", "evict", "oldSize", "fit", "windowEnd", "isNew", "lastReference", "firstReference", "updateEvery", "interval", "updateCallback", "shaka.media.SegmentIndex", "Symbol", "getIteratorForTime", "iter", "partialSegmentIndex", "shaka.media.SegmentIterator", "shaka.media.SegmentIndex.forSingleSegment", "segmentIndex_", "currentPosition_", "currentPartialPosition_", "MAX_VALUE", "partial", "shaka.media.SegmentIndex.call", "indexes_", "shaka.media.MetaSegmentIndex", "SegmentIndex", "shaka.media.MetaSegmentIndex.prototype", "numPassedInEarlierIndexes", "harness", "harness_", "isBuffering_", "rate_", "getRate", "movePlayhead", "pollRate_", "shaka.media.PlayRateController", "apply_", "getDefaultRate", "calculateCurrentRate_", "applyRate_", "oldRate", "setRate", "newRate", "observers_", "pollingLoop_", "pollAllObservers_", "shaka.media.PlayheadObserverManager", "observer", "poll", "contentTypeStates_", "getBufferedInfo_", "shaka.media.QualityObserver", "getContentTypeState_", "contentTypeState", "qualityChangePositions", "currentQuality", "addMediaQualityChange", "purgeQualityChangePositions_", "newChangePosition", "changePositions", "insertBeforeIndex", "qualityChange", "positionInSeconds", "qualityAtPosition", "mq1", "mq2", "bufferedRanges", "bufferedInfo", "oldChangePositions", "getSeekRange", "regions_", "getSeekRange_", "filterTimer_", "seekRange", "filterBySeekRange_", "shaka.media.RegionTimeline.REGION_FILTER_INTERVAL", "shaka.media.RegionTimeline", "oldPosition_", "rules_", "weWere", "weAre", "shaka.media.RegionObserver.RelativePosition_.IN_THE_REGION", "invoke", "shaka.media.RegionObserver.RelativePosition_.BEFORE_THE_REGION", "shaka.media.RegionObserver.RelativePosition_.AFTER_THE_REGION", "shaka.media.RegionObserver", "wasSeeking", "previousPosition", "currentPosition", "rule", "eventType", "BEFORE_THE_REGION", "IN_THE_REGION", "AFTER_THE_REGION", "createSegmentRequest", "manifest_", "bufferingGoalScale_", "currentTextStream_", "currentVariant_", "textStreamSequenceId_", "mediaStates_", "failureCallbackBackoff_", "fatalError_", "shaka.media.StreamingEngine", "aborts", "state", "cancelUpdate_", "abortOperations_", "failureRetryParams", "initStreams_", "loadNewTextStream_", "currentSequenceId", "streamText", "mediaSourceEngine", "isTextVisible", "alwaysStreamText", "createMediaState_", "scheduleUpdate_", "unloadTextStream", "setTrickPlay", "mediaState", "trickModeVideo", "restoreStreamAfterTrickPlay", "switchInternal_", "normalVideo", "switchVariant", "clearBuffer", "safeMargin", "force", "switchTextStream", "textStream", "closeSegmentIndex", "segmentIterator", "clearingBuffer", "waitingToFlushBuffer", "performingUpdate", "waitingToClearBuffer", "clearBufferSafeMargin", "clearBuffer_", "makeAbortDecision_", "originalStream", "originalOperation", "createSegmentIndex", "presentationTime", "shouldAbortCurrentRequest_", "getPresentationTime", "lastSegmentReference", "newSegment", "newSegmentSize", "bandwidthEstimate", "safetyBuffer", "forceClearBuffer_", "updateTimer", "shaka.util.Error.Category.STREAMING", "shaka.util.Error.Code.STREAMING_ENGINE_STARTUP_INVALID_STATE", "setDuration_", "lastInitSegmentReference", "lastTimestampOffset", "lastAppendWindowStart", "lastAppendWindowEnd", "recovering", "hasError", "onUpdate_", "thisStream", "mediaStates", "update_", "handleStreamingError_", "ms", "shaka.media.StreamingEngine.isEmbeddedText_", "timeNeeded", "bufferedAhead", "scaledBufferingGoal", "bufferingGoal", "unscaledBufferingGoal", "timeUntilEnd", "oneMicrosecond", "textState", "updateIntervalSeconds", "getSegmentReferenceNeeded_", "otherState", "minTimeNeeded", "maxRunAhead", "fetchAndAppend_", "inaccurateTolerance", "inaccurateManifestTolerance", "lookupTime", "isMP4", "isReadableStreamSupported", "fetchSegment", "remaining", "processingResult", "callbackCalled", "initSourceBuffer_", "ReadableStream", "lowLatencyMode", "sawMDAT", "dataToAppend", "concatArray_", "fetch_", "shaka.log.v1", "ignoreTextStreamFailures", "handleQuotaExceeded_", "waitingForAnotherStreamToRecover", "percentBefore", "round", "setProperties", "fetchInit", "shaka.media.StreamingEngine.APPEND_WINDOW_START_FUDGE_", "shaka.media.StreamingEngine.APPEND_WINDOW_END_FUDGE_", "shaka.media.InitSegmentReference.equal", "onInitSegmentAppended", "emsgSchemeIdUris", "dispatchAllEmsgBoxes", "schemeId", "presentationTimeDelta", "eventDuration", "messageData", "parseEMSG_", "onManifestUpdate", "emsg", "schemeIdUri", "shaka.Player.EventName.Emsg", "evict_", "bufferBehind", "bufferedBehind", "overflow", "isEmbeddedText_", "requestType", "shaka.util.Networking.createSegmentRequest", "modifySegmentRequest", "failureCallback", "startingAt", "startingWith", "shaka.Player.createEmptyPayload_", "currentlyAt_", "currentlyWith_", "waitForWork_", "requests_", "currentStep_", "currentRoute_", "mainLoopPromise_", "mainLoop_", "shaka.routing.Walker", "unblockMainLoop_", "onCancel", "startNewRoute", "onStart", "onEnd", "onSkip", "onEnter", "tryNewRoute_", "interruptible", "newRoute", "node", "takeNextStep_", "onIdle", "getNext", "enterNode", "handleError", "textTrack_", "textTracks", "shaka.Player.TextTrackLabel", "addTextTrack", "shaka.text.SimpleTextDisplayer.prototype", "shaka.text.SimpleTextDisplayer.removeWhere_", "removeInRange", "getCuesToFlatten", "flatCue", "flattenPayload", "openStyleTags", "bold", "shaka.text.Cue.fontWeight.BOLD", "prefixStyleTags", "acc", "tag", "suffixStyleTags", "reduceRight", "flattenedCues", "textTrackCues", "cuesInTextTrack", "inCue", "cueInTextTrack", "containsCue", "shaka.text.SimpleTextDisplayer.convertToTextTrackCue_", "sortedCues", "VTTCue", "addCue", "removeIt", "setTextVisibility", "shakaCue", "vttCue", "align", "shaka.text.Cue.writingMode.VERTICAL_LEFT_TO_RIGHT", "vertical", "shaka.text.Cue.writingMode.VERTICAL_RIGHT_TO_LEFT", "shaka.text.Cue.lineInterpretation.PERCENTAGE", "snapToLines", "removeWhere_", "predicate", "oldState", "removeCue", "shaka.text.SimpleTextDisplayer", "removeAllChildren", "firstChild", "removeChild", "shaka.util.Dom", "shaka.util.Dom.removeAllChildren", "videoContainer", "isTextVisible_", "cues_", "videoContainer_", "textContainer_", "classList", "style", "display", "flexDirection", "alignItems", "justifyContent", "appendChild", "captionsTimer_", "updateCaptions_", "updatePeriod", "currentCuesMap_", "resizeObserver_", "ResizeObserver", "observe", "regionElements_", "shaka.text.UITextDisplayer.prototype", "cuesList", "cueInList", "disconnect", "oldNumCues", "isElementUnderTextContainer_", "elemToCheck", "parentElement", "updateCuesRecursive_", "container", "parents", "updateDOM", "toUproot", "toPlant", "cueRegistry", "shouldBeDisplayed", "wrapper", "cueElement", "regionElement", "createCue_", "forceUpdate", "previousCuesMap", "isNested", "needWrapper", "setCaptionStyles_", "regionId", "getRegionElement_", "heightUnit", "widthUnit", "viewportAnchorUnit", "top", "left", "shaka.text.Cue.displayAlign.BEFORE", "shaka.text.Cue.displayAlign.CENTER", "hasWrapper", "isLeaf", "whiteSpace", "nonBreakingSpace", "repeat", "webkitTextStrokeColor", "webkitTextStrokeWidth", "paddingLeft", "shaka.text.UITextDisplayer.convertLengthValue_", "paddingRight", "backgroundRepeat", "backgroundSize", "backgroundPosition", "shaka.text.UITextDisplayer.inheritProperty_", "margin", "shaka.text.Cue.lineAlign.END", "bottom", "right", "paddingTop", "shaka.text.Cue.positionAlign.LEFT", "cssFloat", "shaka.text.Cue.positionAlign.RIGHT", "webkitWritingMode", "convertLengthValue_", "lengthValue", "unit", "lengthValueInfo", "clientHeight", "inheritProperty_", "shaka.text.UITextDisplayer", "convert", "adCuePoints", "webvttTimeString", "adCuePoint", "milliseconds", "webvttString", "webvttSettings", "settings", "shaka.text.Cue.textAlign.START", "shaka.text.Cue.textAlign.END", "shaka.text.WebVttGenerator", "sid_", "sf_", "playbackStarted_", "buffering_", "starved_", "applySegmentData", "segmentInfo", "st", "getStreamType_", "shaka.util.CmcdManager.StreamType.LIVE", "shaka.util.CmcdManager.StreamType.VOD", "ot", "getObjectType_", "isMedia", "shaka.util.CmcdManager.ObjectType.VIDEO", "shaka.util.CmcdManager.ObjectType.AUDIO", "shaka.util.CmcdManager.ObjectType.MUXED", "shaka.util.CmcdManager.ObjectType.TIMED_TEXT", "bl", "getBufferLength_", "br", "tb", "getTopBandwidth_", "appendSrcData", "createData_", "shaka.util.CmcdManager.ObjectType.MANIFEST", "su", "shaka.util.CmcdManager.serialize", "shaka.util.CmcdManager.appendQueryToUri", "appendTextTrackData", "shaka.util.CmcdManager.ObjectType.CAPTION", "crypto", "randomUUID", "shaka.util.CmcdManager.Version", "sf", "sid", "cid", "mtp", "useHeaders", "pr", "getPlaybackRate", "isVideo", "bs", "shaka.util.CmcdManager.toHeaders", "shaka.util.CmcdManager.ObjectType.INIT", "ranges", "NaN", "getCurrentTime", "range", "getVariantTracks", "serialize", "toHundred", "toRounded", "isValid", "results", "formatters", "dl", "nor", "toUrlSafe", "rtp", "formatter", "toHeaders", "headerNames", "headerGroups", "headerMap", "nrr", "appendQueryToUri", "MANIFEST", "MUXED", "INIT", "CAPTION", "TIMED_TEXT", "VOD", "LIVE", "shaka.util.CmcdManager.StreamingFormat", "DASH", "HLS", "OTHER", "mergeConfigObjects", "destination", "source", "template", "overrides", "ignoreKeys", "subPath", "subTemplate", "subMergeValid", "shaka.util.ConfigUtils.mergeConfigObjects", "convertToConfigObject", "fieldName", "configObject", "last", "searchIndex", "nameStart", "referenceParametersAndReturn", "returnValue", "shaka.util.ConfigUtils", "shaka.util.ConfigUtils.convertToConfigObject", "createDefault", "abrMaxHeight", "saveData", "drm", "shaka.media.DrmEngine.defaultInitDataTransform", "availabilityWindowOverride", "disableAudio", "disableVideo", "disableText", "disableThumbnails", "defaultPresentationDelay", "dash", "clockSyncUri", "ignoreDrmInfo", "disableXlinkProcessing", "xlinkFailGracefully", "ignoreMinBufferTime", "initialSegmentLimit", "ignoreSuggestedPresentationDelay", "ignoreEmptyAdaptationSet", "ignoreMaxSegmentDuration", "keySystemsByURI", "manifestPreprocessor", "shaka.util.ConfigUtils.referenceParametersAndReturn", "hls", "ignoreImageStreamFailures", "useFullSegmentsForStartTime", "defaultAudioCodec", "defaultVideoCodec", "streaming", "startAtSegmentBoundary", "useNativeHlsOnSafari", "autoLowLatencyMode", "preferNativeHls", "observeQualityChanges", "offline", "trackSelectionCallback", "tracks", "downloadSizeCallback", "sizeEstimate", "estimate", "storage", "usage", "quota", "progressCallback", "content", "progress", "usePersistentLicense", "abrFactory", "abr", "preferredAudioLanguage", "preferredTextLanguage", "preferredVariantRole", "preferredTextRole", "preferForcedSubs", "playRangeStart", "playRangeEnd", "textDisplayFactory", "cmcd", "offline.trackSelectionCallback", "shaka.util.PlayerConfiguration.defaultTrackSelect", "updates", "shaka.util.PlayerConfiguration.createDefault", "defaultTrackSelect", "allVariants", "selectedVariants", "tracksByHeight", "selectedTracks", "middleIndex", "shaka.util.PlayerConfiguration", "shaka.util.PlayerConfiguration.mergeConfigObjects", "open_", "closed_", "start_", "timestamp", "currentTimeSeconds", "getTimeSpentIn", "entry", "getCopy", "currentText_", "history_", "updateCurrentText", "newText", "fromAdaptation", "bandwidthEstimate_", "currentStreamBandwidth_", "maxSegmentDurationSeconds_", "liveLatencySeconds_", "drmTimeSeconds_", "manifestTimeSeconds_", "loadLatencySeconds_", "completionPercent_", "totalCorruptedFrames_", "totalDecodedFrames_", "totalDroppedFrames_", "height_", "width_", "stateHistory_", "shaka.util.StateHistory", "switchHistory_", "shaka.util.SwitchHistory", "dependencyInjector", "loadMode_", "shaka.Player.LoadMode.NOT_LOADED", "globalEventManager_", "attachEventManager_", "loadEventManager_", "abrManagerFactory_", "abrManager_", "assetUri_", "parserFactory_", "streamingEngine_", "qualityObserver_", "cmcdManager_", "regionTimeline_", "bufferObserver_", "bufferPoller_", "playRateController_", "playheadObservers_", "playhead_", "mediaSourceEngine_", "drmEngine_", "networkingEngine_", "nextExternalStreamId_", "defaultConfig_", "maxHwRes_", "stats_", "currentAdaptationSetCriteria_", "currentTextLanguage_", "currentTextRole_", "currentTextForced_", "cleanupOnUnload_", "updatedStartTime_", "createNetworkingEngine", "adManager_", "shaka.Player.adManagerFactory_", "retryStreaming", "detachNode_", "attachNode_", "unloadNode_", "parserNode_", "manifestNode_", "mediaSourceNode_", "drmNode_", "loadNode_", "srcEqualsDrmNode_", "srcEqualsNode_", "actions", "wants", "onAttach_", "onDetach_", "onUnload_", "onInitializeMediaSourceEngine_", "onInitializeParser_", "onParseManifest_", "onInitializeDrm_", "onLoad_", "onInitializeSrcEqualsDrm_", "onSrcEquals_", "walker_", "walkerImplementation", "at", "goingTo", "getNextStep_", "getNextMatchingAllDependencies_", "makeEvent_", "shaka.Player.EventName.OnStateChange", "action", "shaka.Player.EventName.OnStateIdle", "shaka.Player", "events", "shaka.Player.LoadMode.DESTROYED", "events.onStart", "events.onEnd", "events.onCancel", "events.onError", "events.onSkip", "shaka.Player.prototype", "initializeMediaSource", "createAbortLoadError_", "shaka.util.Platform.supportsMediaSource", "wrapWalkerListenersWithPromise_", "detach", "unload", "currentPayload", "updateStartTime", "assetUri", "shaka.Player.EventName.Loading", "startTimeOfLoad", "shouldUseSrcEquals_", "useSrcEquals", "shaka.util.Stats", "createCmcd_", "shaka.util.Error.Code.NO_VIDEO_ELEMENT", "shaka.Player.EventName.Loaded", "shaka.Player.SRC_EQUAL_EXTENSIONS_TO_MIME_TYPES_", "videoErrorToShakaError_", "onVideoError_", "cleanupTasks", "shaka.Player.EventName.Unloading", "onAssetUnload", "lastChild", "lastTextFactory_", "updateBufferState_", "closedCaptionsParser", "textDisplayerFactory", "createMediaSourceEngine", "dispatchMetadataEvent_", "processTimedMetadataMediaSrc_", "metadataType", "frame", "onHlsTimedMetadata", "networkingEngine", "manifestConfig", "shaka.media.ManifestParser.getFactory", "nodeName", "onRegionEvent_", "shaka.Player.EventName.TimelineRegionAdded", "onDashTimedMetadata", "mediaQualityInfo", "onMediaQualityChange_", "shaka.Player.EventName.MediaQualityChanged", "modifyManifestRequest", "manifestInfo", "filterManifest_", "makeTextStreamsForClosedCaptions", "makeTextStreamsForClosedCaptions_", "onTimelineRegionAdded", "findSimilarRegion_", "similarRegion", "isLowLatencyMode", "isLowLatencyMode_", "isAutoLowLatencyMode", "isAutoLowLatencyMode_", "enableLowLatencyMode", "delta", "shaka.Player.EventName.ManifestParsed", "shaka.util.Error.Code.NO_VARIANTS", "shaka.Player.filterForAVVariants_", "firstEvent", "createDrmEngine", "onKeyStatus_", "onExpirationUpdated_", "shaka.Player.EventName.DrmSessionUpdate", "updateStateHistory", "onRateChange", "rebufferThreshold", "initialVariant", "activeVariantTrack", "adjustedTime", "activeTextTrack", "initialTextStream", "defaultPlaybackRate", "updateStateHistory_", "onRateChange_", "this.abrManager_.playbackRateChanged", "shaka.Player.applyPlayRange_", "switchVariant_", "createPlayhead", "createPlayheadObserversForMSE_", "startBufferManagement_", "shaka.util.StreamUtils.chooseCodecsAndFilterManifest", "createStreamingEngine", "shaka.Player.LoadMode.MEDIA_SOURCE", "activateChaptersTrack_", "shaka.Player.EventName.Streaming", "t", "updateAbrManagerVariants_", "chooseVariant_", "adjustStartTime_", "onAdaptation_", "shaka.util.StreamUtils.variantToTrack", "getTextTracks", "shaka.util.StreamUtils.filterStreamsByLanguageAndRole", "chooseTextStream_", "addTextStreamToSwitchHistory_", "shouldInitiallyShowText_", "setInitialTextState_", "onTextTrackVisibility_", "shouldStreamText_", "isTextTrackVisible", "onAbrStatusChanged_", "filterManifestByCurrentVariant_", "checkPlayableVariants_", "onTracksChanged_", "hasPrimary", "shaka.util.MimeUtils.getCodecs", "encrypted", "shaka.media.SrcEqualsPlayhead", "unloaded", "preload", "audioTracks", "processTimedMetadataSrcEqls_", "shaka.Player.LoadMode.SRC_EQUALS", "fullyLoaded", "setupPreferredAudioOnSrc_", "getFilteredTextTracks_", "setupPreferredTextOnSrc_", "abortedError", "selectAudioLanguage", "selectTextLanguage", "activeCues", "onCueMetadataChange", "getMetadataTracks_", "shaka.Player.EventName.Metadata", "filterForAVVariants_", "isAVVariant", "shaka.media.DrmEngine", "bytesDownloaded", "shaka.Player.EventName.DownloadHeadersReceived", "shaka.Player.EventName.DownloadFailed", "shaka.media.MediaSourcePlayhead", "pollBufferState_", "regionObserver", "shaka.Player.EventName.TimelineRegionEnter", "shaka.Player.EventName.TimelineRegionExit", "manager", "shaka.media.BufferingObserver", "updateBufferingSettings_", "shaka.Player.TYPICAL_BUFFERING_THRESHOLD_", "satisfiedThreshold", "isBufferedToEndSrc_", "fudge", "isBufferedToEndMS_", "liveEdge", "bufferedToEnd", "bufferLead", "newState", "shaka.media.MediaSourceEngine", "shaka.util.CmcdManager", "onManifestUpdate_", "onSegmentAppended_", "arguments", "applyConfig_", "filterManifestWithRestrictions_", "activeVariant", "chooseVariantAndSwitch_", "oldTextDisplayer", "getBufferFullness", "bufferedLength", "bufferedEnd", "lengthToBeBuffered", "resetConfiguration", "getLoadMode", "getMediaElement", "getNetworkingEngine", "getAssetUri", "getAdManager", "isAudioOnly", "videoTracks", "videoHeight", "seekable", "goToLive", "isBuffering", "trickPlay", "cancelTrickPlay", "activeTracks", "shaka.util.StreamUtils.html5AudioTrackToTrack", "currentTextStream", "shaka.util.StreamUtils.textStreamToTrack", "shaka.util.StreamUtils.html5TextTrackToTrack", "getImageTracks", "image", "shaka.util.StreamUtils.imageStreamToTrack", "getThumbnails", "imageStream", "referencePosition", "fullImageWidth", "fullImageHeight", "totalImages", "segmentDuration", "thumbnailDuration", "thumbnailTime", "positionX", "positionY", "thumbnailPosition", "imageHeight", "imageWidth", "selectTextTrack", "onTextChanged_", "selectVariantTrack", "switchHtml5Track_", "getAudioLanguagesAndRoles", "shaka.Player.getLanguageAndRolesFrom_", "getTextLanguagesAndRoles", "getAudioLanguages", "shaka.Player.getLanguagesFrom_", "getTextLanguages", "diff", "bestVariant", "curVariant", "selectedLanguage", "languageAndRoleMatch", "languageMatch", "chosenText", "selectVariantsByLabel", "firstVariantWithLabel", "trackMatch", "expected", "actual", "getChaptersTracks", "getChaptersTracks_", "getChapters", "inputlanguage", "chaptersTracksWithLanguage", "chaptersTracks", "chapters", "uniqueChapters", "chaptersTrack", "chapter", "title", "setTextTrackVisibility", "newVisibility", "getPlayheadTimeAsDate", "walkerPayload", "getStartDate", "startDate", "getPresentationStartTimeAsDate", "getStats", "streamBandwidth", "decodedFrames", "droppedFrames", "corruptedFrames", "estimatedBandwidth", "completionPercent", "loadLatency", "manifestTimeSeconds", "drmTimeSeconds", "playTime", "pauseTime", "bufferingTime", "licenseTime", "liveLatency", "switchHistory", "stateHistory", "completionRatio", "percent", "getVideoPlaybackQuality", "totalVideoFrames", "droppedVideoFrames", "dropped", "corruptedVideoFrames", "corrupted", "licenseSeconds", "valueOf", "videoWidth", "shaka.util.Error.Code.CONTENT_NOT_LOADED", "shaka.Player.TEXT_EXTENSIONS_TO_MIME_TYPES_", "shaka.util.Error.Code.TEXT_COULD_NOT_GUESS_MIME_TYPE", "shaka.util.Error.Code.TEXT_ONLY_WEBVTT_SRC_EQUALS", "trackElement", "srclang", "setAttribute", "srcTrack", "shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_SRC_EQUALS", "shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM", "shaka.util.Error.Code.MISSING_TEXT_PLUGIN", "addTextTrackAsync", "vvtText", "blob", "getTextMimetype_", "getServerSideCuePoints", "addSrcTrackElement_", "getTextData_", "convertToWebVTT_", "Blob", "addChaptersTrack", "shaka.util.Error.Code.CHAPTERS_TRACK_FAILED", "shaka.text.WebVttGenerator.convert", "setMaxHardwareResolution", "retryDelaySeconds", "delaySeconds", "getManifest", "getManifestParserFactory", "config.streaming.failureCallback", "defaultStreamingFailureCallback_", "shaka.util.Error.Code.HTTP_ERROR", "config.textDisplayFactory", "setVideoContainer", "closedCaptionsSet", "CLOSED_CAPTION", "filterManifestWithStreamUtils_", "shaka.util.StreamUtils.filterManifest", "tracksChanged", "originalAllowed", "curDrmInfo", "checkRestrictedVariants_", "activeAudio", "activeVideo", "getAdjustedTime", "audioStartTime", "videoStartTime", "refTime", "shaka.Player.EventName.Buffering", "shaka.Player.EventName.RateChange", "history", "playableVariants", "adaptationSet", "addVariantToSwitchHistory_", "oldTrack", "newTrack", "onVariantChanged_", "currentTrack", "audioStream", "preferredTextLocale", "audioLocale", "textLocale", "to", "shaka.Player.EventName.Adaptation", "delayDispatchEvent_", "shaka.Player.EventName.TracksChanged", "shaka.Player.EventName.VariantChanged", "shaka.Player.EventName.TextChanged", "shaka.Player.EventName.TextTrackVisibility", "shaka.Player.EventName.AbrStatusChanged", "shaka.Player.EventName.Error", "eventElement", "msExtendedCode", "shaka.util.Error.Code.VIDEO_ERROR", "keyStatusMap", "isGlobalStatus", "keyStatus", "shaka.Player.restrictedStatuses_.includes", "variantsUpdated", "shaka.Player.EventName.ExpirationUpdated", "applyPlayRange_", "fullDuration", "hasPlayable", "hasAppRestrictions", "missingKeys", "badKeyStatuses", "restrictedKeyStatuses", "shaka.util.Error.Code.RESTRICTIONS_CANNOT_BE_MET", "valid", "shaka.util.Error.Code.CONTENT_UNSUPPORTED_BY_BROWSER", "getLanguagesFrom_", "languages", "getLanguageAndRolesFrom_", "languageToRoles", "languageRoleToLabel", "pairings", "shaka.util.Error.Code.LOAD_INTERRUPTED", "destinationNode", "resetNode", "createEmptyPayload_", "listeners.onCancel", "listeners.onEnd", "listeners.onError", "listeners.onSkip", "promptsOkay", "media", "plugins", "shaka.media.DrmEngine.probeSupport", "testExtensions", "testMimeTypes", "shaka.util.Platform.supportsMediaType", "basicType", "shaka.Player.supportPlugins_", "isBrowserSupported", "shaka.util.Platform.safariVersion", "MediaKeys", "MediaKeySystemAccess", "setAdManagerFactory", "registerSupportPlugin", "AbrStatusChanged", "Adaptation", "Buffering", "DownloadFailed", "DownloadHeadersReceived", "DrmSessionUpdate", "Emsg", "ExpirationUpdated", "Loaded", "Loading", "ManifestParsed", "MediaQualityChanged", "Metadata", "OnStateChange", "OnStateIdle", "RateChange", "Streaming", "TextChanged", "TextTrackVisibility", "TimelineRegionAdded", "TimelineRegionEnter", "TimelineRegionExit", "TracksChanged", "Unloading", "VariantChanged", "shaka.Player.EventName", "LargeGap", "SessionDataEvent", "shaka.Player.LoadMode", "shaka.Player.version", "shaka.Deprecate.onPending_", "shaka.Deprecate.onExpired_", "shaka.Player.restrictedStatuses_", "loadTimes_", "skipped_", "playedCompletely_", "imaAd", "imaAdManager", "ad_", "manager_", "isPaused_", "volume_", "getVolume", "google", "ima", "AdEvent", "PAUSED", "RESUMED", "shaka.ads.ClientSideAd.prototype", "getMinSuggestedDuration", "getRemainingTime", "isPaused", "isSkippable", "getSkipTimeOffset", "getTimeUntilSkippable", "skipOffset", "canSkipIn", "canSkipNow", "getAdSkippableState", "resume", "setVolume", "volume", "isMuted", "isLinear", "resize", "fullscreenElement", "ViewMode", "FULLSCREEN", "NORMAL", "setMuted", "muted", "getSequenceLength", "podInfo", "getAdPodInfo", "getTotalAds", "getPositionInSequence", "getAdPosition", "shaka.ads.ClientSideAd", "adContainer", "adContainer_", "requestAdsStartTime_", "setLocale", "adDisplayContainer", "AdDisplayContainer", "initialize", "adsLoader_", "AdsLoader", "getSettings", "setPlayerType", "setPlayerVersion", "imaAdsManager_", "AdsManagerLoadedEvent", "ADS_MANAGER_LOADED", "onAdsManagerLoaded_", "AdErrorEvent", "AD_ERROR", "onAdError_", "contentComplete", "shaka.ads.ClientSideAdManager", "getError", "onAdComplete_", "shaka.ads.AdManager.CUEPOINTS_CHANGED", "shaka.ads.AdManager.ADS_LOADED", "getAdsManager", "shaka.ads.AdManager.IMA_AD_MANAGER_LOADED", "cuePointStarts", "getCuePoints", "cuePoints", "shakaCuePoint", "addImaEventListeners_", "offsetWidth", "offsetHeight", "adError", "convertEventAndSend", "CONTENT_PAUSE_REQUESTED", "onAdStart_", "STARTED", "FIRST_QUARTILE", "shaka.ads.AdManager.AD_FIRST_QUARTILE", "MIDPOINT", "shaka.ads.AdManager.AD_MIDPOINT", "THIRD_QUARTILE", "shaka.ads.AdManager.AD_THIRD_QUARTILE", "COMPLETE", "shaka.ads.AdManager.AD_COMPLETE", "CONTENT_RESUME_REQUESTED", "ALL_ADS_COMPLETED", "SKIPPED", "shaka.ads.AdManager.AD_SKIPPED", "VOLUME_CHANGED", "shaka.ads.AdManager.AD_VOLUME_CHANGED", "VOLUME_MUTED", "shaka.ads.AdManager.AD_MUTED", "shaka.ads.AdManager.AD_PAUSED", "shaka.ads.AdManager.AD_RESUMED", "SKIPPABLE_STATE_CHANGED", "shaka.ads.AdManager.AD_SKIP_STATE_CHANGED", "CLICK", "shaka.ads.AdManager.AD_CLICKED", "AD_PROGRESS", "shaka.ads.AdManager.AD_PROGRESS", "AD_BUFFERING", "shaka.ads.AdManager.AD_BUFFERING", "IMPRESSION", "shaka.ads.AdManager.AD_IMPRESSION", "DURATION_CHANGE", "shaka.ads.AdManager.AD_DURATION_CHANGED", "USER_CLOSE", "shaka.ads.AdManager.AD_CLOSED", "LOADED", "shaka.ads.AdManager.AD_LOADED", "shaka.ads.AdManager.ALL_ADS_COMPLETED", "LINEAR_CHANGED", "shaka.ads.AdManager.AD_LINEAR_CHANGED", "AD_METADATA", "shaka.ads.AdManager.AD_METADATA", "LOG", "shaka.ads.AdManager.AD_RECOVERABLE_ERROR", "AD_BREAK_READY", "shaka.ads.AdManager.AD_BREAK_READY", "INTERACTION", "shaka.ads.AdManager.AD_INTERACTION", "getAd", "shaka.ads.AdManager.AD_STARTED", "shaka.ads.AdManager.AD_STOPPED", "adProgressData_", "shaka.ads.ServerSideAd.prototype", "shaka.ads.ServerSideAd", "streamPromise_", "streamRequestStartTime_", "isLiveContent_", "snapForwardTime_", "backupUrl_", "currentCuePoints_", "uiSettings", "dai", "api", "UiSettings", "streamManager_", "StreamManager", "shaka.ads.AdManager.IMA_STREAM_MANAGER_LOADED", "StreamEvent", "onLoaded_", "AD_BREAK_STARTED", "AD_BREAK_ENDED", "onAdBreakEnded_", "onAdProgress_", "getStreamData", "streamData", "adProgressData", "CUEPOINTS_CHANGED", "cuepoints", "point", "onCuePointsChanged_", "shaka.ads.ServerSideAdManager", "onTimedMetadata", "checkForSnapback_", "streamTimeForContentTime", "previousCuePoint", "previousCuePointForStreamTime", "played", "ssAdManager_", "csAdManager_", "shaka.ads.AdsStats", "locale_", "shaka.ads.AdManager", "shaka.ads.AdManager.prototype", "initClientSide", "shaka.util.Error.Category.ADS", "shaka.util.Error.Code.CS_IMA_SDK_MISSING", "loadTime", "requestClientSideAds", "imaRequest", "shaka.util.Error.Code.CS_AD_MANAGER_NOT_INITIALIZED", "requestAds", "initServerSide", "shaka.util.Error.Code.SS_IMA_SDK_MISSING", "requestServerSideStream", "backupUrl", "shaka.util.Error.Code.SS_AD_MANAGER_NOT_INITIALIZED", "adTagParameters", "adTagParams", "shaka.util.Error.Code.CURRENT_DAI_REQUEST_NOT_FINISHED", "LiveStreamRequest", "requestStream", "replaceServerSideAdTagParameters", "replaceAdTagParameters", "loadTimes", "started", "playedCompletely", "skipped", "processMetadata", "thing", "Event", "simpleEvent", "eventKey", "eventValue", "properties", "getOwnPropertyNames", "contents", "deserialize", "simulateTimeRanges_", "shaka.cast.CastUtils.VideoEvents", "shaka.cast.CastUtils.VideoAttributes", "shaka.cast.CastUtils.VideoInitStateAttributes", "shaka.cast.CastUtils.VideoVoidMethods", "shaka.cast.CastUtils.PlayerGetterMethods", "shaka.cast.CastUtils.LargePlayerGetterMethods", "shaka.cast.CastUtils.PlayerGetterMethodsThatRequireLive", "shaka.cast.CastUtils.PlayerInitState", "shaka.cast.CastUtils.PlayerInitAfterLoadState", "shaka.cast.CastUtils.PlayerVoidMethods", "shaka.cast.CastUtils.PlayerPromiseMethods", "receiverAppId", "onStatusChanged", "onFirstCastStateUpdate", "onRemoteEvent", "onResumeLocal", "onInitStateRequired", "receiverAppId_", "statusChangeTimer_", "onFirstCastStateUpdate_", "hasJoinedExistingSession_", "onRemoteEvent_", "onResumeLocal_", "onInitStateRequired_", "isCasting_", "apiReady_", "receiverName_", "appData_", "onConnectionStatusChangedBound_", "this.onConnectionStatusChangedBound_", "onConnectionStatusChanged_", "onMessageReceivedBound_", "this.onMessageReceivedBound_", "namespace", "serialized", "shaka.cast.CastUtils.deserialize", "targetName", "shaka.util.FakeEvent.fromRealEvent", "onMessageReceived_", "cachedProperties_", "property", "asyncCallPromises_", "reconstructedError", "nextAsyncCallId_", "castPromise_", "shaka.cast.CastSender.instances_.add", "shaka.cast.CastSender.prototype", "shaka.cast.CastSender.instances_.delete", "rejectAllPromises_", "shaka.cast.CastSender.session_", "removeListeners_", "isCasting", "receiverName", "chrome", "isAvailable", "sessionRequest", "SessionRequest", "apiConfig", "ApiConfig", "shaka.cast.CastSender.instances_", "onExistingSessionJoined_", "instance", "availability", "shaka.cast.CastSender.hasReceivers_", "shaka.cast.CastSender.STATUS_DELAY", "oldSession", "SessionStatus", "STOPPED", "__onGCastApiAvailable", "shaka.cast.CastSender.onGCastApiAvailable_", "shaka.cast.CastSender.__onGCastApiAvailable_", "setAppData", "appData", "sendMessage_", "initState", "shaka.util.Error.Category.CAST", "shaka.util.Error.Code.CAST_API_UNAVAILABLE", "shaka.util.Error.Code.NO_CAST_RECEIVERS", "shaka.util.Error.Code.ALREADY_CASTING", "requestSession", "onSessionInitiated_", "onConnectionError_", "showDisconnectDialog", "forceDisconnect", "shaka.cast.CastSender.session_.stop", "shaka.cast.CastUtils.VideoVoidMethods.includes", "remoteCall_", "shaka.cast.CastUtils.PlayerVoidMethods.includes", "shaka.cast.CastUtils.PlayerPromiseMethods.includes", "remoteAsyncCall_", "propertyGetter_", "addUpdateListener", "onSessionCreated_", "addMessageListener", "shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE", "shaka.util.Error.Code.UNEXPECTED_CAST_ERROR", "shaka.util.Error.Code.CAST_CANCELED_BY_USER", "shaka.util.Error.Code.CAST_CONNECTION_TIMED_OUT", "shaka.util.Error.Code.CAST_RECEIVER_APP_UNAVAILABLE", "methodName", "removeUpdateListener", "removeMessageListener", "connected", "shaka.cast.CastSender.session_.status", "shaka.cast.CastSender.session_.receiver.friendlyName", "receiver", "friendlyName", "shaka.cast.CastUtils.serialize", "sendMessage", "shaka.log.error", "available", "sender", "player", "localVideo_", "localPlayer_", "playerEventTarget_", "videoEventTarget_", "playerProxy_", "videoProxy_", "compiledToExternNames_", "sender_", "shaka.cast.CastSender", "onCastStatusChanged_", "getInitState_", "shaka.cast.CastProxy", "waitFor", "shaka.cast.CastProxy.prototype", "getVideo", "getPlayer", "canCast", "suggestDisconnect", "changeReceiverId", "newAppId", "videoProxyLocalEvent_", "playerProxyLocalEvent_", "configurable", "videoProxyGet_", "videoProxySet_", "iterateOverPlayerMethods_", "playerProxyGet_", "mapCompiledToUncompiledPlayerMethodNames_", "methodsToNames", "name2", "shouldAddToTheMap", "seenNames", "proto", "getPrototypeOf", "objProto", "pair", "setter", "getter", "manifestReady", "videoState", "appDataCallback", "contentIdCallback", "player_", "targets_", "appDataCallback_", "contentIdCallback_", "isConnected_", "isIdle_", "updateNumber_", "startUpdatingUpdateNumber_", "initialStatusUpdatePending_", "genericBus_", "shakaBus_", "pollTimer_", "pollAttributes_", "shaka.cast.CastReceiver", "isConnected", "shaka.cast.CastReceiver.prototype", "isIdle", "setContentMetadata", "clearContentMetadata", "setContentTitle", "MetadataType", "GENERIC", "setContentImage", "imageUrl", "setContentArtist", "artist", "MUSIC_TRACK", "CastReceiverManager", "getInstance", "onSenderConnected", "manager.onSenderConnected", "onSendersChanged_", "onSenderDisconnected", "manager.onSenderDisconnected", "onSystemVolumeChanged", "manager.onSystemVolumeChanged", "systemVolume", "getSystemVolume", "fakeVolumeChangeEvent_", "getCastMessageBus", "shaka.cast.CastUtils.GENERIC_MESSAGE_NAMESPACE", "onMessage", "this.genericBus_.onMessage", "onGenericMessage_", "this.shakaBus_.onMessage", "onShakaMessage_", "proxyEvent_", "canDisplayType", "shaka.cast.CastReceiver.IDLE_INTERVAL", "getSenders", "maybeSendMediaInfoMessage_", "sendMediaStatus_", "initState_", "shaka.cast.CastReceiver.POLL_INTERVAL", "frequency", "sendMediaInfoMessage_", "requestId", "setSystemVolumeLevel", "setSystemVolumeMuted", "senderId", "sendAsyncComplete_", "resumeState", "volumeObject", "oldVolumeLevel", "oldVolumeMuted", "mediaInfo", "customData", "bus", "getCastChannel", "send", "broadcast", "mediaStatus", "getPlayState_", "shaka.cast.CastReceiver.PLAY_STATE.IDLE", "shaka.cast.CastReceiver.PLAY_STATE.BUFFERING", "shaka.cast.CastReceiver.PLAY_STATE.PAUSED", "shaka.cast.CastReceiver.PLAY_STATE.PLAYING", "IDLE", "PLAYING", "BUFFERING", "psshBox", "systemIds", "cencKeyIds", "pssh", "parsePsshBox_", "numKeyIds", "createPssh", "systemId", "dataLength", "psshSize", "psshData", "byteCursor", "normaliseInitData", "shaka.util.Pssh", "dedupedInitDatas", "parseFromAdaptationSet", "elems", "parsed", "shaka.dash.ContentProtection.parseElements_", "defaultInit", "parsedNonCenc", "shaka.util.Error.Code.DASH_CONFLICTING_KEY_IDS", "shaka.dash.ContentProtection.MP4Protection_", "schemeUri", "shaka.dash.ContentProtection.convertElements_", "shaka.util.ManifestParserUtils.createDrmInfo", "defaultKeyId", "firstRepresentation", "parseFromRepresentation", "context", "repContext", "shaka.dash.ContentProtection.parseFromAdaptationSet", "asUnknown", "repUnencrypted", "asInfo", "repInfo", "shaka.util.Error.Code.DASH_NO_COMMON_KEY_SYSTEM", "parseMsPro_", "records", "recordValue", "getLaurl_", "getPlayReadyLicenseUrl", "proNode", "shaka.util.XmlUtils.findChildNS", "record", "shaka.dash.ContentProtection.parseMsPro_", "shaka.dash.ContentProtection.PLAYREADY_RECORD_TYPES.RIGHTS_MANAGEMENT", "rootElement", "shaka.dash.ContentProtection.getLaurl_", "convertElements_", "elements", "shaka.util.Pssh.createPssh", "proInitData", "licenseParser", "shaka.dash.ContentProtection.licenseUrlParsers_.get", "parseElements_", "shaka.dash.ContentProtection.parseElement_", "parseElement_", "shaka.util.XmlUtils.getAttributeNS", "shaka.dash.ContentProtection.CencNamespaceUri_", "psshs", "shaka.util.XmlUtils.getContents", "shaka.util.Error.Code.DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED", "shaka.util.Error.Code.DASH_PSSH_BAD_ENCODING", "RIGHTS_MANAGEMENT", "shaka.dash.ContentProtection.licenseUrlParsers_", "getWidevineLicenseUrl", "mslaurlNode", "shaka.dash.ContentProtection.getPlayReadyLicenseUrl", "fillUriTemplate", "uriTemplate", "representationId", "number", "valueTable", "widthStr", "valueString", "paddingSize", "parseSegmentInfo", "timescaleStr", "shaka.dash.MpdUtils.inheritAttribute", "shaka.util.XmlUtils.parsePositiveInt", "durationStr", "representation", "shaka.util.XmlUtils.parseFloat", "startNumberStr", "unscaledPresentationTimeOffset", "startNumber", "shaka.util.XmlUtils.parseNonNegativeInt", "timelineNode", "shaka.dash.MpdUtils.inheritChild", "periodInfo", "timePoints", "lastEndTime", "timePoint", "shaka.util.XmlUtils.parseAttr", "shaka.util.XmlUtils.parseInt", "nextStartTime", "periodDuration", "unscaledStart", "scaledPresentationTimeOffset", "inheritAttribute", "period", "shaka.util.Functional.isNotNull", "nodes", "inheritChild", "shaka.util.XmlUtils.findChild", "handleXlinkInElement_", "failGracefully", "baseUri", "linkDepth", "xlinkHref", "shaka.dash.MpdUtils.XlinkNamespaceUri_", "xlinkActuate", "removeAttributeNS", "shaka.util.Error.Code.DASH_XLINK_DEPTH_LIMIT", "shaka.util.Error.Code.DASH_UNSUPPORTED_XLINK_ACTUATE", "shaka.util.ManifestParserUtils.resolveUris", "shaka.util.XmlUtils.parseXml", "shaka.util.Error.Code.DASH_INVALID_XML", "setAttributeNode", "cloneNode", "shaka.dash.MpdUtils.processXlinks", "processXlinks", "shaka.dash.MpdUtils.handleXlinkInElement_", "childOperations", "resolveToZeroString", "sidxData", "sidxOffset", "shaka.media.Mp4SegmentIndexParser.parseSIDX_", "shaka.util.Error.Code.MP4_SIDX_WRONG_BOX_TYPE", "parseSIDX_", "shaka.util.Error.Code.MP4_SIDX_INVALID_TIMESCALE", "earliestPresentationTime", "firstOffset", "referenceCount", "chunk", "referenceType", "subsegmentDuration", "shaka.util.Error.Code.MP4_SIDX_TYPE_NOT_SUPPORTED", "unscaledStartTime", "referenceSize", "reader_", "shaka.util.EbmlParser", "parseElement", "vint", "parseVint_", "parseId_", "shaka.util.Error.Code.EBML_OVERFLOW", "shaka.util.EbmlParser.DYNAMIC_SIZES", "dynamicSizeConst", "elementSize", "shaka.util.EbmlElement", "firstByte", "log2", "getUint", "parseCues_", "cuesElement", "segmentOffset", "timecodeScale", "lastTime", "lastOffset", "shaka.media.WebmSegmentIndexParser.CUE_POINT_ID", "tuple", "shaka.media.WebmSegmentIndexParser.parseCuePoint_", "unscaledTime", "currentOffset", "relativeOffset", "parseCuePoint_", "cuePointElement", "cueTimeElement", "shaka.media.WebmSegmentIndexParser.CUE_TIME_ID", "shaka.util.Error.Code.WEBM_CUE_TIME_ELEMENT_MISSING", "cueTrackPositionsElement", "shaka.media.WebmSegmentIndexParser.CUE_TRACK_POSITIONS_ID", "shaka.util.Error.Code.WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING", "cueTrackParser", "shaka.media.WebmSegmentIndexParser.CUE_CLUSTER_POSITION", "createInitSegment", "initialization", "resolvedUris", "shaka.util.XmlUtils.parseRange", "shaka.dash.SegmentBase.createQualityInfo", "qualityInfo", "createStreamInfo", "requestInitSegment", "shaka.dash.SegmentBase.fromInheritance_", "shaka.dash.SegmentBase.createInitSegment", "shaka.dash.SegmentBase.checkSegmentIndexRangeSupport_", "shallowCopyOfContext", "shaka.util.ObjectUtils.shallowCloneObject", "generateSegmentIndex", "representationIndex", "indexUris", "representationUri", "indexRange", "shaka.dash.SegmentBase.computeIndexRange_", "shaka.dash.SegmentBase.generateSegmentIndexFromUris", "generateSegmentIndexFromUris", "fitLast", "containerType", "localRequest", "responses", "indexData", "dynamic", "isLastPeriod", "shaka.media.WebmSegmentIndexParser.EBML_ID", "ebmlElement", "shaka.util.Error.Code.WEBM_EBML_HEADER_ELEMENT_MISSING", "segmentElement", "shaka.media.WebmSegmentIndexParser.SEGMENT_ID", "shaka.util.Error.Code.WEBM_SEGMENT_ELEMENT_MISSING", "infoElement", "shaka.media.WebmSegmentIndexParser.INFO_ID", "shaka.util.Error.Code.WEBM_INFO_ELEMENT_MISSING", "timecodeScaleNanoseconds", "durationScale", "shaka.media.WebmSegmentIndexParser.TIMECODE_SCALE_ID", "shaka.media.WebmSegmentIndexParser.DURATION_ID", "getFloat32", "getFloat64", "shaka.util.Error.Code.EBML_BAD_FLOATING_POINT_SIZE", "shaka.util.Error.Code.WEBM_DURATION_ELEMENT_MISSING", "cuesData", "shaka.media.WebmSegmentIndexParser.CUES_ID", "shaka.util.Error.Code.WEBM_CUES_ELEMENT_MISSING", "shaka.media.WebmSegmentIndexParser.parseCues_", "fromInheritance_", "segmentBase", "computeIndexRange_", "indexRangeElem", "checkSegmentIndexRangeSupport_", "shaka.dash.SegmentBase.checkSegmentIndexSupport", "shaka.util.Error.Code.DASH_NO_SEGMENT_INFO", "checkSegmentIndexSupport", "shaka.util.Error.Code.DASH_UNSUPPORTED_CONTAINER", "shaka.util.Error.Code.DASH_WEBM_MISSING_INIT", "createQualityInfo", "numChannels", "streamMap", "shaka.dash.SegmentList.fromInheritance_", "shaka.dash.SegmentList.parseSegmentListInfo_", "mediaSegments", "shaka.dash.SegmentList.createSegmentReferences_", "segmentList", "parseSegmentListInfo_", "shaka.dash.SegmentList.parseMediaSegments_", "shaka.dash.MpdUtils.parseSegmentInfo", "createSegmentReferences_", "prevEndTime", "mediaUri", "parseMediaSegments_", "segmentLists", "urlNode", "indexRangeWarningGiven", "isUpdate", "segmentLimit", "periodDurationMap", "shaka.dash.SegmentTemplate.createInitSegment_", "shaka.dash.SegmentTemplate.parseSegmentTemplateInfo_", "shaka.dash.SegmentTemplate.checkSegmentTemplateInfo_", "indexTemplate", "filledTemplate", "shaka.dash.MpdUtils.fillUriTemplate", "shaka.dash.SegmentTemplate.generateSegmentIndexFromDuration_", "shaka.dash.SegmentTemplate.createFromTimeline_", "periodEnd", "shouldFit", "segmentTemplate", "parseSegmentTemplateInfo_", "shaka.dash.SegmentTemplate.fromInheritance_", "mediaTemplate", "checkSegmentTemplateInfo_", "generateSegmentIndexFromDuration_", "createReference", "segmentPeriodTime", "segmentMediaTime", "trueSegmentEnd", "getPeriodEnd", "computeAvailablePositionRange", "availablePeriodTimes", "availablePresentationTimes", "availablePeriodPositions", "availablePresentationPositions", "periodId", "initialPeriodDuration", "minPosition", "maxPosition", "willNeedToAddReferences", "willNeedToEvictReferences", "nextPosition", "availabilityStartTime", "createFromTimeline_", "repId", "segmentReplacement", "timeReplacement", "createUris", "g", "createInitSegment_", "audioStreams_", "videoStreams_", "textStreams_", "imageStreams_", "usedPeriodIds_", "shaka.util.PeriodCombiner", "allStreams", "combinePeriods", "periods", "isDynamic", "firstPeriod", "firstNewPeriodIndex", "audioStreamsPerPeriod", "videoStreamsPerPeriod", "textStreamsPerPeriod", "imageStreamsPerPeriod", "nextVariantId", "commonDrmInfos", "shaka.util.PeriodCombiner.filterOutAudioStreamDuplicates_", "shaka.util.PeriodCombiner.filterOutVideoStreamDuplicates_", "shaka.util.PeriodCombiner.filterOutTextStreamDuplicates_", "shaka.util.PeriodCombiner.filterOutImageStreamDuplicates_", "audioStreams", "videoStreams", "shaka.util.PeriodCombiner.dummyStream_", "shaka.util.PeriodCombiner.combine_", "shaka.util.PeriodCombiner.cloneStream_", "shaka.util.PeriodCombiner.concatenateStreams_", "shaka.media.DrmEngine.getCommonDrmInfos", "filterOutAudioStreamDuplicates_", "filteredAudios", "a1", "duplicate", "a2", "shaka.util.ArrayUtils.hasSameElements", "filterOutTextStreamDuplicates_", "filteredTexts", "t1", "t2", "filterOutVideoStreamDuplicates_", "filteredVideos", "shaka.util.MapUtils.hasSameElements", "filterOutImageStreamDuplicates_", "filteredImages", "i1", "i2", "combineDbStreams", "streamDbsPerPeriod", "audioStreamDbsPerPeriod", "videoStreamDbsPerPeriod", "textStreamDbsPerPeriod", "imageStreamDbsPerPeriod", "combinedAudioStreamDbs", "combinedVideoStreamDbs", "combinedTextStreamDbs", "combinedImageStreamDbs", "combinedStreamDbs", "shaka.util.PeriodCombiner.dummyStreamDB_", "shaka.util.PeriodCombiner.cloneStreamDB_", "shaka.util.PeriodCombiner.concatenateStreamDBs_", "variantIds", "combine_", "outputStreams", "streamsPerPeriod", "unusedStreamsPerPeriod", "outputStream", "ok", "unusedStreams", "isDummyText", "isDummyImage", "hasCodec", "shaka.util.PeriodCombiner.extendExistingOutputStream_", "shaka.util.Error.Code.PERIOD_FLATTENING_FAILED", "shaka.util.PeriodCombiner.createNewOutputStream_", "extendExistingOutputStream_", "shaka.util.PeriodCombiner.findMatchesInAllPeriods_", "matchedStreams", "shaka.util.PeriodCombiner.extendOutputSegmentIndex_", "shaka.util.PeriodCombiner.extendOutputStream_", "extendOutputSegmentIndex_", "createNewOutputStream_", "outputStream.createSegmentIndex", "extendOutputStream_", "used", "cloneStream_", "clone.createSegmentIndex", "clone.closeSegmentIndex", "cloneStreamDB_", "streamDb", "concatenateStreams_", "input", "combineSets", "shaka.util.Error.Code.INCONSISTENT_DRM_ACROSS_PERIODS", "output.trickModeVideo.createSegmentIndex", "concatenateStreamDBs_", "findMatchesInAllPeriods_", "areCompatible", "shaka.util.PeriodCombiner.areAVStreamsCompatible_", "shaka.util.PeriodCombiner.areTextStreamsCompatible_", "shaka.util.PeriodCombiner.areImageStreamsCompatible_", "isBetterMatch", "shaka.util.PeriodCombiner.isAudioStreamBetterMatch_", "shaka.util.PeriodCombiner.isVideoStreamBetterMatch_", "shaka.util.PeriodCombiner.isTextStreamBetterMatch_", "shaka.util.PeriodCombiner.isImageStreamBetterMatch_", "best", "areAVStreamsCompatible_", "areTextStreamsCompatible_", "languageRelatedness", "areImageStreamsCompatible_", "isAudioStreamBetterMatch_", "bestRelatedness", "candidateRelatedness", "bestRoleMatches", "candidateRoleMatches", "shaka.util.PeriodCombiner.compareClosestPreferLower", "channelsBetterOrWorse", "shaka.util.PeriodCombiner.BetterOrWorse.BETTER", "shaka.util.PeriodCombiner.BetterOrWorse.WORSE", "sampleRateBetterOrWorse", "shaka.util.PeriodCombiner.compareClosestPreferMinimalAbsDiff_", "bandwidthBetterOrWorse", "isVideoStreamBetterMatch_", "resolutionBetterOrWorse", "frameRateBetterOrWorse", "isTextStreamBetterMatch_", "isImageStreamBetterMatch_", "dummyStreamDB_", "dummyStream_", "compareClosestPreferLower", "outputValue", "bestValue", "candidateValue", "shaka.util.PeriodCombiner.BetterOrWorse.EQUAL", "compareClosestPreferMinimalAbsDiff_", "absDiffBest", "absDiffCandidate", "BETTER", "EQUAL", "WORSE", "manifestUris_", "globalId_", "streamMap_", "periodDurations_", "periodCombiner_", "updatePeriod_", "averageUpdateDuration_", "updateTimer_", "largestPeriodStartTime_", "lastManifestUpdatePeriodIds_", "minTotalAvailabilityTimeOffset_", "lowLatencyMode_", "shaka.dash.DashParser.prototype", "updateDelay", "requestManifest_", "setUpdateTimer_", "updateDuration", "unshift", "parseManifest_", "finalManifestUri", "mpd", "xlinkOperation", "finalMpd", "processManifest_", "manifestBaseUris", "locations", "absoluteLocations", "uriObjs", "availabilityTimeOffset", "suggestedPresentationDelay", "mpdType", "profiles", "periodsAndDuration", "timingElements", "shaka.util.XmlUtils.parseDuration", "shaka.util.XmlUtils.parseDate", "parsePeriods_", "durationDerivedFromPeriods", "parseUtcTiming_", "presentationDuration", "prevEnd", "periodNodes", "givenDuration", "nextStart", "parsePeriod_", "el", "createFrame_", "eventStreamNodes", "availabilityStart", "parseEventStream_", "adaptationSets", "adaptationSetNodes", "parseAdaptationSet_", "representationIds", "uniqueIds", "shaka.util.Error.Code.DASH_DUPLICATE_REPRESENTATION_ID", "normalAdaptationSets", "as", "trickModeFor", "trickModeAdaptationSets", "trickModeSet", "targetIds", "normalSet", "trickStream", "audioSets", "getSetsOfType_", "videoSets", "textSets", "imageSets", "shaka.util.Error.Code.DASH_EMPTY_PERIOD", "audioSet", "videoSet", "textSet", "imageSet", "getVideoRangeFromTransferCharacteristicCICP", "cicp", "main", "roleElements", "roleValues", "SUBTITLE", "roleElement", "videoRange", "essentialProperties", "unrecognizedEssentialProperty", "videoRangeScheme", "supplementalProperties", "accessibilities", "channelId", "channelAssignments", "captionStr", "channel", "channelAndLanguage", "serviceAndLanguage", "contentProtectionElems", "contentProtection", "labelElements", "firstLabelElement", "representations", "parsedRepresentation", "parseRepresentation_", "isImage", "shaka.util.Error.Code.DASH_EMPTY_ADAPTATION_SET", "shaka.dash.DashParser.guessContentType_", "repIds", "isPrimary", "verifyRepresentation_", "requestInitSegment_", "streamInfo", "shaka.dash.SegmentBase.createStreamInfo", "shaka.dash.SegmentList.createStreamInfo", "shaka.dash.SegmentTemplate.createStreamInfo", "hasManifest", "shaka.dash.ContentProtection.parseFromRepresentation", "supplementalPropertyElems", "expectedUri", "expectedValue", "hasJoc", "thumbnailTileElem", "essentialPropertyElems", "expectedUris", "hevcHDR", "contextId", "stream.createSegmentIndex", "shaka.dash.DashParser.MIN_UPDATE_PERIOD_", "finalDelay", "parent", "shaka.util.XmlUtils.evalDivision", "schemeIdUris", "inBandEventStreams", "audioChannelConfigs", "parseAudioChannels_", "segmentBaseAto", "segmentTemplateAto", "baseUriAto", "intValue", "hexValue", "numBits", "channelCountMapping", "noValue", "requestForTiming_", "requestUris", "date", "shaka.net.NetworkingEngine.RequestType.TIMING", "schemesAndValues", "sv", "eventNode", "guessContentType_", "shaka.dash.DashParser", "tags", "shaka.hls.Tag", "attrToStr", "isNumericAttr", "tagStr", "appendages", "getAttributeValue", "getRequiredAttrValue", "shaka.util.Error.Code.HLS_REQUIRED_ATTRIBUTE_MISSING", "partialSegments", "filterTagsByName", "filterTagsByType", "tagType", "getFirstTagWithName", "tagsWithName", "shaka.hls.Utils.filterTagsByName", "getFirstTagWithNameAsNumber", "shaka.hls.Utils.getFirstTagWithName", "data_", "skipWhitespace", "readRegex", "regex", "lastIndex", "indexOf_", "atEnd", "readRegexReturnCapture_", "parsePlaylist", "absolutePlaylistUri", "lines", "shaka.util.Error.Code.HLS_PLAYLIST_HEADER_MISSING", "playlistType", "MASTER", "parseTag_", "shaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS.includes", "MEDIA", "shaka.hls.ManifestTextParser.SEGMENT_TAGS.includes", "shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY", "segmentsData", "segmentTags", "partialSegmentTags", "currentMapTag", "absoluteSegmentUri", "absoluteMediaPlaylistUri", "verbatimSegmentUri", "shaka.hls.Segment", "shaka.hls.Playlist", "tagUri", "shaka.hls.Attribute", "word", "blocks", "shaka.util.Error.Code.INVALID_HLS_TAG", "shaka.util.TextParser", "blockAttrs", "blockValue", "valueRegex", "attributeRegex", "attrName", "shaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS", "shaka.hls.ManifestTextParser.SEGMENT_TAGS", "shaka.net.DataUriPlugin.parseRaw", "originalUri", "parseRaw", "shaka.util.Error.Code.MALFORMED_DATA_URI", "infoAndData", "dataStr", "typeInfoList", "base64Encoded", "shaka.net.DataUriPlugin", "shaka.net.DataUriPlugin.parse", "globalVariables_", "groupIdToStreamInfosMap_", "variantUriSet_", "uriToStreamInfosMap_", "presentationTimeline_", "masterPlaylistUri_", "manifestTextParser_", "shaka.hls.ManifestTextParser", "updatePlaylistDelay_", "updatePlaylistTimer_", "presentationType_", "shaka.hls.HlsParser.PresentationType_.VOD", "maxTargetDuration_", "minTargetDuration_", "lowLatencyPresentationDelay_", "partialTargetDuration_", "segmentsToNotifyByStream_", "groupIdToClosedCaptionsMap_", "aesEncrypted_", "groupIdToCodecsMap_", "playlistStartTime_", "mapTagToInitSegmentRefMap_", "discontinuityToTso_", "shaka.hls.HlsParser.prototype", "pending", "streamInfos", "isLive_", "updateStream_", "PresentationType", "manifestUri", "playlist", "variablesTags", "mediaVariables", "mediaSequenceNumber", "playlistStartTime", "newestSegment", "endListTag", "shaka.hls.HlsParser.PresentationType_", "canSkipSegments", "parseMediaVariables_", "createSegments_", "verbatimMediaPlaylistUri", "mediaSequenceToStartTime", "discontinuityToMediaSequence", "shaka.hls.Utils.getFirstTagWithNameAsNumber", "setPresentationType_", "mediaTags", "variantTags", "imageTags", "sesionDataTags", "minFirstTimestamp", "minDuration", "streamsToNotify", "shaka.util.Error.Code.HLS_MASTER_PLAYLIST_NOT_PROVIDED", "parseMasterVariables_", "parseCodecs_", "createStreamInfosFromMediaTags_", "parseClosedCaptions_", "createVariantsForTags_", "parseTexts_", "parseImages_", "shaka.util.Error.Code.HLS_AES_128_ENCRYPTION_NOT_SUPPORTED", "minTimestamp", "maxTimestamp", "createPresentationTimeline_", "notifySegments_", "variableTag", "mediaImport", "globalValue", "variantTag", "audioGroupId", "videoGroupId", "subGroupId", "getCodecsForVariantTag_", "textCodecs", "subtitleTags", "textStreamPromises", "groupId", "textStreamInfos", "textStreamInfo", "shaka.hls.Utils.filterTagsByType", "createStreamInfoFromMediaTag_", "imageStreamPromises", "createStreamInfoFromImageTag_", "promises", "variantsPromises", "resolution", "createStreamInfosForVariantTag_", "videoInfos", "audioInfos", "audioInfo", "videoInfo", "videoStream", "audioDrmInfos", "videoDrmInfos", "variantUriKey", "ignoreStream", "streamURI", "hasSameUri", "createStreamInfoFromVariantTag_", "filterLegacyCodecs_", "defaultCodecsArray", "defaultCodecs", "codecsString", "seen", "shortCodec", "getLanguage_", "languageValue", "closedCaptionsTags", "instreamId", "defaultAttrValue", "characteristics", "forcedAttrValue", "variableSubstitution_", "channelcountstring", "createStreamInfo_", "verbatimImagePlaylistUri", "closedCaptionsAttr", "getClosedCaptions_", "drmTags", "segmentKeyTags", "drmTag", "keyFormat", "drmParser", "prevLowLatencyMode", "characteristic", "serverControlTag", "shaka.hls.HlsParser.KEYFORMATS_TO_DRM_PARSERS_", "shaka.util.Error.Code.HLS_KEYFORMATS_NOT_SUPPORTED", "determinePresentationType_", "guessMimeType_", "shaka.hls.HlsParser.RAW_FORMATS_.includes", "shaka.util.Error.Code.HLS_INTERNAL_SKIP_STREAM", "presentationTypeTag", "isVod", "isEvent", "shaka.hls.HlsParser.PresentationType_.LIVE", "shaka.hls.HlsParser.PresentationType_.EVENT", "shaka.util.Error.Code.HLS_REQUIRED_TAG_MISSING", "targetDuration", "partialTargetDurationTag", "getInitSegmentReference_", "playlistUri", "variables", "mapTag", "verbatimInitSegmentUri", "absoluteInitSegmentUri", "mapTagKey", "initSegmentRef", "createInitSegmentReference_", "byterange", "createSegmentReference_", "previousReference", "hlsSegment", "extinfTag", "partialSegmentRefs", "pAbsoluteUri", "pPreviousReference", "pStartTime", "pDuration", "pEndTime", "pStartByte", "pEndByte", "pByterangeStart", "pByterange", "parseByteRange_", "pUri", "extinfValues", "byterangeTag", "tilesTag", "hlsSegments", "skipTag", "skippedSegments", "firstStartTime", "firstSegmentUri", "discontintuitySequenceNum", "disconMap", "discontintuityTag", "getTimestampOffset_", "mediaStartTime", "fetchStartOfSegment_", "fullRequest", "partialRequest", "makeNetworkRequest_", "shaka.hls.HlsParser.START_OF_SEGMENT_SIZE_", "isDiscontinuity", "segmentRef", "fetches", "segmentResponse", "initSegmentResponse", "getStartTimeFromMp4Segment_", "getStartTimeFromTsSegment_", "shaka.util.Error.Code.HLS_COULD_NOT_PARSE_SEGMENT_START_TIME", "segmentUri", "mediaData", "parsedMedia", "parsedTFDTBox", "skipPacket", "packetStart", "syncByte", "fail", "syncByteScanLength", "flagsAndPacketId", "adaptationFieldControl", "startCode", "ptsDtsIndicator", "pesHeaderLengthRemaining", "pts0", "pts1", "pts2", "shaka.hls.HlsParser.TS_TIMESCALE_", "newUri", "uriVariables", "variable", "variableName", "replaceValue", "shaka.util.Error.Code.HLS_VARIABLE_NOT_FOUND", "parsedUri", "headRequest", "contentMimeType", "fallbackMimeType", "shaka.hls.HlsParser.EXTENSION_MAP_BY_CONTENT_TYPE_", "shaka.hls.HlsParser", "shaka.hls.HlsParser.RAW_FORMATS_", "shaka.hls.HlsParser.AUDIO_EXTENSIONS_TO_MIME_TYPES_", "shaka.hls.HlsParser.VIDEO_EXTENSIONS_TO_MIME_TYPES_", "shaka.hls.HlsParser.TEXT_EXTENSIONS_TO_MIME_TYPES_", "shaka.hls.HlsParser.IMAGE_EXTENSIONS_TO_MIME_TYPES_", "widevineDrmParser_", "VALID_METHODS", "parsedData", "keyIdLowerCase", "playreadyDrmParser_", "EVENT", "makeResponse", "responseURL", "responseText", "shaka.net.HttpFetchPlugin.Headers_", "controller", "shaka.net.HttpFetchPlugin.AbortController_", "abortStatus", "canceled", "timedOut", "shaka.net.HttpFetchPlugin.request_", "signal", "credentials", "timeoutMs", "request_", "fetch", "arrayBuffer", "lastLoaded", "contentLengthRaw", "contentLength", "shaka.net.HttpFetchPlugin.fetch_", "shaka.net.HttpFetchPlugin.ReadableStream_", "shaka.net.HttpFetchPlugin.headersToGenericObject_", "getReader", "readObj", "read", "done", "enqueue", "shaka.net.HttpPluginUtils.makeResponse", "headersToGenericObject_", "headersObj", "isSupported", "Response", "AbortController", "shaka.net.HttpFetchPlugin", "shaka.net.HttpFetchPlugin.isSupported", "shaka.net.HttpFetchPlugin.parse", "Headers", "shaka.net.NetworkingEngine.PluginPriority.PREFERRED", "xhr", "shaka.net.HttpXHRPlugin.Xhr_", "open", "responseType", "withCredentials", "onabort", "xhr.onabort", "calledHeadersReceived", "onreadystatechange", "xhr.onreadystatechange", "shaka.net.HttpXHRPlugin.headersToGenericObject_", "onload", "xhr.onload", "xhrResponse", "onerror", "xhr.onerror", "ontimeout", "xhr.ontimeout", "onprogress", "xhr.onprogress", "lengthComputable", "setRequestHeader", "lowercasedKey", "headerLines", "getAllResponseHeaders", "shaka.net.HttpXHRPlugin", "shaka.net.HttpXHRPlugin.parse", "XMLHttpRequest", "shaka.net.NetworkingEngine.PluginPriority.FALLBACK", "estimateId", "isInitSegment", "idForSegmentRef", "makeSegmentRequest", "actualDownloaded_", "estimatedDownloaded_", "estimatedTotal_", "pending_", "nextId_", "shaka.offline.DownloadProgressEstimator", "groups_", "abortAll", "abortCallbacks_", "onProgress_", "this.onProgress_", "onInitData_", "this.onInitData_", "estimator_", "shaka.offline.DownloadManager", "setCallbacks", "onProgress", "onInitData", "queue", "onDownloaded", "segmentBytes", "fetchSegment_", "shaka.util.Error.Category.STORAGE", "waitToFinish", "abortCallback", "transaction", "storeName", "transaction_", "store_", "objectStore", "promise_", "transaction.onabort", "transaction.onerror", "oncomplete", "transaction.oncomplete", "shaka.offline.indexeddb.DBOperation", "forEachEntry", "openCursor", "onsuccess", "req.onsuccess", "cursor", "continue", "store", "connection_", "shaka.offline.indexeddb.DBConnection", "startReadWriteOperation", "stopTracking_", "segmentStore", "manifestStore", "segmentStore_", "manifestStore_", "shaka.offline.indexeddb.BaseStorageCell.prototype", "hasFixedKeySpace", "addSegments", "rejectAdd", "removeSegments", "onRemove", "getSegments", "rawSegments", "get_", "convertSegmentData", "addManifests", "updateManifest", "shaka.util.Error.Code.MODIFY_OPERATION_NOT_SUPPORTED", "updateManifestImplementation", "put", "updateManifestExpiration", "newExpiration", "removeManifests", "getManifests", "rawManifests", "convertManifest", "getAllManifests", "old", "shaka.util.Error.Code.NEW_KEY_OPERATION_NOT_SUPPORTED", "request.onsuccess", "missing", "shaka.util.Error.Code.KEY_NOT_FOUND", "shaka.offline.indexeddb.EmeSessionStorageCell", "getAll", "shaka.offline.indexeddb.StorageMechanism.SESSION_ID_STORE", "sessionIds", "mechanisms_", "shaka.offline.StorageMuxer", "destroys", "mechanism", "shaka.offline.StorageMuxer.registry_", "mech", "initPromises", "getActive", "handle", "mechanismName", "getCells", "cell", "cellName", "shaka.util.Error.Code.MISSING_STORAGE_CELL", "forEachCell", "getCell", "forEachEmeSessionCell", "getEmeSessionCell", "mechanisms", "shaka.util.Error.Code.STORAGE_NOT_SUPPORTED", "erase", "alreadyInitialized", "registry", "register", "shaka.offline.StorageMuxer.registry_.set", "unregister", "shaka.offline.StorageMuxer.registry_.delete", "shaka.offline.StorageMuxer.register", "shaka.offline.indexeddb.BaseStorageCell.apply", "shaka.offline.indexeddb.V1StorageCell", "shaka.offline.indexeddb.BaseStorageCell", "BaseStorageCell", "shaka.offline.indexeddb.V1StorageCell.convertPeriod_", "shaka.util.PeriodCombiner.combineDbStreams", "creationTime", "originalManifestUri", "appMetadata", "shaka.offline.indexeddb.V1StorageCell.fillMissingVariants_", "shaka.offline.indexeddb.V1StorageCell.convertStream_", "convertStream_", "initSegmentKey", "initSegmentUri", "shaka.offline.indexeddb.V1StorageCell.getKeyFromSegmentUri_", "presentationTimeOffset", "dataKey", "getKeyFromSegmentUri_", "shaka.util.Error.Code.MALFORMED_OFFLINE_URI", "fillMissingVariants_", "nextId", "variantId", "shaka.offline.indexeddb.V2StorageCell", "shaka.offline.indexeddb.V5StorageCell", "shaka.offline.indexeddb.V5StorageCell.prototype", "manifests", "sessions_", "v5_", "v3_", "v2_", "v1_", "db_", "timeOutTimer", "shaka.util.Error.Code.INDEXED_DB_INIT_TIMED_OUT", "indexedDB", "shaka.offline.indexeddb.StorageMechanism.DB_NAME", "shaka.offline.indexeddb.StorageMechanism.VERSION", "open.onsuccess", "db", "stores", "objectStoreNames", "contains", "shaka.offline.indexeddb.StorageMechanism.V1_MANIFEST_STORE", "shaka.offline.indexeddb.StorageMechanism.V1_SEGMENT_STORE", "shaka.offline.indexeddb.StorageMechanism.V2_MANIFEST_STORE", "shaka.offline.indexeddb.StorageMechanism.V2_SEGMENT_STORE", "shaka.offline.indexeddb.StorageMechanism.V3_MANIFEST_STORE", "shaka.offline.indexeddb.StorageMechanism.V3_SEGMENT_STORE", "shaka.offline.indexeddb.StorageMechanism.V5_MANIFEST_STORE", "shaka.offline.indexeddb.StorageMechanism.V5_SEGMENT_STORE", "onupgradeneeded", "open.onupgradeneeded", "storeNames", "createObjectStore", "autoIncrement", "open.onerror", "shaka.util.Error.Code.INDEXED_DB_ERROR", "shaka.offline.indexeddb.StorageMechanism.prototype", "shaka.offline.indexeddb.StorageMechanism.deleteAll_", "del", "deleteDatabase", "onblocked", "del.onblocked", "del.onsuccess", "del.onerror", "shaka.offline.indexeddb.StorageMechanism", "mechanism_", "cell_", "key_", "asString_", "shaka.offline.OfflineUri", "fromManifestDB", "manifestDB", "streamDB", "createVariants", "fromStreamDB_", "audios", "videos", "variantMap", "fromSegmentDB_", "segmentDB", "fromInitSegmentDB_", "uri_", "shaka.offline.OfflineManifestParser.prototype", "muxer", "converter", "finalManifest", "shaka.offline.OfflineUri.parse", "shaka.offline.ManifestConverter", "foundSession", "shaka.offline.OfflineManifestParser", "offlineUri", "getSegment_", "shaka.offline.OfflineScheme", "shaka.offline.OfflineScheme.plugin", "deleted", "bucket", "shaka.offline.SessionDeleter.isCompatible_", "doDelete_", "drmEngine", "licenseUri", "isCompatible_", "comp", "y", "fromManifest", "shaka.offline.StoredContentUtils.getTracks_", "isIncomplete", "getTracks_", "shaka.util.StreamUtils.getPlayableVariants", "estimateByStreamId_", "addVariant", "setBitrate_", "audioBitRate", "shaka.offline.StreamBandwidthEstimator.DEFAULT_AUDIO_BITRATE_", "videoBitRate", "addImage", "shaka.offline.StreamBandwidthEstimator.DEFAULT_IMAGE_BITRATE_", "getEstimate_", "bitRate", "shaka.util.Error.Code.LOCAL_PLAYER_INSTANCE_REQUIRED", "openOperations_", "openDownloadManagers_", "destroyNetworkingEngine", "awaits", "shaka.offline.Storage.prototype", "downloader", "storeOp", "getParser", "abortableStoreOp", "startAbortableOperation_", "getStoreInProgress", "activeHandle", "manifestId", "drmError", "canDownload", "toDownload", "requireSupport_", "parseManifest", "ensureNotDestroyed_", "shaka.util.Error.Code.CANNOT_STORE_LIVE_OFFLINE", "makeManifestDB_", "downloadSegments_", "shaka.offline.StoredContentUtils.fromManifestDB", "shaka.offline.Storage.cleanStoredManifest", "pendingManifestUpdates", "pendingDataSize", "download", "usingBgFetch", "manifestUpdates", "dataSize", "dataKeys", "updateDRM", "shaka.offline.DownloadInfo.idForSegmentRef", "setManifestDrmFields_", "getManifestIsEncrypted_", "getManifestIncludesInitData_", "shaka.offline.Storage.assignSegmentsToManifest", "cleanStoredManifest", "shaka.offline.Storage", "assignSegmentsToManifest", "dataSizeUpdate", "throwIfAbortedFn", "manifestUpdated", "complete", "pendingSegmentRefId", "pendingInitSegmentRefId", "allTracks", "chosenTracks", "trackSize", "allowedDownload", "textIds", "imageIds", "shaka.util.StreamUtils.filterByRestrictions", "shaka.util.Error.Code.STORAGE_LIMIT_REACHED", "shaka.util.Error.Code.DOWNLOAD_SIZE_CALLBACK_ERROR", "shaka.offline.Storage.validateManifest_", "pendingContent", "shaka.offline.StoredContentUtils.fromManifest", "needsInitData", "currentSystemId", "shaka.offline.Storage.defaultSystemIds_.get", "estimator", "shaka.offline.StreamBandwidthEstimator", "shaka.offline.StreamBandwidthEstimator.DEFAULT_TEXT_BITRATE_", "createStreams_", "audioEncrypted", "shaka.util.Error.Code.NO_INIT_DATA_FOR_OFFLINE", "contentUri", "nullableUri", "removeFromDRM_", "removeFromStorage_", "getCapabilities_", "manifestDb", "shaka.offline.Storage.deleteLicenseFor_", "segmentIds", "shaka.offline.Storage.getAllSegmentIds_", "removeEmeSessions", "removeEmeSessions_", "net", "hasRemaining", "cells", "sessionIdCell", "deletedSessionIds", "list_", "shaka.offline.Storage.getAllStreamsFromManifest_", "streamSet", "streamDBs", "createStream_", "shaka.offline.Storage.forEachSegment_", "estimatedByteLength", "segmentDownload", "shaka.offline.DownloadInfo", "initDownload", "forEachSegment_", "shaka.offline.Storage.support", "getAllSegmentIds_", "deleteLicenseFor_", "drmConfig", "shaka.offline.Storage.getCapabilities_", "getAllStreamsFromManifest_", "validateManifest_", "texts", "deleteAll", "shaka.offline.Storage.defaultSystemIds_", "polyfill", "newItem", "shaka.polyfill.polyfills_.length", "shaka.polyfill.polyfills_", "shaka.polyfill.polyfills_.splice", "shaka.polyfill.polyfills_.push", "shaka.polyfill", "shaka.polyfill.register", "installAll", "install", "getOwnPropertyDescriptor", "shaka.polyfill.Aria.addARIAMixinAttribute_", "addARIAMixinAttribute_", "snakeCaseName", "baseName", "shaka.polyfill.Aria", "shaka.polyfill.Aria.install", "EncryptionSchemePolyfills.install", "shaka.polyfill.EncryptionScheme", "shaka.polyfill.EncryptionScheme.install", "Document", "requestFullscreen", "mozRequestFullScreen", "msRequestFullscreen", "webkitRequestFullscreen", "exitFullscreen", "mozCancelFullScreen", "msExitFullscreen", "webkitCancelFullScreen", "mozFullScreenElement", "msFullscreenElement", "webkitCurrentFullScreenElement", "webkitFullscreenElement", "mozFullScreenEnabled", "msFullscreenEnabled", "webkitFullscreenEnabled", "shaka.polyfill.Fullscreen.proxyEvent_", "newEvent", "createEvent", "initEvent", "shaka.polyfill.Fullscreen", "shaka.polyfill.Fullscreen.install", "shaka.polyfill.MathRound", "shaka.polyfill.MathRound.install", "shaka.polyfill.MediaCapabilities.originalMcap", "shaka.polyfill.MediaCapabilities.decodingInfo_", "decodingInfo_", "videoConfig", "audioConfig", "extendedType", "mediaCapkeySystemConfig", "capability", "mediaKeySystemConfig", "powerEfficient", "smooth", "configuration", "displayType", "shaka.polyfill.MediaCapabilities", "shaka.polyfill.MediaCapabilities.install", "shaka.polyfill.MediaSource.patchCastIsTypeSupported_", "shaka.polyfill.MediaSource.rejectTsContent_", "shaka.polyfill.MediaSource.stubAbort_", "shaka.polyfill.MediaSource.patchRemovalRange_", "shaka.polyfill.MediaSource.rejectCodec_", "shaka.polyfill.MediaSource.patchVp09_", "stubAbort_", "MediaSource.prototype.addSourceBuffer", "sourceBuffer.abort", "patchRemovalRange_", "originalRemove", "SourceBuffer", "SourceBuffer.prototype.remove", "rejectTsContent_", "originalIsTypeSupported", "MediaSource.isTypeSupported", "basicMimeType", "rejectCodec_", "actualCodec", "patchCastIsTypeSupported_", "hasCodecs", "patchVp09_", "codecsIndex", "codecsParam", "vp09Index", "codecName", "shaka.polyfill.MediaSource", "shaka.polyfill.MediaSource.install", "screen", "orientation", "shaka.polyfill.Orientation.installBasedOnWindowMethods_", "installBasedOnWindowMethods_", "setValues", "angle", "shaka.polyfill.Orientation.FakeOrientation", "shaka.polyfill.Orientation", "shaka.polyfill.Orientation.install", "lock", "lockOrientation", "mozLockOrientation", "msLockOrientation", "success", "unlock", "unsupportedKeySystemError", "DOMException", "NOT_SUPPORTED_ERR", "unlockOrientation", "mozUnlockOrientation", "msUnlockOrientation", "HTMLVideoElement", "WebKitMediaKeys", "shaka.polyfill.PatchedMediaKeysApple.setMediaKeys", "shaka.polyfill.PatchedMediaKeysApple.MediaKeys", "shaka.polyfill.PatchedMediaKeysApple.MediaKeySystemAccess", "shaka.polyfill.PatchedMediaKeysApple.requestMediaKeySystemAccess", "supportedConfigurations", "oldMediaKeys", "setMedia", "onWebkitNeedKey_", "dataview", "RangeError", "event2", "shaka.polyfill.PatchedMediaKeysApple", "shaka.polyfill.PatchedMediaKeysApple.install", "cfg", "newCfg", "ranAnyTests", "checkConfig_", "configuration_", "nativeMediaKeys_", "TypeError", "shaka.polyfill.PatchedMediaKeysApple.MediaKeySession", "shaka.polyfill.PatchedMediaKeysApple.onWebkitNeedKey_", "webkitSetMediaKeys", "nativeMediaKeys", "nativeMediaKeySession_", "updatePromise_", "generateRequestPromise_", "shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap", "onWebkitKeyMessage_", "status_", "onWebkitKeyAdded_", "updateKeyStatus_", "onWebkitKeyError_", "WebKitMediaKeyError", "MEDIA_KEYERR_OUTPUT", "MEDIA_KEYERR_HARDWARECHANGE", "shaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype", "shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype", "fn", "shaka.media.DrmEngine.DUMMY_KEY_ID.value", "fakeKeyId", "MSMediaKeys", "shaka.polyfill.PatchedMediaKeysMs.MediaKeys", "shaka.polyfill.PatchedMediaKeysMs.MediaKeySystemAccess", "shaka.polyfill.PatchedMediaKeysMs.requestMediaKeySystemAccess", "shaka.polyfill.PatchedMediaKeysMs.MediaKeySystemAccess.setMediaKeys", "onMsNeedKey_", "CustomEvent", "shaka.util.Pssh.normaliseInitData", "shaka.polyfill.PatchedMediaKeysMs", "shaka.polyfill.PatchedMediaKeysMs.install", "shaka.polyfill.PatchedMediaKeysMs.MediaKeySession", "shaka.polyfill.PatchedMediaKeysMs.onMsNeedKey_", "msSetMediaKeys", "shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap", "onMsKeyMessage_", "onMsKeyAdded_", "onMsKeyError_", "MSMediaKeyError", "MS_MEDIA_KEYERR_OUTPUT", "MS_MEDIA_KEYERR_HARDWARECHANGE", "shaka.polyfill.PatchedMediaKeysMs.MediaKeySession.prototype", "shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap.prototype", "shaka.polyfill.PatchedMediaKeysNop.requestMediaKeySystemAccess", "shaka.polyfill.PatchedMediaKeysNop.setMediaKeys", "shaka.polyfill.PatchedMediaKeysNop.MediaKeys", "shaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess", "shaka.polyfill.PatchedMediaKeysNop", "shaka.polyfill.PatchedMediaKeysNop.install", "webkitGenerateKeyRequest", "shaka.polyfill.PatchedMediaKeysWebkit.prefix_", "generateKeyRequest", "shaka.polyfill.PatchedMediaKeysWebkit.requestMediaKeySystemAccess", "shaka.polyfill.PatchedMediaKeysWebkit.setMediaKeys", "shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys", "shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySystemAccess", "prefixApi_", "prefix", "shaka.polyfill.PatchedMediaKeysWebkit", "shaka.polyfill.PatchedMediaKeysWebkit.install", "internalKeySystem_", "allowPersistentState", "tmpVideo", "unsupportedError", "keySystem_", "media_", "newSessions_", "sessionMap_", "findSession_", "generatePromise_", "shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession", "shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap", "MediaKeyError", "generate_", "offlineSessionId", "mangledInitData", "generateKeyRequestName", "shaka.polyfill.PatchedMediaKeysWebkit.prefixApi_", "exception2", "licenseString", "addKeyName", "shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype", "nextUpdatePromise", "cancelKeyRequestName", "shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype", "requestPictureInPicture", "exitPictureInPicture", "webkitSupportsPresentationMode", "pictureInPictureEnabled", "pictureInPictureElement", "shaka.polyfill.PiPWebkit.requestPictureInPicture_", "shaka.polyfill.PiPWebkit.getDisablePictureInPicture_", "shaka.polyfill.PiPWebkit.setDisablePictureInPicture_", "shaka.polyfill.PiPWebkit.exitPictureInPicture_", "shaka.polyfill.PiPWebkit.proxyEvent_", "shaka.polyfill.PiPWebkit.PIP_MODE_", "webkitPresentationMode", "requestPictureInPicture_", "webkitSetPresentationMode", "exitPictureInPicture_", "pipElement", "shaka.polyfill.PiPWebkit.INLINE_MODE_", "getDisablePictureInPicture_", "hasAttribute", "setDisablePictureInPicture_", "shaka.polyfill.PiPWebkit", "shaka.polyfill.PiPWebkit.install", "shaka.polyfill.RandomUUID.randomUUID_", "randomUUID_", "uuid", "shaka.polyfill.RandomUUID", "shaka.polyfill.RandomUUID.install", "webkitTemporaryStorage", "queryUsageAndQuota", "shaka.polyfill.StorageEstimate.storageEstimate_", "storageEstimate_", "shaka.polyfill.StorageEstimate", "shaka.polyfill.StorageEstimate.install", "shaka.polyfill.Symbol.getSymbolDescription_", "getSymbolDescription_", "shaka.polyfill.Symbol", "shaka.polyfill.Symbol.install", "originalPlay", "HTMLMediaElement.prototype.play", "shaka.polyfill.VideoPlayPromise", "shaka.polyfill.VideoPlayPromise.install", "shaka.polyfill.VideoPlaybackQuality.webkit_", "webkit_", "webkitDroppedFrameCount", "webkitDecodedFrameCount", "shaka.polyfill.VideoPlaybackQuality", "shaka.polyfill.VideoPlaybackQuality.install", "TextTrackCue", "replacement", "constructorLength", "shaka.polyfill.VTTCue.from3ArgsTextTrackCue_", "shaka.polyfill.VTTCue.from6ArgsTextTrackCue_", "from3ArgsTextTrackCue_", "from6ArgsTextTrackCue_", "shaka.polyfill.VTTCue", "shaka.polyfill.VTTCue.install", "shaka.text.LrcTextParser", "prevCue", "shaka.text.LrcTextParser.lyricLine_.exec", "shaka.text.LrcTextParser.timeFormat_.exec", "shaka.text.LrcTextParser.lyricLine_", "shaka.text.LrcTextParser.timeFormat_", "shaka.text.TtmlTextParser", "tt", "shaka.util.Error.Code.INVALID_XML", "shaka.util.XmlUtils.getAttributeNSList", "shaka.text.TtmlTextParser.parameterNs_", "subFrameRate", "frameRateMultiplier", "tickRate", "spaceStyle", "extent", "shaka.text.TtmlTextParser.styleNs_", "whitespaceTrim", "rateInfo", "shaka.text.TtmlTextParser.RateInfo_", "metadataElements", "shaka.util.XmlUtils.getChildren", "styles", "regionElements", "cueRegions", "globalResults", "shaka.text.TtmlTextParser.percentValues_.exec", "shaka.text.TtmlTextParser.pixelValues_.exec", "globalWidth", "globalHeight", "percentage", "shaka.text.TtmlTextParser.getStyleAttributeFromRegion_", "shaka.text.CueRegion.units.PX", "origin", "cueRegion", "shaka.util.Error.Code.INVALID_TEXT_CUE", "div", "shaka.text.TtmlTextParser.parseCue_", "cellResolutionInfo", "cueNode", "timeContext", "parentCueElement", "isContent", "parentNode", "COMMENT_NODE", "span", "imageElement", "shaka.text.TtmlTextParser.smpteNsList_", "shaka.text.TtmlTextParser.getElementsFromCollection_", "nameSpace", "parentIsContent", "localWhitespaceTrim", "isLeafNode", "isTextNode", "nestedCue", "childNode", "hasTextContent", "hasTimeAttributes", "shaka.text.TtmlTextParser.parseTime_", "ELEMENT_NODE", "shaka.text.TtmlTextParser.resolveTime_", "regionElementForStyle", "shaka.text.TtmlTextParser.addStyle_", "addStyle_", "shouldInheritRegionStyles", "shaka.text.TtmlTextParser.getStyleAttribute_", "shaka.text.Cue.direction.HORIZONTAL_RIGHT_TO_LEFT", "shaka.text.TtmlTextParser.textAlignToPositionAlign_", "shaka.text.TtmlTextParser.textAlignToLineAlign_", "wrapOption", "shaka.text.TtmlTextParser.unitValues_", "shaka.text.TtmlTextParser.percentValue_", "backgroundImageType", "backgroundImageEncoding", "backgroundImageData", "textOutline", "textDecorationRegion", "shaka.text.TtmlTextParser.addTextDecoration_", "textDecorationElement", "shaka.text.TtmlTextParser.getStyleAttributeFromElement_", "addTextDecoration_", "decoration", "shaka.text.Cue.textDecoration.LINE_THROUGH", "shaka.text.Cue.textDecoration.OVERLINE", "getStyleAttribute_", "getStyleAttributeFromRegion_", "shaka.text.TtmlTextParser.getInheritedStyleAttribute_", "getStyleAttributeFromElement_", "elementAttribute", "getInheritedStyleAttribute_", "inheritedStyles", "styleValue", "styleAttributeValue", "shaka.text.TtmlTextParser.styleEbuttsNs_", "getElementsFromCollection_", "attributeName", "collection", "prefixName", "nsName", "items", "attributeValue", "itemNames", "resolveTime_", "parentTime", "parseTime_", "shaka.text.TtmlTextParser.parseTimeAttribute_", "parseTimeAttribute_", "shaka.text.TtmlTextParser.timeColonFormatFrames_.test", "shaka.text.TtmlTextParser.timeColonFormatFrames_.exec", "frames", "shaka.text.TtmlTextParser.timeColonFormat_.test", "shaka.text.TtmlTextParser.parseTimeFromRegex_", "shaka.text.TtmlTextParser.timeColonFormat_", "shaka.text.TtmlTextParser.timeColonFormatMilliseconds_.test", "shaka.text.TtmlTextParser.timeColonFormatMilliseconds_", "shaka.text.TtmlTextParser.timeFramesFormat_.test", "shaka.text.TtmlTextParser.timeFramesFormat_.exec", "shaka.text.TtmlTextParser.timeTickFormat_.test", "shaka.text.TtmlTextParser.timeTickFormat_.exec", "ticks", "shaka.text.TtmlTextParser.timeHMSFormat_.test", "shaka.text.TtmlTextParser.timeHMSFormat_", "parseTimeFromRegex_", "multiplierResults", "numerator", "denominator", "shaka.text.TtmlTextParser.percentValues_", "shaka.text.TtmlTextParser.pixelValues_", "shaka.text.TtmlTextParser.timeColonFormatFrames_", "shaka.text.TtmlTextParser.timeFramesFormat_", "shaka.text.TtmlTextParser.timeTickFormat_", "shaka.text.Cue.lineAlign.CENTER", "shaka.text.Cue.positionAlign.CENTER", "shaka.text.Mp4TtmlParser", "sawSTPP", "shaka.util.Error.Code.INVALID_MP4_TTML", "shaka.text.VttTextParser", "shaka.util.Error.Code.INVALID_TEXT_HEADER", "cueTimeMatch", "mpegTimeMatch", "cueTime", "shaka.text.VttTextParser.parseTime_", "mpegTime", "rolloverSeconds", "shaka.text.VttTextParser.TS_ROLLOVER_", "shaka.text.VttTextParser.MPEG_TIMESCALE_", "regions", "shaka.text.CueRegion.units.LINES", "shaka.text.CueRegion.scrollMode.UP", "shaka.text.VttTextParser.addDefaultTextColor_", "block", "styleBlocks", "lastBlockIndex", "styleBlock", "styleSelector", "selector", "propertyLines", "validStyle", "lineParts", "shaka.text.Cue.fontStyle.OBLIQUE", "expect", "shaka.text.VttTextParser.parseCueStyles", "shaka.text.VttTextParser.parseCueSetting", "parseCueStyles", "rootCue", "names", "newPayload", "tagEnd", "tagStart", "hasVoiceEndTag", "voiceTag", "newName", "shaka.text.VttTextParser.htmlUnescape_", "shaka.text.VttTextParser.generateCueFromElement_", "getOrDefault_", "generateCueFromElement_", "styleTag", "voice", "shaka.text.VttTextParser.getOrDefault_", "refCue", "lineBreakCue", "isFirst", "textArr", "textCue", "parseCueSetting", "shaka.text.VttTextParser.getRegionById_", "getRegionById_", "regionsWithId", "regexExpresion", "htmlUnescape_", "htmlUnescapes", "reEscapedHtml", "reHasEscapedHtml", "entity", "timescale_", "shaka.text.Mp4VttParser", "sawWVTT", "shaka.util.Error.Code.INVALID_MP4_VTT", "baseTime", "presentations", "rawPayload", "sawTFDT", "sawTRUN", "defaultDuration", "parsedTFHDBox", "parsedTRUNBox", "presentation", "totalSize", "payloadName", "shaka.text.Mp4VttParser.parseVTTC_", "parseVTTC_", "shaka.text.Mp4VttParser.assembleCue_", "assembleCue_", "shaka.text.SbvTextParser", "strFromData", "blocklist", "shaka.text.SbvTextParser.parseTime_", "shaka.text.SrtTextParser", "shaka.text.SrtTextParser.srt2webvtt", "newData", "srt2webvtt", "srt", "cuelist", "shaka.text.SsaTextParser", "shaka.text.SsaTextParser.ssaContent_.exec", "styleColumns", "styleLines", "shaka.text.SsaTextParser.lineParts_.exec", "shaka.text.SsaTextParser.valuesFormat_", "eventColumns", "eventLines", "styleName", "shaka.text.SsaTextParser.parseTime_", "styleData", "shaka.text.SsaTextParser.addStyle_", "ccsColor", "shaka.text.SsaTextParser.parseSsaColor_", "cssBackgroundColor", "italic", "alignment", "alignmentInt", "parseSsaColor_", "colorString", "abgr", "shaka.text.SsaTextParser.timeFormat_.exec", "shaka.text.SsaTextParser.ssaContent_", "shaka.text.SsaTextParser.lineParts_", "shaka.text.SsaTextParser.timeFormat_", "EmeEncryptionSchemePolyfill", "EmeEncryptionSchemePolyfill.originalRMKSA_", "EmeEncryptionSchemePolyfill.probeRMKSA_", "probeRMKSA_", "assert", "EmeEncryptionSchemePolyfill.originalRMKSA_.call", "hasEncryptionScheme", "EmeEncryptionSchemePolyfill.polyfillRMKSA_", "EmeEncryptionSchemePolyfill.polyfillRMKSA_.call", "polyfillRMKSA_", "supportedScheme", "filteredSupportedConfigurations", "filteredVideoCapabilities", "filteredAudioCapabilities", "clonedConfiguration", "guessSupportedScheme", "EmeEncryptionSchemePolyfill.filterCapabilities_", "EmeEncryptionSchemePolyfillMediaKeySystemAccess", "filterCapabilities_", "capabilities", "EmeEncryptionSchemePolyfill.install", "McEncryptionSchemePolyfill", "McEncryptionSchemePolyfill.originalDecodingInfo_", "McEncryptionSchemePolyfill.probeDecodingInfo_", "probeDecodingInfo_", "requestedConfiguration", "McEncryptionSchemePolyfill.originalDecodingInfo_.call", "McEncryptionSchemePolyfill.polyfillDecodingInfo_", "McEncryptionSchemePolyfill.getMediaKeySystemAccess_", "McEncryptionSchemePolyfill.polyfillDecodingInfo_.call", "polyfillDecodingInfo_", "audioScheme", "videoScheme", "notSupportedResult", "encryptionScheme", "getMediaKeySystemAccess_", "mediaCapKeySystemConfig", "McEncryptionSchemePolyfill.install", "mksa", "mksa_", "firstAudioCapability", "firstCapability", "EncryptionSchemePolyfills", "module", "exports"]
}
